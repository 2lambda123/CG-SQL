(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{148:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},_=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),_=a,h=u["".concat(i,".").concat(_)]||u[_]||m[_]||s;return n?r.a.createElement(h,l(l({ref:t},c),{},{components:n})):r.a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=_;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<s;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}_.displayName="MDXCreateElement"},73:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),s=(n(0),n(148)),i=["components"],l={id:"int08",title:"Part 8: Test Helpers",sidebar_label:"Part 8: Test Helpers"},o={unversionedId:"int08",id:"int08",isDocsHomePage:!1,title:"Part 8: Test Helpers",description:"\x3c!---",source:"@site/../CQL_Guide/int08.md",slug:"/int08",permalink:"/cql-guide/int08",version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1633985353,sidebar_label:"Part 8: Test Helpers",sidebar:"someSidebar",previous:{title:"Part 7: JSON Generation",permalink:"/cql-guide/int07"}},c=[{value:"Preface",id:"preface",children:[]},{value:"Test Helpers",id:"test-helpers",children:[{value:"Initialization",id:"initialization",children:[]},{value:"Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set",id:"dummy-table-dummy-insert-dummy-select-dummy-result-set",children:[]},{value:"Dummy Test",id:"dummy-test",children:[]}]}],p={rightToc:c};function u(e){var t=e.components,n=Object(r.a)(e,i);return Object(s.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h3",{id:"preface"},"Preface"),Object(s.b)("p",null,"Part 8 continues with a discussion of the Test Helper  generation code.\nAs in the previous sections, the goal here is not to go over every detail but rather to give\na sense of how helpers are created in general -- the core strategies and implementation choices --\nso that when reading the source you will have an idea how it all hangs together."),Object(s.b)("h2",{id:"test-helpers"},"Test Helpers"),Object(s.b)("p",null,"The testability features are described in ",Object(s.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch12"},"Chapter 12")," of the Guide\nSo, we won't be discussing all the details of what can be created.  Instead we're going to go over\nthe theory of how the generator works. This generator is somewhat different than others in that\nit only concerns itself with procedures and only those that have been suitably annotated --\nthere are large parts of the tree that are of no interest to the test helper logic, including,\nimportantly the body of procedures.  Only the signature matters.  As we'll see there is a fairly\nlarge family of generators that are like this."),Object(s.b)("p",null,"We'll have one section for every kind of output, but really only the ",Object(s.b)("inlineCode",{parentName:"p"},"dummy_test")," helper is\nworthy of detailed discussion the others, as we'll see, are very simple."),Object(s.b)("h3",{id:"initialization"},"Initialization"),Object(s.b)("p",null,"The generator is wired like the others with a suitable main, this one is pretty simple:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},'// Main entry point for test_helpers\ncql_noexport void cg_test_helpers_main(ast_node *head) {\n  Contract(options.file_names_count == 1);\n  cql_exit_on_semantic_errors(head);\n  exit_on_validating_schema();\n  cg_test_helpers_reset_globals();\n\n  CHARBUF_OPEN(output_buf);\n\n  cg_th_output = &output_buf;\n\n  bprintf(cg_th_output, "%s", rt->source_prefix);\n  cg_test_helpers_stmt_list(head);\n  cql_write_file(options.file_names[0], cg_th_output->ptr);\n\n  CHARBUF_CLOSE(output_buf);\n  cg_test_helpers_reset_globals();\n}\n')),Object(s.b)("p",null,"The text output will be ultimately put into ",Object(s.b)("inlineCode",{parentName:"p"},"output_buf")," defined here and ",Object(s.b)("inlineCode",{parentName:"p"},"helper_flags")," will track which kinds of helpers\nwe saw.  This helps us to emit the right sections of output as we'll see."),Object(s.b)("p",null,"The code iterates the AST looking at the top level statement list only and in particular looking for ",Object(s.b)("inlineCode",{parentName:"p"},"CREATE PROC"),"\nstatements."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},'// Iterate through statement list\nstatic void cg_test_helpers_stmt_list(ast_node *head) {\n  Contract(is_ast_stmt_list(head));\n  init_all_trigger_per_table();\n  init_all_indexes_per_table();\n  CHARBUF_OPEN(procs_buf);\n  CHARBUF_OPEN(decls_buf);\n  cg_th_procs = &procs_buf;\n  cg_th_decls = &decls_buf;\n\n  for (ast_node *ast = head; ast; ast = ast->right) {\n    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);\n\n    if (is_ast_create_proc_stmt(stmt)) {\n      EXTRACT_STRING(proc_name, stmt->left);\n      cg_test_helpers_create_proc_stmt(stmt, misc_attrs);\n    }\n  }\n\n  bprintf(cg_th_output, "%s", decls_buf.ptr);\n  bprintf(cg_th_output, "\\n");\n  bprintf(cg_th_output, "%s", procs_buf.ptr);\n\n  CHARBUF_CLOSE(decls_buf);\n  CHARBUF_CLOSE(procs_buf);\n  symtab_delete(all_tables_with_triggers);\n  all_tables_with_triggers = NULL;\n  symtab_delete(all_tables_with_indexes);\n  all_tables_with_indexes = NULL;\n}\n')),Object(s.b)("p",null,"There are some preliminaries:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"we make a symbol table that maps from tables names to the list of triggers on that table by walking all the triggers"),Object(s.b)("li",{parentName:"ul"},"we make a symbol table that maps from tables names to the list of indices on that table by walking all the indices"),Object(s.b)("li",{parentName:"ul"},"we'll need two buffers one for declarations (that must go first) and one for procedure bodies"),Object(s.b)("li",{parentName:"ul"},"each ",Object(s.b)("inlineCode",{parentName:"li"},"CREATE PROC")," statement potentially contributes to both sections"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"cg_test_helpers_create_proc_stmt")," checks for the helper attributes and sets up the dispatch to emit the test helpers")),Object(s.b)("p",null,"To do this we have to walk any misc attributes on the procedure we're looking for things of the form ",Object(s.b)("inlineCode",{parentName:"p"},"@attribute(cql:autotest=xxx)")),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},"static void cg_test_helpers_create_proc_stmt(ast_node *stmt, ast_node *misc_attrs) {\n  Contract(is_ast_create_proc_stmt(stmt));\n\n  if (misc_attrs) {\n    helper_flags = 0;\n    dummy_test_infos = symtab_new();\n\n    find_misc_attrs(misc_attrs, test_helpers_find_ast_misc_attr_callback, stmt);\n\n    symtab_delete(dummy_test_infos);\n    dummy_test_infos = NULL;\n  }\n}\n")),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"find_misc_attrs")," calls ",Object(s.b)("inlineCode",{parentName:"p"},"test_helpers_find_ast_misc_attr_callback"),".  We're going to keep track of\nwhich kinds of helpers we have found to help us with the output.  This is where ",Object(s.b)("inlineCode",{parentName:"p"},"helper_flags"),"\ncomes in. The flags are:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},"#define DUMMY_TABLE           1 // dummy_table attribute flag\n#define DUMMY_INSERT          2 // dummy_insert attribute flag\n#define DUMMY_SELECT          4 // dummy_select attribute flag\n#define DUMMY_RESULT_SET      8 // dummy_result_set attribute flag\n#define DUMMY_TEST         0x10 // dummy_test attribute flag\n")),Object(s.b)("p",null,"And now we're ready for actual dispatch:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},'// This is invoked for every misc attribute on every create proc statement\n// in this translation unit.  We\'re looking for attributes of the form cql:autotest=(...)\n// and we ignore anything else.\nstatic void test_helpers_find_ast_misc_attr_callback(\n  CSTR _Nullable misc_attr_prefix,\n  CSTR _Nonnull misc_attr_name,\n  ast_node *_Nullable ast_misc_attr_value_list,\n  void *_Nullable context)\n{\n  ast_node *stmt = (ast_node *)context;\n  Contract(is_ast_create_proc_stmt(stmt));\n\n  if (misc_attr_prefix &&\n      misc_attr_name &&\n      !Strcasecmp(misc_attr_prefix, "cql") &&\n      !Strcasecmp(misc_attr_name, "autotest")) {\n    ...\n  }\n}\n')),Object(s.b)("p",null,"The main dispatch looks like this:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},"// In principle, any option can be combined with any other but some only make sense for procs with\n// a result.\n\nEXTRACT_STRING(autotest_attr_name, misc_attr_value);\nif (is_autotest_dummy_test(autotest_attr_name)) {\n  cg_test_helpers_dummy_test(stmt);\n}\n\n// these options are only for procs that return a result set\nif (has_result_set(stmt) || has_out_stmt_result(stmt) || has_out_union_stmt_result(stmt)) {\n  if (is_autotest_dummy_table(autotest_attr_name)) {\n    helper_flags |= DUMMY_TABLE;\n    cg_test_helpers_dummy_table(proc_name);\n  }\n  else if (is_autotest_dummy_insert(autotest_attr_name)) {\n    helper_flags |= DUMMY_INSERT;\n    cg_test_helpers_dummy_insert(proc_name);\n  }\n  else if (is_autotest_dummy_select(autotest_attr_name)) {\n    helper_flags |= DUMMY_SELECT;\n    cg_test_helpers_dummy_select(proc_name);\n  }\n  else if (is_autotest_dummy_result_set(autotest_attr_name)) {\n    helper_flags |= DUMMY_RESULT_SET;\n    cg_test_helpers_dummy_result_set(proc_name);\n  }\n}\n")),Object(s.b)("p",null,"Most of these options are very simple indeed.   ",Object(s.b)("inlineCode",{parentName:"p"},"cg_test_helpers_dummy_test")," is the trickiest\nby far and we'll save it for last, let's dispense with the easy stuff."),Object(s.b)("h3",{id:"dummy-table-dummy-insert-dummy-select-dummy-result-set"},"Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set"),Object(s.b)("p",null,"All of these are a very simple template.  The language includes just the right features\nto emit these procedures as nearly constant strings. The ",Object(s.b)("inlineCode",{parentName:"p"},"LIKE")," construct was literally\ndesigned to make these patterns super simple.  You can see all the patterns\nin ",Object(s.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch12"},"Chapter 12"),' but let\'s look at the code for\nthe first one.  This is "dummy table".'),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-C"},'// Emit an open proc which creates a temp table in the form of the original proc\n// Emit a close proc which drops the temp table\nstatic void cg_test_helpers_dummy_table(CSTR name) {\n  bprintf(cg_th_procs, "\\n");\n  bprintf(cg_th_procs, "CREATE PROC open_%s()\\n", name);\n  bprintf(cg_th_procs, "BEGIN\\n");\n  bprintf(cg_th_procs, "  CREATE TEMP TABLE test_%s(LIKE %s);\\n", name, name);\n  bprintf(cg_th_procs, "END;\\n");\n\n  bprintf(cg_th_procs, "\\n");\n  bprintf(cg_th_procs, "CREATE PROC close_%s()\\n", name);\n  bprintf(cg_th_procs, "BEGIN\\n");\n  bprintf(cg_th_procs, "  DROP TABLE test_%s;\\n", name);\n  bprintf(cg_th_procs, "END;\\n");\n}\n')),Object(s.b)("p",null,"The purpose of this is to create helper functions that can create a temporary\ntable with the same columns in it as the procedure you are trying to mock.\nYou can then select rows out of that table (with ",Object(s.b)("inlineCode",{parentName:"p"},"dummy_select"),") or insert\nrows into the table (with ",Object(s.b)("inlineCode",{parentName:"p"},"dummy_insert"),").  Or you can make a single\nrow result set (often enough) with ",Object(s.b)("inlineCode",{parentName:"p"},"dummy_result_set"),"."),Object(s.b)("p",null,"As we can see we simply prepend ",Object(s.b)("inlineCode",{parentName:"p"},"open_")," to the procedure name and use\nthat to create a test helper that make the temporary table.  The table's\ncolumns are defined to be ",Object(s.b)("inlineCode",{parentName:"p"},"LIKE")," the result shape of the procedure under\ntest.  Recall this helper is only available to procedures that return a result set.\nThe temporary table gets a ",Object(s.b)("inlineCode",{parentName:"p"},"test_")," prefix.  Assuming the procedure with the\nannotation is ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," then this code is universal:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-sql"},"CREATE TEMP TABLE test_foo(LIKE foo);\n")),Object(s.b)("p",null,"Is universal, no matter the result shape of ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," you get a table with those columns."),Object(s.b)("p",null,"For this to work we need to emit a declaration of ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," before this code.  However,\nsince we have the full definition of ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," handy that is no problem.  We remember\nthat we'll need it by setting a flag in ",Object(s.b)("inlineCode",{parentName:"p"},"helper_flags"),"."),Object(s.b)("p",null,"The code for ",Object(s.b)("inlineCode",{parentName:"p"},"close_foo")," is even simpler if that's possible.  The great thing is\nall need to know the columns of ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," has been removed from the test helper.  The\nCQL compiler handles this as a matter of course and it is generally useful.\nSee ",Object(s.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms"},"Chapter 5"),"\nfor more examples."),Object(s.b)("p",null,"All the others are equally simple and use similar tricks.  These were the first\ntest helpers.  They're actually not that popular because they are so easy to create\nyourself anyway."),Object(s.b)("h3",{id:"dummy-test"},"Dummy Test"),Object(s.b)("p",null,"the hard stuff..."))}u.isMDXComponent=!0}}]);