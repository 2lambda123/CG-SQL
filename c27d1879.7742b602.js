(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{116:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),l=n(6),i=(n(0),n(143)),r=["components"],s={id:"int03",title:"Part 3: C Code Generation",sidebar_label:"Part 3: C Code Generation"},o={unversionedId:"int03",id:"int03",isDocsHomePage:!1,title:"Part 3: C Code Generation",description:"\x3c!---",source:"@site/../CQL_Guide/int03.md",slug:"/int03",permalink:"/cql-guide/int03",version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1629493127,sidebar_label:"Part 3: C Code Generation",sidebar:"someSidebar",previous:{title:"Part 2: Semantic Analysis",permalink:"/cql-guide/int02"}},c=[{value:"Preface",id:"preface",children:[]},{value:"C Code Generation",id:"c-code-generation",children:[{value:"Launching the Code Generator",id:"launching-the-code-generator",children:[]},{value:"Character Buffers and Byte Buffers",id:"character-buffers-and-byte-buffers",children:[]},{value:"Expressions",id:"expressions",children:[]},{value:"Basic Control Flow Patterns",id:"basic-control-flow-patterns",children:[]},{value:"Cleanup and Errors",id:"cleanup-and-errors",children:[]},{value:"String Literals",id:"string-literals",children:[]},{value:"Executing SQLite Statements",id:"executing-sqlite-statements",children:[]}]}],b={rightToc:c};function p(e){var t=e.components,n=Object(l.a)(e,r);return Object(i.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h3",{id:"preface"},"Preface"),Object(i.b)("p",null,"Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.\nAs in the previous sections, the goal here is not to go over every detail of code generation but rather to give\na sense of how codegen happens in general -- the core strategies and implementation choices --\nso that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish\nthis, various key data structures will be explained in detail as well as selected examples of their use."),Object(i.b)("h2",{id:"c-code-generation"},"C Code Generation"),Object(i.b)("p",null,"There are several key pieces of C code that we have to generate to make working CQL procedures using C\nfunctions.  This all happens in ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c"),".  From a big picture perspective, these are the essential problems:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"we have to compile SQL expressions into C",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"including expressions with variables that are nullable"),Object(i.b)("li",{parentName:"ul"},"including SQL expressions that are highly complex like ",Object(i.b)("inlineCode",{parentName:"li"},"CASE..WHEN..THEN..END")," and ",Object(i.b)("inlineCode",{parentName:"li"},"IN (..)")))),Object(i.b)("li",{parentName:"ul"},"we have to generate control flow for things like ",Object(i.b)("inlineCode",{parentName:"li"},"IF"),", ",Object(i.b)("inlineCode",{parentName:"li"},"WHILE")," and, ",Object(i.b)("inlineCode",{parentName:"li"},"SWITCH")),Object(i.b)("li",{parentName:"ul"},"we have to make result sets",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"including the code to slurp up all the rows from a SQL statement into an array of values"),Object(i.b)("li",{parentName:"ul"},"we want to do this very economically"))),Object(i.b)("li",{parentName:"ul"},"we have to be able to create the text for every SQLite statement and bind any variables to it"),Object(i.b)("li",{parentName:"ul"},"we have to check every SQLite API for errors and throw exceptions consistently and deal with them",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"including constructs that allow users to handle exceptions, such as ",Object(i.b)("inlineCode",{parentName:"li"},"TRY/CATCH")))),Object(i.b)("li",{parentName:"ul"},"we have to track any reference types carefully so that retain/release pairs are done consistently",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"even in the presence of SQLite errors or other exceptions"))),Object(i.b)("li",{parentName:"ul"},"we have to produce a ",Object(i.b)("inlineCode",{parentName:"li"},".h")," and a ",Object(i.b)("inlineCode",{parentName:"li"},".c")," file for the C compiler",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"contributions to these files could come from various places"),Object(i.b)("li",{parentName:"ul"},"the ",Object(i.b)("inlineCode",{parentName:"li"},".c")," file will itself have various sections and we might need to contribute to them at various points in the compilation"))),Object(i.b)("li",{parentName:"ul"},"we want to do this all in one pass over the AST"),Object(i.b)("li",{parentName:"ul"},"we get to assume that the program is error free, codegen never runs unless semantic analysis reports zero errors",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"so nothing can be wrong by the time the codegen pass runs, we never detect errors here"),Object(i.b)("li",{parentName:"ul"},"sometimes we add ",Object(i.b)("inlineCode",{parentName:"li"},"Contract")," and ",Object(i.b)("inlineCode",{parentName:"li"},"Invariant")," statements to ",Object(i.b)("inlineCode",{parentName:"li"},"cg.c")," that make our assumptions clear and prevent regressions")))),Object(i.b)("p",null,"There are some very important building blocks used to solve these problems we will start with those, then move to\na discussion of each of the essential kinds of code generation that we have to do to get working programs."),Object(i.b)("h3",{id:"launching-the-code-generator"},"Launching the Code Generator"),Object(i.b)("p",null,"Once semantic analysis is done all of the code generators have the same contract: they\nhave a main function like ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c_main")," for the C code generator.  It gets the root of\nthe AST and it can use the public interface of the semantic analyzer to get additional\ninformation.  See ",Object(i.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int02"},"Part 2")," for those details."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Main entry point for code-gen.  This will set up the buffers for the global\n// variables and any loose calls or DML.  Any code that needs to run in the\n// global scope will be added to the global_proc.  This is the only codegen\n// error that is possible.  If you need global code and you don't have a global\n// proc then you can't proceed.  Semantic analysis do\u0192esn't want to know that stuff.\n// Otherwise all we do is set up the most general buffers for the global case and\n// spit out a function with the correct name.\ncql_noexport void cg_c_main(ast_node *head) { ... }\n")),Object(i.b)("p",null,"In addition to initializing its scratch storage, the main entry point also sets up a\nsymbol table for AST dispatch just like the ",Object(i.b)("inlineCode",{parentName:"p"},"gen_")," and ",Object(i.b)("inlineCode",{parentName:"p"},"sem_")," functions do.  Here\nare some samples from that table with the most common options:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  DDL_STMT_INIT(drop_table_stmt);\n  DDL_STMT_INIT(drop_view_stmt);\n  DDL_STMT_INIT(create_table_stmt);\n  DDL_STMT_INIT(create_view_stmt);\n")),Object(i.b)("p",null,"The DDL (Data Definition Lanaguage) statements all get the same handling:  The text of the statement\nis generated from the AST. Any variables are bound and then the statement is executed.  The work\nis done with ",Object(i.b)("inlineCode",{parentName:"p"},"cg_bound_sql_statement")," which will be discussed later."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Straight up DDL invocation.  The ast has the statement, execute it!\n// We don't minify the aliases because DDL can have views and the view column names\n// can be referred to in users of the view.  Loose select statements can have\n// no external references to column aliases.\nstatic void cg_any_ddl_stmt(ast_node *ast) {\n  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);\n}\n")),Object(i.b)("p",null,"DML (Data Manipulation Language) statements are declared similarly:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"  STD_DML_STMT_INIT(begin_trans_stmt);\n  STD_DML_STMT_INIT(commit_trans_stmt);\n  STD_DML_STMT_INIT(rollback_trans_stmt);\n  STD_DML_STMT_INIT(savepoint_stmt);\n  STD_DML_STMT_INIT(delete_stmt);\n")),Object(i.b)("p",null,"They are handled by ",Object(i.b)("inlineCode",{parentName:"p"},"cg_std_dml_exec_stmt"),"; the processing is identical to\nDDL except ",Object(i.b)("inlineCode",{parentName:"p"},"CG_MINIFY_ALIASES")," is specified.  This allows the code generator\nto remove unused column aliases in select statements to save space."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"// Straight up DML invocation.  The ast has the statement, execute it!\nstatic void cg_std_dml_exec_stmt(ast_node *ast) {\n  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);\n}\n")),Object(i.b)("p",null,"Note that this flag difference only matters for the ",Object(i.b)("inlineCode",{parentName:"p"},"create view")," statement\nbut for symmetry all the DDL is handled with one macro and all the DML\nwith the second macro."),Object(i.b)("p",null,"Next, the easiest case... there are a bunch of statements that create\nno code-gen at all.  These are type defintions that are interesting\nonly to the semantic analyzer or other control statements.  Some examples:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  NO_OP_STMT_INIT(declare_enum_stmt);\n  NO_OP_STMT_INIT(declare_named_type);\n")),Object(i.b)("p",null,"Next, the general purpose statement handler.  This creates a mapping\nfrom the ",Object(i.b)("inlineCode",{parentName:"p"},"if_stmt")," AST node to ",Object(i.b)("inlineCode",{parentName:"p"},"cg_if_stmt"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  STMT_INIT(if_stmt);\n  STMT_INIT(switch_stmt);\n  STMT_INIT(while_stmt);\n  STMT_INIT(assign);\n")),Object(i.b)("p",null,"The next group is the expressions, with precedence and operator specified. There is a lot of code sharing\nas you can see from this sample:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  EXPR_INIT(num, cg_expr_num, "num", C_EXPR_PRI_ROOT);\n  EXPR_INIT(str, cg_expr_str, "STR", C_EXPR_PRI_ROOT);\n  EXPR_INIT(null, cg_expr_null, "NULL", C_EXPR_PRI_ROOT);\n  EXPR_INIT(dot, cg_expr_dot, "DOT", C_EXPR_PRI_ROOT);\n\n  EXPR_INIT(mul, cg_binary, "*", C_EXPR_PRI_MUL);\n  EXPR_INIT(div, cg_binary, "/", C_EXPR_PRI_MUL);\n  EXPR_INIT(mod, cg_binary, "%", C_EXPR_PRI_MUL);\n  EXPR_INIT(add, cg_binary, "+", C_EXPR_PRI_ADD);\n  EXPR_INIT(sub, cg_binary, "-", C_EXPR_PRI_ADD);\n  EXPR_INIT(not, cg_unary, "!", C_EXPR_PRI_UNARY);\n  EXPR_INIT(tilde, cg_unary, "~", C_EXPR_PRI_UNARY);\n  EXPR_INIT(uminus, cg_unary, "-", C_EXPR_PRI_UNARY);\n')),Object(i.b)("p",null,"Most (not all) of the binary operators are handled with one function ",Object(i.b)("inlineCode",{parentName:"p"},"cg_binary")," and likewise\nmost unary operators are handled with ",Object(i.b)("inlineCode",{parentName:"p"},"cg_unary"),"."),Object(i.b)("p",null,"Note: the precedence constants are the ",Object(i.b)("inlineCode",{parentName:"p"},"C_EXPR_PRI_*")," flavor because parentheses will be\ngenerated based on the C rules at this point.  Importantly, the AST still, and always\nhas the user-specified order of operations encoded in it, there's no change there.  The\nonly thing that changes is where parentheses are needed to get the desired result.  Parens\nmay need to be added and some that were present in the original text might no longer be needed."),Object(i.b)("p",null,"e.g."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  /* NOT is weaker than + */\n  LET x := (NOT 1) + (NOT 2);\n  SET x := NOT 1 + 2;\nEND;\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"void p(void) {\n  cql_bool x = 0;\n\n  /* ! is stronger than + */\n  x = ! 1 + ! 2;\n  x = ! (1 + 2);\n}\n")),Object(i.b)("p",null,"Finally, many built-in functions need special codegen."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  FUNC_INIT(coalesce);\n  FUNC_INIT(printf);\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"FUNC_INIT(coalesce)")," creates a mapping between the function name ",Object(i.b)("inlineCode",{parentName:"p"},"coalesce")," and the generator ",Object(i.b)("inlineCode",{parentName:"p"},"cg_func_coalesce"),"."),Object(i.b)("h3",{id:"character-buffers-and-byte-buffers"},"Character Buffers and Byte Buffers"),Object(i.b)("p",null,"The first kind of text output that CQL could produce was the AST echoing.  This was original done directly with ",Object(i.b)("inlineCode",{parentName:"p"},"fprintf")," but\nthat was not flexible enough as the output had to be captured to be emitted into other places like comments or the text of\nSQL statements to go to SQLite.  This forces that pass to use character buffers, which we touched on in Part 1.  Code generation\nhas a more profound dependency on character buffers -- they are literally all over ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c")," and we need to go over how hey are used."),Object(i.b)("p",null,"The public interace is in ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf.h")," and it's really quite simple.  You allocate a ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," and then you can ",Object(i.b)("inlineCode",{parentName:"p"},"bprintf")," into it.\nLet's be a bit more specific:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_INTERNAL_SIZE 1024\n#define CHARBUF_GROWTH_SIZE 1024\n\ntypedef struct charbuf\n{\n  char *ptr;      // pointer to stored data, if any\n  uint32_t used;  // bytes used in current buffer\n  uint32_t max;   // max bytes in current buffer\n\n  // builtin buffer storage\n  char internal[CHARBUF_INTERNAL_SIZE];\n} charbuf;\n\ncql_data_decl( int32_t charbuf_open_count );\n\ncql_noexport void bopen(charbuf* b);\ncql_noexport void bclose(charbuf *b);\ncql_noexport void bprintf(charbuf *b, const char *format, ...);\n")),Object(i.b)("p",null,"The typical pattern goes something like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  charbuf foo;\n  bopen(&foo);\n  bprintf(&foo, "Hello %s\\n", "World");\n  // do something with foo.ptr\n  bclose(&foo);\n')),Object(i.b)("p",null,"Note that ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," includes ",Object(i.b)("inlineCode",{parentName:"p"},"CHARBUF_INTERNAL_SIZE")," of storage that does not\nhave to be allocated with ",Object(i.b)("inlineCode",{parentName:"p"},"malloc")," and it doesn't grow very aggressively.\nThis reflects that fact that most ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," instances are very small.\nOf course a ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," could go on the heap if it needs to outlive\nthe function it appears in, but this is exceedingly rare."),Object(i.b)("p",null,"To make sure buffers are consistently closed (and this is a problem because\nthere are often a lot of them.  They are allocated with these simple helper\nmacros."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_OPEN(x) \\\n  int32_t __saved_charbuf_count##x = charbuf_open_count; \\\n  charbuf x; \\\n  bopen(&x)\n\n#define CHARBUF_CLOSE(x) \\\n  bclose(&x); \\\n  Invariant(__saved_charbuf_count##x == charbuf_open_count)\n")),Object(i.b)("p",null,"the earlier example would be written more properly:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  CHARBUF_OPEN(foo);\n    bprintf(&foo, "Hello %s\\n", "World");\n    // do something with foo.ptr\n  CHARBUF_CLOSE(foo);\n')),Object(i.b)("p",null,"If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure."),Object(i.b)("p",null,'It\'s normal to create several buffers in the course of doing code generation.  In fact some of these buffers\nbecome "globally" visible and get swapped out as needed.  For instance this kind of chaining is normal.\nInside of ',Object(i.b)("inlineCode",{parentName:"p"},"cg_create_proc_stmt")," there is these sequence:"),Object(i.b)("p",null,"Make new buffers..."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  CHARBUF_OPEN(proc_fwd_ref);\n  CHARBUF_OPEN(proc_body);\n  CHARBUF_OPEN(proc_locals);\n  CHARBUF_OPEN(proc_cleanup);\n")),Object(i.b)("p",null,"Save what we got..."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  charbuf *saved_main = cg_main_output;\n  charbuf *saved_decls = cg_declarations_output;\n  charbuf *saved_scratch = cg_scratch_vars_output;\n  charbuf *saved_cleanup = cg_cleanup_output;\n  charbuf *saved_fwd_ref = cg_fwd_ref_output;\n")),Object(i.b)("p",null,"Switch to the new..."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  cg_fwd_ref_output = &proc_fwd_ref;\n  cg_main_output = &proc_body;\n  cg_declarations_output = &proc_locals;\n  cg_scratch_vars_output = &proc_locals;\n  cg_cleanup_output = &proc_cleanup;\n")),Object(i.b)("p",null,"And of course the code puts the original values back when it's done and closes the buffers."),Object(i.b)("p",null,"This means that while processing a procedure the codegen that declares say scratch variables,\nwhich would go to ",Object(i.b)("inlineCode",{parentName:"p"},"cg_scratch_vars_output")," is going to target the ",Object(i.b)("inlineCode",{parentName:"p"},"proc_locals")," buffer\nwhich will be emitted before the ",Object(i.b)("inlineCode",{parentName:"p"},"body"),".  By the time ",Object(i.b)("inlineCode",{parentName:"p"},"cg_stmt_list")," is invoked the\n",Object(i.b)("inlineCode",{parentName:"p"},"cg_main_output")," variable will be pointing to the procedure body, thus any statements\nwill go into there rather than being acculated at the global level -- it's possible to\nhave code that is not in a procedure (see ",Object(i.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/x1#--global_proc-name"},Object(i.b)("inlineCode",{parentName:"a"},"--global_proc")),")."),Object(i.b)("p",null,"But in general, it's very useful to have different buffers going on at the same time.  New local variables\nor scratch variables can be added to their own buffer which goes before the code runs.  New cleanup\nsteps that are necessary can be added to the cleanup output which will appear at the end.  The final\nfunction combines all of these pieces with maybe some glue.  Everything works like this, ",Object(i.b)("inlineCode",{parentName:"p"},"IF")," statements,\nexpressions, all of it."),Object(i.b)("p",null,"One interesting but unexpected feature of ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," is that it provides helper methods for indenting\nbuffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C\ncode because of course you want (e.g.) the body of an ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statement to be indented.  CQL tries to create\nwell formatted code that is readable by humans as much as possible."),Object(i.b)("h4",{id:"byte-buffers"},"Byte Buffers"),Object(i.b)("p",null,"These are less commonly used but there is a peer to ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," creatively called ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf"),".  This gives you\na growable binary buffer.  It's often used to hold arrays of structures.  Interestingly, ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c")," doesn't\ncurrently consume byte buffers, the presence of ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf.c")," actually came late to the CQL compiler. However\nthe CQL runtime ",Object(i.b)("inlineCode",{parentName:"p"},"cqlrt.c")," (and ",Object(i.b)("inlineCode",{parentName:"p"},"cqlrt_common.c"),") provide ",Object(i.b)("inlineCode",{parentName:"p"},"cql_bytebuf_open"),", ",Object(i.b)("inlineCode",{parentName:"p"},"cql_bytebuf_alloc")," and,\n",Object(i.b)("inlineCode",{parentName:"p"},"cql_bytebuf_close")," which are akin to the ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," methods.  These functions are used in the generated\ncode to create result sets at runtime.  The ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf")," was so useful that it found its way back from the\nruntime into the compiler itself, and is used by other code-generators like the schema upgrader.   The\nsemantic analyzer also uses it to help with query fragments and to track the various upgrade annotations."),Object(i.b)("p",null,"Both ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," and ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf")," are simple enough that they don't need discussion. It's easier to just read\nthe code and the comments."),Object(i.b)("h3",{id:"expressions"},"Expressions"),Object(i.b)("p",null,"Many of the output needs of CQL stemmed from the base case of creating expressions.  A simple CQL\nexpression like"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-sql"},"  SET x := x + y;\n")),Object(i.b)("p",null,"seems innocuous enough, we'd like this to compile to this code:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  x = x + y;\n")),Object(i.b)("p",null,"And indeed, it might.  Here's some actual output from the compiler:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER NOT NULL;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_int32 x = 0;\n  cql_int32 y = 0;\n\n  x = x + y;\n\n}\n#undef _PROC_\n')),Object(i.b)("p",null,"(*) the output above was created by using ",Object(i.b)("inlineCode",{parentName:"p"},"out/cql --in x --cg x.h x.c --nolines")," to avoid all the # directives"),Object(i.b)("p",null,"Looks easy enough.  And indeed if all expressions were like this, you could do expression compilation pretty simply --\nevery binary operator would look something like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"recurse left"),Object(i.b)("li",{parentName:"ul"},"emit infix operator"),Object(i.b)("li",{parentName:"ul"},"recurse right")),Object(i.b)("p",null,"This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have\nthe whole expression."),Object(i.b)("p",null,"This doesn't work at all.  To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result\nis telling:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_nullable_int32 x;\n  cql_set_null(x);\n  cql_nullable_int32 y;\n  cql_set_null(y);\n\n  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);\n\n}\n#undef _PROC_\n')),Object(i.b)("p",null,"All that's happened in the above is that ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y")," became nullable variables, that is the ",Object(i.b)("inlineCode",{parentName:"p"},"NOT NULL")," was\nremoved from the declaration.  This makes all the difference in the world, and this is a fairly easy case.\nThe problem is that nullable value types like cql_nullable_int32 have an integer and a boolean and these\ndon't flow into expressions that use operators like ",Object(i.b)("inlineCode",{parentName:"p"},"+"),", ",Object(i.b)("inlineCode",{parentName:"p"},"-"),", ",Object(i.b)("inlineCode",{parentName:"p"},"/")," and so forth.  This means that even\nsimple expressions involving nullable types actually expand into several statements.  And, in general,\nthese statements need a place to put their temporary results to accumulate the answer, so scratch variables\nare required to make all this work."),Object(i.b)("p",null,"Here's a more realistic example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)\nBEGIN\n  SET result := 5 * x + 3 * y;\nEND;\n*/\n\n#define _PROC_ "combine"\nvoid combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {\n  cql_contract_argument_notnull((void *)result, 3);\n\n  cql_nullable_int32 _tmp_n_int_1;\n  cql_set_null(_tmp_n_int_1);\n  cql_nullable_int32 _tmp_n_int_2;\n  cql_set_null(_tmp_n_int_2);\n\n  cql_set_null(*result); // set out arg to non-garbage\n  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);\n  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);\n  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);\n\n}\n#undef _PROC_\n#pragma clang diagnostic pop\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1")," holds the product of x and 5, it's null if ",Object(i.b)("inlineCode",{parentName:"li"},"x.is_null")," is true"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2")," holds the product of y and 3, it's null if ",Object(i.b)("inlineCode",{parentName:"li"},"y.is_null")," is true"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"*result")," holds the answer, it's null if either of ",Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.is_null"),", ",Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2.is_null")," is true",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"otherwise it's ",Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.value + _tmp_n_int_2.value"))))),Object(i.b)("p",null,"So, in general, we need to emit arbitarily many statements in the course of evaluating even simple looking expressions\nand we need good mechanisms to manage that.  This is what we'll talk about in the coming sections."),Object(i.b)("h4",{id:"managing-scratch-variables"},"Managing Scratch Variables"),Object(i.b)("p",null,"The function that actually assigns scratch variables is ",Object(i.b)("inlineCode",{parentName:"p"},"cg_scratch_var")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// The scratch variable helper uses the given sem_type and the current\n// stack level to create a temporary variable name for that type at that level.\n// If the variable does not already have a declaration (as determined by the masks)\n// then a declaration is added to the scratch_vars section.  This is one of the root\n// ways of getting an .is_null and .value back.  Note that not null variables always\n// have a .is_null of "0" which becomes important when deciding how to assign\n// one result to another.  Everything stays uniform.\nstatic void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)\n')),Object(i.b)("p",null,"The signature is a bit unexpected so we'll go over this, some of this will make more\nsense as we learn about expressions generally but this is as good an introduction as any."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ast")," holds a reference to a variable we want to assign to, this is normally ",Object(i.b)("inlineCode",{parentName:"li"},"NULL")," for scratch variables, it's not null for the ",Object(i.b)("inlineCode",{parentName:"li"},"RESULT")," macros which we'll study later, so for now ignore this"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"sem_type")," holds the type of the variable we need, it must be a unitary type, optionally with ",Object(i.b)("inlineCode",{parentName:"li"},"SEM_TYPE_NOTNULL")," set"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"var")," is a character buffer that will get the name of the variable"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null")," is a character buffer that will get the ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression for this variable (more below)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value")," is a character buffer that will get the ",Object(i.b)("inlineCode",{parentName:"li"},"value")," expression for this variable (more below)")),Object(i.b)("p",null,"And this is a good time to talk about ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," because they will be everywhere."),Object(i.b)("p",null,'Every expression evaluation in the C code generator has two essential results, the text that corresponds to the current\nvalue so far (e.g. "(1+2)*3") and the text for the current expression that will tell you if the result is null,\nthis could be as simple as "0" for a expression that is known to be not null.  So let\'s make this a little more concrete:'),Object(i.b)("p",null,"Suppose you ask for a scratch not null integer we get results like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"var"),":  ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_n_int_1"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"0"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_n_int_1"'))),Object(i.b)("p",null,'Meaning: if you want the value, use the text "_tmp_n_int_1" if you want to know if the variable is null, use the text "0"\nNote: many parts of ',Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c")," special case an ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," value of ",Object(i.b)("inlineCode",{parentName:"p"},'"0"')," to make better code because such a thing is known to\nbe not null at compile time."),Object(i.b)("p",null,"Now let's suppose you ask for a scratch nullable integer, we get results like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"var"),":  ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_int_1"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_int_1.is_null"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_int_1.value"'))),Object(i.b)("p",null,"So again, you have exactly the text you need to test for null and the test you need to get the value."),Object(i.b)("p",null,"Additional notes:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},'scratch variables can be re-used, they are on a "stack"'),Object(i.b)("li",{parentName:"ul"},"a bitmask is used to track which scratch variables have aleady had a declaration emitted, so they are only declared once"),Object(i.b)("li",{parentName:"ul"},"the variable name is based on the current value of the ",Object(i.b)("inlineCode",{parentName:"li"},"stack_level")," variable which is increased in a push/pop fashion as temporaries come in and out of scope"),Object(i.b)("li",{parentName:"ul"},"this strategy isn't perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad"),Object(i.b)("li",{parentName:"ul"},"importantly there is one stacklevel variable for all temporaries not one stacklevel for every type of temporary, this seemed like a reasonable simplification")),Object(i.b)("h4",{id:"allocating-scratch-variables"},"Allocating Scratch Variables"),Object(i.b)("p",null,"The most common reason for a scratch variable is that a temporary is needed for some part of the computation.\nThe most common reason for a temporary variable is to hold an intermediate result of a computation involving\nnullable arithmetic."),Object(i.b)("p",null,"These temporaries are created with ",Object(i.b)("inlineCode",{parentName:"p"},"CG_PUSH_TEMP")," which simply creates the three ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," variables you need and then asks for a\nscratch variable of the type you need.  The variables follow a simple naming convention.  The stack level is increased."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers\n// with the text needed to refer to the variable.  cg_scratch_var picks the name\n// based on stack level-and type.\n#define CG_PUSH_TEMP(name, sem_type) \\\nCHARBUF_OPEN(name); \\\nCHARBUF_OPEN(name##_is_null); \\\nCHARBUF_OPEN(name##_value); \\\ncg_scratch_var(NULL, sem_type, &name, &name##_is_null, &name##_value); \\\nstack_level++;\n")),Object(i.b)("p",null,"Symetrically, ",Object(i.b)("inlineCode",{parentName:"p"},"CG_POP_TEMP")," releases the charbufs and restores the stack level.  As with the other macros, these are designed to\nmake it impossible to forget to free your buffers or get the stack wrong.  In fact, the stack is checked at strategic places\nto ensure its back to baseline.  You can always just snapshot ",Object(i.b)("inlineCode",{parentName:"p"},"stacklevel"),", do some work that should be clean, and then\nadd an ",Object(i.b)("inlineCode",{parentName:"p"},"Invariant")," that ",Object(i.b)("inlineCode",{parentName:"p"},"stacklevel")," is back to where it was."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Release the buffers for the temporary, restore the stack level.\n#define CG_POP_TEMP(name) \\\nCHARBUF_CLOSE(name##_value); \\\nCHARBUF_CLOSE(name##_is_null); \\\nCHARBUF_CLOSE(name); \\\nstack_level--;\n")),Object(i.b)("h4",{id:"recursing-sub-expressions"},"Recursing Sub-expressions"),Object(i.b)("p",null,"Now that we understand that we can create scratch variables as needed, it's time to take a look at the typical evaluation patterns\nand how the evaluation works within that pattern.  This is everywhere in ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c"),"."),Object(i.b)("p",null,"So let's look at an actual evaluator, the simplest of them all, this one does code generation for the ",Object(i.b)("inlineCode",{parentName:"p"},"NULL")," literal."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'static void cg_expr_null(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {\n  Contract(is_ast_null(expr));\n  // null literal\n  bprintf(value, "NULL");\n  bprintf(is_null, "1");\n}\n')),Object(i.b)("p",null,"Now this may be looking familiar: the signature of the code generator is something very much like the\nsignature of the the ",Object(i.b)("inlineCode",{parentName:"p"},"gen_")," functions in the echoing code.  That's really because in some sense\nthe echoing code is like a very simple code generator itself."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"expr")," : the AST we are generating code for"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"op")," : the relevant operator if any (operators share code)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null")," : a ",Object(i.b)("inlineCode",{parentName:"li"},"charbuf")," into which we can write the ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression text"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value")," : a ",Object(i.b)("inlineCode",{parentName:"li"},"charbuf")," into which we can write the ",Object(i.b)("inlineCode",{parentName:"li"},"value")," expression text"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pri")," : the binding strength of the node above this one"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pri_new")," : the binding strength of this node")),Object(i.b)("p",null,"This particular generator is going to produce ",Object(i.b)("inlineCode",{parentName:"p"},'"NULL"')," for the ",Object(i.b)("inlineCode",{parentName:"p"},"value")," and ",Object(i.b)("inlineCode",{parentName:"p"},'"1"')," for the ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," expression."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," are the chief outputs, and the caller will use these to create its own expression results\nwith recursive logic.  But the expression logic can also write into the statement stream, and as we'll see,\nit does."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"pri")," and ",Object(i.b)("inlineCode",{parentName:"p"},"pri_new")," work exactly like they did in the echoing code (see ",Object(i.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),"),\nthey are used to allow the code generator to decide if it needs to emit parentheses.  But recall that the binding strengths\nnow will be the C binding strengths NOT the SQL binding strengths (discussed above)."),Object(i.b)("p",null,"Let's look at one of the simplest operators: the ",Object(i.b)("inlineCode",{parentName:"p"},"IS NULL")," operator handled by ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr_is_null")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// The code-gen for is_null is one of the easiest.  The recursive call\n// produces is_null as one of the outputs.  Use that.  Our is_null result\n// is always zero because IS NULL is never, itself, null.\nstatic void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {\n  sem_t sem_type_expr = expr->sem->sem_type;\n\n  // expr IS NULL\n  bprintf(is_null, "0"); // the result of is null is never null\n\n  // The fact that this is not constant not null for not null reference types reflects\n  // the weird state of affairs with uninitualized reference variables which\n  // must be null even if they are typed not null.\n\n  if (is_not_nullable(sem_type_expr) && !is_ref_type(sem_type_expr)) {\n    // Note, sql has no side-effects so we can fold this away.\n    bprintf(value, "0");\n  }\n  else {\n    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);\n    bprintf(value, "%s", expr_is_null.ptr);\n    CG_POP_EVAL(expr);\n  }\n}\n')),Object(i.b)("p",null,"So walking through this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the result of ",Object(i.b)("inlineCode",{parentName:"li"},"IS NULL"),' is never null, so we can immediately put "0" into the ',Object(i.b)("inlineCode",{parentName:"li"},"is_null")," buffer"),Object(i.b)("li",{parentName:"ul"},"if the operand is a not-null numeric type then the result of ",Object(i.b)("inlineCode",{parentName:"li"},"IS NULL")," is ",Object(i.b)("inlineCode",{parentName:"li"},"0")),Object(i.b)("li",{parentName:"ul"},"if the operand might actually be null then",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"use ",Object(i.b)("inlineCode",{parentName:"li"},"CG_PUSH_EVAL")," to recursively do codegen for it"),Object(i.b)("li",{parentName:"ul"},"copy its ",Object(i.b)("inlineCode",{parentName:"li"},"expr_is_null")," text into our ",Object(i.b)("inlineCode",{parentName:"li"},"value")," text")))),Object(i.b)("p",null,"Note: the code reveals one of the big CQL secrets that not null reference variables can be null...  C has the same issue with ",Object(i.b)("inlineCode",{parentName:"p"},"_Nonnull")," globals."),Object(i.b)("p",null,"Now let's look at those helper macros, they are pretty simple:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Make a temporary buffer for the evaluation results using the canonical naming convention\n// burn the stack slot so that any type and numbered temporary that was needed\n// won't be re-used until this scope is over.\n#define CG_PUSH_EVAL(expr, pri) \\\nCHARBUF_OPEN(expr##_is_null); \\\nCHARBUF_OPEN(expr##_value); \\\ncg_expr(expr, &expr##_is_null, &expr##_value, pri); \\\nstack_level++;\n")),Object(i.b)("p",null,"The push macro simply creates buffers to hold the ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," results, then it calls ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr")," to dispatch the indicated expression.\nThe ",Object(i.b)("inlineCode",{parentName:"p"},"pri")," value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is your ",Object(i.b)("inlineCode",{parentName:"p"},"pri_new"),"\nvalue but often you can use ",Object(i.b)("inlineCode",{parentName:"p"},"C_EXPR_PRI_ROOT")," if you know that, because of your current context, the callee will never need parentheses."),Object(i.b)("p",null,"How do we know this here? It seems like the operand of ",Object(i.b)("inlineCode",{parentName:"p"},"IS NULL")," could be anything surely it might need parentheses?  Let's consider:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"if the operand is of not null numeric type then we aren't even going to evaluate it, we're on the easy \"no it's not null\" path"),Object(i.b)("li",{parentName:"ul"},"if the operand is nullable then the only place the answer can be stored is in a scratch variable and its ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression will be exactly like ",Object(i.b)("inlineCode",{parentName:"li"},"var.is_null")),Object(i.b)("li",{parentName:"ul"},"if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression will be like ",Object(i.b)("inlineCode",{parentName:"li"},"!var"))),Object(i.b)("p",null,"None of these require further wrapping regardless of what is above this node in the tree because of he strength of the ",Object(i.b)("inlineCode",{parentName:"p"},".")," and ",Object(i.b)("inlineCode",{parentName:"p"},"!")," operators."),Object(i.b)("p",null,'Other cases are usually simpler, such as "no parentheses need to be added by the child node becasue it will be used as the argument to a helper\nfunction so there will always be parens hard-coded anyway".  However these things need to be carefully tested hence the huge variety of codegen tests.'),Object(i.b)("p",null,"Note that after calling ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr")," the stack level was artificially increased.  We'll get to that in the next section.  For now, looking at ",Object(i.b)("inlineCode",{parentName:"p"},"POP_EVAL")," we\ncan see it's very straightforward:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Close the buffers used for the above.  Return the stack level to its original state.\n// Numbered scratch variables are re-used as though they were a stack.\n#define CG_POP_EVAL(expr) \\\nCHARBUF_CLOSE(expr##_value); \\\nCHARBUF_CLOSE(expr##_is_null); \\\nstack_level--;\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"CG_POP_EVAL")," simply closes the buffers and restores the stack."),Object(i.b)("h4",{id:"result-variables"},"Result Variables"),Object(i.b)("p",null,'When recursion happens in the codegen, the common place that the result will be found is\nin a temporary variable -- the generated code will use one or more statements to arrange for the correct\nanswer to be in that variable.  To do this, the codegen needs to first get the name of a suitable\nresult variable of a suitable type.  This is the "other" reason for making scratch variables.'),Object(i.b)("p",null,"There are three macros that make this pretty simple.  The first is ",Object(i.b)("inlineCode",{parentName:"p"},"CG_RESERVE_RESULT_VAR")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Make a scratch variable to hold the final result of an evaluation.\n// It may or may not be used.  It should be the first thing you put\n// so that it is on the top of your stack.  This only saves the slot.\n#define CG_RESERVE_RESULT_VAR(ast, sem_type) \\\nint32_t stack_level_reserved = stack_level; \\\nsem_t sem_type_reserved = sem_type; \\\nast_node *ast_reserved = ast; \\\nCHARBUF_OPEN(result_var); \\\nCHARBUF_OPEN(result_var_is_null); \\\nCHARBUF_OPEN(result_var_value); \\\nstack_level++;\n")),Object(i.b)("p",null,"If this looks a lot like ",Object(i.b)("inlineCode",{parentName:"p"},"PUSH_TEMP")," that shouldn't be surprising.  The name of the variable\nand the expression parts always go into ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," variables named ",Object(i.b)("inlineCode",{parentName:"p"},"result_var")," ",Object(i.b)("inlineCode",{parentName:"p"},"result_var_is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"result_var_value"),"\nbut the scratch variable isn't actually allocated!  However -- we burn the stack_level as though it had been\nallocated.  What's up with that?"),Object(i.b)("p",null,"The name might be a clue, this macro reserves stack level slot for the result variable, it's used if you might\nneed a result variable, but you might not.  When you want it we can artificially move the stack level back\nto this spot where the slot was burned, allocate the scratch variable, and then put the stack back.\nThe ",Object(i.b)("inlineCode",{parentName:"p"},"CG_USE_RESULT_VAR")," macro does exactly that."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// If the result variable is going to be used, this writes its name\n// and .value and .is_null into the is_null and value fields.\n#define CG_USE_RESULT_VAR() \\\nint32_t stack_level_now = stack_level; \\\nstack_level = stack_level_reserved; \\\ncg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value); \\\nstack_level = stack_level_now; \\\nInvariant(result_var.used > 1); \\\nbprintf(is_null, "%s", result_var_is_null.ptr); \\\nbprintf(value, "%s", result_var_value.ptr)\n')),Object(i.b)("p",null,"Once the code generator decides that it will in fact be using a result variable to represent the answer, then\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," buffers can be immediately populated to whatever the values were\nfor the result variable.  That text will be correct regardless of what codegen is used\nto populate the variable."),Object(i.b)("p",null,"There is a simpler macro that reserves and uses the result variable in one step, it's very common.  The\n\"reserve\" pattern is only necessary when there are some paths that need a result variable and some\nthat don't."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"// This does reserve and use in one step\n#define CG_SETUP_RESULT_VAR(ast, sem_type) \\\nCG_RESERVE_RESULT_VAR(ast, sem_type); \\\nCG_USE_RESULT_VAR();\n")),Object(i.b)("p",null,"And now armed with this knowledge we can go back to a previous mystery, let's look at ",Object(i.b)("inlineCode",{parentName:"p"},"CG_PUSH_EVAL")," again"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Make a temporary buffer for the evaluation results using the canonical naming convention\n// burn the stack slot so that any type and numbered temporary that was needed\n// won't be re-used until this scope is over.\n#define CG_PUSH_EVAL(expr, pri) \\\nCHARBUF_OPEN(expr##_is_null); \\\nCHARBUF_OPEN(expr##_value); \\\ncg_expr(expr, &expr##_is_null, &expr##_value, pri); \\\nstack_level++;\n")),Object(i.b)("p",null,"The reason that ",Object(i.b)("inlineCode",{parentName:"p"},"CG_PUSH_EVAL")," includes ",Object(i.b)("inlineCode",{parentName:"p"},"stack_level++")," is that it is entirely possible, even likely,\nthat the result of ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr")," is in a result variable.  The convention is that if the codegen\nrequires a result variable it is allocated ",Object(i.b)("em",{parentName:"p"},"first")," before any other temporaries.  This is why\nthere is a way to reserve a variable that you ",Object(i.b)("em",{parentName:"p"},"might")," need.  When the codegen is complete,\nand before anything else happens, ",Object(i.b)("inlineCode",{parentName:"p"},"stack_level")," is increased so that the temporary that is\nholding the result will not be re-used!  Any other temporaries are available but the result\nis still live.  This might be easy to get wrong but the macros make it easy to get it right."),Object(i.b)("p",null,"Now, armed with the knowledge that there a result variables and temporary variables and both\ncome from the scratch variable we can resolve the last mystery we left hanging.  Why does\nthe scratch variable API accept an AST pointer?"),Object(i.b)("p",null,"The only place that pointer can be not null is in the ",Object(i.b)("inlineCode",{parentName:"p"},"CG_USE_RESULT_VAR")," macro, it was\nthis line:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"cg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value);\n")),Object(i.b)("p",null,"And ",Object(i.b)("inlineCode",{parentName:"p"},"ast_reserved")," refers to the AST that we are trying to evaluate.  There's an important\nspecial case that we want to optimize that saves a lot of scratch variables.  It's handled\nby this code in ",Object(i.b)("inlineCode",{parentName:"p"},"cg_scratch_var"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.\n  if (is_assignment_target_reusable(ast, sem_type)) {\n    Invariant(ast && ast->parent && ast->parent->left);\n    EXTRACT_ANY_NOTNULL(name_ast, ast->parent->left);\n    EXTRACT_STRING(name, name_ast);\n    if (is_out_parameter(name_ast->sem->sem_type)) {\n      bprintf(var, "*%s", name);\n    }\n    else {\n      bprintf(var, "%s", name);\n    }\n  }\n')),Object(i.b)("p",null,"The idea is that if the generator is doing an assignment like:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},"  SET x := a + b;\n")),Object(i.b)("p",null,"Then the code generator doesn't need a scratch variable to hold the result of the expression ",Object(i.b)("inlineCode",{parentName:"p"},"a + b")," like it would\nin many other contexts.  It can use ",Object(i.b)("inlineCode",{parentName:"p"},"x")," as the result variable!  The ",Object(i.b)("inlineCode",{parentName:"p"},"SET")," codegen will discover\nthat the value it's supposed to set is already in ",Object(i.b)("inlineCode",{parentName:"p"},"x")," so it does nothing and everything just\nworks out.  The price of this is a call to ",Object(i.b)("inlineCode",{parentName:"p"},"is_assignment_target_reusable")," and then some\nlogic to handle the case where ",Object(i.b)("inlineCode",{parentName:"p"},"x")," is an out argument (hence call by reference, hence needs to be used as ",Object(i.b)("inlineCode",{parentName:"p"},"*x"),")."),Object(i.b)("h3",{id:"basic-control-flow-patterns"},"Basic Control Flow Patterns"),Object(i.b)("p",null,"To get a sense of how the compiler generates code for statements, we can look at some of the easiest cases."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// "While" suffers from the same problem as IF and as a consequence\n// generating while (expression) would not generalize.\n// The overall pattern for while has to look like this:\n//\n//  for (;;) {\n//    prep statements;\n//    condition = final expression;\n//    if (!condition) break;\n//\n//    statements;\n//  }\n//\n// Note that while can have leave and continue substatements which have to map\n// to break and continue.   That means other top level statements that aren\'t loops\n// must not create a C loop construct or break/continue would have the wrong target.\nstatic void cg_while_stmt(ast_node *ast) {\n  Contract(is_ast_while_stmt(ast));\n  EXTRACT_ANY_NOTNULL(expr, ast->left);\n  EXTRACT(stmt_list, ast->right);\n  sem_t sem_type = expr->sem->sem_type;\n\n  // WHILE [expr] BEGIN [stmt_list] END\n\n  bprintf(cg_main_output, "for (;;) {\\n");\n\n  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);\n\n  if (is_nullable(sem_type)) {\n    bprintf(cg_main_output, "if (!cql_is_nullable_true(%s, %s)) break;\\n", expr_is_null.ptr, expr_value.ptr);\n  }\n  else {\n    bprintf(cg_main_output, "if (!(%s)) break;\\n", expr_value.ptr);\n  }\n\n  bool_t loop_saved = cg_in_loop;\n  cg_in_loop = true;\n\n  CG_POP_EVAL(expr);\n\n  cg_stmt_list(stmt_list);\n\n  bprintf(cg_main_output, "}\\n");\n\n  cg_in_loop = loop_saved;\n}\n')),Object(i.b)("p",null,"The comment before the ",Object(i.b)("inlineCode",{parentName:"p"},"cg_while_stmt")," actually says it pretty clearly; the issue is\nthat the expression in the while statement might actually require many C statements\nto evaluate.  There are many cases of this sort of thing, but the simplest is\nprobably when any nullable types are in that expression.  A particular example\nillustrates this pretty clearly."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"CREATE PROC p ()\nBEGIN\n  DECLARE x INTEGER NOT NULL;\n  SET x := 1;\n  WHILE x < 5\n  BEGIN\n    SET x := x + 1;\n  END;\nEND;\n*/\n\nvoid p(void) {\n  cql_int32 x = 0;\n\n  x = 1;\n  for (;;) {\n  /* in trickier cases there would be code right here */\n  if (!(x < 5)) break;\n    x = x + 1;\n  }\n}\n")),Object(i.b)("p",null,"In this case, the ",Object(i.b)("inlineCode",{parentName:"p"},"while")," pattern could have been used because the condition is simply ",Object(i.b)("inlineCode",{parentName:"p"},"x < 5")," so this whole pattern is\noverkill.  But consider this program just a tiny bit different."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x INTEGER;  -- x is nullable\n  SET x := 1;\n  WHILE x < 5\n  BEGIN\n    SET x := x + 1;\n  END;\nEND;\n*/\n\nvoid p(void) {\n  cql_nullable_int32 x;\n  cql_set_null(x);\n  cql_nullable_bool _tmp_n_bool_0;\n  cql_set_null(_tmp_n_bool_0);\n\n  cql_set_notnull(x, 1);\n  for (;;) {\n  cql_set_nullable(_tmp_n_bool_0, x.is_null, x.value < 5);\n  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;\n    cql_set_nullable(x, x.is_null, x.value + 1);\n  }\n}\n")),Object(i.b)("p",null,"Even for this small little case, the nullable arithmetic macros have to be used to keep ",Object(i.b)("inlineCode",{parentName:"p"},"x")," up to date.\nThe result of ",Object(i.b)("inlineCode",{parentName:"p"},"x < 5"),' is of type "bool" rather than "bool not null" so a temporary variable captures\nthe result of the expression.  This is an easy case but similar things happen if the expression\nincludes ',Object(i.b)("inlineCode",{parentName:"p"},"CASE...WHEN...")," or ",Object(i.b)("inlineCode",{parentName:"p"},"IN")," constructs.  There are many other cases."),Object(i.b)("p",null,"So with this in mind, let's reconsider what ",Object(i.b)("inlineCode",{parentName:"p"},"cg_while_stmt")," is doing:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"we start the ",Object(i.b)("inlineCode",{parentName:"li"},"for")," statement in the output",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"there's a bprintf for that"))),Object(i.b)("li",{parentName:"ul"},"we evaluate the while expression, the details will be in ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"li"},"value"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"we use CG_PUSH_EVAL for that"))),Object(i.b)("li",{parentName:"ul"},"if the result is nullable there is a helper macro ",Object(i.b)("inlineCode",{parentName:"li"},"cql_is_nullable_true")," that tells us if the value is not null and true"),Object(i.b)("li",{parentName:"ul"},"if the result is not nullable we can use ",Object(i.b)("inlineCode",{parentName:"li"},"expr_value.ptr")," directly"),Object(i.b)("li",{parentName:"ul"},"we make a note that we're in a loop (this matters for statement cleanup, more on that later)"),Object(i.b)("li",{parentName:"ul"},"we recurse to do more statements with ",Object(i.b)("inlineCode",{parentName:"li"},"cg_stmt_list")),Object(i.b)("li",{parentName:"ul"},"finally we end the ",Object(i.b)("inlineCode",{parentName:"li"},"for")," that we began")),Object(i.b)("p",null,"This kind of structure is common to all the control flow cases.  Generally, we have to deal with the\nfact that CQL expressions become C statements so we use a more general flow control strategy. But with this\nin mind, it's easy to imagine how ",Object(i.b)("inlineCode",{parentName:"p"},"IF")," ",Object(i.b)("inlineCode",{parentName:"p"},"LOOP")," and ",Object(i.b)("inlineCode",{parentName:"p"},"SWITCH")," are handled."),Object(i.b)("h3",{id:"cleanup-and-errors"},"Cleanup and Errors"),Object(i.b)("p",null,"There are a number of places where things can go wrong when running a CQL procedure.  The most\ncommon sources are: (1) SQLite APIs, almost all of which can fail, and, (2) calling other procedures\nwhich also might fail.  Here's a very simple example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nDECLARE PROC something_that_might_fail (arg TEXT) USING TRANSACTION;\n\nCREATE PROC p ()\nBEGIN\n  LET arg := "test";\n  CALL something_that_might_fail(arg);\nEND;\n*/\n\ncql_string_literal(_literal_1_test_p, "test");\n\nCQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {\n  cql_code _rc_ = SQLITE_OK;\n  cql_string_ref arg = NULL;\n\n  cql_set_string_ref(&arg, _literal_1_test_p);\n  _rc_ = something_that_might_fail(_db_, arg);\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_string_release(arg);\n  return _rc_;\n}\n')),Object(i.b)("p",null,"Let's look at this carefully:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"first, we had to declare ",Object(i.b)("inlineCode",{parentName:"li"},"something_that_might_fail"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"the declaration includes ",Object(i.b)("inlineCode",{parentName:"li"},"USING TRANSACTION")," indicating the procedure uses the database"),Object(i.b)("li",{parentName:"ul"},"we didn't provide the definition, that will lead to a link time error but we're ignoring that for now"))),Object(i.b)("li",{parentName:"ul"},"there is a string literal named ",Object(i.b)("inlineCode",{parentName:"li"},"_literal_1_test_p")," that is auto-created",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cql_string_literal"),' can expand into a variety of things, whatever you want "make a string literal" to mean'),Object(i.b)("li",{parentName:"ul"},"its defined in ",Object(i.b)("inlineCode",{parentName:"li"},"cqlrt.h")," and it's designed to be replaced"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cql_set_string_ref(&arg, _literal_1_test_p);"),' is expected to "retain" the string (+1 ref count)'),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cql_cleanup")," is the exit label, this code will run for sure",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"cleanup statements are accumulated by writing to ",Object(i.b)("inlineCode",{parentName:"li"},"cg_cleanup_output")," which usually writes to the ",Object(i.b)("inlineCode",{parentName:"li"},"proc_cleanup")," buffer"),Object(i.b)("li",{parentName:"ul"},"because cleanup is in its own buffer you can add to it freely whenever a new declaration that requires cleanup arises"),Object(i.b)("li",{parentName:"ul"},"in this case the declaration of the string literal caused the ",Object(i.b)("inlineCode",{parentName:"li"},"C")," variable ",Object(i.b)("inlineCode",{parentName:"li"},"arg")," to be created and also the cleanup code"))),Object(i.b)("li",{parentName:"ul"},"now we call ",Object(i.b)("inlineCode",{parentName:"li"},"something_that_might_fail")," passing it our database pointer and the argument"),Object(i.b)("li",{parentName:"ul"},"the hidden ",Object(i.b)("inlineCode",{parentName:"li"},"_db_")," pointer is passed to all procedures that use the database"),Object(i.b)("li",{parentName:"ul"},"these are also the ones that can fail"),Object(i.b)("li",{parentName:"ul"},"any failed return code (not ",Object(i.b)("inlineCode",{parentName:"li"},"SQLITE_OK"),") causes two things",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"the ",Object(i.b)("inlineCode",{parentName:"li"},"cql_error_trace()")," macro is invoked (this macro typically expands to nothing)"),Object(i.b)("li",{parentName:"ul"},"the code stops what it's doing and runs the cleanup code via ",Object(i.b)("inlineCode",{parentName:"li"},"goto cql_cleanup;"))))),Object(i.b)("p",null,"The essential sequence is this one:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"}," if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n")),Object(i.b)("p",null,"The C code generator uses this pattern all over to check if anything went wrong and to exit with an error code.\nExtensive logging can be very expensive but in debug builds, it's quite normal for ",Object(i.b)("inlineCode",{parentName:"p"},"cql_error_trace")," to expand\ninto something like ",Object(i.b)("inlineCode",{parentName:"p"},'fprintf(stderr, "error %d in %s %s:%d\\n", _rc_, _PROC_, __FILE__, __LINE_)')," which probably\na lot more logging than you want in a production build but great if you're debugging.  Recall that CQL generates\n",Object(i.b)("inlineCode",{parentName:"p"},'#define _PROC_ "p"')," before every procedure."),Object(i.b)("p",null,"This pattern generalizes well and indeed if we use the exception handling pattern, we get a lot of control.\nLet's generalize this a tiny bit."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC p (OUT success BOOL NOT NULL)\nBEGIN\n  LET arg := "test";\n  BEGIN TRY\n    CALL something_that_might_fail(arg);\n    SET success := 1;\n  END TRY;\n  BEGIN CATCH\n    SET success := 0;\n  END CATCH;\nEND;\n')),Object(i.b)("p",null,"CQL doesn't have complicated exception objects or anything like that, exceptions are just simple\ncontrol flow.  Here's the code for the above:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_bool *_Nonnull success) {\n  cql_contract_argument_notnull((void *)success, 1);\n\n  cql_code _rc_ = SQLITE_OK;\n  cql_string_ref arg = NULL;\n\n  *success = 0; // set out arg to non-garbage\n  cql_set_string_ref(&arg, _literal_1_test_p);\n  // try\n  {\n    _rc_ = something_that_might_fail(_db_, arg);\n    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }\n    *success = 1;\n    goto catch_end_1;\n  }\n  catch_start_1: {\n    *success = 0;\n  }\n  catch_end_1:;\n  _rc_ = SQLITE_OK;\n\n  cql_string_release(arg);\n  return _rc_;\n}\n")),Object(i.b)("p",null,"The code is nearly the same.  Let's look at the essential differences:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"If there is an error, the code hits ",Object(i.b)("inlineCode",{parentName:"li"},"goto catch_start_1")),Object(i.b)("li",{parentName:"ul"},"If the try block succeeds, the code hits ",Object(i.b)("inlineCode",{parentName:"li"},"goto catch_end_1")),Object(i.b)("li",{parentName:"ul"},"both branches set the ",Object(i.b)("inlineCode",{parentName:"li"},"success")," out parameter"),Object(i.b)("li",{parentName:"ul"},"we added that out argument, CQL generated an error check to ensure that arg 1 is not null",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cql_contract_argument_notnull((void *)success, 1)"),", the 1 means arg 1"),Object(i.b)("li",{parentName:"ul"},"the hidden ",Object(i.b)("inlineCode",{parentName:"li"},"_db_")," arg doesn't count")))),Object(i.b)("p",null,"How does this happen?  ",Object(i.b)("inlineCode",{parentName:"p"},"cg_trycatch_helper")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// Very little magic is needed to do try/catch in our context.  The error\n// handlers for all the sqlite calls check _rc_ and if it\'s an error they\n// "goto" the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.\n// Inside the try block, the cleanup handler is changed to the catch block.\n// The catch block puts it back.  Otherwise, generate nested statements as usual.\nstatic void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {\n  CHARBUF_OPEN(catch_start);\n  CHARBUF_OPEN(catch_end);\n\n  // We need unique labels for this block\n  ++catch_block_count;\n  bprintf(&catch_start, "catch_start_%d", catch_block_count);\n  bprintf(&catch_end, "catch_end_%d", catch_block_count);\n\n  // Divert the error target.\n  CSTR saved_error_target = error_target;\n  bool_t saved_error_target_used = error_target_used;\n  error_target = catch_start.ptr;\n  error_target_used = 0;\n ...\n')),Object(i.b)("p",null,"All of the error handling does goto ",Object(i.b)("inlineCode",{parentName:"p"},"error_target")," whatever that is.  The\ntry/catch pattern simply changes the current error target.  The rest of\nthe code is just to save the current error target and to create unique\nlabels for the the control flow."),Object(i.b)("p",null,"The important notion is that, if anything goes wrong, whatever it is,\nthe generator simply does a ",Object(i.b)("inlineCode",{parentName:"p"},"goto error_target")," and that will either\nhit the catch block or else go to cleanup."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"THROW")," operation illustrates this well:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// Convert _rc_ into an error code.  If it already is one keep it.\n// Then go to the current error target.\nstatic void cg_throw_stmt(ast_node *ast) {\n  Contract(is_ast_throw_stmt(ast));\n\n  bprintf(cg_main_output, "_rc_ = cql_best_error(%s);\\n", rcthrown_current);\n  bprintf(cg_main_output, "goto %s;\\n", error_target);\n  error_target_used = 1;\n  rcthrown_used = 1;\n}\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"first we make sure ",Object(i.b)("em",{parentName:"li"},"rc")," has some kind of error in it either ",Object(i.b)("inlineCode",{parentName:"li"},"rcthrown_current")," or else ",Object(i.b)("inlineCode",{parentName:"li"},"SQLITE_ERROR")),Object(i.b)("li",{parentName:"ul"},"then we goto the current error target"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"error_target_used")," tracks whether there were any possible errors, this is just to avoid C compiler errors about unused labels.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"if the label is not used it won't be emitted"),Object(i.b)("li",{parentName:"ul"},"the code never jump back to an error label so we'll always know if it was used before we need to emit it")))),Object(i.b)("p",null,"Note: every catch block captures the value of ",Object(i.b)("inlineCode",{parentName:"p"},"_rc_")," in a local variable whose name is in ",Object(i.b)("inlineCode",{parentName:"p"},"rcthrown_current"),".\nThis is the current failing result code accessible by ",Object(i.b)("inlineCode",{parentName:"p"},"@RC")," in CQL."),Object(i.b)("p",null,"A catch block can therefore do stuff like:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-sql"},"IF @RC = 1 THEN\n  THROW;\nELSE\n  call attempt_retry();\nEND IF;\n")),Object(i.b)("p",null,"or something like that."),Object(i.b)("p",null,"This entire mechanism is built with basically just a few state variables that nest.  There is no complicated stack walking\nor anything like that.  All the code has to do is chain the error labels together and let users create new catch blocks\nwith new error labels.  All that together gives you very flexible try/catch behaviour."),Object(i.b)("h3",{id:"string-literals"},"String Literals"),Object(i.b)("p",null,"Before we move on to more complex statements we have to discuss string literals a little bit.  We've mentioned before\nthat the compiler is going to generate something like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'cql_string_literal(_literal_1_test_p, "test");\n')),Object(i.b)("p",null,"To create a reference counted object ",Object(i.b)("inlineCode",{parentName:"p"},"_literal_1_test_p")," that it can use.  Now we're going to talk about how\nthe text ",Object(i.b)("inlineCode",{parentName:"p"},'"test"')," was created and how that gets more complicated."),Object(i.b)("p",null,"The first thing to remember is that the generator creates C programs.  That means\nno matter what kind of literal we might be processing it's ending up encoded as a C string for the C\ncompiler.  The C compiler will be the first thing the decodes the text the generator produces and\nputs the byte we need into the final programs data segment or whereever.  That means if we have\nSQL format strings that need to go to SQLite they will be twice-encoded, the SQL string is escaped\nas needed for SQLite and ",Object(i.b)("em",{parentName:"p"},"that")," is escaped again for the C compiler."),Object(i.b)("p",null,"An example might make this clearer consider the following SQL:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},"  SELECT '\"x''y\"' AS a, \"'y'\\n\" AS b;\n")),Object(i.b)("p",null,"The generated text for this statement will be:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  \"SELECT '\\\"x''y\\\"', '''y''\\n'\"\n")),Object(i.b)("p",null,"Let's review that in some detail:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'the first string "a" is a standard SQL string'),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"it is represented unchanged in the AST, it is ",Object(i.b)("em",{parentName:"li"},"not")," unescaped"),Object(i.b)("li",{parentName:"ul"},"even the outer single quotes are preserved, CQL has no need to change it at all"),Object(i.b)("li",{parentName:"ul"},"when we emit it into our output it will be read by the C compiler, so"),Object(i.b)("li",{parentName:"ul"},"at that time it is escaped ",Object(i.b)("em",{parentName:"li"},"again")," into C format",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"the double quotes which required no escaping in SQL become ",Object(i.b)("inlineCode",{parentName:"li"},'\\"')))),Object(i.b)("li",{parentName:"ul"},"the single quote character requires no escape but there are still two of them because SQLite will also process this string"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'the second string "b" is a C formatted string literal'),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"SQLite doesn't support this format or its escapes, therefore"),Object(i.b)("li",{parentName:"ul"},"as discussed in ",Object(i.b)("a",{parentName:"li",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),", it is decoded to plain text, then re-encoded as a SQL escaped string"),Object(i.b)("li",{parentName:"ul"},"internal newlines do not require escaping in SQL, they are in the string as the newline character not '\\n' or anything like that",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"to be completely precise the byte value 0x0a is in the string unescaped"))),Object(i.b)("li",{parentName:"ul"},"internal single quotes don't require escaping in C, these have to be doubled in a SQL string"),Object(i.b)("li",{parentName:"ul"},"the outer double quotes are removed and replaced by single quoates during this process"),Object(i.b)("li",{parentName:"ul"},"the AST now has a valid SQL formatted string possibly with weird characters in it"),Object(i.b)("li",{parentName:"ul"},"as before, this string has to be formatted for the C compiler so now it has to be escaped again"),Object(i.b)("li",{parentName:"ul"},"the single quotes require no further processing, though now there are quite a few of them"),Object(i.b)("li",{parentName:"ul"},'the embedded newline is converted to the escape sequence "\\n" so we\'re back to sort of where we started',Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"the C compiler will convert this back to the byte 0x0a which is what ends up in the data segment")))))),Object(i.b)("p",null,"In the above example we were making one overall string for the ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," statement so the outer double quotes\nare around the whole statement.  That was just for the convenience of this example.  If the literals had\nbeen in some other loose context then individual strings would be produced the same way.  Except, not so fast,\nnot every string literal is heading for SQLite.  Some are just making regular strings.  In that case even\nif they are destined for SQLite they will go as bound arguments to a statement not in the text of the SQL.\nThat means ",Object(i.b)("em",{parentName:"p"},"those")," strings do not need SQL escaping."),Object(i.b)("p",null,"Consider:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},"  LET a := '\"x''y\"';\n  LET b := \"'y'\\n\";\n")),Object(i.b)("p",null,"To do those assignments we need:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'cql_string_literal(_literal_1_x_y_p, "\\"x\'y\\"");\ncql_string_literal(_literal_2_y_p, "\'y\'\\n");\n')),Object(i.b)("p",null,"In both of these cases the steps are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"unescape the escaped SQL string in the AST to plain text",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"removing the outer single quotes of course"))),Object(i.b)("li",{parentName:"ul"},"re-escape the plain text (which might include newlines and such) as a C string",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"emit that text, including its outer double quotes")))),Object(i.b)("p",null,"Trivia: the name of the string literal variables include a fragment of the string to make them a little easier to spot."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"encoders.h")," has the encoding functions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cg_decode_string_literal")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cg_encode_string_literal")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cg_encode_c_string_literal")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cg_decode_c_string_literal"))),Object(i.b)("p",null,"As well as similar functions for single characters to make all this possible.  Pretty much every combination\nof encoding and re-encoding happens in some path through the code generator."),Object(i.b)("h3",{id:"executing-sqlite-statements"},"Executing SQLite Statements"),Object(i.b)("p",null,"By way of example let's consider a pretty simple piece of SQL we might want to run."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE TABLE foo(id INTEGER, t TEXT);\n\nCREATE PROC p (id_ INTEGER, t_ TEXT)\nBEGIN\n  UPDATE foo\n  SET t = t_\n    WHERE id = id_;\nEND;\n")),Object(i.b)("p",null,"To make this happen we're going to have to do the following things:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"create a string literal with the statement we need"),Object(i.b)("li",{parentName:"ul"},"the references to ",Object(i.b)("inlineCode",{parentName:"li"},"id_")," and ",Object(i.b)("inlineCode",{parentName:"li"},"t_")," have to be replaced with ",Object(i.b)("inlineCode",{parentName:"li"},"?")),Object(i.b)("li",{parentName:"ul"},"we prepare that statement"),Object(i.b)("li",{parentName:"ul"},"we bind the values of ",Object(i.b)("inlineCode",{parentName:"li"},"id_")," and ",Object(i.b)("inlineCode",{parentName:"li"},"t_")),Object(i.b)("li",{parentName:"ul"},"we ",Object(i.b)("inlineCode",{parentName:"li"},"step")," the statement"),Object(i.b)("li",{parentName:"ul"},"we ",Object(i.b)("inlineCode",{parentName:"li"},"finalize")," the statement"),Object(i.b)("li",{parentName:"ul"},"suitable error checks have to be done at each stage")),Object(i.b)("p",null,"That's quite a bit of code and it's easy to forget a step, this is an area where CQL shines.  The\ncode we had to write in CQL was very clear and all the error checking is implicit."),Object(i.b)("p",null,"This is the generated code.  We'll walk through it and discuss how it is created."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'CQL_WARN_UNUSED cql_code p(\n  sqlite3 *_Nonnull _db_,\n  cql_nullable_int32 id_,\n  cql_string_ref _Nullable t_)\n{\n  cql_code _rc_ = SQLITE_OK;\n  sqlite3_stmt *_temp_stmt = NULL;\n\n  _rc_ = cql_prepare(_db_, &_temp_stmt,\n    "UPDATE foo "\n    "SET t = ? "\n      "WHERE id = ?");\n  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,\n                CQL_DATA_TYPE_INT32, &id_,\n                CQL_DATA_TYPE_STRING, t_);\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = sqlite3_step(_temp_stmt);\n  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n  cql_finalize_stmt(&_temp_stmt);\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_finalize_stmt(&_temp_stmt);\n  return _rc_;\n}\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the functions signature includes the hidden ",Object(i.b)("inlineCode",{parentName:"li"},"_db_")," parameter plus the two arguments"),Object(i.b)("li",{parentName:"ul"},"we need a hidden ",Object(i.b)("inlineCode",{parentName:"li"},"_rc_")," variable to hold the result codes from SQLite"),Object(i.b)("li",{parentName:"ul"},"we need a scratch ",Object(i.b)("inlineCode",{parentName:"li"},"sqlite3_stmt *")," named ",Object(i.b)("inlineCode",{parentName:"li"},"_temp_stmt")," to talk to SQLite",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"when this is created, the cleanup section gets ",Object(i.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt(&_temp_stmt);")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt")," sets the statement to null and does nothing if it's already null"))),Object(i.b)("li",{parentName:"ul"},"the string ",Object(i.b)("inlineCode",{parentName:"li"},'"INSERT INTO foo(id, t) VALUES(?, ?)"')," is created from the AST",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"recall that we have ",Object(i.b)("inlineCode",{parentName:"li"},"variables_callback")," as an option, it's used here to track the variables and replace them with ",Object(i.b)("inlineCode",{parentName:"li"},"?")),Object(i.b)("li",{parentName:"ul"},"more on this shortly"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cql_multibind")," is used to bind the values of ",Object(i.b)("inlineCode",{parentName:"li"},"id_")," and ",Object(i.b)("inlineCode",{parentName:"li"},"t_"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"this is just a varargs version of the normal SQLite binding functions, it's only done this way to save space"),Object(i.b)("li",{parentName:"ul"},"only one error check is needed for any binding failure"),Object(i.b)("li",{parentName:"ul"},"the type of binding is encoded very economically"),Object(i.b)("li",{parentName:"ul"},'the "2" here refers to two arguments'))),Object(i.b)("li",{parentName:"ul"},"the usual error processing happens with ",Object(i.b)("inlineCode",{parentName:"li"},"cql_error_trace")," and ",Object(i.b)("inlineCode",{parentName:"li"},"goto cql_cleanup")),Object(i.b)("li",{parentName:"ul"},"the statment is executed with ",Object(i.b)("inlineCode",{parentName:"li"},"sqlite3_step")),Object(i.b)("li",{parentName:"ul"},"temporary statements are finalized immediately with ",Object(i.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"in this case its redundant because the code is going to fall through to cleanup anyway"),Object(i.b)("li",{parentName:"ul"},"in general there could be many statements and we want to finalize immediately"),Object(i.b)("li",{parentName:"ul"},"this is an optimization opportunity, procedures with just one statement are very common")))),Object(i.b)("p",null,"Most of these steps are actually hard coded.  There is no variability in the sequence\nafter the ",Object(i.b)("inlineCode",{parentName:"p"},"multibind")," call, so that's just boiler-plate the compiler can inject."),Object(i.b)("p",null,"We don't want to declare ",Object(i.b)("inlineCode",{parentName:"p"},"_temp_stmt")," over and over so there's a flag that records\nwhether it has already been declared in the current procedure."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// Emit a declaration for the temporary statement _temp_stmt_ if we haven\'t\n// already done so.  Also emit the cleanup once.\nstatic void ensure_temp_statement() {\n  if (!temp_statement_emitted) {\n    bprintf(cg_declarations_output, "sqlite3_stmt *_temp_stmt = NULL;\\n");\n    bprintf(cg_cleanup_output, "  cql_finalize_stmt(&_temp_stmt);\\n");\n    temp_statement_emitted = 1;\n  }\n}\n')),Object(i.b)("p",null,"This is a great example of how, no matter where the processing happens to be,\nthe generator can emit things into the various sections.  Here it adds\na declaration and an cleanup with no concern about what else might be going on."),Object(i.b)("p",null,"So most of the above is just boiler-plate, the tricky part is:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"getting the text of the SQL"),Object(i.b)("li",{parentName:"ul"},"binding the variables")),Object(i.b)("p",null,"All of this is the business of this function:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// This is the most important function for sqlite access;  it does the heavy\n// lifting of generating the C code to prepare and bind a SQL statement.\n// If cg_exec is true (CG_EXEC) then the statement is executed immediately\n// and finalized.  No results are expected.  To accomplish this we do the following:\n//   * figure out the name of the statement, either it's given to us\n//     or we're using the temp statement\n//   * call get_statement_with_callback to get the text of the SQL from the AST\n//     * the callback will give us all the variables to bind\n//     * count the variables so we know what column numbers to use (the list is backwards!)\n//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form\n//   * bind any variables\n//   * if there are variables CG_EXEC will step and finalize\nstatic void cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_flags)\n{\n  ...\n}\n")),Object(i.b)("p",null,"The core of this function looks like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  gen_sql_callbacks callbacks;\n  init_gen_sql_callbacks(&callbacks);\n  callbacks.variables_callback = cg_capture_variables;\n  callbacks.variables_context = &vars;\n  // ... more flags\n\n  CHARBUF_OPEN(temp);\n  gen_set_output_buffer(&temp);\n  gen_statement_with_callbacks(stmt, &callbacks);\n")),Object(i.b)("p",null,"It's set up the callbacks for variables and it calls the echoing function on the buffer.  We've\ntalked about ",Object(i.b)("inlineCode",{parentName:"p"},"gen_statement_with_callbacks")," in  ",Object(i.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),"."),Object(i.b)("p",null,"Let's take a look at that callback function:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},'// This is the callback method handed to the gen_ method that creates SQL for us\n// it will call us every time it finds a variable that needs to be bound.  That\n// variable is replaced by ? in the SQL output.  We end up with a list of variables\n// to bind on a silver platter (but in reverse order).\nstatic bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {\n  list_item **head = (list_item**)context;\n  add_item_to_list(head, ast);\n\n  bprintf(buffer, "?");\n  return true;\n}\n')),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"context")," variable was set to be ",Object(i.b)("inlineCode",{parentName:"p"},"vars"),", we convert it back to the correct type\nand add the current ast to that list.  ",Object(i.b)("inlineCode",{parentName:"p"},"add_item_to_list")," always puts things at the\nhead so the list will be in reverse order."),Object(i.b)("p",null,"With this done, we're pretty much set.  We'll produce the statement with a sequence\nlike this one (there are a couple of variations, but this is the most general)"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  bprintf(cg_main_output, "_rc_ = cql_prepare(_db_, %s%s_stmt,\\n  ", amp, stmt_name);\n  cg_pretty_quote_plaintext(temp.ptr, cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);\n  bprintf(cg_main_output, ");\\n");\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"cg_pretty_quote_plaintext")," is one of the C string encoding formats, it could have been just the regular C string encoding\nbut that would have been a bit wasteful and it wouldn't have looked as nice.  This function does a little transform."),Object(i.b)("p",null,"The normal echo of the update statement in question looks like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"  UPDATE foo\n  SET t = ?\n    WHERE id = ?;\n")),Object(i.b)("p",null,"Note that it has indenting and newlines embedded in it.  The standard encoding of that would look like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'"  UPDATE foo\\n  SET t = ?\\n    WHERE id = ?;"\n')),Object(i.b)("p",null,"That surely works, but it's wasteful and ugly. The pretty format instead produces:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'    "UPDATE foo "\n    "SET t = ? "\n      "WHERE id = ?"\n')),Object(i.b)("p",null,"So, the newlines are gone from the string (they aren't needed), instead the string literal was broken into lines for readability.\nThe indenting is gone from the string, instead the string fragments are indented.  So what you get is a string literal that\nreads nicely but doesn't have unnecessary whitespace for SQLite.  Obviously you can't use pretty-quoted literals in all cases,\nit's exclusively for SQLite formatting."),Object(i.b)("p",null,"All that's left to do is bind the arguments.  Remember that arg list is in reverse order:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  uint32_t count = 0;\n  for (list_item *item = vars; item; item = item->next, count++) ;\n\n  // ...\n\n  reverse_list(&vars);\n\n  if (count) {\n    bprintf(cg_main_output, "cql_multibind(&_rc_, _db_, %s%s_stmt, %d", amp, stmt_name, count);\n\n    // Now emit the binding args for each variable\n    for (list_item *item = vars; item; item = item->next)  {\n      Contract(item->ast->sem->name);\n      bprintf(cg_main_output, ",\\n              ");\n      cg_bind_column(item->ast->sem->sem_type, item->ast->sem->name);\n    }\n\n    bprintf(cg_main_output, ");\\n");\n  }\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"first compute the count, we don't need to bind if there are no variables"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"reverse_list")," does exactly what is sounds like (finally a real-world use-case for reverse-list-in-place)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cg_bind_column")," creates one line of the var-args output: column type and variable name",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"the type and name information is right there on the ",Object(i.b)("inlineCode",{parentName:"li"},"AST")," in the ",Object(i.b)("inlineCode",{parentName:"li"},"sem_node"))))),Object(i.b)("p",null,"And that's it.  With those few helpers we can bind any SQLite statement the same way.  All of the\n",Object(i.b)("inlineCode",{parentName:"p"},"DDL_STMT_INIT")," and ",Object(i.b)("inlineCode",{parentName:"p"},"DML_STMT_INIT")," statements are completely implemented by this path."),Object(i.b)("p",null,"Next we'll talk about the cases where some data comes back from SQLite."))}p.isMDXComponent=!0},143:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),l=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),b=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=b(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},h=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=b(n),h=a,d=p["".concat(r,".").concat(h)]||p[h]||u[h]||i;return n?l.a.createElement(d,s(s({ref:t},c),{},{components:n})):l.a.createElement(d,s({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);