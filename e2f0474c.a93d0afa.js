(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{132:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),i=n(6),r=(n(0),n(148)),o=["components"],s={id:"int02",title:"Part 2: Semantic Analysis",sidebar_label:"Part 2: Semantic Analysis"},l={unversionedId:"int02",id:"int02",isDocsHomePage:!1,title:"Part 2: Semantic Analysis",description:"\x3c!---",source:"@site/../CQL_Guide/int02.md",slug:"/int02",permalink:"/cql-guide/int02",version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1638326825,sidebar_label:"Part 2: Semantic Analysis",sidebar:"someSidebar",previous:{title:"Part 1: Lexing, Parsing, and the AST",permalink:"/cql-guide/int01"},next:{title:"Part 3: C Code Generation",permalink:"/cql-guide/int03"}},c=[{value:"Preface",id:"preface",children:[]},{value:"Semantic Analysis",id:"semantic-analysis",children:[{value:"Decorated AST examples",id:"decorated-ast-examples",children:[]},{value:"The Base Data Structures",id:"the-base-data-structures",children:[]},{value:"Initiating Semantic Analysis",id:"initiating-semantic-analysis",children:[]},{value:"Semantic Errors",id:"semantic-errors",children:[]},{value:"The Primitive Types",id:"the-primitive-types",children:[]},{value:"Unary Operators",id:"unary-operators",children:[]},{value:"Binary Operators",id:"binary-operators",children:[]},{value:"Simple Statement Validation",id:"simple-statement-validation",children:[]},{value:"Expression Contexts",id:"expression-contexts",children:[]},{value:"Name Resolution",id:"name-resolution",children:[]},{value:"Nullability Improvements",id:"nullability-improvements",children:[]},{value:"Structure types and the notion of Shapes",id:"structure-types-and-the-notion-of-shapes",children:[]},{value:"Join Types",id:"join-types",children:[]},{value:"Schema Regions",id:"schema-regions",children:[]},{value:"Results of Semantic Analysis",id:"results-of-semantic-analysis",children:[]},{value:"Recap",id:"recap",children:[]}]}],b={rightToc:c};function p(e){var t=e.components,n=Object(i.a)(e,o);return Object(r.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h3",{id:"preface"},"Preface"),Object(r.b)("p",null,"Part 2 continues with a discussion of the essentials of the semantic analysis pass of the CQL compiler.\nAs in the previous sections, the goal here is not to go over every single rule but rather to give\na sense of how semantic analysis happens in general -- the core strategies and implementation choices --\nso that when reading the code you will have an idea how smaller pieces fit into the whole. To accomplish\nthis, various key data structures will be explained in detail as well as selected examples of their use."),Object(r.b)("h2",{id:"semantic-analysis"},"Semantic Analysis"),Object(r.b)("p",null,'The overall goal of the semantic analysis pass is to verify that a correct program has been submitted\nto the compiler. The compiler does this by "decorating" the AST with semantic information.  This information\nis mainly concerned with the "types" of the various things in the program.  A key function of the semantic\nanalyzer, the primary "weapon" in computing these types if you will, is name resolution.  The semantic analyzer\ndecides what any given name means in any context and then uses that meaning, which is itself based on the\nAST constructs that came before, to compute types and then check those types for errors.'),Object(r.b)("p",null,"Broadly speaking the errors that can be discovered are of these forms:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"mentioned names do not exist",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. using a variable or table or column without declaring it"))),Object(r.b)("li",{parentName:"ul"},"mentioned names are not unique, or are ambiguous",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. every view must have a unique name"),Object(r.b)("li",{parentName:"ul"},"e.g. table names need to be unique, or aliased when joining tables"))),Object(r.b)("li",{parentName:"ul"},"operands are not compatible with each other or with the intended operation",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. you can't add a string to a real"),Object(r.b)("li",{parentName:"ul"},"e.g. you can't do the ",Object(r.b)("inlineCode",{parentName:"li"},"%")," operation on a real"),Object(r.b)("li",{parentName:"ul"},"e.g. the expression in a ",Object(r.b)("inlineCode",{parentName:"li"},"WHERE")," clause must result in a numeric"),Object(r.b)("li",{parentName:"ul"},"e.g. the first argument to ",Object(r.b)("inlineCode",{parentName:"li"},"printf")," must be a string literal."),Object(r.b)("li",{parentName:"ul"},"e.g. you can't assign a long value to an integer variable"),Object(r.b)("li",{parentName:"ul"},"e.g. you can't assign a possibly null result to a not-null variable"))),Object(r.b)("li",{parentName:"ul"},"there are too many or two few operands for an operation",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. an ",Object(r.b)("inlineCode",{parentName:"li"},"INSERT")," statement must include sufficiently many columns and no extras"),Object(r.b)("li",{parentName:"ul"},"e.g. a function or procedure call must have the correct number of operands"))),Object(r.b)("li",{parentName:"ul"},"an operation is happening in a context where it is not allowed",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. use of aggregate functions in the ",Object(r.b)("inlineCode",{parentName:"li"},"WHERE")," clause"),Object(r.b)("li",{parentName:"ul"},"e.g. use of unique SQLite functions outside of a SQL statement")))),Object(r.b)("p",null,"There are several hundred possible errors, no attempt will be made to cover them all here but we will\ntalk about how errors are created, recorded, and reported."),Object(r.b)("h3",{id:"decorated-ast-examples"},"Decorated AST examples"),Object(r.b)("p",null,"Recalling the AST output from ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),", this is what that same tree\nlooks like with semantic information attached."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"LET X := 1 + 3;\n\n  {let_stmt}: X: integer notnull variable\n  | {name X}: X: integer notnull variable\n  | {add}: integer notnull\n    | {int 1}: integer notnull\n    | {int 3}: integer notnull\n")),Object(r.b)("p",null,"And here's an example with some structure types"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"SELECT 1 AS x, 3.2 AS y;\n\n  {select_stmt}: select: { x: integer notnull, y: real notnull }\n  | {select_core_list}: select: { x: integer notnull, y: real notnull }\n  | | {select_core}: select: { x: integer notnull, y: real notnull }\n  |   | {select_expr_list_con}: select: { x: integer notnull, y: real notnull }\n  |     | {select_expr_list}: select: { x: integer notnull, y: real notnull }\n  |     | | {select_expr}: x: integer notnull\n  |     | | | {int 1}: integer notnull\n  |     | | | {opt_as_alias}\n  |     | |   | {name x}\n  |     | | {select_expr_list}\n  |     |   | {select_expr}: y: real notnull\n  |     |     | {dbl 3.2}: real notnull\n  |     |     | {opt_as_alias}\n  |     |       | {name y}\n  |     | {select_from_etc}: ok\n  |       | {select_where}\n  |         | {select_groupby}\n  |           | {select_having}\n  | {select_orderby}\n    | {select_limit}\n      | {select_offset}\n")),Object(r.b)("p",null,"These can be generated by adding ",Object(r.b)("inlineCode",{parentName:"p"},"--sem --print")," to the CQL command line along with ",Object(r.b)("inlineCode",{parentName:"p"},"--in your_file.sql"),"."),Object(r.b)("p",null,"Keep these shapes in mind as we discuss the various sources of type information."),Object(r.b)("h3",{id:"the-base-data-structures"},"The Base Data Structures"),Object(r.b)("p",null,"First recall that every AST node has this field in it:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"struct sem_node *_Nullable sem;\n")),Object(r.b)("p",null,"This is the pointer to the semantic information for that node. Semantic analysis happens immediately\nafter parsing and before any of the code-generators run.  Importantly, code generators never run\nif semantic analysis reported any errors.  Before we get into the shape of the semantic node, we\nshould start with the fundamental unit of type info ",Object(r.b)("inlineCode",{parentName:"p"},"sem_t")," which is usually stored in a variable\ncalled ",Object(r.b)("inlineCode",{parentName:"p"},"sem_type"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef uint64_t sem_t;\n")),Object(r.b)("p",null,"The low order bits of a ",Object(r.b)("inlineCode",{parentName:"p"},"sem_t")," encode the core type and indeed there is an helper function\nto extract the core type from a ",Object(r.b)("inlineCode",{parentName:"p"},"sem_t"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Strips out all the flag bits and gives you the base/core type.\ncql_noexport sem_t core_type_of(sem_t sem_type) {\n  return sem_type & SEM_TYPE_CORE;\n}\n")),Object(r.b)("p",null,"The core bits are as follows:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#define SEM_TYPE_NULL 0         // the subtree is a null literal (not just nullable)\n#define SEM_TYPE_BOOL 1         // the subtree is a bool\n#define SEM_TYPE_INTEGER 2      // the subtree is an integer\n#define SEM_TYPE_LONG_INTEGER 3 // the subtree is a long integer\n#define SEM_TYPE_REAL 4         // the subtree is a real\n#define SEM_TYPE_TEXT 5         // the subtree is a text type\n#define SEM_TYPE_BLOB 6         // the subtree is a blob type\n#define SEM_TYPE_OBJECT 7       // the subtree is any object type\n#define SEM_TYPE_STRUCT 8       // the subtree is a table/view\n#define SEM_TYPE_JOIN 9         // the subtree is a join\n#define SEM_TYPE_ERROR 10       // marks the subtree as having a problem\n#define SEM_TYPE_OK 11          // sentinel for ok but no type info\n#define SEM_TYPE_PENDING 12     // sentinel for type calculation in flight\n#define SEM_TYPE_REGION 13      // the ast is a schema region\n#define SEM_TYPE_CORE 0xff      // bit mask for the core types\n\n#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) // the last unitary type\n")),Object(r.b)("p",null,"These break into a few categories:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"NULL")," to ",Object(r.b)("inlineCode",{parentName:"li"},"OBJECT"),' are the "unitary" types, these are the types that a single simple variable can be',Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"a column can be any of these except ",Object(r.b)("inlineCode",{parentName:"li"},"OBJECT")," or ",Object(r.b)("inlineCode",{parentName:"li"},"NULL")),Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},"NULL")," type comes only from the ",Object(r.b)("inlineCode",{parentName:"li"},"NULL")," literal which has no type"),Object(r.b)("li",{parentName:"ul"},"instances of say a ",Object(r.b)("inlineCode",{parentName:"li"},"TEXT")," column might have a ",Object(r.b)("inlineCode",{parentName:"li"},"NULL")," value but they are known to be ",Object(r.b)("inlineCode",{parentName:"li"},"TEXT")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"STRUCT")," indicates that the object has many fields, like a table, or a cursor"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"JOIN")," indicates that the object is the concatenation of many ",Object(r.b)("inlineCode",{parentName:"li"},"STRUCT")," types",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"T1 inner join T2")," is a ",Object(r.b)("inlineCode",{parentName:"li"},"JOIN")," type with ",Object(r.b)("inlineCode",{parentName:"li"},"T1")," and ",Object(r.b)("inlineCode",{parentName:"li"},"T2")," being the parts"),Object(r.b)("li",{parentName:"ul"},"a ",Object(r.b)("inlineCode",{parentName:"li"},"JOIN")," could be flattened to ",Object(r.b)("inlineCode",{parentName:"li"},"STRUCT"),", but this is typically not done"),Object(r.b)("li",{parentName:"ul"},"the type of a ",Object(r.b)("inlineCode",{parentName:"li"},"SELECT")," statement will be a ",Object(r.b)("inlineCode",{parentName:"li"},"STRUCT")," representing the expressions that were selected"),Object(r.b)("li",{parentName:"ul"},"those expressions in turn used columns from the ",Object(r.b)("inlineCode",{parentName:"li"},"JOIN")," that was the ",Object(r.b)("inlineCode",{parentName:"li"},"FROM")," clause"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ERROR")," indicates that the subtree had an error",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the error will have been already reported"),Object(r.b)("li",{parentName:"ul"},"the error type generally cascades up the AST to the root"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"OK")," indicates that there is no type information but there was no problem",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. a correct ",Object(r.b)("inlineCode",{parentName:"li"},"IF")," statement will resolve to simply ",Object(r.b)("inlineCode",{parentName:"li"},"OK")," (no error)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"PENDING")," is used sometimes while a type computation is in progress",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this type doesn't appear in the AST, but has its own unique value so as to not conflict with any others"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"REGION")," is used to identify AST fragments that correspond to schema regions",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"see ",Object(r.b)("a",{parentName:"li",href:"https://cgsql.dev/cql-guide/ch10"},"Chapter 10")," of the Guide for more information on regions"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"CORE")," is the mask for the core parts, ",Object(r.b)("inlineCode",{parentName:"li"},"0xf")," would do the job but for easy reading in the debugger we use ",Object(r.b)("inlineCode",{parentName:"li"},"0xff"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"new core types are not added very often, adding a new one is usually a sign that you are doing something wrong")))),Object(r.b)("p",null,"The core type can be modified by various flags.  The flags in principle can be combined in any way but in practice many combinations make no sense.\nFor instance, ",Object(r.b)("inlineCode",{parentName:"p"},"HAS_DEFAULT")," is for table columns and ",Object(r.b)("inlineCode",{parentName:"p"},"CREATE_FUNC")," is for function declarations. There is no one object that could require both of these."),Object(r.b)("p",null,"The full list as of this writing is as follows:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'#define SEM_TYPE_NOTNULL               _64(0x0100) // set if and only if null is not possible\n#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) // set for table columns with a default\n#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) // set for table columns with autoinc\n#define SEM_TYPE_VARIABLE              _64(0x0800) // set for variables and parameters\n#define SEM_TYPE_IN_PARAMETER          _64(0x1000) // set for in parameters (can mix with below)\n#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) // set for out parameters (can mix with above)\n#define SEM_TYPE_DML_PROC              _64(0x4000) // set for stored procs that have DML/DDL\n#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) // set for a cursor with simplified fetch syntax\n#define SEM_TYPE_CREATE_FUNC          _64(0x10000) // set for a function that returns a created object +1 ref\n#define SEM_TYPE_SELECT_FUNC          _64(0x20000) // set for a sqlite UDF function declaration\n#define SEM_TYPE_DELETED              _64(0x40000) // set for columns that are not visible in the current schema version\n#define SEM_TYPE_VALIDATED            _64(0x80000) // set if item has already been validated against previous schema\n#define SEM_TYPE_USES_OUT            _64(0x100000) // set if proc has a one rowresult using the OUT statement\n#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) // set if proc uses the OUT UNION form for multi row result\n#define SEM_TYPE_PK                  _64(0x400000) // set if column is a primary key\n#define SEM_TYPE_FK                  _64(0x800000) // set if column is a foreign key\n#define SEM_TYPE_UK                 _64(0x1000000) // set if column is a unique key\n#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) // set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement\n#define SEM_TYPE_SENSITIVE          _64(0x4000000) // set if the object is privacy sensitive\n#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) // set if the object is a deployable region\n#define SEM_TYPE_BOXED             _64(0x10000000) // set if a cursor\'s lifetime is managed by a box object\n#define SEM_TYPE_HAS_CHECK         _64(0x20000000) // set for table column with a "check" clause\n#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) // set for table column with a "collate" clause\n#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) // set if inferred to not be nonnull (but was originally nullable)\n#define SEM_TYPE_VIRTUAL          _64(0x100000000) // set if and only if this is a virtual table\n#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) // set if and only if hidden column on a virtual table\n#define SEM_TYPE_TVF              _64(0x400000000) // set if and only table node is a table valued function\n#define SEM_TYPE_IMPLICIT         _64(0x800000000) // set if and only the variable was declare implicitly (via declare out)\n#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) // set if proc calls an out union proc for\n')),Object(r.b)("p",null,"Note: ",Object(r.b)("inlineCode",{parentName:"p"},"_64(x)")," expands to either a trailing ",Object(r.b)("inlineCode",{parentName:"p"},"L")," or a trailing ",Object(r.b)("inlineCode",{parentName:"p"},"LL")," depending on the bitness of the compiler, whichever yields an ",Object(r.b)("inlineCode",{parentName:"p"},"int64_t"),"."),Object(r.b)("p",null,"Going over the meaning of all of the above is again beyond the scope of this document; some of the flags are very specialized and essentially the validation\njust requires a bit of storage in the tree to do its job so that storage is provided with a flag.  However two flag bits are especially important and\nare computed almost everywhere ",Object(r.b)("inlineCode",{parentName:"p"},"sem_t")," is used.  These are ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_NOTNULL")," and ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_SENSITIVE"),"."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_NOTNULL")," indicates that the marked item is known to be ",Object(r.b)("inlineCode",{parentName:"li"},"NOT NULL"),", probably because it was declared as such, or directly derived from a not null item",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Typically when two operands are combined both must be marked ",Object(r.b)("inlineCode",{parentName:"li"},"NOT NULL")," for the result to still be ",Object(r.b)("inlineCode",{parentName:"li"},"NOT NULL")," (there are exceptions like ",Object(r.b)("inlineCode",{parentName:"li"},"COALESCE"),")"),Object(r.b)("li",{parentName:"ul"},"Values that might be null cannot be assigned to targets that must not be null"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_SENSITIVE")," indicates that the marked item is some kind of PII or other sensitive data.",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Any time a sensitive operand is combined with another operand the resulting type is sensitive"),Object(r.b)("li",{parentName:"ul"},'There are very few ways to "get rid" of the sensitive bit -- it corresponds to the presence of ',Object(r.b)("inlineCode",{parentName:"li"},"@sensitive")," in the data type declaration."),Object(r.b)("li",{parentName:"ul"},"Values that are sensitive cannot be assigned to targets that are not marked sensitive")))),Object(r.b)("p",null,"The semantic node ",Object(r.b)("inlineCode",{parentName:"p"},"sem_node")," carries all the possible semantic info we might need, the ",Object(r.b)("inlineCode",{parentName:"p"},"sem_type")," holds the flags above and tells us how to interpret the rest of the node.\nThere are many fields, we'll talk about some of the most important ones here to give you a sense of how things hang together."),Object(r.b)("p",null,"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"CSTR")," is simply an alias for ",Object(r.b)("inlineCode",{parentName:"p"},"const char *"),".  ",Object(r.b)("inlineCode",{parentName:"p"},"CSTR")," is used extensively in the codebase for brevity."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct sem_node {\n  sem_t sem_type;                   // core type plus flags\n  CSTR name;                        // for named expressions in select columns etc.\n  CSTR kind;                        // the Foo in object<Foo>, not a variable or column name\n  CSTR error;                       // error text for test output, not used otherwise\n  struct sem_struct *sptr;          // encoded struct if any\n  struct sem_join *jptr;            // encoded join if any\n  int32_t create_version;           // create version if any (really only for tables and columns)\n  int32_t delete_version;           // create version if any (really only for tables and columns)\n  bool_t recreate;                  // for tables only, true if marked @recreate\n  CSTR recreate_group_name;         // for tables only, the name of the recreate group if they are in one\n  CSTR region;                      // the schema region, if applicable, null means unscoped (default)\n  symtab *used_symbols;             // for select statements, we need to know which of the ids in the select list was used if any\n  list_item *index_list;            // for tables we need the list of indices that use this table (so we can recreate them together if needed)\n  struct eval_node *value;          // for enum values we have to store the evaluated constant value of each member of the enum\n} sem_node;\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_type")," : already discussed above, this tells you how to interpret everything else"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name")," : variables, columns, etc. have a canonical name, when a name case-insensitivity resolves, the canonical name is stored here",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"typically later passes emit the canonical variable name everywhere"),Object(r.b)("li",{parentName:"ul"},"e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"FoO")," and ",Object(r.b)("inlineCode",{parentName:"li"},"fOO")," might both resolve to an object declared as ",Object(r.b)("inlineCode",{parentName:"li"},"foo"),", we always emit ",Object(r.b)("inlineCode",{parentName:"li"},"foo")," in codegen"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"kind")," : in CQL any type can be discriminated as in ",Object(r.b)("inlineCode",{parentName:"li"},"declare foo real<meters>"),", the kind here is ",Object(r.b)("inlineCode",{parentName:"li"},"meters"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"two expressions of the same core type (e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"real"),") are incompatible if they have a ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," and the ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," does not match"),Object(r.b)("li",{parentName:"ul"},"e.g. if you have ",Object(r.b)("inlineCode",{parentName:"li"},"bar real<liters>")," then ",Object(r.b)("inlineCode",{parentName:"li"},"set foo := bar;")," is an error even though both are ",Object(r.b)("inlineCode",{parentName:"li"},"real")," because ",Object(r.b)("inlineCode",{parentName:"li"},"foo")," above is ",Object(r.b)("inlineCode",{parentName:"li"},"real<meters>")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sptr")," : if the item's core type is ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_STRUCT")," then this is populated, see below"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"jptr")," : if the item's core type is ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_JOIN")," then this is populated, see below")),Object(r.b)("p",null,"If the object is a structure type then this is simply an array of names, kinds, and semantic types.  In fact the semantic types will be all be unitary, possibly modified by ",Object(r.b)("inlineCode",{parentName:"p"},"NOT_NULL")," or ",Object(r.b)("inlineCode",{parentName:"p"},"SENSITIVE")," but none of the other flags apply.  A single ",Object(r.b)("inlineCode",{parentName:"p"},"sptr"),' directly corresponds to the notion of a "shape" in the analyzer.  Shapes come from anything\nthat looks like a table, such as a cursor, or the result of a ',Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statement."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// for tables and views and the result of a select\n\ntypedef struct sem_struct {\n  CSTR struct_name;               // struct name\n  uint32_t count;                 // count of fields\n  CSTR *names;                    // field names\n  CSTR *kinds;                    // the "kind" text of each column, if any, e.g. integer<foo> foo is the kind\n  sem_t *semtypes;                // typecode for each field\n} sem_struct;\n')),Object(r.b)("p",null,"If the object is a join type (such as the parts of the ",Object(r.b)("inlineCode",{parentName:"p"},"FROM")," clause) then the ",Object(r.b)("inlineCode",{parentName:"p"},"jptr")," field will be populated. This is nothing more than a named list of struct types."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// for the data type of (parts of) the FROM clause\n// sometimes I refer to as a "joinscope"\n\ntypedef struct sem_join {\n  uint32_t count;                 // count of table/views in the join\n  CSTR *names;                    // names of the table/view\n  struct sem_struct **tables;     // struct type of each table/view\n} sem_join;\n')),Object(r.b)("p",null,"With these building blocks we can represent the type of anything in the CQL language."),Object(r.b)("h3",{id:"initiating-semantic-analysis"},"Initiating Semantic Analysis"),Object(r.b)("p",null,"The semantic analysis pass runs much the same way as the AST emitter.  In ",Object(r.b)("inlineCode",{parentName:"p"},"sem.c")," there is the essential function ",Object(r.b)("inlineCode",{parentName:"p"},"sem_main"),". It suffices\nto call ",Object(r.b)("inlineCode",{parentName:"p"},"sem_main")," on the root of the AST. That root node is expected to be a ",Object(r.b)("inlineCode",{parentName:"p"},"stmt_list")," node."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// This method loads up the global symbol tables in either empty state or\n// with the appropriate tokens ready to go.  Using our own symbol tables for\n// dispatch saves us a lot of if/else string comparison verbosity.\ncql_noexport void sem_main(ast_node *ast) {\n  // restore all globals and statics we own\n  sem_cleanup();\n  eval_init();\n  ...\n}\n")),Object(r.b)("p",null,"As you can see, ",Object(r.b)("inlineCode",{parentName:"p"},"sem_main")," begins by resetting all the global state.  You can of course do this yourself after calling ",Object(r.b)("inlineCode",{parentName:"p"},"sem_main")," (when you're done with the results)."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sem_main")," sets a variety of useful and public global variables that describe the results of the analysis.  The ones in ",Object(r.b)("inlineCode",{parentName:"p"},"sem.h")," are part of the contract and\nyou should feel free to use them in a downstream code-generator.  Other items are internal and should be avoided.\nThe internal items are typically defined statically in ",Object(r.b)("inlineCode",{parentName:"p"},"sem.c"),". The essential outputs will be described in the last section of this part."),Object(r.b)("p",null,"The cleanup has this structure:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// This method frees all the global state of the semantic analyzer\ncql_noexport void sem_cleanup() {\n  eval_cleanup();\n\n  BYTEBUF_CLEANUP(deployable_validations);\n  BYTEBUF_CLEANUP(recreate_annotations);\n  BYTEBUF_CLEANUP(schema_annotations);\n\n  SYMTAB_CLEANUP(funcs);\n  SYMTAB_CLEANUP(globals);\n  SYMTAB_CLEANUP(indices);\n  SYMTAB_CLEANUP(locals);\n  ...\n\n  // these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.\n\n  all_ad_hoc_list = NULL;\n  all_functions_list = NULL;\n    ...\n")),Object(r.b)("p",null,"This basically deallocates everything and resets all the globals to ",Object(r.b)("inlineCode",{parentName:"p"},"NULL"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sem_main")," of course has to walk the AST and it does so in much the same way as we saw in ",Object(r.b)("inlineCode",{parentName:"p"},"gen_sql.c"),". There is a series of symbol tables\nwhose key is an AST type and whose value is a function plus arguments to dispatch (effectively a lambda).  The semantic analyzer doesn't\nhave to think about things like \"should I emit parentheses\" so the signature of each type of lambda can be quite a bit simpler.  We'll\ngo over each kind with some examples."),Object(r.b)("p",null,"First we have the non-sql statements, these are basic flow control or other things that SQLite will never see directly."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  symtab *syms = non_sql_stmts;\n\n  STMT_INIT(if_stmt);\n  STMT_INIT(while_stmt);\n  STMT_INIT(switch_stmt);\n  STMT_INIT(leave_stmt);\n  ...\n")),Object(r.b)("p",null,"Here ",Object(r.b)("inlineCode",{parentName:"p"},"STMT_INIT")," creates a binding between (e.g.) the AST type ",Object(r.b)("inlineCode",{parentName:"p"},"if_stmt")," and the function ",Object(r.b)("inlineCode",{parentName:"p"},"sem_if_stmt"),".  This lets us dispatch any part of the AST\nto its handler directly."),Object(r.b)("p",null,"Next we have the SQL statements.  These get analyzed in the same way as the others, and with functions that have the same signature, however,\nif you use one of these it means that procedure that contained this statement must get a database connection in order to run.  Use of the database\nwill require the procedure's signature to change; this is recorded by the setting the ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_DML_PROC")," flag bit to be set on the procedures AST node."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  syms = sql_stmts;\n\n  STMT_INIT(create_table_stmt);\n  STMT_INIT(drop_table_stmt);\n  STMT_INIT(create_index_stmt);\n  STMT_INIT(create_view_stmt);\n  STMT_INIT(select_stmt);\n  STMT_INIT(delete_stmt);\n  STMT_INIT(update_stmt);\n  STMT_INIT(insert_stmt);\n  ...\n")),Object(r.b)("p",null,"Again ",Object(r.b)("inlineCode",{parentName:"p"},"STMT_INIT")," creates a binding between (e.g.) the AST type ",Object(r.b)("inlineCode",{parentName:"p"},"delete_stmt")," and the function ",Object(r.b)("inlineCode",{parentName:"p"},"sem_delete_stmt")," so we can dispatch to the handler."),Object(r.b)("p",null,"Next we have expression types, these are set up with ",Object(r.b)("inlineCode",{parentName:"p"},"EXPR_INIT"),".  Many of the operators require exactly the same kinds of verification, so in order to be\nable to share the code, the expression analysis functions get an extra argument for the operator in question.  Typically the string of the operator\nis only needed to make a good quality error message with validation being otherwise identical.  Here are some samples..."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  EXPR_INIT(num, sem_expr_num, "NUM");\n  EXPR_INIT(str, sem_expr_str, "STR");\n  EXPR_INIT(blob, sem_expr_blob, "BLB");\n  EXPR_INIT(null, sem_expr_null, "NULL");\n  EXPR_INIT(dot, sem_expr_dot, "DOT");\n  EXPR_INIT(const, sem_expr_const, "CONST");\n  EXPR_INIT(mul, sem_binary_math, "*");\n  EXPR_INIT(mod, sem_binary_integer_math, "%");\n  EXPR_INIT(not, sem_unary_logical, "NOT");\n  EXPR_INIT(is_true, sem_unary_is_true_or_false, "IS TRUE");\n  EXPR_INIT(tilde, sem_unary_integer_math, "~");\n  EXPR_INIT(uminus, sem_unary_math, "-");\n')),Object(r.b)("p",null,"Looking at the very first entry as an example, we see that ",Object(r.b)("inlineCode",{parentName:"p"},"EXPR_INIT")," creates a mapping between the AST type ",Object(r.b)("inlineCode",{parentName:"p"},"num"),"\nand the analysis function ",Object(r.b)("inlineCode",{parentName:"p"},"sem_expr_num")," and that function will get the text ",Object(r.b)("inlineCode",{parentName:"p"},'"NUM"')," as an extra argument.\nAs it happens ",Object(r.b)("inlineCode",{parentName:"p"},"sem_expr_num")," doesn't need the extra argument, but ",Object(r.b)("inlineCode",{parentName:"p"},"sem_binary_math")," certainly needs the ",Object(r.b)("inlineCode",{parentName:"p"},'"*"'),"\nas that function handles a large number of binary operators."),Object(r.b)("p",null,"Let's quickly go over this list as these are the most important analyzers:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr_num")," : analyzes any numeric constant"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr_str")," : analyzes any string literal or identifier"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr_blob")," : analyzes any blob literal"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr_null")," : analyzes the NULL literal (and nothing else)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr_dot")," : analyzes a compound name like ",Object(r.b)("inlineCode",{parentName:"li"},"T1.id")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr_const")," : analyzes a ",Object(r.b)("inlineCode",{parentName:"li"},"const(...)")," expression, doing the constant evaluation"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_binary_math")," : analyzes any normal binary math operator like '+', '-', '/' etc."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_binary_integer_math")," : analyzes any binary math operator where the operands must be integers like '%' or '|'"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_unary_logical")," : analyzes any unary logical operator (the result is a bool), this is really only ",Object(r.b)("inlineCode",{parentName:"li"},"NOT")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_unary_is_true_or_false")," : analyzes any of the ",Object(r.b)("inlineCode",{parentName:"li"},"IS TRUE"),", ",Object(r.b)("inlineCode",{parentName:"li"},"IS FALSE"),", family of postfix unary operators"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_unary_integer_math")," : analyzes any unary operator where the operand must be an integer, this is really only ",Object(r.b)("inlineCode",{parentName:"li"},"~")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_unary_math")," : analyzes any any math unary operator, presently only negation (but in the future unary ",Object(r.b)("inlineCode",{parentName:"li"},"+")," too)")),Object(r.b)("p",null,"The last group of normal associations are for builtin functions, like these:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  FUNC_INIT(changes);\n  FUNC_INIT(printf);\n  FUNC_INIT(strftime);\n  FUNC_INIT(date);\n  FUNC_INIT(time);\n")),Object(r.b)("p",null,"Each of these is dispatched when a function call is found in the tree.  By way of example ",Object(r.b)("inlineCode",{parentName:"p"},"FUNC_INIT(changes)"),"\ncauses the ",Object(r.b)("inlineCode",{parentName:"p"},"changes")," function to map to ",Object(r.b)("inlineCode",{parentName:"p"},"sem_func_changes")," for validation."),Object(r.b)("p",null,"There are a few other similar macros for more exotic cases but the general pattern should be clear now.  With these in place\nit's very easy to traverse arbitrary statement lists and arbitrary expressions with sub expressions and have the correct function\ninvoked without having large ",Object(r.b)("inlineCode",{parentName:"p"},"switch")," blocks all over."),Object(r.b)("h3",{id:"semantic-errors"},"Semantic Errors"),Object(r.b)("p",null,"Some of the following examples will show the handling of semantic errors more precisely but the theory is pretty simple.  Each of the analyzers that has\nbeen registered is responsible for putting an appropriate ",Object(r.b)("inlineCode",{parentName:"p"},"sem_node")," into the AST it is invoked on.  The caller will look to see if that ",Object(r.b)("inlineCode",{parentName:"p"},"sem_node"),"\nis of type ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_ERROR")," using ",Object(r.b)("inlineCode",{parentName:"p"},"is_error(ast)"),".  If it is, the caller will mark its own AST as errant using ",Object(r.b)("inlineCode",{parentName:"p"},"record_error(ast)")," and this continues all\nthe way up the tree.  The net of this is that wherever you begin semantic analysis, you can know if there were any problems by checking for an error at the\ntop of the tree you provided."),Object(r.b)("p",null,"At the point of the initial error, the analyzer is expected to also call ",Object(r.b)("inlineCode",{parentName:"p"},"report_error")," providing a suitable message.  This will be logged to ",Object(r.b)("inlineCode",{parentName:"p"},"stderr"),".\nIn test mode it is also stored in the AST so that verification steps can confirm that errors were reported at exactly the right place."),Object(r.b)("p",null,"If there are no errors, then a suitable ",Object(r.b)("inlineCode",{parentName:"p"},"sem_node")," is created for the resulting type or else, at minimum, ",Object(r.b)("inlineCode",{parentName:"p"},"record_ok(ast)"),' is used to place the shared "OK" type on the node.\nThe "OK" type indicates no type information, but no errors either.  "OK" is helpful for statements that don\'t involve expressions like ',Object(r.b)("inlineCode",{parentName:"p"},"DROP TABLE Foo"),"."),Object(r.b)("h3",{id:"the-primitive-types"},"The Primitive Types"),Object(r.b)("p",null,"Perhaps the simplest analysis of all happens at the leaves of the AST.  By way of example, here is the code for expression nodes of type ",Object(r.b)("inlineCode",{parentName:"p"},"num"),", the numeric literals."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Expression type for numeric primitives\nstatic void sem_expr_num(ast_node *ast, CSTR cstr) {\n  Contract(is_ast_num(ast));\n  EXTRACT_NUM_TYPE(num_type, ast);\n  switch (num_type) {\n  case NUM_BOOL:\n    ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL);\n    break;\n\n  case NUM_INT:\n    ast->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);\n    break;\n\n  case NUM_LONG:\n    ast->sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);\n    break;\n\n  default:\n    // this is all that's left\n    Contract(num_type == NUM_REAL);\n    ast->sem = new_sem(SEM_TYPE_REAL | SEM_TYPE_NOTNULL);\n    break;\n  }\n}\n")),Object(r.b)("p",null,"As you can see the code simply looks at the AST node, confirming first that it is a ",Object(r.b)("inlineCode",{parentName:"p"},"num")," node.  Then it extracts the ",Object(r.b)("inlineCode",{parentName:"p"},"num_type"),".\nThen ",Object(r.b)("inlineCode",{parentName:"p"},"ast->sem")," is set to a semantic node of the matching type adding in ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_NOTNULL")," because literals are never null."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"new_sem")," function is used to make an empty ",Object(r.b)("inlineCode",{parentName:"p"},"sem_node")," with the ",Object(r.b)("inlineCode",{parentName:"p"},"sem_type")," filled in as specified.  Nothing can go wrong creating a literal so there are no failure modes."),Object(r.b)("p",null,"It doesn't get much simpler unless maybe..."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Expression type for constant NULL\nstatic void sem_expr_null(ast_node *ast, CSTR cstr) {\n  Contract(is_ast_null(ast));\n  // null literal\n  ast->sem = new_sem(SEM_TYPE_NULL);\n}\n")),Object(r.b)("p",null,"It's hard to get simpler than doing semantic analysis of the ",Object(r.b)("inlineCode",{parentName:"p"},"NULL")," literal.  Its code should be clear with no further explanation needed."),Object(r.b)("h3",{id:"unary-operators"},"Unary Operators"),Object(r.b)("p",null,"Let's dive in to a simple case that does require some analysis -- the unary operators.  There are comparatively few and there isn't much code required to handle them all."),Object(r.b)("p",null,"Here's the code for the unary math operators:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// The only unary math operators are '-' and '~'\n// Reference types are not allowed\nstatic void sem_unary_math(ast_node *ast, CSTR op) {\n  sem_t core_type, combined_flags;\n  if (!sem_unary_prep(ast, &core_type, &combined_flags)) {\n    return;\n  }\n\n  if (!sem_validate_numeric(ast, core_type, op)) {\n    return;\n  }\n\n  // The result of unary math promotes to integer.  Basically this converts\n  // bool to integer.  Long integer and Real stay as they are.  Text is\n  // already ruled out.\n  sem_t sem_type_result = sem_combine_types(\n      (SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL),\n      (core_type | combined_flags));\n\n  ast->sem = new_sem(sem_type_result);\n  ast->sem->kind = ast->left->sem->kind;\n\n  // note ast->sem->name is NOT propagated because SQLite doesn't let you refer to\n  // the column 'x' in 'select -x' -- the column name is actually '-x' which is useless\n  // so we have no name once you apply unary math (unless you use 'as')\n  // hence ast->sem->name = ast->left->sem->name is WRONG here and it is not missing on accident\n}\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Unary Prep")),Object(r.b)("p",null,'OK already we need to pause, there is a "prep" pattern here common to most of the shared operators that we should discuss.\nThe prep step takes care of most of the normal error handling which is the same for all the unary operators\nand same pattern happens in binary operators.  Let\'s take a look at ',Object(r.b)("inlineCode",{parentName:"p"},"sem_unary_prep"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// The unary operators all have a similar prep to the binary.  We need\n// to visit the left side (it's always the left node even if the operator goes on the right)\n// if that's ok then we need the combined_flags and core type.  There is only\n// the one.  Returns true if everything is ok.\nstatic bool_t sem_unary_prep(ast_node *ast, sem_t *core_type, sem_t *combined_flags) {\n  // op left | left op\n  sem_expr(ast->left);\n\n  if (is_error(ast->left)) {\n    *core_type = SEM_TYPE_ERROR;\n    *combined_flags = 0;\n    record_error(ast);\n    return false;\n  }\n\n  sem_node *sem = ast->left->sem;\n  sem_t sem_type = sem->sem_type;\n\n  *core_type = core_type_of(sem_type);\n  *combined_flags = not_nullable_flag(sem_type) | sensitive_flag(sem_type);\n\n  Invariant(is_unitary(*core_type));\n  return true;\n}\n")),Object(r.b)("p",null,"Reviewing the steps:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"first we analyze the operand, it will be in ",Object(r.b)("inlineCode",{parentName:"li"},"ast->left")),Object(r.b)("li",{parentName:"ul"},"if that's an error, we just return the error code from the prep steps"),Object(r.b)("li",{parentName:"ul"},"now that it's not an error, we pull the core type out of the operand"),Object(r.b)("li",{parentName:"ul"},"then we pull the not nullable and sensitive flag bits out of the operand"),Object(r.b)("li",{parentName:"ul"},"finally return a boolean indicating the presence of an error (or not) for convenience")),Object(r.b)("p",null,"This is useful setup for all the unary operators, and as we'll see, the binary operators have a similar prep step."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Back to Unary Processing")),Object(r.b)("p",null,"Looking at the overall steps we see:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_unary_prep")," : verifies that the operand is not an error, and gets its core type and flag bits"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_validate_numeric")," : verifies that the operand is a numeric type",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"recall these are the math unary operators, so the operand must be numeric"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_types")," : creates the smallest type that holds two compatible types",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},'by combining with "integer not null" we ensure that the resulting type is at least as big as an integer'),Object(r.b)("li",{parentName:"ul"},"if the argument is of type ",Object(r.b)("inlineCode",{parentName:"li"},"long")," or ",Object(r.b)("inlineCode",{parentName:"li"},"real")," then it will be the bigger type and the resulting type will be ",Object(r.b)("inlineCode",{parentName:"li"},"long")," or ",Object(r.b)("inlineCode",{parentName:"li"},"real")," as appropriate"),Object(r.b)("li",{parentName:"ul"},"in short, ",Object(r.b)("inlineCode",{parentName:"li"},"bool")," is promoted to ",Object(r.b)("inlineCode",{parentName:"li"},"int"),", everything else stays the same"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_types")," also combines the nullability and sensitivity appropriately"))),Object(r.b)("li",{parentName:"ul"},"a new ",Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," of the combined type is created",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},'the type "kind" of the operand is preserved (e.g. the ',Object(r.b)("inlineCode",{parentName:"li"},"meters")," in ",Object(r.b)("inlineCode",{parentName:"li"},"real<meters>"),")"),Object(r.b)("li",{parentName:"ul"},"any column alias or variable name is not preserved, the value is now anonymous")))),Object(r.b)("p",null,"These primitives are designed to combine well, for instance, consider ",Object(r.b)("inlineCode",{parentName:"p"},"sem_unary_integer_math")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"static void sem_unary_integer_math(ast_node *ast, CSTR op) {\n  sem_unary_math(ast, op);\n  sem_reject_real(ast, op);\n}\n")),Object(r.b)("p",null,"The steps are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_unary_math")," : do the sequence we just discussed"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_reject_real")," : report/record an error if the result type is ",Object(r.b)("inlineCode",{parentName:"li"},"real")," otherwise do nothing")),Object(r.b)("p",null,"Note that in all cases the ",Object(r.b)("inlineCode",{parentName:"p"},"op")," string simply gets pushed down to the place where the errors happen.  Let's take a quick look at one of\nthe sources of errors in the above.  Here's the numeric validator:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'static bool_t sem_validate_numeric(ast_node *ast, sem_t core_type, CSTR op) {\n  if (is_blob(core_type)) {\n    report_error(ast->left, "CQL0045: blob operand not allowed in", op);\n    record_error(ast);\n    return false;\n  }\n\n  if (is_object(core_type)) {\n    report_error(ast->left, "CQL0046: object operand not allowed in", op);\n    record_error(ast);\n    return false;\n  }\n\n  if (is_text(core_type)) {\n    report_error(ast->left, "CQL0047: string operand not allowed in", op);\n    record_error(ast);\n    return false;\n  }\n\n  return true;\n}\n')),Object(r.b)("p",null,"That function is pretty much dumb as rocks.  The non-numeric types are blob, object, and text.  There is a custom error for each type (it could have been shared\nbut specific error messages seem to help users).  This code doesn't know its context, but all it needs is ",Object(r.b)("inlineCode",{parentName:"p"},"op")," to tell it what the numeric-only\noperator was and it can produce a nice error message.  It leaves an error in the AST using ",Object(r.b)("inlineCode",{parentName:"p"},"record_error"),", its caller can then simply ",Object(r.b)("inlineCode",{parentName:"p"},"return"),"\nif anything goes wrong."),Object(r.b)("p",null,"It's not hard to guess how ",Object(r.b)("inlineCode",{parentName:"p"},"sem_reject_real")," works:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// Some math operators like << >> & | % only make sense on integers\n// This function does the extra checking to ensure they do not get real values\n// as arguments.  It\'s a post-pass after the normal math checks.\nstatic void sem_reject_real(ast_node *ast, CSTR op) {\n  if (!is_error(ast)) {\n    sem_t core_type = core_type_of(ast->sem->sem_type);\n    if (core_type == SEM_TYPE_REAL) {\n      report_error(ast, "CQL0001: operands must be an integer type, not real", op);\n      record_error(ast);\n    }\n  }\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'if the AST node isn\'t already an error, and the node is of type "real", report an error'),Object(r.b)("li",{parentName:"ul"},"it assumes the type is already known to be numeric"),Object(r.b)("li",{parentName:"ul"},"the pre-check for errors is to avoid double reporting; if something has already gone wrong, the core type will be ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_ERROR"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"no new error recording is needed in that case, obviously an error was already recorded")))),Object(r.b)("h3",{id:"binary-operators"},"Binary Operators"),Object(r.b)("h4",{id:"binary-prep"},"Binary Prep"),Object(r.b)("p",null,"With the knowledge we have so far, this code pretty much speaks for itself, but we'll walk through it."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// All the binary ops do the same preparation, they evaluate the left and the\n// right expression, then they check those for errors.  Then they need\n// the types of those expressions and the combined_flags of the result.  This\n// does exactly that for its various callers.  Returns true if all is well.\nstatic bool_t sem_binary_prep(ast_node *ast, sem_t *core_type_left, sem_t *core_type_right, sem_t *combined_flags) {\n  EXTRACT_ANY_NOTNULL(left, ast->left);\n  EXTRACT_ANY_NOTNULL(right, ast->right);\n\n  // left op right\n  sem_expr(left);\n  sem_expr(right);\n\n  if (is_error(left) || is_error(right)) {\n    record_error(ast);\n    *core_type_left = SEM_TYPE_ERROR;\n    *core_type_right = SEM_TYPE_ERROR;\n    *combined_flags = 0;\n    return false;\n  }\n\n  *core_type_left = core_type_of(left->sem->sem_type);\n  *core_type_right = core_type_of(right->sem->sem_type);\n  *combined_flags = combine_flags(left->sem->sem_type, right->sem->sem_type);\n\n  Invariant(is_unitary(*core_type_left));\n  Invariant(is_unitary(*core_type_right));\n\n  return true;\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_expr")," : used to recursively walk the left and right nodes"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_error")," : checks if either side had errors, if so, simply propagate the error"),Object(r.b)("li",{parentName:"ul"},"extract the left and right core types"),Object(r.b)("li",{parentName:"ul"},"combine nullability and sensitivity flags")),Object(r.b)("p",null,"And that's it!  These are the standard prep steps for all binary operators. With this done,\nthe caller has the core types of the left and right operands plus combined flags on a silver platter\nand one check is needed to detect if anything went wrong."),Object(r.b)("h4",{id:"example-is-or-is-not"},"Example: Is or Is Not"),Object(r.b)("p",null,"This analyzer is the simplest of all the binaries"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// IS and IS NOT are special in that they return a not null boolean.\nstatic void sem_binary_is_or_is_not(ast_node *ast, CSTR op) {\n  sem_t core_type_left, core_type_right, combined_flags;\n\n  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {\n    return;\n  }\n\n  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {\n    return;\n  }\n\n  // the result of is or is not is always a bool and never null\n  ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | sensitive_flag(combined_flags));\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_binary_prep")," : checks for errors in the left or right"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_verify_compat")," : ensures that left and right operands are type compatible (discussed later)"),Object(r.b)("li",{parentName:"ul"},"the result is always of type ",Object(r.b)("inlineCode",{parentName:"li"},"bool not null"))),Object(r.b)("p",null,"If either step goes wrong the error will naturally propagate."),Object(r.b)("h4",{id:"example-binary-math"},"Example: Binary Math"),Object(r.b)("p",null,"This is the general worker for binary math operations, the most common operations like '+', '-', '*' and so forth."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// For all math operations, we combine the types and yield the type that\n// holds both using the helper.  If any text, that's an error.\nstatic void sem_binary_math(ast_node *ast, CSTR op) {\n  sem_t core_type_left, core_type_right, combined_flags;\n  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {\n    return;\n  }\n\n  if (error_any_object(ast, core_type_left, core_type_right, op)) {\n    return;\n  }\n\n  if (error_any_blob_types(ast, core_type_left, core_type_right, op)) {\n    return;\n  }\n\n  if (error_any_text_types(ast, core_type_left, core_type_right, op)) {\n    return;\n  }\n\n  sem_t core_type = sem_combine_types(core_type_left, core_type_right);\n\n  CSTR kind = sem_combine_kinds(ast->right, ast->left->sem->kind);\n  if (is_error(ast->right)) {\n    record_error(ast);\n    return;\n  }\n\n  ast->sem = new_sem(core_type | combined_flags);\n  ast->sem->kind = kind;\n}\n")),Object(r.b)("p",null,"Let's have a look at those steps:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_binary_prep")," : checks for errors on the left or right"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"error_any_object")," : reports an error if the left or right is of type object"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"error_any_blob_types")," : reports an error if the left or right is of type blob"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"error_any_text_types")," : reports an error if the left or right is of type text"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_type")," : computes the combined type, the smallest numeric type that holds both left and right",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"note the operands are now known to be numeric"),Object(r.b)("li",{parentName:"ul"},"the three type error checkers give nice tight errors about the left or right operand"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_kinds")," : tries to create a single type ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," for both operands",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"if their ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," is incompatible, records an error on the right"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new_sem")," : creates a ",Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," with the combined type, flags, and then the ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," is set.")),Object(r.b)("p",null,"At this point it might help to look a few more of the base validators, they are very unremarkable."),Object(r.b)("h4",{id:"example-validator-error_any_object"},"Example Validator: error_any_object"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// If either of the types is an object then produce an error on the ast.\nstatic bool_t error_any_object(ast_node *ast, sem_t core_type_left, sem_t core_type_right, CSTR op) {\n  if (is_object(core_type_left)) {\n    report_error(ast->left, "CQL0002: left operand cannot be an object in", op);\n    record_error(ast);\n    return true;\n  }\n\n  if (is_object(core_type_right)) {\n    report_error(ast->right, "CQL0003: right operand cannot be an object in", op);\n    record_error(ast);\n    return true;\n  }\n\n  return false;\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_object")," : checks a ",Object(r.b)("inlineCode",{parentName:"li"},"sem_type")," against ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_OBJECT"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"if the left or right child is an object an appropriate error is generated"))),Object(r.b)("li",{parentName:"ul"},"there is no strong convention about returning ",Object(r.b)("inlineCode",{parentName:"li"},"true")," if ok, or ",Object(r.b)("inlineCode",{parentName:"li"},"true")," if error, it's pretty ad hoc",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this doesn't seem to cause a lot of problems")))),Object(r.b)("h4",{id:"example-validator-sem_combine_kinds"},"Example Validator: sem_combine_kinds"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Here we check that type<Foo> only combines with type<Foo> or type.\n// If there is a current object type, then the next item must match\n// If there is no such type, then an object type that arrives becomes the required type\n// if they ever don't match record an error\nstatic CSTR sem_combine_kinds_general(ast_node *ast, CSTR kleft, CSTR kright) {\n  if (kright) {\n    if (kleft) {\n      if (strcmp(kleft, kright)) {\n        CSTR errmsg = dup_printf(\"CQL0070: expressions of different kinds can't be mixed: '%s' vs. '%s'\", kright, kleft);\n        report_error(ast, errmsg, NULL);\n        record_error(ast);\n      }\n    }\n    return kright;\n  }\n\n  return kleft;\n}\n\n// helper to crack the ast nodes first and then call the normal comparisons\nstatic CSTR sem_combine_kinds(ast_node *ast, CSTR kright) {\n  CSTR kleft = ast->sem->kind;\n  return sem_combine_kinds_general(ast, kleft, kright);\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_kinds")," : uses the worker ",Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_kinds_general")," after extracting the ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," from the left node",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"usually you already have one ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," and you want to know if another ",Object(r.b)("inlineCode",{parentName:"li"},"kind")," is compatible hence this helper"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_combine_kinds_general"),' : applies the general rules for "kind" strings:',Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"NULL + NULL => NULL"),Object(r.b)("li",{parentName:"ul"},"NULL + x  => x"),Object(r.b)("li",{parentName:"ul"},"x + NULL => x"),Object(r.b)("li",{parentName:"ul"},"x + x => x"),Object(r.b)("li",{parentName:"ul"},"x + y => error (if x != y)"))),Object(r.b)("li",{parentName:"ul"},"this is one of the rare functions that creates a dynamic error message")),Object(r.b)("h4",{id:"example-validator--is_numeric_compat"},"Example Validator : is_numeric_compat"),Object(r.b)("p",null,"This helper is frequently called several times in the course of other semantic checks.\nThis one produces no errors, that's up to the caller. Often there is a numeric path\nand a non-numeric path so this helper can't create the errors as it doesn't yet know\nif anything bad has happened.  Most of the ",Object(r.b)("inlineCode",{parentName:"p"},"is_something")," functions are the same way."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cql_noexport bool_t is_numeric_compat(sem_t sem_type) {\n  sem_type = core_type_of(sem_type);\n  return sem_type >= SEM_TYPE_NULL && sem_type <= SEM_TYPE_REAL;\n}\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"is_numeric_compat")," operates by checking the core type for the numeric range.\nNote that ",Object(r.b)("inlineCode",{parentName:"p"},"NULL")," is compatible with numerics because expressions like ",Object(r.b)("inlineCode",{parentName:"p"},"NULL + 2"),"\nhave meaning in SQL.  The type of that expression is nullable integer and\nthe result is ",Object(r.b)("inlineCode",{parentName:"p"},"NULL"),"."),Object(r.b)("h4",{id:"example-validator--sem_combine_types"},"Example Validator : sem_combine_types"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// The second workhorse of semantic analysis, given two types that\n// are previously known to be compatible, it returns the smallest type\n// that holds both.  If either is nullable the result is nullable.\n// Note: in the few cases where that isn't true the normal algorithm for\n// nullablity result must be overridden (see coalesce for instance).\nstatic sem_t sem_combine_types(sem_t sem_type_1, sem_t sem_type_2) {\n  ... too much code ... summary below\n}\n")),Object(r.b)("p",null,"This beast is rather lengthy but unremarkable. It follows these rules:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"text is only compatible with text"),Object(r.b)("li",{parentName:"ul"},"object is only compatible with object"),Object(r.b)("li",{parentName:"ul"},"blob is only compatible with blob"),Object(r.b)("li",{parentName:"ul"},"numerics are only compatible with other numerics and NULL",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"NULL promotes the other operand, whatever it is (might still be NULL)"),Object(r.b)("li",{parentName:"ul"},"bool promotes to integer if needed"),Object(r.b)("li",{parentName:"ul"},"integer promotes to long integer if needed"),Object(r.b)("li",{parentName:"ul"},"long integer promotes to real if needed"),Object(r.b)("li",{parentName:"ul"},"the combined type is the smallest numeric type that holds left and right according to the above")))),Object(r.b)("p",null,"Some examples might be helpful:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"1 + 2L  ->  long"),Object(r.b)("li",{parentName:"ul"},"false + 3.1 -> real"),Object(r.b)("li",{parentName:"ul"},"2L + 3.1 -> real"),Object(r.b)("li",{parentName:"ul"},"true + 2 -> integer"),Object(r.b)("li",{parentName:"ul"},"'x' + 1 -> not compatible")),Object(r.b)("p",null,"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"sem_combine_types")," assumes the types have already been checked for compatibility and will use ",Object(r.b)("inlineCode",{parentName:"p"},"Contract")," to enforce\nthis.  You should be using other helpers like ",Object(r.b)("inlineCode",{parentName:"p"},"is_numeric_compat")," and friends to ensure the types agree before computing\nthe combined type.  A list of values that must be compatible with each other (e.g. in ",Object(r.b)("inlineCode",{parentName:"p"},"needle IN (haystack)"),") can be\nchecked using ",Object(r.b)("inlineCode",{parentName:"p"},"sem_verify_compat")," repeatedly."),Object(r.b)("h4",{id:"example-validator--sem_verify_assignment"},"Example Validator : sem_verify_assignment"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"sem_verify_assignment")," function is used any time there is something like a logical ",Object(r.b)("inlineCode",{parentName:"p"},"assignment")," going on.  There are\ntwo important cases:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SET x := y")," : an actual assignment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"call foo(x)")," : the expression ",Object(r.b)("inlineCode",{parentName:"li"},"x"),' must be "assignable" to the formal variable for the argument of ',Object(r.b)("inlineCode",{parentName:"li"},"foo"))),Object(r.b)("p",null,"This is a lot like normal binary operator compatibility with one extra rule: the source expression must\nnot be a bigger type than the target.  e.g. you cannot assign a ",Object(r.b)("inlineCode",{parentName:"p"},"long")," to an ",Object(r.b)("inlineCode",{parentName:"p"},"integer"),", nor pass a long\nexpression to a function that has an integer parameter."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// This verifies that the types are compatible and that it\'s ok to assign\n// the expression to the variable.  In practice that means:\n// * the variable type core type and kind must be compatible with the expression core type and kind\n// * the variable must be nullable if the expression is nullable\n// * the variable must be sensitive if the assignment is sensitive\n// * the variable type must be bigger than the expression type\n// Here ast is used only to give a place to put any errors.\nstatic bool_t sem_verify_assignment(ast_node *ast, sem_t sem_type_needed, sem_t sem_type_found, CSTR var_name) {\n  if (!sem_verify_compat(ast, sem_type_needed, sem_type_found, var_name)) {\n    return false;\n  }\n\n  if (!sem_verify_safeassign(ast, sem_type_needed, sem_type_found, var_name)) {\n    return false;\n  }\n\n  if (is_nullable(sem_type_found) && is_not_nullable(sem_type_needed)) {\n    report_error(ast, "CQL0013: cannot assign/copy possibly null expression to not null target", var_name);\n    return false;\n  }\n\n  if (sensitive_flag(sem_type_found) && !sensitive_flag(sem_type_needed)) {\n    report_error(ast, "CQL0014: cannot assign/copy sensitive expression to non-sensitive target", var_name);\n    return false;\n  }\n\n  return true;\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_verify_compat")," : checks for standard type compatibility between the left and the right"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_verify_safeassign")," : checks that if the types are different the right operand is the smaller"),Object(r.b)("li",{parentName:"ul"},"nullability checks ensure you aren't trying to assign a nullable value to a not null variable"),Object(r.b)("li",{parentName:"ul"},"sensitivity checks ensure you aren't trying to assign a sensitive value to a not sensitive variable")),Object(r.b)("h3",{id:"simple-statement-validation"},"Simple Statement Validation"),Object(r.b)("p",null,"With the expression building blocks, most of the usual kind of language statements become quite simple to check\nfor correctness.  It's probably easiest to illustrate this with an example, let's look at validation for\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"WHILE")," statement."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// While semantic analysis is super simple.\n//  * the condition must be numeric\n//  * the statement list must be error-free\n//  * loop_depth is increased allowing the use of interior leave/continue\nstatic void sem_while_stmt(ast_node *ast) {\n  Contract(is_ast_while_stmt(ast));\n  EXTRACT_ANY_NOTNULL(expr, ast->left);\n  EXTRACT(stmt_list, ast->right);\n\n  // WHILE [expr] BEGIN [stmt_list] END\n\n  sem_numeric_expr(expr, ast, "WHILE", SEM_EXPR_CONTEXT_NONE);\n\n  if (is_error(expr)) {\n    record_error(ast);\n    return;\n  }\n\n  if (stmt_list) {\n    loop_depth++;\n\n    sem_stmt_list(stmt_list);\n\n    loop_depth--;\n\n    if (is_error(stmt_list)) {\n      record_error(ast);\n      return;\n    }\n  }\n\n  record_ok(ast);\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"EXTRACT*")," : pulls out the tree parts we need"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_numeric_expr")," : verifies the loop expression is numeric"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_stmt_list")," : recursively validates the body of the loop")),Object(r.b)("p",null,"Note: the while expression is one of the loop constructs which means ",Object(r.b)("inlineCode",{parentName:"p"},"LEAVE")," and ",Object(r.b)("inlineCode",{parentName:"p"},"CONTINUE")," are legal inside it.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"loop_depth")," global tracks the fact that we are in a loop so that analysis for ",Object(r.b)("inlineCode",{parentName:"p"},"LEAVE")," and ",Object(r.b)("inlineCode",{parentName:"p"},"CONTINUE")," can report errors if we are not."),Object(r.b)("p",null,"It's not hard to imagine that ",Object(r.b)("inlineCode",{parentName:"p"},"sem_stmt_list")," will basically walk the AST, pulling out statements and dispatching them using the ",Object(r.b)("inlineCode",{parentName:"p"},"STMT_INIT")," tables previously discussed.\nYou might land right back in ",Object(r.b)("inlineCode",{parentName:"p"},"sem_while_stmt")," for a nested ",Object(r.b)("inlineCode",{parentName:"p"},"WHILE")," -- it's turtles all the way down."),Object(r.b)("p",null,"If ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_EXPR_CONTEXT_NONE")," is a mystery, don't worry it's covered in the next section."),Object(r.b)("h3",{id:"expression-contexts"},"Expression Contexts"),Object(r.b)("p",null,"It turns out that in the SQL language some expression types are only valid in some parts of a SQL statement (e.g. aggregate functions can't appear in a ",Object(r.b)("inlineCode",{parentName:"p"},"LIMIT")," clause) and so there is always a context for any numeric expression.  When a new root expression is being evaluated, it sets the expression context per the caller's specification."),Object(r.b)("p",null,"The expression contexts are as follows:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#define SEM_EXPR_CONTEXT_NONE           0x0001\n#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002\n#define SEM_EXPR_CONTEXT_WHERE          0x0004\n#define SEM_EXPR_CONTEXT_ON             0x0008\n#define SEM_EXPR_CONTEXT_HAVING         0x0010\n#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020\n#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040\n#define SEM_EXPR_CONTEXT_LIMIT          0x0080\n#define SEM_EXPR_CONTEXT_OFFSET         0x0100\n#define SEM_EXPR_CONTEXT_TABLE_FUNC     0x0200\n#define SEM_EXPR_CONTEXT_WINDOW         0x0400\n#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800\n#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000\n")),Object(r.b)("p",null,"The idea here is simple, when calling a root expression, the analyzer provides the context value that has the bit that corresponds to the current context.\nFor instance, the expression being validated in is the ",Object(r.b)("inlineCode",{parentName:"p"},"WHERE")," clause, the code will provide ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_EXPR_CONTEXT_WHERE"),'.\nThe inner validators check this context, in particular anything that is only available in some contexts has a bit-mask of that is the union\nof the context bits where it can be used.  The validator can check those possibilities against the current context with one bitwise "and" operation.\nA zero result indicates that the operation is not valid in the current context.'),Object(r.b)("p",null,'This bitwise "and" is performed by one of these two helper macros which makes the usage a little clearer:'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context & (x)))\n#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context & (x)))\n")),Object(r.b)("h4",{id:"expression-context-example--concat"},"Expression Context Example : Concat"),Object(r.b)("p",null,"The concatenation operator ",Object(r.b)("inlineCode",{parentName:"p"},"||"),' is challenging to successfully emulate because it does many different kinds of\nnumeric to string conversions automatically.  Rather than perennially getting this wrong, we simply do not support\nthis operator in a context where SQLite isn\'t going to be doing the concatenation.  So typically users\nuse "printf" instead to get formatting done outside of a SQL context.  The check for invalid use of ',Object(r.b)("inlineCode",{parentName:"p"},"||")," is very simple\nand it happens of course in ",Object(r.b)("inlineCode",{parentName:"p"},"sem_concat"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {\n    report_error(ast, "CQL0241: CONCAT may only appear in the context of a SQL statement", NULL);\n    record_error(ast);\n    return;\n  }\n')),Object(r.b)("h4",{id:"expression-context-example--in"},"Expression Context Example : IN"),Object(r.b)("p",null,"A slightly more complex example happens processing the ",Object(r.b)("inlineCode",{parentName:"p"},"IN")," operator.  This operator has two forms,\nthe form with an expression list, which can be used anywhere, and the form with a ",Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statement.\nThe latter form can only appear in some sections of SQL, and not at all in loose expressions.  For\ninstance, that form may not appear in the ",Object(r.b)("inlineCode",{parentName:"p"},"LIMIT")," or ",Object(r.b)("inlineCode",{parentName:"p"},"OFFSET")," sections of a SQLite statement."),Object(r.b)("p",null,"We use this construct to do the validation:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'    uint32_t valid = SEM_EXPR_CONTEXT_SELECT_LIST\n                    |SEM_EXPR_CONTEXT_WHERE\n                    |SEM_EXPR_CONTEXT_ON\n                    |SEM_EXPR_CONTEXT_HAVING\n                    |SEM_EXPR_CONTEXT_TABLE_FUNC;\n\n    if (CURRENT_EXPR_CONTEXT_IS_NOT(valid)) {\n      report_error( ast, "CQL0078: [not] in (select ...) is only allowed inside "\n                         "of select lists, where, on, and having clauses", NULL);\n      record_error(ast);\n      return;\n    }\n')),Object(r.b)("p",null,"If the reader is interested in a simple learning exercise, run down the purpose of ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_EXPR_CONTEXT_TABLE_FUNC")," -- it's simple,\nbut important, and it only has one use case so it's easy to find."),Object(r.b)("h3",{id:"name-resolution"},"Name Resolution"),Object(r.b)("p",null,"We've gotten pretty far without talking about the elephant in the room: name resolution."),Object(r.b)("p",null,"Like SQL, many statements in CQL have names in positions where the type of the name is completely unambiguous.  For instance\nnobody could be confused what sort of symbol ",Object(r.b)("inlineCode",{parentName:"p"},"Foo")," is in ",Object(r.b)("inlineCode",{parentName:"p"},"DROP INDEX Foo"),"."),Object(r.b)("p",null,"This type, with a clear name category, are the easiest name resolutions, and there are a lot in this form.  Let's do an example."),Object(r.b)("h4",{id:"example-index-name-resolution"},"Example: Index Name Resolution"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// This is the basic checking for the drop index statement\n// * the index must exist (have been declared) in some version\n// * it could be deleted now, that\'s ok, but the name has to be valid\nstatic void sem_drop_index_stmt(ast_node *ast) {\n  Contract(is_ast_drop_index_stmt(ast));\n  EXTRACT_ANY_NOTNULL(name_ast, ast->right);\n  EXTRACT_STRING(name, name_ast);\n\n  ast_node *index_ast = find_usable_index(name, name_ast,  "CQL0112: index in drop statement was not declared");\n  if (!index_ast) {\n    record_error(ast);\n    return;\n  }\n\n  record_ok(ast);\n}\n')),Object(r.b)("p",null,"Well, this is interesting.  But what's going on with ",Object(r.b)("inlineCode",{parentName:"p"},"find_usable_index"),"? What is usable?  Why aren't we just looking up the index\nname in some name table? Let's have a look at the details of ",Object(r.b)("inlineCode",{parentName:"p"},"find_usable_index"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// returns the node only if it exists and is not restricted by the schema region.\nstatic ast_node *find_usable_index(CSTR name, ast_node *err_target, CSTR msg) {\n  ast_node *index_ast = find_index(name);\n  if (!index_ast) {\n    report_error(err_target, msg, name);\n    return NULL;\n  }\n\n  if (!sem_validate_object_ast_in_current_region(name, index_ast, err_target, msg)) {\n    return NULL;\n  }\n\n  return index_ast;\n}\n")),Object(r.b)("p",null,"We haven't discussed schema regions yet but what you need to know about them for now is this:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"any object can be in a region."),Object(r.b)("li",{parentName:"ul"},"a region may depend on other regions")),Object(r.b)("p",null,"If an object is in a region, then it may only use schema parts that are in\nthe same region, or the region's dependencies (transitively)."),Object(r.b)("p",null,'The point of this is that you might have a rather large schema and you probably don\'t want any piece\nof code to use any piece of schema.  You can use regions to ensure that the code for feature "X" doesn\'t\ntry to use schema designed exclusively for feature "Y".  That "X" code probably has no business even\nknowing of the existence of "Y" schema.'),Object(r.b)("p",null,"So now ",Object(r.b)("inlineCode",{parentName:"p"},"usable")," simply means this:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"find_index")," can find the name in the symbol table for indices"),Object(r.b)("li",{parentName:"ul"},"the found index is accessible in the current region")),Object(r.b)("p",null,"If we had used an example that was looking up a table name, the same region considerations would apply,\nhowever, additionally tables can be deprecated with ",Object(r.b)("inlineCode",{parentName:"p"},"@delete")," so there would be additional checks to make\nsure we're talking about a live table and not a table's tombstone."),Object(r.b)("p",null,"In short, these simple cases just require looking up the entity and verifying that it's accessible in the current context."),Object(r.b)("h4",{id:"flexible-name-resolution"},"Flexible Name Resolution"),Object(r.b)("p",null,'The "hard case" for name resolution is where the name is occurring in an expression.  Such a name can refer to\nall manner of things. It could be a global variable, a local variable, an argument, a table column, a field in a cursor,\nand others.  The general name resolver goes through several phases looking for the name.  Each phase can either report\nan affirmative success or error (in which case the search stops), or it may simply report that the name was not found\nbut the search should continue.'),Object(r.b)("p",null,"We can demystify this a bit by looking at the most common way to get name resolution done."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Resolves a (potentially qualified) identifier, writing semantic information\n// into `ast` if successful, or reporting and recording an error for `ast` if\n// not.\nstatic void sem_resolve_id(ast_node *ast, CSTR name, CSTR scope) {\n  Contract(is_id(ast) || is_ast_dot(ast));\n  Contract(name);\n\n  // We have no use for `type` and simply throw it away.\n  sem_t *type = NULL;\n  sem_resolve_id_with_type(ast, name, scope, &type);\n}\n")),Object(r.b)("p",null,"The name resolver works on either a vanilla name (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"x"),") or a scoped name (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"T1.x"),").  The name and scope are provided.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"ast")," parameter is used only as a place to report errors, there is no further cracking of the AST needed to resolve\nthe name.  As you can see ",Object(r.b)("inlineCode",{parentName:"p"},"sem_resolve_id")," just calls the more general function ",Object(r.b)("inlineCode",{parentName:"p"},"sem_resolve_id_with_type")," and is used\nin the most common case where you don't need to be able to mutate the sematic type info for the identifier.  That's the 99% case."),Object(r.b)("p",null,'So let\'s move on to the "real" resolver.'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// This function is responsible for resolving both unqualified identifiers (ids)\n// and qualified identifiers (dots). It performs the following two roles:\n//\n// - If an optional `ast` is provided, it works the same way most semantic\n//   analysis functions work: semantic information will be written into into the\n//   ast, errors will be reported to the user, and errors will be recorded in\n//   the AST.\n//\n// - `*typr_ptr` will be set to mutable type (`sem_t *`) in the current\n//   environment if the identifier successfully resolves to a type. (There are,\n//   unfortunately, a few exceptions in which a type will be successfully\n//   resolved and yet `*typr_ptr` will not be set. These include when a cursor\n//   in an expression position, when the expression is `rowid` (or similar), and\n//   when the id resolves to an enum case. The reason no mutable type is\n//   returned in these cases is that a new type is allocated as part of semantic\n//   analysis, and there exists no single, stable type in the environment to\n//   which a pointer could be returned. This is a limitation of this function,\n//   albeit one that\'s currently not problematic.)\n//\n//  Resolution is attempted in the order that the `sem_try_resolve_*` functions\n//  appear in the `resolver` array. Each takes the same arguments: An (optional)\n//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the\n//  identifier provided to one of these resolvers is resolved successfully, *or*\n//  if the correct resolver was found but there was an error in the program,\n//  `SEM_RESOLVE_STOP` is returned and resolution is complete, successful or not.\n//  If a resolver is tried and it determines that it is not the correct resolver\n//  for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned and the\n//  next resolver is tried.\n//\n// This function should not be called directly. If one is interested in\n// performing semantic analysis, call `sem_resolve_id` (or, if within an\n// expression, `sem_resolve_id_expr`). Alternatively, if one wants to get a\n// mutable type from the environment, call `find_mutable_type`.\nstatic void sem_resolve_id_with_type(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {\n  Contract(name);\n  Contract(type_ptr);\n\n  *type_ptr = NULL;\n\n  sem_resolve (*resolver[])(ast_node *ast, CSTR, CSTR, sem_t **) = {\n    sem_try_resolve_arguments,\n    sem_try_resolve_column,\n    sem_try_resolve_rowid,\n    sem_try_resolve_cursor_as_expression,\n    sem_try_resolve_variable,\n    sem_try_resolve_enum,\n    sem_try_resolve_cursor_field,\n    sem_try_resolve_arg_bundle,\n  };\n\n  for (uint32_t i = 0; i < sizeof(resolver) / sizeof(void *); i++) {\n    if (resolver[i](ast, name, scope, type_ptr) == SEM_RESOLVE_STOP) {\n      return;\n    }\n  }\n\n  report_resolve_error(ast, "CQL0069: name not found", name);\n  record_resolve_error(ast);\n}\n')),Object(r.b)("p",null,'This function is well described in its own comments.  We can easily see the "mini-resolvers"\nwhich attempt to find the name in order:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_arguments")," : an argument in the argument list"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_column")," : a column name (possibly scoped)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_rowid")," : the virtual rowid column (possibly scoped)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_cursor_as_expression")," : use of a cursor as a boolean, the bool is true if the cursor has data"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_variable")," : local or global variables"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_enum")," : the constant value of an enum (must be scoped)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_cursor_field")," : a field in a cursor (must be scoped)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_try_resolve_arg_bundle")," : a field in an argument bundle (must be scoped)")),Object(r.b)("p",null,"These all use this enum to communicate progress:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to\n// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to\n// indicate that the correct resolver was found. Continuing implies that no\n// failure has (yet) occurred, but stopping implies neither success nor failure.\ntypedef enum {\n  SEM_RESOLVE_CONTINUE = 0,\n  SEM_RESOLVE_STOP = 1\n} sem_resolve;\n")),Object(r.b)("p",null,"Each of these mini-resolvers will have a series of rules, for example ",Object(r.b)("inlineCode",{parentName:"p"},"sem_try_resolve_cursor_field")," is going to have to do\nsomething like this:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"if there is no scope, it can't be a cursor field, return ",Object(r.b)("inlineCode",{parentName:"li"},"CONTINUE")),Object(r.b)("li",{parentName:"ul"},"if the scope is not the name of a cursor, return ",Object(r.b)("inlineCode",{parentName:"li"},"CONTINUE")),Object(r.b)("li",{parentName:"ul"},"if the name is a field in the cursor, return ",Object(r.b)("inlineCode",{parentName:"li"},"STOP")," with success"),Object(r.b)("li",{parentName:"ul"},"else, report that the name is not a valid member of the cursor, and return ",Object(r.b)("inlineCode",{parentName:"li"},"STOP")," with an error")),Object(r.b)("p",null,"All the mini-resolvers are similarly structured, generically:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"if it's not my case, return ",Object(r.b)("inlineCode",{parentName:"li"},"CONTINUE")),Object(r.b)("li",{parentName:"ul"},"if it is my case return ",Object(r.b)("inlineCode",{parentName:"li"},"STOP")," (maybe with an error)")),Object(r.b)("p",null,"Some of the mini-resolvers have quite a few steps, but any one mini-resolver is only about a screenful of code\nand it does one job."),Object(r.b)("h3",{id:"nullability-improvements"},"Nullability Improvements"),Object(r.b)("p",null,"Via a form of occurrence typing, CQL has the ability to determine that, due to a\nprior conditional check, a nullable variable or cursor field cannot be null\nwithin a particular context, and CQL will improve its type therein accordingly."),Object(r.b)("p",null,"Unlike most forms of semantic analysis performed by CQL, the analysis for\nnullability improvements makes heavy use of the ",Object(r.b)("inlineCode",{parentName:"p"},"find_mutable_type")," function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Returns the *mutable* type (`sem_t *`) for a given (potentially qualified)\n// identifier if one exists in the environment. See the documentation for\n// `sem_resolve_id_with_type` for limitations.\nstatic sem_t *find_mutable_type(CSTR name, CSTR scope);\n")),Object(r.b)("p",null,"This function allows us to look up the type of the original binding referred to\nby a particular name/scope pair. In essence, it provides access to the current\ntype environment for whichever part of the program we are analyzing. It also\nallows us to mutate that environment by virtue of the fact that it returns a\npointer to the type of the binding, not merely the type itself."),Object(r.b)("p",null,"By using ",Object(r.b)("inlineCode",{parentName:"p"},"find_mutable_type")," to get a type pointer and toggling the\n",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_INFERRED_NOTNULL")," flag, the procedures ",Object(r.b)("inlineCode",{parentName:"p"},"sem_set_notnull_improved")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improved")," are able to record that a nullable identifier or\ncursor field is either temporarily nonnull or no longer nonnull respectively:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Enables a nonnull improvement, if possible.\nstatic void sem_set_notnull_improved(CSTR name, CSTR scope);\n\n// This needs to be called for everything that is no longer safe to consider NOT\n// NULL due to a mutation. It is fine to call this for something not currently\n// subject to improvement, but it must only be called with a name/scope pair\n// referring to something has a mutable type (e.g., it must not be an unbound\n// variable, a cursor used an expression, an enum case, et cetera).\nstatic void sem_unset_notnull_improved(CSTR name, CSTR scope);\n")),Object(r.b)("p",null,"Similarly, ",Object(r.b)("inlineCode",{parentName:"p"},"sem_is_notnull_improved")," uses ",Object(r.b)("inlineCode",{parentName:"p"},"find_mutable_type")," to check whether\nor not something is currently improved:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Returns true if currently improved to be nonnull, else false.\nstatic bool_t sem_is_notnull_improved(CSTR name, CSTR scope);\n")),Object(r.b)("p",null,'Why does nullability inference use this approach? The reason is that the\nalternative would be maintaining some sort of set of currently improved\nidentifiers and cursor fields and checking it whenever resolving an identifier\nor cursor field. The problem would be that merely knowing that some identifier\n"x" is improved would not be sufficient, however: We\'d have to know ',Object(r.b)("em",{parentName:"p"},"which"),' "x".\nIs it the local variable "x"? Is it the column "x" of the table from which we\'re\ncurrently selecting?  In essence, correctly maintaining an independent set of\nall currently active improvements would involve re-implementing all of the\nscoping rules of the language. By using ',Object(r.b)("inlineCode",{parentName:"p"},"find_mutable_type"),", we can simply\npiggyback on the existing name resolution logic and avoid all of these issues."),Object(r.b)("p",null,"A nullability improvement is always created within a particular context. When an\nimprovement is added via ",Object(r.b)("inlineCode",{parentName:"p"},"sem_set_notnull_improved"),", a record of that\nimprovement is recorded in the current context. When that context ends, that\nrecord is used to allow ",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improved")," to remove the improvement.\nIt is also the case that ",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improved")," may remove an improvement\nbefore a context has ended due to a SET, FETCH, or call to a procedure or\nfunction with an OUT argument resulting in the improvement no longer being safe.\nThe common type of context is defined as follows:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// A list node holding the `sem_t *` for a nullability improvement. These are\n// used both for un-setting improvements when the scope of an improvement ends\n// and for keeping track of improvements that require special treatment (i.e.,\n// improvements of globals must be unset at every CALL).\ntypedef struct notnull_improvement_context_item {\n  sem_t *type;\n  struct notnull_improvement_context_item *next;\n} notnull_improvement_context_item;\n\n// A `notnull_improvement_context` is simply a list of context items.\ntypedef notnull_improvement_context_item *notnull_improvement_context;\n")),Object(r.b)("p",null,'Contexts are not always quite so simple as a collection of improvements to unset\nwhen they end, however. That is because there are two types of contexts: the\n"normal", non-contingent contexts of which we just spoke, and contingent\ncontexts. Whereas non-contingent contexts are merely a simple collection of\nimprovements to later unset, contingent contexts record both improvements made\nvia ',Object(r.b)("inlineCode",{parentName:"p"},"sem_set_notnull_improved")," ",Object(r.b)("em",{parentName:"p"},"and")," improvements removed via\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improved"),". When a contingent context ends, it plays back all\nof the improvements and un-improvements made in reverse, performing the opposite\nof what originally occurred at each step. The result of this is to restore the\nstate of the world to what it was before the context was entered. This reversal\nis essential for allowing us to analyze each branch of an IF or CASE\nindependently such that any SET, FETCH, or OUT arguments in one branch do not\nnegatively affect all later branches. Contingent contexts (also known as\nhistories) hold the same data as non-contingent contexts, but they also have an\nextra piece of information that indicates which type of action was performed:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Indicates whether an improvement was set or unset within a\n// `notnull_improvement_history_item`.\ntypedef enum {\n  NOTNULL_IMPROVEMENT_DELTA_WAS_SET,\n  NOTNULL_IMPROVEMENT_DELTA_WAS_UNSET,\n} notnull_improvement_delta;\n\n// A list node used to record a nullability improvement or un-improvement. These\n// can be later replayed in the order opposite of that in which they originally\n// occurred with the converse action being taken at each step, thus restoring\n// the original state of the world before any improvements or un-improvements\n// were made. In essence, they are nothing more than a\n// `notnull_improvement_context_item` with a `notnull_improvement_delta`.\ntypedef struct notnull_improvement_history_item {\n  sem_t *type;\n  notnull_improvement_delta delta;\n  struct notnull_improvement_history_item *next;\n} notnull_improvement_history_item;\n\n// A `notnull_improvement_history` is simply a list of history items.\ntypedef notnull_improvement_history_item *notnull_improvement_history;\n")),Object(r.b)("p",null,"Both non-contingent and contingent contexts are pushed and popped via pairs of\nmacros:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Pushes a new context for nullability improvements. All improvements set while\n// the context is active will be unset at the corresponding\n// `POP_NOTNULL_IMPROVEMENT_CONTEXT`.\n#define PUSH_NOTNULL_IMPROVEMENT_CONTEXT() ...\n\n// Un-sets all improvements made within the current context and reverts to the\n// previous context.\n#define POP_NOTNULL_IMPROVEMENT_CONTEXT() ...\n\n// Similar to `PUSH_NOTNULL_IMPROVEMENT_CONTEXT`, but used for contexts that\n// will only be entered at runtime if some condition is true. This is used for\n// each branch in an IF (and soon CASE and IIF) to allow any improvements and\n// un-improvements made within to be reverted, and the original state of the\n// world restored, before checking the next branch. This must only be used when\n// the current context is not contingent; see\n// `is_current_notnull_improvement_context_contingent`.\n#define PUSH_CONTINGENT_NOTNULL_IMPROVEMENT_CONTEXT() ...\n\n// Pops the current contingent improvement context, reverting all improvements\n// and un-improvements made within, and reverts to the previous context. Should\n// no contingent contexts remain after the pop, an invariant enforces that\n// `current_notnull_improvement_history` is NULL (which must be the case because\n// we never record history when a contingent context is not in effect).\n#define POP_CONTINGENT_NOTNULL_IMPROVEMENT_CONTEXT() ...\n")),Object(r.b)("p",null,"In the case of ",Object(r.b)("inlineCode",{parentName:"p"},"POP_NOTNULL_IMPROVEMENT_CONTEXT"),", it calls\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improvements_in_context")," to unset all improvements within the\ncontext that is ending; in the case of\n",Object(r.b)("inlineCode",{parentName:"p"},"POP_CONTINGENT_NOTNULL_IMPROVEMENT_CONTEXT"),", it calls\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_revert_notnull_improvement_history")," to revert them:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Unsets nonnull improvements for all items in the list provided.\nstatic void sem_unset_notnull_improvements_in_context(notnull_improvement_context context);\n\n// Given a history, play it back in reverse, performing the opposite of what\n// originally occurred at each step. The result will be the state of the world\n// before any of the improvements and un-improvements were made. For any\n// previous un-improvement that is re-improved by the reversal, that\n// re-improvement will be recorded in the current nonnull improvement context so\n// that it can be re-unimproved when said context is eventually popped.\n//\n// An example of a full timeline might look like this:\n//\n//   1. A nonnull improvement context is pushed while some variable x is\n//      presently improved.\n//   2. A contingent nonnull improvement context is pushed.\n//   3. Some variable x is unimproved due to it being set to null.\n//   4. The contingent nonnull improvement context is popped and x is restored\n//      to its previous improved state, bringing us back to the state of the\n//      world as it was in step 1.\n//   5. Additional contingent contexts are pushed and popped.\n//   6. The improvement context pushed in step 1 is popped, and x is again\n//      unimproved because it was unimproved in step 3 within the inner\n//      contingent context pushed in step 2.\nstatic void sem_revert_notnull_improvement_history(notnull_improvement_history history);\n")),Object(r.b)("p",null,"As can be seen in the comments for the macros, a contingent context must only\never be created within a non-contingent context. The reason for this restriction\nis mainly that doing otherwise would not serve any purpose. The comment for\n",Object(r.b)("inlineCode",{parentName:"p"},"is_current_notnull_improvement_context_contingent")," explains:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Tracks whether or not the current nonnull improvement context, if any, is\n// contingent (i.e., may or may not be entered depending upon the truth of some\n// condition). The sole reason for tracking this is to be able to assert that a\n// contingent context is not pushed when the current context is already\n// contingent. The reason for asserting this is that contingent contexts are\n// meant to be used for branches within a conditional (e.g., the 'x', 'y', and\n// 'z' statement lists in 'IF cond THEN x ELSE IF y ELSE z END IF') and should\n// always be within a non-contingent context that encapsulates the entire set of\n// branches (as that context gathers all of the un-improvements that result\n// within any of the branches so that re-improvements resulting from history\n// reverts can be un-set appropriately when the non-contingent context is\n// eventually popped).\nstatic bool_t is_current_notnull_improvement_context_contingent = false;\n")),Object(r.b)("p",null,'As with other PUSH- and POP-style macros in "sem.c", global variables keep track\nof the current contexts and the pushing and popping happens via temporarily\nsaving a current context on the stack and later restoring it. The two types of\ncontexts are held in the following globals:'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// This is the context into which any nonnull improvements made will be\n// recorded. Each context holds all of the improvements that were made while it\n// was the current context, not just those that are still in effect. For\n// example, if a particular improvement is unset due to a SET or FETCH, it will\n// remain in whichever context was the current context when it was first set.\n// This is okay because the goal of maintaining contexts is merely to be able to\n// unset all improvements within a given context when it ends.\nstatic notnull_improvement_context current_notnull_improvement_context;\n\n// This is the history into which all nonnull improvements *and* un-improvements\n// made will be recorded when `contingent_notnull_improvement_context_depth` is\n// greater than zero (i.e., whenever a contingent improvement context is in\n// effect). It is used to restore the state of the world to what it was at the\n// moment the current contingent improvement context was pushed.\nstatic notnull_improvement_history_item *current_notnull_improvement_history;\n")),Object(r.b)("p",null,"As an optimization, we avoid recording improvements and un-improvements in\n",Object(r.b)("inlineCode",{parentName:"p"},"current_notnull_improvement_history")," when there is no contingent context\ncurrently in effect:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Tracks how many contingent notnull improvement contexts are currently in\n// effect. This allows us the optimization of not recording items into the\n// history when `contingent_notnull_improvement_context_depth` is 0 as they\n// would not be of any future use.\nstatic uint32_t contingent_notnull_improvement_context_depth = 0;\n")),Object(r.b)("p",null,"Maintaining accurate histories is critical for\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_revert_notnull_improvement_history")," to work correctly. It all ultimately\nboils down to always using ",Object(r.b)("inlineCode",{parentName:"p"},"sem_set_notnull_improved")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improved")," to set and unset improvements, but it's essential\nto understand how things actually play out in practice as the comment within\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_unset_notnull_improvements_in_context")," explains; feel free to skip over\nthis for now if it's overwhelming:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Is it very important that we only unset improvements that are currently\n// set. Doing otherwise would result in an invalid history, and reverting\n// said invalid history would result in things being re-improved\n// inappropriately. Suppose we have this code:\n//\n//   IF b IS NULL RETURN;\n//   -- 'b' is nonnull here\n//   IF ... THEN\n//     IF a IS NOT NULL THEN\n//       -- 'a' is nonnull here due to the condition\n//       SET b := NULL;\n//     END IF;\n//     -- 'a' is un-improved here because the THEN branch above ended\n//     -- 'b' is nullable here because it was un-improved at the above SET\n//   ELSE\n//     -- 'a' is nullable here as its un-improvement was not reverted\n//     -- 'b' is nonnull here as its un-improvement was reverted\n//   END IF;\n//   -- 'b' is nullable here due to the SET\n//\n// At the end of the outer THEN branch, both 'a' and 'b' will have been\n// un-improved, the former at the end of the inner THEN branch, and the\n// latter by the SET. Within the ELSE branch though, it is critical that we\n// re-improve 'b' (because it was already improved at the start of the outer\n// IF), yet even more critical that we not re-improve 'a' (because it was\n// not already improved at the start of the previous branch, and so\n// re-improving it would be unsafe).\n//\n// The timeline above plays out as follows:\n//\n//   01. 'b' is improved in initial context C0.\n//   02. Context C1 is pushed for the outer IF.\n//   03. Contingent context C2 is pushed for the outer THEN.\n//   04. Context C3 is pushed for the inner IF.\n//   05. Contingent context C4 is pushed for the inner THEN.\n//   06. 'a' is improved due to the condition which generates a history item\n//       in C4 and a context item in C3.\n//   07. 'b' is un-improved due to the SET which generates a history item in\n//       C4.\n//   08. Contingent context C4 is reverted, un-improving 'a' and\n//       re-improving 'b' (which generates a context item in C3).\n//   09. Context C3 is unset, with the context item added in step 06 for 'a'\n//       being ignored (as 'a' is already unset) and the context item added\n//       in step 08 for 'b' resulting in 'b' being unset (which generates a\n//       history item in C2).\n//   10. Contingent context C2 is reverted, re-re-improving 'b' (which\n//       generates a context item in C1) due to the history item generated\n//       by C3 in step 09.\n//   11. Contingent context C5 is pushed for the ELSE.\n//   12. Contingent context C5 is reverted for the ELSE, to no effect.\n//   13. Context C1 is popped, re-un-improving 'b' due to the context item\n//       generated by C2 in step 10.\n//\n// Suppose, however, that we generated a history item in C2 by unsetting 'a'\n// (which was already unset) in step 09. This would've caused 'a' to be\n// re-improved in step 10 which would've caused it to be nonnull in the\n// ELSE, which is unsafe.\n")),Object(r.b)("p",null,"Improvements can introduced into the current context via\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_set_notnull_improved")," directly (when a variable is SET to a value of a\nnonnull type), but more commonly they are introduced via one of the following\ntwo functions:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Given a conditional expression `ast` containing possibly AND-linked IS NOT\n// NULL subexpressions, set all of the applicable improvements within the\n// current nullability context.\nstatic void sem_set_notnull_improvements_for_true_condition(ast_node *expr);\n\n// Improvements for known-false conditions are dual to improvements for\n// known-true conditions: Known-false conditions improve ids and dots verified\n// to be NULL via `IS NULL` along the outermost spine of `OR` expressions,\n// whereas known-true conditions improve ids and dots verified to be nonnull via\n// `IS NOT NULL` along the outermost spine of `AND` expressions. For example,\n// the following two statements introduce the same improvements:\n//\n//   IF a IS NOT NULL AND b IS NOT NULL THEN\n//     -- `a` and `b` are improved here because we know the condition is true\n//   END IF;\n//\n//   IF a IS NULL OR b IS NULL RETURN;\n//   -- `a` and `b` are improved here because we know the condition is false\n//   -- since we must not have returned if we got this far\nstatic void sem_set_notnull_improvements_for_false_condition(ast_node *ast);\n")),Object(r.b)("p",null,"These functions introduce improvements by gathering up all of the ",Object(r.b)("inlineCode",{parentName:"p"},"IS NOT NULL"),"\nchecks (in the true case) or ",Object(r.b)("inlineCode",{parentName:"p"},"IS NULL")," checks (in the false case) and\nintroducing improvements appropriately. The true version is used when we enter a\ncontext that will only be evaluated at runtime when some particular condition is\ntrue; the false version, conversely, is used when we enter a context that will\nonly be evaluated at runtime when some particular condition is false:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},'IF some_condition THEN\n  -- "true" improvements from `some_condition` are in\n  -- effect here\nELSE IF another_condition THEN\n  -- "false" improvements from `some_condition` and true\n  -- improvements from `another_condition` are in effect\n  -- here\nELSE\n   -- "false" improvements from both `some_condition` and\n   -- `another_condition` are in effect here\nEND IF;\n')),Object(r.b)("p",null,"Global variables in CQL require special treatment when it comes to nullability\nimprovements. This is because any procedure call could potentially mutate any\nnumber of global variables, and so all currently improved globals must be\nun-improved at every such call. The following context keeps track of which\nglobal variables are currently improved:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// This keeps track of all global variables that may currently be improved to be\n// NOT NULL. We need this because we must un-improve all such variables after\n// every procedure call (because we don't do interprocedural analysis and cannot\n// know which globals may have been set to NULL).\nstatic notnull_improvement_context global_notnull_improvement_context;\n")),Object(r.b)("p",null,"The fact that we don't do interprocedural analysis (as the comment above\nindicates) is not a deficiency. Programmers should be able to reason locally\nabout nullability improvements, and an analysis that depended upon the details\nof how other procedures were implemented would make that impossible."),Object(r.b)("p",null,"So far, we have talked a lot about how improvements are set and unset, but we\nhaven't talked about how the improvement actually happens in terms of code\ngeneration. Since CQL represents values of nullable and nonnull types\ndifferently (at least in the case of non-reference types), we cannot simply\ntreat a value of a nullable type as though it were of a nonnull type: We need to\nactually change its representation."),Object(r.b)("p",null,"The way this works is that, whenever we resolve a name/scope pair via\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_resolve_id_expr"),", we check whether the pair is currently improved via\n",Object(r.b)("inlineCode",{parentName:"p"},"sem_is_notnull_improved"),". If it is, we call ",Object(r.b)("inlineCode",{parentName:"p"},"rewrite_nullable_to_notnull")," to\nwrap the id or dot we're resolving with a call to the function\n",Object(r.b)("inlineCode",{parentName:"p"},"cql_inferred_notnull")," (for which we generate code in\n",Object(r.b)("inlineCode",{parentName:"p"},"cg_func_cql_inferred_notnull"),"):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// Wraps an id or dot in a call to cql_inferred_notnull.\ncql_noexport void rewrite_nullable_to_unsafe_notnull(ast_node *_Nonnull ast);\n\n// The `cql_inferred_notnull` function is not used by the programmer directly,\n// but rather inserted via a rewrite during semantic analysis to coerce a value\n// of a nullable type to be nonnull. The reason for this approach, as opposed to\n// just changing the type directly, is that there are also representational\n// differences between values of nullable and nonnull types; some conversion is\n// required.\nstatic void cg_func_cql_inferred_notnull(ast_node *call_ast, charbuf *is_null, charbuf *value);\n")),Object(r.b)("p",null,"As the comment for ",Object(r.b)("inlineCode",{parentName:"p"},"cg_func_cql_inferred_notnull")," indicates, programmers do not\nuse ",Object(r.b)("inlineCode",{parentName:"p"},"cql_inferred_notnull")," directly: It is only inserted as a product of the\nabove-mentioned rewrite. In fact, we explicitly disallow its use by programmers\nin the parser:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'// We insert calls to `cql_inferred_notnull` as part of a rewrite so we expect\n// to see it during semantic analysis, but it cannot be allowed to appear in a\n// program. It would be unsafe if it could: It coerces a value from a nullable\n// type to a nonnull type without any runtime check.\n#define YY_ERROR_ON_CQL_INFERRED_NOTNULL(x) \\\n  EXTRACT_STRING(proc_name, x); \\\n  if (!strcmp(proc_name, "cql_inferred_notnull")) { \\\n    yyerror("Call to internal function is not allowed \'cql_inferred_notnull\'"); \\\n  }\n')),Object(r.b)("p",null,"One subtle aspect of the rewrite is that the rewrite itself performs analysis to\nvalidate the product of the rewrite (as do other many other rewrites). To avoid\ngoing into a loop of rewriting, analyzing the result (which ultimately happens\nin ",Object(r.b)("inlineCode",{parentName:"p"},"sem_special_func_cql_inferred_notnull"),"), rewriting again because the result\ncontains a name that is improved, et cetera, we keep track of whether or not\nwe're currently analyzing a subexpression under a call to ",Object(r.b)("inlineCode",{parentName:"p"},"cql_inferred_notnull"),"\nand avoid re-rewriting appropriately:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"// This is true if we are analyzing a call to `cql_inferred_notnull`. This can\n// happen for three reasons:\n//\n// * We just did a rewrite that produced a `cql_inferred_notnull` call and now\n//   we're computing its type.\n// * We're analyzing an expression that was already analyzed (e.g., in a CTE).\n// * We're analyzing the output of a previous CQL run within which calls to\n//   `cql_inferrred_notnull` may occur.\n//\n// Regardless of the cause, if `is_analyzing_notnull_rewrite` is true, we do not\n// want to rewrite again.\nstatic bool_t is_analyzing_notnull_rewrite;\n\nstatic void sem_special_func_cql_inferred_notnull(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {\n  ...\n  // Since we're checking a call to `cql_inferred_notnull`, its arguments have\n  // already been rewritten and we don't want to do it again. Setting\n  // `is_analyzing_notnull_rewrite` prevents that.\n  is_analyzing_notnull_rewrite = true;\n  sem_arg_list(arg_list, IS_NOT_COUNT);\n  is_analyzing_notnull_rewrite = false;\n  ...\n}\n\n// Like `sem_resolve_id`, but specific to expression contexts (where nullability\n// improvements are applicable).\nstatic void sem_resolve_id_expr(ast_node *ast, CSTR name, CSTR scope) {\n  ...\n  if (is_analyzing_notnull_rewrite) {\n    // If we're analyzing the product of a rewrite and we're already inside of a\n    // call to `cql_inferred_notnull`, do not expand again.\n    // forever.\n    return;\n  }\n  ...\n}\n")),Object(r.b)("p",null,"At this point, you should have a decent understanding how how nullability\nimprovements function, both in terms of semantic analysis and in terms of code\ngeneration. The implementation is heavily commented, so reading the code and\nsearching for calls to the core functions listed below should be sufficient to\nfill in any gaps:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"bool_t sem_is_notnull_improved(CSTR name, CSTR scope);\nvoid sem_set_notnull_improved(CSTR name, CSTR scope);\nvoid sem_unset_notnull_improved(CSTR name, CSTR scope);\nvoid sem_unset_notnull_improvements_in_context(notnull_improvement_context context);\nvoid sem_revert_notnull_improvement_history(notnull_improvement_history history);\nvoid sem_set_notnull_improvements_for_true_condition(ast_node *expr);\nvoid sem_set_notnull_improvements_for_false_condition(ast_node *ast);\nvoid sem_special_func_cql_inferred_notnull(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate)\nvoid rewrite_nullable_to_unsafe_notnull(ast_node *_Nonnull ast);\n")),Object(r.b)("h3",{id:"structure-types-and-the-notion-of-shapes"},"Structure types and the notion of Shapes"),Object(r.b)("p",null,"Earlier we discussed ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_STRUCT")," briefly. Recall the basic notion of the ",Object(r.b)("inlineCode",{parentName:"p"},"structure")," type:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// for tables and views and the result of a select\n\ntypedef struct sem_struct {\n  CSTR struct_name;               // struct name\n  uint32_t count;                 // count of fields\n  CSTR *names;                    // field names\n  CSTR *kinds;                    // the "kind" text of each column, if any, e.g. integer<foo> foo is the kind\n  sem_t *semtypes;                // typecode for each field\n} sem_struct;\n')),Object(r.b)("p",null,'The structure is nothing more than an array of names, types and kinds with a count.  But it creates the notion of\nwhat\'s usually called a "shape" in the codebase. Shapes can be used in a variety of ways as is described in\n',Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms"},"Chapter 5")," of the CQL Guide. But before we get\ninto shapes, let's look at an example of how a structure type is created."),Object(r.b)("p",null,"The code that follows is the back end of ",Object(r.b)("inlineCode",{parentName:"p"},"sem_create_table_stmt"),".  At this point the bulk of the analysis is\ndone and the columns all have their types.  We're about to build the struct type for the table.  Let's see how\nthat goes."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  // now create a struct type with the correct number of columns\n  // the types have already been computed so all we have to do is\n  // check for duplicates\n  sem_struct *sptr = new_sem_struct(name, cols);\n\n  symtab *columns = symtab_new();\n\n  int32_t col = 0;\n  for (ast_node *item = col_key_list; item; item = item->right) {\n    Contract(is_ast_col_key_list(item));\n    EXTRACT_ANY_NOTNULL(def, item->left);\n\n    if (is_ast_col_def(def)) {\n      Invariant(def->sem->name);\n      Invariant(col <= cols);  // it's possible that the rest are deleted and we're at the end.\n\n      // columns must be unique, including deleted columns\n      if (!symtab_add(columns, def->sem->name, NULL)) {\n        EXTRACT_NOTNULL(col_def_type_attrs, def->left);\n        EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);\n        EXTRACT_ANY_NOTNULL(col_def_ast, col_def_name_type->left);\n\n        report_error(col_def_ast, \"CQL0142: duplicate column name\", def->sem->name);\n        record_error(ast);\n        symtab_delete(columns);\n        goto cleanup;;\n      }\n\n      if (is_deleted(def->sem->sem_type)) {\n        continue;\n      }\n\n      Invariant(col < cols);\n\n      sptr->names[col] = def->sem->name;\n      sptr->semtypes[col] = def->sem->sem_type;\n      sptr->kinds[col] = def->sem->kind;\n      col++;\n    }\n  }\n\n  symtab_delete(columns);\n\n  Invariant(col == cols);\n\n  ast->sem = new_sem(SEM_TYPE_STRUCT);\n  ast->sem->sptr = sptr;\n  ast->sem->jptr = sem_join_from_sem_struct(sptr);\n  ast->sem->region = current_region;\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new_sem_struct")," : makes a struct to hold the result, we already have the count of columns and the table name"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"symtab_new")," : is going to gives us a scratch symbol table so we can check for duplicate column names"),Object(r.b)("li",{parentName:"ul"},"we walk all the items in the table and use ",Object(r.b)("inlineCode",{parentName:"li"},"is_ast_col_def(def)")," to find the column definitions"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Invariant(def->sem->name)")," : claims that we must have already computed the semantic info for the column and it has its name populated",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this was done earlier"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"symtab_add(columns, def->sem->name, NULL)")," : adds a nil entry under the column name, if this fails we have a duplicate column",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"in which case we report errors and stop"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_deleted")," : tells us if the column was marked with ",Object(r.b)("inlineCode",{parentName:"li"},"@delete")," in which case it no longer counts as part of the table"),Object(r.b)("li",{parentName:"ul"},"if all this is good we set the ",Object(r.b)("inlineCode",{parentName:"li"},"names"),", ",Object(r.b)("inlineCode",{parentName:"li"},"kinds"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"semtypes")," from the column definition's semnatic info"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"symtab_delete")," : cleans up the temporary symbol table"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new_sem")," : creates a ",Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," of type ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_STRUCT")," which is filled in",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_join_from_sem_struct")," will be discussed shortly, but it creates a ",Object(r.b)("inlineCode",{parentName:"li"},"jptr")," with one table in it")))),Object(r.b)("p",null,'Structure types often come from the shape of a table, but other things can create a structure type.  For instance, the\ncolumns of a view, or any select statement, are also described by a structure type and are therefore valid "shapes".  The\nreturn type of a procedure usually comes from a ',Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statement so the procedure too can be the source of a shape.\nThe arguments of a procedure form a shape.  The fields of a cursor form a shape.  You can even have a named subset\nof the arguments of a procedure and use them like a shape. All of these things are described by structure types."),Object(r.b)("h4",{id:"shapes-and-the-like-construct"},"Shapes and the LIKE construct"),Object(r.b)("p",null,"There are many cases where you want to be able to capture or re-use something with a known shape and you don't\nwant to have to fully re-declare the thing.  CQL uses the ",Object(r.b)("inlineCode",{parentName:"p"},"LIKE")," construct to do these sorts of things.  This is\nmore fully explained in ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms"},"Chapter 5")," of the Guide,\nbut for now let's look at two different cases that are of interest."),Object(r.b)("p",null,"First, a cursor:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"DECLARE C CURSOR LIKE Foo;  -- Foo something with a shape\n")),Object(r.b)("p",null,"So, in the above, Foo could be a table, a view, a procedure with a result, another cursor, and so forth."),Object(r.b)("p",null,"How might we do this?  This is the business of ",Object(r.b)("inlineCode",{parentName:"p"},"sem_declare_cursor_like_name")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// Here we\'re going to make a new value cursor using the indicated name for the shape.\n// The name has to be "likeable" meaning it refers to some named thing with a shape\n// such as a table, a view, another cursor, or a procedure that returns a result set.\n// These are the so called "value cursors" in that they have no underlying statement\n// that they move through.  You can just load them up with a row and pass them around.\nstatic void sem_declare_cursor_like_name(ast_node *ast) {\n  Contract(is_ast_declare_cursor_like_name(ast));\n  EXTRACT_ANY_NOTNULL(new_cursor_ast, ast->left);\n  EXTRACT_STRING(new_cursor_name, new_cursor_ast);\n  EXTRACT_ANY_NOTNULL(like_ast, ast->right);\n  EXTRACT_ANY_NOTNULL(name_ast, like_ast->left);\n  EXTRACT_STRING(like_name, name_ast);\n\n  // no duplicates allowed\n  if (!sem_verify_legal_variable_name(ast, new_cursor_name)) {\n    record_error(new_cursor_ast);\n    record_error(ast);\n    return;\n  }\n\n  // must be a valid shape\n  ast_node *found_shape = sem_find_likeable_ast(like_ast, LIKEABLE_FOR_VALUES);\n  if (!found_shape) {\n    record_error(ast);\n    return;\n  }\n\n  // good to go, make our cursor, with storage.\n  name_ast->sem = like_ast->sem = found_shape->sem;\n  new_cursor_ast->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);\n  new_cursor_ast->sem->sptr = found_shape->sem->sptr;\n  new_cursor_ast->sem->name = new_cursor_name;\n  ast->sem = new_cursor_ast->sem;\n\n  symtab_add(current_variables, new_cursor_name, new_cursor_ast);\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"EXTRACT")," : gets the pieces we need from the AST"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_verify_legal_variable_name")," : makes sure the cursor name is unique and doesn't hide a table name"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_find_likeable_ast")," : searches for something with a suitable name that has a shape"),Object(r.b)("li",{parentName:"ul"},"we populate the name node with the  semantic type that we found"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new_sem")," : makes a new ",Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," for the cursor variable with ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_STRUCT"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"set the ",Object(r.b)("inlineCode",{parentName:"li"},"sptr")," field using the discovered shape")))),Object(r.b)("p",null,"Note: ",Object(r.b)("inlineCode",{parentName:"p"},"name_ast->sem")," isn't actually used for anything but it is helpful for debugging. If the AST is printed it\nshows the original unmodified semantic type which can be helpful."),Object(r.b)("p",null,"Briefly ",Object(r.b)("inlineCode",{parentName:"p"},"sem_find_likeable_ast")," does these steps:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"if the right of the ",Object(r.b)("inlineCode",{parentName:"li"},"LIKE")," refers to procedure arguments (e.g. C LIKE Foo ARGUMENTS), get the args of the named procedure and use them as a shape"),Object(r.b)("li",{parentName:"ul"},"if the right is a local or global, and its a cursor, use the shape of that cursor for the new cursor"),Object(r.b)("li",{parentName:"ul"},"if the right is the name of an argument bundle, use the shape of the bundle",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"e.g. in ",Object(r.b)("inlineCode",{parentName:"li"},"CREATE PROC Foo(p1 like Person, p2 like Person)")," ",Object(r.b)("inlineCode",{parentName:"li"},"p1")," and ",Object(r.b)("inlineCode",{parentName:"li"},"p2")," are the names of argument bundles shaped like ",Object(r.b)("inlineCode",{parentName:"li"},"Person")))),Object(r.b)("li",{parentName:"ul"},"if the right is the name of a table or view, use that shape"),Object(r.b)("li",{parentName:"ul"},"if the right is the name of a procedure with a structure result, use that shape"),Object(r.b)("li",{parentName:"ul"},"if it's none of these, produce an error")),Object(r.b)("p",null,"This is the primary source of shape reuse.  Let's look at how we might use that."),Object(r.b)("p",null,"Suppose we want to write a procedure that inserts a row into the table ",Object(r.b)("inlineCode",{parentName:"p"},"Foo"),", we could certainly list the columns of ",Object(r.b)("inlineCode",{parentName:"p"},"Foo")," as arguments like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC InsertIntoFoo(id integer, t text, r real, b blob)\nBEGIN\n  INSERT INTO Foo(id, t, r, b) VALUES(id, t, r, b);\nEND;\n")),Object(r.b)("p",null,"But that approach is going to get a lot less exciting when there are lots of columns and it will be increasingly a maintenance headache."),Object(r.b)("p",null,"Compare that with the following:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC InsertIntoFoo(row LIKE Foo)\nBEGIN\n  INSERT INTO Foo FROM row;\nEND;\n")),Object(r.b)("p",null,"Those two versions of ",Object(r.b)("inlineCode",{parentName:"p"},"InsertIntoFoo")," compile into the same code.  The semantic analyzer expands the ",Object(r.b)("inlineCode",{parentName:"p"},"(row LIKE Foo)")," into\n",Object(r.b)("inlineCode",{parentName:"p"},"(row_id integer, row_t text, row_r real, row_b blob)")," and then replaces ",Object(r.b)("inlineCode",{parentName:"p"},"FROM row")," with\n",Object(r.b)("inlineCode",{parentName:"p"},"(row_id, row_t, row_r, row_b)"),".  In both case it simply looked up the shape using ",Object(r.b)("inlineCode",{parentName:"p"},"sem_find_likeable_ast"),'\nand then altered the AST to the canonical pattern.  This kind of "shape sugar" is all over CQL and\ngreatly increases maintainability while eliminating common errors.  The most common operation is simply\nto expland a "shape" into a list of arguments or columns (maybe with or without type names).  SQLite doesn\'t\nknow any of this shape magic so by the time SQLite sees the code it has to look "normal" -- the shapes\nare all resolved.'),Object(r.b)("h3",{id:"join-types"},"Join Types"),Object(r.b)("p",null,"The last of the type building data structure is the join type.  Recall that we have this shape:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// for the data type of (parts of) the FROM clause\n// sometimes I refer to as a "joinscope"\n\ntypedef struct sem_join {\n  uint32_t count;                 // count of table/views in the join\n  CSTR *names;                    // names of the table/view\n  struct sem_struct **tables;     // struct type of each table/view\n} sem_join;\n')),Object(r.b)("p",null,"This is an array of named structure types, which is exactly what you get when you do something like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"select * from T1 INNER JOIN T2;\n")),Object(r.b)("p",null,"The result has all of the columns of ",Object(r.b)("inlineCode",{parentName:"p"},"T1")," and all of the columns of ",Object(r.b)("inlineCode",{parentName:"p"},"T2"),".  They can be referred to with scoped\nnames like ",Object(r.b)("inlineCode",{parentName:"p"},"T1.x"),' which means "find the ',Object(r.b)("inlineCode",{parentName:"p"},"sptr")," corresponding to the name ",Object(r.b)("inlineCode",{parentName:"p"},"T1")," then within that structure\nfind the column named ",Object(r.b)("inlineCode",{parentName:"p"},"x"),'".  In general, when we join, we take a ',Object(r.b)("inlineCode",{parentName:"p"},"jptr")," on the left and concatenate it\nwith a ",Object(r.b)("inlineCode",{parentName:"p"},"jptr")," on the right.  For all this to work we have to start somewhere, usually single tables."),Object(r.b)("p",null,"As we saw when we make a table we use ",Object(r.b)("inlineCode",{parentName:"p"},"sem_join_from_sem_struct")," to make its initial ",Object(r.b)("inlineCode",{parentName:"p"},"jptr"),".  Let's\nhave a look at that now:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Create a base join type from a single struct.\nstatic sem_join *sem_join_from_sem_struct(sem_struct *sptr) {\n  sem_join *jptr = new_sem_join(1);\n  jptr->names[0] = sptr->struct_name;\n  jptr->tables[0] = new_sem_struct_strip_table_flags(sptr);\n\n  return jptr;\n}\n")),Object(r.b)("p",null,"It doesn't get much simpler than the above, here are the steps briefly:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new_sem_join")," : gives us an empty ",Object(r.b)("inlineCode",{parentName:"li"},"sem_join")," with room for 1 table"),Object(r.b)("li",{parentName:"ul"},"we use the struct name for the name and the table's ",Object(r.b)("inlineCode",{parentName:"li"},"sptr")," for the shape"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new_sem_struct_strip_table_flags")," : copies the table's ",Object(r.b)("inlineCode",{parentName:"li"},"sptr")," keeping only the essential flags",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_HIDDEN_COL")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SEM_FLAG_NOTNULL")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SEM_FLAG_SENSITIVE"))))),Object(r.b)("p",null,"The other flags (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_PK"),") have no value in doing type checking and were only needed to help validate the table itself.\nThose extra flags would be harmless but they would also contaminate all of the debug output, so they are stripped.  As a result\nthe type of columns as they appear in say ",Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statements is simpler than how they appear in a ",Object(r.b)("inlineCode",{parentName:"p"},"CREATE TABLE")," statement."),Object(r.b)("p",null,"When we need to create a new join type we simply (*) make a new ",Object(r.b)("inlineCode",{parentName:"p"},"sem_join")," that is the concatenation of the left and right sides of the join\noperation."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"some join types change the nullability of columns like ",Object(r.b)("inlineCode",{parentName:"li"},"LEFT JOIN"),", so we have to handle that too"),Object(r.b)("li",{parentName:"ul"},"the names of the tables in the new concatenated joinscope have to be unambiguous so there is also error checking to do"),Object(r.b)("li",{parentName:"ul"},"but basically it's just a concat...")),Object(r.b)("p",null,'Importantly, we call the thing a "joinscope" because it creates a namespace.  When we are evaluating names inside of the ',Object(r.b)("inlineCode",{parentName:"p"},"FROM")," clause or\neven later in say a ",Object(r.b)("inlineCode",{parentName:"p"},"WHERE")," clause, the joinscope that we have created so far controls the ",Object(r.b)("inlineCode",{parentName:"p"},"table.column")," combinations you can\nuse in expressions.  This changes again when there is a subquery, so the joinscopes can be pushed and popped as needed."),Object(r.b)("p",null,"By way of example, you'll see these two patterns in the code:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  PUSH_JOIN(from_scope, select_from_etc->sem->jptr);\n  error = sem_select_orderby(select_orderby);\n  POP_JOIN();\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"PUSH_JOIN")," : use the ",Object(r.b)("inlineCode",{parentName:"li"},"jptr")," from the ",Object(r.b)("inlineCode",{parentName:"li"},"FROM")," clause to put things back in scope for the ",Object(r.b)("inlineCode",{parentName:"li"},"ORDER BY")," clause")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  PUSH_JOIN_BLOCK();\n  sem_numeric_expr(ast->left, ast, "LIMIT", SEM_EXPR_CONTEXT_LIMIT);\n  POP_JOIN();\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"PUSH_JOIN_BLOCK")," : causes the name search to stop, nothing deeper in the stack is searched"),Object(r.b)("li",{parentName:"ul"},"in this case we do not allow ",Object(r.b)("inlineCode",{parentName:"li"},"LIMIT")," expressions to see any joinscopes, they may not use any columns",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"even if the ",Object(r.b)("inlineCode",{parentName:"li"},"LIMIT")," clause is appearing in a subquery it can't refer to columns in the parent query.")))),Object(r.b)("h3",{id:"schema-regions"},"Schema Regions"),Object(r.b)("p",null,"We touched briefly on schema regions earlier in this section.  The purpose and language for regions\nis described more fully in ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch10#schema-regions"},"Chapter 10")," of the Guide.\nIn this section we'll deal with how they are implemented and what you should expect to see in the code."),Object(r.b)("p",null,"When a region declaration is found this method is used:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// A schema region is an partitioning of the schema such that it\n// only uses objects in the same partition or one of its declared\n// dependencies.  One schema region may be upgraded independently\n// from any others (assuming they happen such that dependents are done first).\n// Here we validate:\n//  * the region name is unique\n//  * the dependencies (if any) are unique and exist\nstatic void sem_declare_schema_region_stmt(ast_node *ast)  { ... }\n")),Object(r.b)("p",null,"The general rules are described in the comment, but effectively it accumulates the list of\nthe declared region's dependencies.  Sometimes these are called the antecedent regions.  Since\na region can only depend on regions that have already been declared, it's not possible\nto make any cycles. Regions are declared before you put anything into them."),Object(r.b)("p",null,"Pieces of schema or procedures (or anything really) can go into a region by putting that code\ninside a begin/end pair for the named region.  Like so:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"@begin_schema_region your_region;\n  -- your stuff\n@end_schema_region;\n")),Object(r.b)("p",null,'Now whatever happens to be in "your stuff" is:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"limited to seeing only the things that ",Object(r.b)("inlineCode",{parentName:"li"},"your_region")," is allowed to see, and"),Object(r.b)("li",{parentName:"ul"},"contributes its contents to ",Object(r.b)("inlineCode",{parentName:"li"},"your_region"),' thereby limiting how others will be able to use "your stuff"')),Object(r.b)("p",null,"To see how this happens, let's have a look at ",Object(r.b)("inlineCode",{parentName:"p"},"sem_begin_schema_region_stmt"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// Entering a schema region makes all the objects that follow part of that\n// region.  It also means that all the contained objects must refer to\n// only pieces of schema that are in the same region or a dependent region.\n// Here we validate that region we are entering is in fact a valid region\n// and that there isn\'t already a schema region.\nstatic void sem_begin_schema_region_stmt(ast_node * ast) {\n  Contract(is_ast_begin_schema_region_stmt(ast));\n  EXTRACT_STRING(name, ast->left);\n\n  // @BEGIN_SCHEMA_REGION name\n\n  if (!verify_schema_region_out_of_proc(ast)) {\n    record_error(ast);\n    return;\n  }\n\n  if (current_region) {\n    report_error(ast, "CQL0246: schema regions do not nest; end the current region before starting a new one", NULL);\n    record_error(ast);\n    return;\n  }\n\n  ast_node *region = find_region(name);\n  if (!region) {\n    report_error(ast->left, "CQL0244: unknown schema region", name);\n    record_error(ast);\n    return;\n  }\n\n  // Get the canonical name of the region (case adjusted)\n  Contract(is_region(region));\n  EXTRACT_STRING(region_name, region->left);\n\n  // we already know we are not in a region\n  Invariant(!current_region_image);\n  current_region_image = symtab_new();\n  sem_accumulate_public_region_image(current_region_image, region_name);\n\n  // this is the one and only text pointer value for this region\n  current_region = region_name;\n  record_ok(ast);\n}\n')),Object(r.b)("p",null,"We see these basic steps:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"EXTRACT")," : gets the region name"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"verify_schema_region_out_of_proc")," : makes sure we are out of any procedure (we have to be at the top level)",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"errors if in a procedure"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"current_region")," : is tested to make sure we are not already in a region (no nesting)",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"errors if already in a region"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"find_region")," : is used to find the region AST by name",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"errors if the region name isn't valid"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"EXTRACT")," : is used again to get the canonical name of the region",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"you could write ",Object(r.b)("inlineCode",{parentName:"li"},"@begin_schema_region YoUr_ReGION;")," but we want the canonical name ",Object(r.b)("inlineCode",{parentName:"li"},"your_region"),", as it was declared"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"symtab_new")," : creates a new symbol table ",Object(r.b)("inlineCode",{parentName:"li"},"current_region_image")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_accumulate_public_region_image")," : populates ",Object(r.b)("inlineCode",{parentName:"li"},"current_region_image")," by recursively walking this region adding the names of all the regions we find along the way",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"note the regions form a DAG so we might find the same name twice, we can stop if we find a region that is already in the image symbol table"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"current_region")," : set it to the now new current region")),Object(r.b)("p",null,"Now we're all set up."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"We can use ",Object(r.b)("inlineCode",{parentName:"li"},"current_region")," to set the ",Object(r.b)("inlineCode",{parentName:"li"},"region")," in the ",Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," of anything we encounter"),Object(r.b)("li",{parentName:"ul"},"We can use ",Object(r.b)("inlineCode",{parentName:"li"},"current_region_image")," to quickly see if we are allowed to use any given region",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"if it's in the symbol table we can use it")))),Object(r.b)("p",null,"Recall that at the end of ",Object(r.b)("inlineCode",{parentName:"p"},"sem_create_table_stmt")," we do this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  ast->sem = new_sem(SEM_TYPE_STRUCT);\n  ast->sem->sptr = sptr;\n  ast->sem->jptr = sem_join_from_sem_struct(sptr);\n  ast->sem->region = current_region;\n")),Object(r.b)("p",null,"That should make a lot more sense now."),Object(r.b)("p",null,"When doing the symmetric check in ",Object(r.b)("inlineCode",{parentName:"p"},"sem_validate_object_ast_in_current_region")," we see this pattern:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Validate whether or not an object is usable with a schema region. The object\n// can only be a table, view, trigger or index.\nstatic bool_t sem_validate_object_ast_in_current_region(\n  CSTR name,\n  ast_node *table_ast,\n  ast_node *err_target,\n  CSTR msg)\n{\n  // We're in a non-region therefore no validation needed because non-region stmt\n  // can reference schema in any region.\n  if (!current_region) {\n    return true;\n  }\n\n  if (table_ast->sem && table_ast->sem->region) {\n    // if we have a current region then the image is always computed!\n    Invariant(current_region_image);\n    if (!symtab_find(current_region_image, table_ast->sem->region)) {\n      // The target region is not accessible from this region\n      ...\n      return false;\n    }\n  } else {\n    // while in schema region '%s', accessing an object that isn't in a region is invalid\n    ...\n    return false;\n  }\n\n  return true;\n}\n")),Object(r.b)("p",null,"I've elided some of the code here, but only the part that generates error messages.  The essential logic is:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"if we are not in a region we can access anything"),Object(r.b)("li",{parentName:"ul"},"if we're in a region then...",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the thing we're trying to access must also be in a region, and"),Object(r.b)("li",{parentName:"ul"},"that region must be in ",Object(r.b)("inlineCode",{parentName:"li"},"current_region_image")),Object(r.b)("li",{parentName:"ul"},"otherwise, we can't access it")))),Object(r.b)("p",null,"This is enough to do all the region validation we need."),Object(r.b)("h3",{id:"results-of-semantic-analysis"},"Results of Semantic Analysis"),Object(r.b)("p",null,"Semantic Analysis leaves a lot of global state ready for the remaining stages to harvest.  If the state\nis defined in ",Object(r.b)("inlineCode",{parentName:"p"},"sem.h")," then it's ok to harvest.  Here we'll highlight some of the most important things you\ncan use in later passes.  These are heavily used in the code generators."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cql_data_decl( struct list_item *all_tables_list );\ncql_data_decl( struct list_item *all_functions_list );\ncql_data_decl( struct list_item *all_views_list );\ncql_data_decl( struct list_item *all_indices_list );\ncql_data_decl( struct list_item *all_triggers_list );\ncql_data_decl( struct list_item *all_regions_list );\ncql_data_decl( struct list_item *all_ad_hoc_list );\ncql_data_decl( struct list_item *all_select_functions_list );\ncql_data_decl( struct list_item *all_enums_list );\n")),Object(r.b)("p",null,"These linked lists are authoritiative, they let you easily enumerate all the objects of the specified type.  For\ninstance, if you wanted to do some validation of all indices you could simply walk ",Object(r.b)("inlineCode",{parentName:"p"},"all_indices_list"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cql_noexport ast_node *find_proc(CSTR name);\ncql_noexport ast_node *find_region(CSTR name);\ncql_noexport ast_node *find_func(CSTR name);\ncql_noexport ast_node *find_table_or_view_even_deleted(CSTR name);\ncql_noexport ast_node *find_enum(CSTR name);\n")),Object(r.b)("p",null,"These functions give you access to the core name tables (which are still valid!) so that you can look up procedures, functions,\ntables, etc. by name."),Object(r.b)("p",null,"Finally, information about all the schema annotations is invaluable for building schema upgraders.  These\ntwo buffers hold dense arrays of annotation records as shown below."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'cql_data_decl( bytebuf *schema_annotations );\ncql_data_decl( bytebuf *recreate_annotations );\n\ntypedef struct recreate_annotation {\n  CSTR target_name;               // the name of the target\n  CSTR group_name;                // group name or "" if no group (not null, safe to sort)\n  ast_node *target_ast;           // top level target (table, view, or index)\n  ast_node *annotation_ast;       // the actual annotation\n  int32_t ordinal;                // when sorting we want to use the original order (reversed actually) within a group\n} recreate_annotation;\n\ntypedef struct schema_annotation {\n  int32_t version;                // the version number (always > 0)\n  ast_node *target_ast;           // top level target (table, view, or index)\n  CSTR target_name;               // the name of the target\n  uint32_t annotation_type;       // one of the codes below for the type of annotation\n  ast_node *annotation_ast;       // the actual annotation\n  int32_t column_ordinal;         // -1 if not a column\n  ast_node *column_ast;           // a particular column if column annotation\n} schema_annotation;\n\n// Note: schema annotations are processed in the indicated order: the numbers matter\n#define SCHEMA_ANNOTATION_INVALID 0\n#define SCHEMA_ANNOTATION_FIRST 1\n#define SCHEMA_ANNOTATION_CREATE_TABLE 1\n#define SCHEMA_ANNOTATION_CREATE_COLUMN 2\n#define SCHEMA_ANNOTATION_DELETE_TRIGGER 3\n#define SCHEMA_ANNOTATION_DELETE_VIEW 4\n#define SCHEMA_ANNOTATION_DELETE_INDEX 5\n#define SCHEMA_ANNOTATION_DELETE_COLUMN 6\n#define SCHEMA_ANNOTATION_DELETE_TABLE 7\n#define SCHEMA_ANNOTATION_AD_HOC 8\n#define SCHEMA_ANNOTATION_LAST 8\n')),Object(r.b)("p",null,'And of course, each "back end" is provided with the root of the AST so that it can also search\nand/or walk the AST in its own manner.  We will see examples of this in later sections.'),Object(r.b)("h3",{id:"recap"},"Recap"),Object(r.b)("p",null,"At present, there are nearly 20000 lines in ",Object(r.b)("inlineCode",{parentName:"p"},"sem.c")," and it would no doubt take more than 20000 lines of text\nto explain what they all do, and that would be more imprecise than the source code, and probably less\nreadable.  ",Object(r.b)("inlineCode",{parentName:"p"},"sem.c")," includes over 4000 lines of comments, and probably should have more.  While there\nis a lot of code there it's very readable and I encourage you to do so to get your answers."),Object(r.b)("p",null,"The point of this part of the Internals Guide isn't to fully explain all 400+ error checks in about\nas many semantic error checking functions, it's to showcase the key concepts shared by all of them. Things like:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"errors are reported largely in the AST and percolate up"),Object(r.b)("li",{parentName:"ul"},"expressions and statements have general purpose dispatch logic for continuing a statement walk"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"EXTRACT")," macros are used to keep the tree walk on track and correct in the face of changes"),Object(r.b)("li",{parentName:"ul"},"regions are used for visibility"),Object(r.b)("li",{parentName:"ul"},"versioning contributes to visibility"),Object(r.b)("li",{parentName:"ul"},"nullability and sensitivity are tracked throughout using type bits"),Object(r.b)("li",{parentName:"ul"},'type "kind" is managed by a simple string in the ',Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," payload"),Object(r.b)("li",{parentName:"ul"},"the three main payloads are",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_node")," for basic info, and"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_struct")," or ",Object(r.b)("inlineCode",{parentName:"li"},"sem_join")," for the non-unitary types")))),Object(r.b)("p",null,"This isn't everything but it should leave you well armed to begin your own exploration of ",Object(r.b)("inlineCode",{parentName:"p"},"sem.c"),"."))}p.isMDXComponent=!0},148:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),b=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=b(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=b(n),u=a,d=p["".concat(o,".").concat(u)]||p[u]||m[u]||r;return n?i.a.createElement(d,s(s({ref:t},c),{},{components:n})):i.a.createElement(d,s({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);