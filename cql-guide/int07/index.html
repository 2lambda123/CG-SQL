<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 7: JSON Generation | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 7: JSON Generation | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int07"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int07"><link rel="stylesheet" href="/styles.ba4a4811.css">
<link rel="preload" href="/styles.4cc7e11a.js" as="script">
<link rel="preload" href="/runtime~main.b42ec90e.js" as="script">
<link rel="preload" href="/main.545e0595.js" as="script">
<link rel="preload" href="/1.3a9ec2a8.js" as="script">
<link rel="preload" href="/2.b42165a9.js" as="script">
<link rel="preload" href="/3.9c3bdf8e.js" as="script">
<link rel="preload" href="/1be78505.655346c0.js" as="script">
<link rel="preload" href="/92.b9f2f94f.js" as="script">
<link rel="preload" href="/5456faf3.d505401c.js" as="script">
<link rel="preload" href="/17896441.25d1d0d8.js" as="script">
<link rel="preload" href="/029bd7b3.5080fa78.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int04">Part 4: Testing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int05">Part 5: CQL Runtime</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int06">Part 6: Schema Management</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int07">Part 7: JSON Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int08">Part 8: Test Helpers</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 7: JSON Generation</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 7 continues with a discussion of the JSON generation code.
As in the previous sections, the goal here is not to go over every detail but rather to give
a sense of how JSON creation works in general -- the core strategies and implementation choices --
so that when reading the source you will have an idea how it all hangs together. To accomplish
this, we&#x27;ll illustrate the key strategies used to extract the data and format the JSON.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="json-schema"></a>JSON Schema<a aria-hidden="true" tabindex="-1" class="hash-link" href="#json-schema" title="Direct link to heading">#</a></h2><p>The JSON schema is described in <a href="https://cgsql.dev/cql-guide/ch13" target="_blank" rel="noopener noreferrer">Chapter 13</a> of the Guide and there
is a nice diagram of its <a href="https://cgsql.dev/json-diagram" target="_blank" rel="noopener noreferrer">grammar</a> for reference.  So, we won&#x27;t be
discussing all the details of the output.  Instead we&#x27;re going to go over the theory of how the
JSON generator works. It is structured very much like the other code generators but it happens
to produce a JSON file.  It&#x27;s call the &quot;JSON Schema&quot; because most of the content is a description
of the database schema in JSON form.  As such it&#x27;s almost entirely just a simple walk of the AST
in the correct order.  The only really tricky bit is the extra dependency analysis on the AST.
This allows us to emit usage information in the output for downstream tools to use as needed.  </p><p>We&#x27;ll cover these topics:</p><ul><li>walking the AST</li><li>formatting</li><li>computing the dependencies</li></ul><p>This should be a short chapter compared to the others, this output really is much simpler to
create than the C or the schema upgrader.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="walking-the-ast"></a>Walking the AST<a aria-hidden="true" tabindex="-1" class="hash-link" href="#walking-the-ast" title="Direct link to heading">#</a></h3><p>If you run this command:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">$ cql --in x --rt json_schema --cg x.json</span></div></div></div></div></div><p>Where <code>x</code> is an empty file, you&#x27;ll get the following skeletal JSON, lightly reformatted for brevity:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-JSON codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;tables&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;virtualTables&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;views&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;indices&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;triggers&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;attributes&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;queries&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;inserts&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;generalInserts&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;updates&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;deletes&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;general&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;regions&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;adHocMigrationProcs&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;enums&quot; : [  ]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>From this we can deduce a great deal of the structure of the code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for json schema format</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_json_schema_main(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(options.file_names_count == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_exit_on_semantic_errors(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  tables_to_procs = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(main);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *output = &amp;main;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;%s&quot;, rt-&gt;source_prefix);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // master dictionary begins</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\n{\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(defs, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_tables(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_virtual_tables(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_views(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_indices(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_triggers(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_stmt_list(output, head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_regions(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_ad_hoc_migration_procs(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_enums(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (options.test) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_table_users(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(defs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\n}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], output-&gt;ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(main);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(tables_to_procs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>cg_json_schema_main</code> is the main function and you can see that it mirrors that skeletal
JSON output nearly exactly with some additional test output options.  We&#x27;ll cover
the test output in a later section when we&#x27;ve had a chance to discuss the dependency
analysis.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-json-writer-views"></a>Example JSON Writer: Views<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-json-writer-views" title="Direct link to heading">#</a></h4><p>These are sufficiently easy that we can just walk through one of the procedures front to back.
Let&#x27;s look at the &quot;views&quot; section.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The set of views look rather like the query section in as much as</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// they are in fact nothing more than named select statements.  However</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the output here is somewhat simplified.  We only emit the whole select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// statement and any binding args, we don&#x27;t also emit all the pieces of the select.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_views(charbuf *output) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;views\&quot; : [\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(views, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t i = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = all_views_list; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *ast = item-&gt;ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(is_ast_create_view_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *misc_attrs = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *attr_target = ast-&gt;parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_stmt_and_attr(attr_target)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target-&gt;parent);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      misc_attrs = misc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_test_details(output, ast, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_OPTION(flags, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(view_and_attrs, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(name_and_select, view_and_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(select_stmt, name_and_select-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, name_and_select-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (i &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;{\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool_t is_deleted = ast-&gt;sem-&gt;delete_version &gt; 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    BEGIN_INDENT(view, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\&quot;name\&quot; : \&quot;%s\&quot;&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;CRC\&quot; : \&quot;%lld\&quot;&quot;, crc_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;isTemp\&quot; : %d&quot;, !!(flags &amp; VIEW_IS_TEMP));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;isDeleted\&quot; : %d&quot;, is_deleted);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_deleted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n\&quot;deletedVersion\&quot; : %d&quot;, ast-&gt;sem-&gt;delete_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_deleted_migration_proc(output, view_and_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_emit_region_info(output, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_misc_attrs(output, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_projection(output, select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_fragment_with_params(output, &quot;select&quot;, select_stmt, gen_one_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_dependencies(output, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    END_INDENT(view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\n}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    i++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(views);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;]&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="view-loop"></a>View Loop<a aria-hidden="true" tabindex="-1" class="hash-link" href="#view-loop" title="Direct link to heading">#</a></h4><p>Already we can see the structure emerging, and of course its nothing
more than a bunch of <code>bprintf</code>.  Let&#x27;s do it section by section:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(output, &quot;\&quot;views\&quot; : [\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN_INDENT(views, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (list_item *item = all_views_list; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ..</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END_INDENT(views);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(output, &quot;]&quot;);</span></div></div></div></div></div><p>Unsurprisingly, this code will iterate the <code>all_views_list</code> which was
created precisely for this kind of output.  The semantic pass populates
this list for use downstream.</p><p>We&#x27;ll deal with <code>BEGIN_INDENT</code> a bit later, but it should be clear what
it does by the name for now.  So we&#x27;ve made the &quot;views&quot; section and
we&#x27;ll put 0 or more views in it.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="view-extraction"></a>View Extraction<a aria-hidden="true" tabindex="-1" class="hash-link" href="#view-extraction" title="Direct link to heading">#</a></h4><p>The next section extracts the necessary information and emits
the test output:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *ast = item-&gt;ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(is_ast_create_view_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *misc_attrs = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *attr_target = ast-&gt;parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_stmt_and_attr(attr_target)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target-&gt;parent);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      misc_attrs = misc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_test_details(output, ast, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_OPTION(flags, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(view_and_attrs, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(name_and_select, view_and_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(select_stmt, name_and_select-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, name_and_select-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div></div></div></div></div><p>The <code>is_ast_stmt_and_attr</code> node tell us if there were any misc attributes on the
statement.  Those attributes can be extracted and printed.  We have to look up
the tree a little bit from where we are because this is the &quot;all views&quot; list,
if there were attributes on this view they were attached two levels up.  In any
case <code>misc_attrs</code> ends with attributes if there are any.</p><p>After the test output, the necessary view attributes are extracted the usual
way with <code>EXTRACT</code> macros for the view shape.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="test-output"></a>Test Output<a aria-hidden="true" tabindex="-1" class="hash-link" href="#test-output" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_test_details(charbuf *output, ast_node *ast, ast_node *misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (options.test) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\nThe statement ending at line %d\n&quot;, ast-&gt;lineno);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_set_output_buffer(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      gen_with_callbacks(misc_attrs, gen_misc_attrs, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_with_callbacks(ast, gen_one_stmt, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>All of the JSON fragments have the usual test pattern &quot;The statement ending at line nnn&quot;.
This means that the normal validator will be able to find comments in the test file
and associate them with json parts.  The testing strategies are discussed in
[Part 4]((<a href="https://cgsql.dev/cql-guide/int04" target="_blank" rel="noopener noreferrer">https://cgsql.dev/cql-guide/int04</a>).</p><p>In addition, while in test mode, we also emit the original statement that caused
this JSON fragment to be created. This allows the test patterns to cross check
the input and output and also makes the test output more readable for humans.</p><p>Note that in test mode the JSON is effectively corrupted by the test output as it
is not well-formed JSON in any way.  So use of --test is strictly for validation only.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="view-basics"></a>View Basics<a aria-hidden="true" tabindex="-1" class="hash-link" href="#view-basics" title="Direct link to heading">#</a></h4><p>All of the things that go into the JSON have some attributes that are universally present
and generally come directly from the AST.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (i &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;{\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t is_deleted = ast-&gt;sem-&gt;delete_version &gt; 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(view, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;name\&quot; : \&quot;%s\&quot;&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n\&quot;CRC\&quot; : \&quot;%lld\&quot;&quot;, crc_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n\&quot;isTemp\&quot; : %d&quot;, !!(flags &amp; VIEW_IS_TEMP));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n\&quot;isDeleted\&quot; : %d&quot;, is_deleted);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_deleted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;deletedVersion\&quot; : %d&quot;, ast-&gt;sem-&gt;delete_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_deleted_migration_proc(output, view_and_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\n}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  i++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}  </span></div></div></div></div></div><p>This part of the output is the simplest</p><ul><li>we emit a comma if we need one (only the first entry doesn&#x27;t)</li><li>we start the view object &#x27;{&#x27;</li><li>more indenting for the interior of the view</li><li>emit the view name</li><li>emit the CRC of the view (this makes it easy to see if the view changed)<ul><li><code>crc_stmt</code> computes the CRC by echoing the statement into a scratch buffer and then running the CRC algorithm on that buffer</li></ul></li><li>note the &quot;,\n&quot; pattern, this pattern is used because sometimes there are optional parts and using a leading &quot;,\n&quot; makes it clear which part is supposed to emit the comma<ul><li>it turns out getting the commas right is one of the greater annoyances of JSON output</li></ul></li><li>emit &quot;isTemp&quot; </li><li>emit &quot;isDeleted&quot; </li><li>if the view is deleted, emit &quot;deletedVersion&quot;</li><li>if there is a migration procedure on the <code>@delete</code> attribute emit that as well<ul><li><code>cg_json_deleted_migration_proc</code> scans the attribute list for <code>@delete</code> attribute and emits the procedure name on that attribute if there is one</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="optional-info"></a>Optional Info<a aria-hidden="true" tabindex="-1" class="hash-link" href="#optional-info" title="Direct link to heading">#</a></h4><p>The next fragment emits two optional pieces that are present in many types of objects:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_emit_region_info(output, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_misc_attrs(output, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><ul><li>if there is a region assocatied with this view, we emit it here<ul><li><code>cg_json_emit_region_info</code> emits two things:<ul><li>the view&#x27;s region</li><li>the &quot;deployment region&quot; of that region if any (regions are contained in deployable groups)</li><li>see <a href="https://cgsql.dev/cql-guide/ch10#schema-regions" target="_blank" rel="noopener noreferrer">Chapter 10</a> for more info on regions and deployment regions</li></ul></li></ul></li><li>if there are any miscellaneous attributes they are emitted<ul><li>we&#x27;ll use <code>cg_json_misc_attrs</code> as our general formatting example when we get to that</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-view-details"></a>The View Details<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-view-details" title="Direct link to heading">#</a></h4><p>There is very little left in the view emitting code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_projection(output, select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fragment_with_params(output, &quot;select&quot;, select_stmt, gen_one_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_dependencies(output, ast);</span></div></div></div></div></div><ul><li><code>cg_json_projection</code> emits the name and type of each column in the view select list</li><li><code>cg_fragment_with_params</code> emits the statement that creates the view in an attribute named &quot;select&quot;<ul><li>the normal echoing code emits the statement</li><li>views have no variables to bind but other statement forms inside of procedures can have variables in the statement</li><li>the variable names are replace with &quot;?&quot; in the text of the statement</li><li>the names of the variable appear in &quot;selectArgs&quot; (always empty for views)</li></ul></li><li><code>cg_json_dependencies</code> emits the tables and views that were used by this view, it gets its own section</li></ul><p>Those few things produce all JSON for a view. All the other schema elements do basically the same things.  Most of the
helpers are shared so, for instance, regions, misc attributes, and dependencies appear in nearly every kind of object
in the JSON.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="formatting-the-json"></a>Formatting the JSON<a aria-hidden="true" tabindex="-1" class="hash-link" href="#formatting-the-json" title="Direct link to heading">#</a></h3><p>To make the JSON pretty we want to indent it appropriately and put commas in the right
places.  There are some useful macros for this, and they all rely on the fact that
the emitted text goes to a <code>charbuf</code> variable creatively called <code>output</code>.</p><p>Here&#x27;s a sample procedure that was mentioned earlier, it does the usual things:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a list of attributes for the current entity, it could be any kind of entity.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Whatever it is we spit out the attributes here in array format.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_misc_attrs(charbuf *output, ast_node *_Nonnull list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_misc_attrs(list));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;attributes\&quot; : [\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(attr, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_LIST;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *item = list; item; item = item-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    COMMA;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_misc_attr(output, item-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_LIST;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(attr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;]&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The miscellaneous attributes are going to be emitted in a list, and since any
one attribute can actually be a list of attributes, this ends up being recursive
(<code>cg_json_misc_attr</code> can end up calling back to <code>cg_json_misc_attrs</code>).  Attributes
are actually quite flexible.  Let&#x27;s look at the helpers that will be used
to do this formatting.</p><p>From <code>charbuf.h</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These helpers push a buffer and use it for the output temporarily.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// When the buffer is finished (at END_INDENT) bindent is used to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indent it by the indicated amount.  They assume the output buffer is called</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;output&quot;.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define BEGIN_INDENT(name, level) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *name##_saved = output; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t name##_level = level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  output = &amp;name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define END_INDENT(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  output = name##_saved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bindent(output, &amp;name, name##_level); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name); \</span></div></div></div></div></div><ul><li><code>BEGIN_INDENT</code> : sets up the indenting<ul><li>save the current output buffer</li><li>stash the desired indent level in a named local</li><li>make a new scratch buffer using the given name</li><li>set the output to be the scratch buffer</li></ul></li><li><code>END_INDENT</code> : flushes the indented stuff<ul><li>restores the output buffer to what it was</li><li>writes the temporary buffer into the output buffer, indenting it by the desired abount</li><li>close the temporrary buffer</li></ul></li><li><code>bindent</code> : a <code>charbuf</code> helper that reads the input line by line and writes it with indenting spaces to the output</li></ul><p>The rest of the helpers  manage the commas in the (nested) lists:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These little helpers are for handling comma seperated lists where you may or may</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// not need a comma in various places.  The local tracks if there is an item already</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// present and you either get &quot;,\n&quot;  or just &quot;\n&quot; as needed.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define BEGIN_LIST bool_t list_start = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CONTINUE_LIST bool_t list_start = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define COMMA if (!list_start) bprintf(output, &quot;,\n&quot;); else list_start = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define END_LIST if (!list_start) bprintf(output, &quot;\n&quot;)</span></div></div></div></div></div><ul><li><code>BEGIN_LIST</code> : starts a list, records that we are at the beginning of the list</li><li><code>CONTINUE_LIST</code> : starts a list, but assumes things have already been put into it</li><li><code>COMMA</code> : a new item is about to be emitted, add a comma if one is needed<ul><li>i.e. add a comma if we are not on the first item</li></ul></li><li><code>END_LIST</code> : emits a blank line if anything went into the list<ul><li>this puts us in the write place to put an end marker such as &#x27;]&#x27; or &#x27;}&#x27;</li></ul></li></ul><p>So reviewing this bit of code, </p><ul><li>emit the attribute name and start the array &quot;[&quot;</li><li>we start indenting</li><li>we start a list</li><li>we emit a comma if needed</li><li>we emit the new misc attribute<ul><li>this will crack the AST, and get the attribute name and value</li><li>this can recurse</li><li><code>cg_json_misc_attr</code> is pretty simple and a good exercise for the reader</li></ul></li><li>repeat for all attributes</li><li>end the list</li><li>end the indenting</li><li>emit the attribute end &quot;]&quot;</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="quoted-text"></a>Quoted Text<a aria-hidden="true" tabindex="-1" class="hash-link" href="#quoted-text" title="Direct link to heading">#</a></h4><p>Most quoted text in the JSON output is either hard-coded constants,
or else is a CQL identifier and therefore has no special characters.
Those two cases are very simple and no escaping or special formatting
is needed.  We just emit the text with quotes around it. However,
there are cases where general text that might have special characters
in it needs to be emitted.  When that happens a call like this is used:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_pretty_quote_plaintext(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sql.ptr, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    output, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    PRETTY_QUOTE_JSON | PRETTY_QUOTE_SINGLE_LINE);</span></div></div></div></div></div><p><code>cg_pretty_quote_plaintext</code> has been discussed before when it was used to
create SQL strings for the C output. This usage is similar.
Here we&#x27;re using <code>PRETTY_QUOTE_JSON</code> to indicate that only
escape sequences supported by JSON should appear in the output. The format for
hexadecimal escape sequences for non-printable characters is different than C
and some of the C short escapes are not supported
(e.g. &quot;\a&quot; is not legal JSON).  We always use <code>PRETTY_QUOTE_SINGLE_LINE</code>
in the JSON output so that multi-line SQL is rendered as one line.
Remember here we are are JSON-escaping the SQL so the embedded newlines
in the original SQL were already converted to &#x27;\&#x27; &#x27;n&#x27; (two characters)
and therefore any newlines still in the string are those placed there by the
line breaking of the SQL not by newlines in string literals.  Hence
those newlines are optional, any whitespace will do.</p><p>In any case, <code>cg_pretty_quote_plaintext</code> is just the function to do what we need
and this output is only slightly different than what would be emitted for
the C codegen.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="dependency-analysis"></a>Dependency Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#dependency-analysis" title="Direct link to heading">#</a></h3><p>There are a number of places where dependencies have to be computed. To do this job,
this function is used universally:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// For procedures and triggers we want to walk the statement list and emit a set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// of dependency entries that show what the code in question is using and how.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We track tables that are used and if they appear in say the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// (or some other read-context) or if they are the subject of an insert, update,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// or delete.  We also track the use of nested procedures and produce a list of</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// procs the subject might call.  Of course no proc calls ever appear in triggers.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_dependencies(charbuf *output, ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>In general this code walks any AST looking for a variety of patterns in the AST
that correspond to use of tables, directly or indirectly. Actually more accurately,
<code>cg_json_dependencies</code> uses <code>find_table_refs</code> to do the job, and it does so by:</p><ul><li>creating an output buffer for each kind of thing <code>find_table_refs</code> might find</li><li>setting up a simple callback to fill in the buffer</li><li>invoking <code>find_table_refs</code></li><li>formatting the buffers that have any resulting dependency data and emitting them as dependencies</li></ul><p>This works for any kind of AST really, though typically you do this for procedures
or triggers because they have an interesting body.  But the analysis also makes sense for views
because views can refer to other views and to tables.</p><p>The primary code looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  table_callbacks callbacks = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_any_table = cg_found_table,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_any_view = cg_found_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_inserts = cg_found_insert,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_updates = cg_found_update,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_deletes = cg_found_delete,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_from = cg_found_from,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_proc = cg_found_proc,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_context = &amp;context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  find_table_refs(&amp;callbacks, ast);</span></div></div></div></div></div><p>And an example callback:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the callback function that tells us a view name was found in the body</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// of the stored proc we are currently examining.  The void context information</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is how we remember which proc we were processing.   For each table we have</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// a character buffer.  We look it up, create it if not present, and write into it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We also write into the buffer for the current proc which came in with the context.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_found_view(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR view_name, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node* table_ast, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void* pvContext) </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  json_context *context = (json_context *)pvContext;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(context-&gt;cookie == cookie_str);  // sanity check</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(context-&gt;used_views);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_name_to_output(context-&gt;used_views, view_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The callback gets the <code>pvContext</code> back, which is the <code>context</code> local variable
from <code>cg_json_dependencies</code>.  This has all the buffers in it.  All
we have to do is add the name to the buffer, which is done as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void add_name_to_output(charbuf* output, CSTR table_name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (output-&gt;used &gt; 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;, &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;%s\&quot;&quot;, table_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>add a comma if needed</li><li>add the name</li><li>done :D</li></ul><p>Note: The added name of course doesn&#x27;t have to be a table name, but it usually is.</p><p>So we can see that <code>find_table_refs</code> will tell us the kind of thing it found and the name of the thing.</p><p>When all this is done each kind of dependency is emitted if it exists, like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (used_views.used &gt; 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;usesViews\&quot; : [ %s ]&quot;, used_views.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>This gives us a quoted list of the dependencies.  Now, how do we find these?</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="walking-the-ast-for-dependencies"></a>Walking the AST for Dependencies<a aria-hidden="true" tabindex="-1" class="hash-link" href="#walking-the-ast-for-dependencies" title="Direct link to heading">#</a></h4><p><code>find_table_refs</code> is a fairly simple tree walk that looks for certain key patterns
actually the tree walk happens in <code>find_table_node</code> which looks for tables and
procedure calls in the nested AST.</p><p><code>find_table_refs</code> records the callbacks that were specified, and it makes some symbol
tables so that the same table/view/procedure is not reported twice.  After that
it starts walking the AST recursively looking for the patterns.  Here&#x27;s an example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Recursively finds table nodes, executing the callback for each that is found.  The</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// callback will not be executed more than once for the same table name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void find_table_node(table_callbacks *callbacks, ast_node *node) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Check the type of node so that we can find the direct references to tables. We</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // can&#x27;t know the difference between a table or view in the ast, so we will need to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // later find the definition to see if it points to a create_table_stmt to distinguish</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // from views.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  find_ast_str_node_callback alt_callback = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *alt_visited = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_or_view_name_ast = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_ast_delete_stmt(node)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, node-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    table_or_view_name_ast = name_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    alt_callback = callbacks-&gt;callback_deletes;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    alt_visited = callbacks-&gt;visited_delete;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The code afterward will do these steps:</p><ul><li>notice that <code>table_or_view_name_ast</code> was set, hence something was found</li><li>determine that it is in fact a table</li><li>call the general callback for any table seen (but only once for this table)</li><li>call the alternate callback that this is a table being deleted (but only once)</li></ul><p>Almost all the other operations work similarly:</p><ul><li><code>table_or_view_name_ast</code> is set</li><li><code>alt_callback</code> is called but only if</li><li><code>alt_visited</code> doesn&#x27;t already have the symbol</li></ul><p>The exception to the above is the processing that&#x27;s done for procedure calls.
We&#x27;ve actually only talked about table dependencies so far but, additionally,
any procedure includes dependencies on the procedures it calls.</p><p>If a procedure call is found then <code>callbacks-&gt;callback_proc</code> is used and
<code>callbacks-&gt;visited_proc</code> verifies that there are no duplicates.  So much
the same except the names are procedure names.</p><p>Note that the code does not do transitive closure of procedure calls because
in general the called procedure is likely in a different translation unit.
However with the direct calls in place it is easy enough to do transitive closure
from the JSON if you do have all the procedures in one unit or if you have
several JSON results from different compilations.</p><p>However, when a view is encountered, the code does follow into the view body
and recursively reports what the view uses. This means that the reported tables
do include any tables that were used indirectly via views.</p><p>Finally, any CTEs that are used will not be reported because
<code>find_table_or_view_even_deleted</code> will fail for a CTE.  However the body
of the CTE is processed so while the CTE name does not appear, what the
CTE uses does appear, just like any other table usage.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="additional-test-output"></a>Additional Test Output<a aria-hidden="true" tabindex="-1" class="hash-link" href="#additional-test-output" title="Direct link to heading">#</a></h3><p>The extra test output is simply a reverse index:  a mapping that goes
from any table to the procedures that depend on that table.</p><p>The mapping can easily be created by processing the JSON for procedures,
each such procedure includes its dependency information.  As a result it&#x27;s only
used for additional validation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>The JSON output produced by <code>cg_json_schema.c</code> is similar to other codegen
output but lacks most of the complexities.  It deals largely with the
declared schema and the declared procedures and their parameters.  Most
of the output it needs to produce is well supported by the normal text
emission features in the compiler and so we end up with a very straightforward
walk of the AST, visiting each of the relevant kinds of nodes in order.</p><p>Topics covered included:</p><ul><li>the types of output that will be produced</li><li>the general structure of the main JSON emitter</li><li>an example emitter</li><li>typical formatting features necessary to produce good quality JSON</li><li>a tour of the dependency emitter</li></ul><p>As with the other parts, no attempt was made to cover every function in detail.  That is
best done by reading the source code. But there is overall structure here and an understanding
of the basic principles is helpful before diving into the source code.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-11-09T22:40:03.000Z" class="docLastUpdatedAt_217_">11/9/2021</time> by <strong>Winnie Quinn</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int06"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 6: Schema Management</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cql-guide/int08"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Part 8: Test Helpers Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#json-schema" class="table-of-contents__link">JSON Schema</a><ul><li><a href="#walking-the-ast" class="table-of-contents__link">Walking the AST</a></li><li><a href="#formatting-the-json" class="table-of-contents__link">Formatting the JSON</a></li><li><a href="#dependency-analysis" class="table-of-contents__link">Dependency Analysis</a></li><li><a href="#additional-test-output" class="table-of-contents__link">Additional Test Output</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Facebook Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2021 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4cc7e11a.js"></script>
<script src="/runtime~main.b42ec90e.js"></script>
<script src="/main.545e0595.js"></script>
<script src="/1.3a9ec2a8.js"></script>
<script src="/2.b42165a9.js"></script>
<script src="/3.9c3bdf8e.js"></script>
<script src="/1be78505.655346c0.js"></script>
<script src="/92.b9f2f94f.js"></script>
<script src="/5456faf3.d505401c.js"></script>
<script src="/17896441.25d1d0d8.js"></script>
<script src="/029bd7b3.5080fa78.js"></script>
</body>
</html>