<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 2: Semantic Analysis | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 2: Semantic Analysis | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int02"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int02"><link rel="stylesheet" href="/styles.9ec987f3.css">
<link rel="preload" href="/styles.58a786a3.js" as="script">
<link rel="preload" href="/runtime~main.6e310b00.js" as="script">
<link rel="preload" href="/main.f2c34c0c.js" as="script">
<link rel="preload" href="/1.fae5e295.js" as="script">
<link rel="preload" href="/2.0eb37f9a.js" as="script">
<link rel="preload" href="/3.5c2742cc.js" as="script">
<link rel="preload" href="/1be78505.bc52d199.js" as="script">
<link rel="preload" href="/106.5c1aa3b0.js" as="script">
<link rel="preload" href="/5456faf3.c3a29041.js" as="script">
<link rel="preload" href="/17896441.5a19be7f.js" as="script">
<link rel="preload" href="/e2f0474c.4127e1ca.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div class="announcementBar_1l0Z" style="background-color:#20232a;color:#fff" role="banner"><div class="announcementBarContent_1xni">Support Ukraine ðŸ‡ºðŸ‡¦ <a target="_blank" rel="noopener noreferrer" href="https://opensource.fb.com/support-ukraine"> Help Provide Humanitarian Aid to Ukraine</a>.</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x10">Appendix 10: CQL Working Example</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x11">Appendix 11: Production Considerations</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int04">Part 4: Testing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int05">Part 5: CQL Runtime</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int06">Part 6: Schema Management</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int07">Part 7: JSON Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int08">Part 8: Test Helpers</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 2: Semantic Analysis</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 2 continues with a discussion of the essentials of the semantic analysis pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every single rule but rather to give
a sense of how semantic analysis happens in general -- the core strategies and implementation choices --
so that when reading the code you will have an idea of how smaller pieces fit into the whole. To accomplish
this, various key data structures will be explained in detail and selected examples of their use are included.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="semantic-analysis"></a>Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#semantic-analysis" title="Direct link to heading">#</a></h2><p>The overall goal of the semantic analysis pass is to verify that a correct program has been submitted
to the compiler. The compiler does this by &quot;decorating&quot; the AST with semantic information.  This information
is mainly concerned with the &quot;types&quot; of the various things in the program.  A key function of the semantic
analyzer, the primary &quot;weapon&quot; in computing these types, if you will, is name resolution.  The semantic analyzer
decides what any given name means in any context and then uses that meaning, which is itself based on the
AST constructs that came before, to compute types and then check those types for errors.</p><p>Broadly speaking, the errors that can be discovered are of these forms:</p><ul><li>mentioned names do not exist<ul><li>e.g. using a variable or table or column without declaring it</li></ul></li><li>mentioned names are not unique, or are ambiguous<ul><li>e.g. every view must have a unique name</li><li>e.g. table names need to be unique, or aliased when joining tables</li></ul></li><li>operands are not compatible with each other or with the intended operation<ul><li>e.g. you can&#x27;t add a string to a real</li><li>e.g. you can&#x27;t do the <code>%</code> operation on a real</li><li>e.g. the expression in a <code>WHERE</code> clause must result in a numeric</li><li>e.g. the first argument to <code>printf</code> must be a string literal</li><li>e.g. you can&#x27;t assign a long value to an integer variable</li><li>e.g. you can&#x27;t assign a possibly null result to a not-null variable</li></ul></li><li>there are too many or two few operands for an operation<ul><li>e.g. an <code>INSERT</code> statement must include sufficiently many columns and no extras</li><li>e.g. a function or procedure call must have the correct number of operands</li></ul></li><li>an operation is happening in a context where it is not allowed<ul><li>e.g. use of aggregate functions in the <code>WHERE</code> clause</li><li>e.g. use of unique SQLite functions outside of a SQL statement</li></ul></li></ul><p>There are several hundred possible errors, and no attempt will be made to cover them all here but we will
talk about how errors are created, recorded, and reported.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="decorated-ast-examples"></a>Decorated AST examples<a aria-hidden="true" tabindex="-1" class="hash-link" href="#decorated-ast-examples" title="Direct link to heading">#</a></h3><p>Recalling the AST output from <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>, this is what that same tree
looks like with semantic information attached:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">LET X := 1 + 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {let_stmt}: X: integer notnull variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name X}: X: integer notnull variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 3}: integer notnull</span></div></div></div></div></div><p>And here&#x27;s an example with some structure types:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SELECT 1 AS x, 3.2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {select_stmt}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_core_list}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {select_core}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {select_expr_list_con}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_expr_list}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {select_expr}: x: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | | {int 1}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | | {opt_as_alias}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | |   | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {select_expr_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |   | {select_expr}: y: real notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |     | {dbl 3.2}: real notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |     | {opt_as_alias}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |       | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_from_etc}: ok</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {select_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {select_groupby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |           | {select_having}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_orderby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {select_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {select_offset}</span></div></div></div></div></div><p>These can be generated by adding <code>--sem --ast</code> to the CQL command line along with <code>--in your_file.sql</code>.</p><p>Keep these shapes in mind as we discuss the various sources of type information.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-base-data-structures"></a>The Base Data Structures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-base-data-structures" title="Direct link to heading">#</a></h3><p>First recall that every AST node has this field in it:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct sem_node *_Nullable sem;</span></div></div></div></div></div><p>This is the pointer to the semantic information for that node. Semantic analysis happens immediately
after parsing and before any of the code-generators run.  Importantly, code generators never run
if semantic analysis reported any errors.  Before we get into the shape of the semantic node, we
should start with the fundamental unit of type info <code>sem_t</code> which is usually stored in a variable
called <code>sem_type</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef uint64_t sem_t;</span></div></div></div></div></div><p>The low order bits of a <code>sem_t</code> encode the core type and indeed there is a helper function
to extract the core type from a <code>sem_t</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Strips out all the flag bits and gives you the base/core type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport sem_t core_type_of(sem_t sem_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_type &amp; SEM_TYPE_CORE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The core bits are as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_NULL 0         // the subtree is a null literal (not just nullable)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BOOL 1         // the subtree is a bool</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_INTEGER 2      // the subtree is an integer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_LONG_INTEGER 3 // the subtree is a long integer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_REAL 4         // the subtree is a real</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_TEXT 5         // the subtree is a text type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BLOB 6         // the subtree is a blob type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OBJECT 7       // the subtree is any object type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_STRUCT 8       // the subtree is a table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_JOIN 9         // the subtree is a join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_ERROR 10       // marks the subtree as having a problem</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OK 11          // sentinel for ok but no type info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_PENDING 12     // sentinel for type calculation in flight</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_REGION 13      // the ast is a schema region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CURSOR_FORMAL 14      // this is used for the cursor parameter type uniquely</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CORE 0xff      // bit mask for the core types</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) // the last unitary type</span></div></div></div></div></div><p>These break into a few categories:</p><ul><li><code>NULL</code> to <code>OBJECT</code> are the &quot;unitary&quot; types -- these are the types that a single simple variable can be<ul><li>a column can be any of these except <code>OBJECT</code> or <code>NULL</code></li><li>the <code>NULL</code> type comes only from the <code>NULL</code> literal which has no type</li><li>instances of, say, a <code>TEXT</code> column might have a <code>NULL</code> value but they are known to be <code>TEXT</code></li></ul></li><li><code>STRUCT</code> indicates that the object has many fields, like a table, or a cursor</li><li><code>JOIN</code> indicates that the object is the concatenation of many <code>STRUCT</code> types<ul><li>e.g. <code>T1 inner join T2</code> is a <code>JOIN</code> type with <code>T1</code> and <code>T2</code> being the parts</li><li>a <code>JOIN</code> could be flattened to <code>STRUCT</code>, but this is typically not done</li><li>the type of a <code>SELECT</code> statement will be a <code>STRUCT</code> representing the expressions that were selected</li><li>those expressions in turn used columns from the <code>JOIN</code> that was the <code>FROM</code> clause</li></ul></li><li><code>ERROR</code> indicates that the subtree had an error<ul><li>the error will have been already reported</li><li>the error type generally cascades up the AST to the root</li></ul></li><li><code>OK</code> indicates that there is no type information but there was no problem<ul><li>e.g. a correct <code>IF</code> statement will resolve to simply <code>OK</code> (no error)</li></ul></li><li><code>PENDING</code> is used sometimes while a type computation is in progress<ul><li>this type doesn&#x27;t appear in the AST, but has its own unique value so as to not conflict with any others</li></ul></li><li><code>REGION</code> is used to identify AST fragments that correspond to schema regions<ul><li>see <a href="https://cgsql.dev/cql-guide/ch10" target="_blank" rel="noopener noreferrer">Chapter 10</a> of the Guide for more information on regions</li></ul></li><li><code>CORE</code> is the mask for the core parts, <code>0xf</code> would do the job but for easy reading in the debugger we use <code>0xff</code><ul><li>new core types are not added very often, adding a new one is usually a sign that you are doing something wrong</li></ul></li></ul><p>The core type can be modified by various flags.  The flags, in principle, can be combined in any way but in practice many combinations make no sense.
For instance, <code>HAS_DEFAULT</code> is for table columns and <code>CREATE_FUNC</code> is for function declarations. There is no one object that could require both of these.</p><p>The full list as of this writing is as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_NOTNULL               _64(0x0100) // set if and only if null is not possible</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) // set for table columns with a default</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) // set for table columns with autoinc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VARIABLE              _64(0x0800) // set for variables and parameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_IN_PARAMETER          _64(0x1000) // set for in parameters (can mix with below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) // set for out parameters (can mix with above)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DML_PROC              _64(0x4000) // set for stored procs that have DML/DDL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) // set for a cursor with simplified fetch syntax</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CREATE_FUNC          _64(0x10000) // set for a function that returns a created object +1 ref</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_SELECT_FUNC          _64(0x20000) // set for a sqlite UDF function declaration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DELETED              _64(0x40000) // set for columns that are not visible in the current schema version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VALIDATED            _64(0x80000) // set if item has already been validated against previous schema</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_USES_OUT            _64(0x100000) // set if proc has a one rowresult using the OUT statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) // set if proc uses the OUT UNION form for multi row result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_PK                  _64(0x400000) // set if column is a primary key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_FK                  _64(0x800000) // set if column is a foreign key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_UK                 _64(0x1000000) // set if column is a unique key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) // set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_SENSITIVE          _64(0x4000000) // set if the object is privacy sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) // set if the object is a deployable region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BOXED             _64(0x10000000) // set if a cursor&#x27;s lifetime is managed by a box object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_CHECK         _64(0x20000000) // set for table column with a &quot;check&quot; clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) // set for table column with a &quot;collate&quot; clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) // set if inferred to not be nonnull (but was originally nullable)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VIRTUAL          _64(0x100000000) // set if and only if this is a virtual table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) // set if and only if hidden column on a virtual table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_TVF              _64(0x400000000) // set if and only table node is a table valued function</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_IMPLICIT         _64(0x800000000) // set if and only the variable was declare implicitly (via declare out)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) // set if proc calls an out union proc for</span></div></div></div></div></div><p>Note: <code>_64(x)</code> expands to either a trailing <code>L</code> or a trailing <code>LL</code> depending on the bitness of the compiler, whichever yields an <code>int64_t</code>.</p><p>Going over the meaning of all of the above is again beyond the scope of this document; some of the flags are very specialized and essentially the validation
just requires a bit of storage in the tree to do its job so that storage is provided with a flag.  However two flag bits are especially important and
are computed almost everywhere <code>sem_t</code> is used.  These are <code>SEM_TYPE_NOTNULL</code> and <code>SEM_TYPE_SENSITIVE</code>.</p><ul><li><code>SEM_TYPE_NOTNULL</code> indicates that the marked item is known to be <code>NOT NULL</code>, probably because it was declared as such, or directly derived from a not null item<ul><li>Typically when two operands are combined both must be marked <code>NOT NULL</code> for the result to still be <code>NOT NULL</code> (there are exceptions like <code>COALESCE</code>)</li><li>Values that might be null cannot be assigned to targets that must not be null</li></ul></li><li><code>SEM_TYPE_SENSITIVE</code> indicates that the marked item is some kind of PII or other sensitive data.<ul><li>Any time a sensitive operand is combined with another operand the resulting type is sensitive</li><li>There are very few ways to &quot;get rid&quot; of the sensitive bit -- it corresponds to the presence of <code>@sensitive</code> in the data type declaration</li><li>Values that are sensitive cannot be assigned to targets that are not marked sensitive</li></ul></li></ul><p>The semantic node <code>sem_node</code> carries all the possible semantic info we might need, and the <code>sem_type</code> holds the flags above and tells us how to interpret the rest of the node.
There are many fields -- we&#x27;ll talk about some of the most important ones here to give you a sense of how things hang together.</p><p>Note that <code>CSTR</code> is simply an alias for <code>const char *</code>.  <code>CSTR</code> is used extensively in the codebase for brevity.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type;                   // core type plus flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR name;                        // for named expressions in select columns, etc.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kind;                        // the Foo in object&lt;Foo&gt;, not a variable or column name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR error;                       // error text for test output, not used otherwise</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct *sptr;          // encoded struct if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_join *jptr;            // encoded join if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t create_version;           // create version if any (really only for tables and columns)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t delete_version;           // delete version if any (really only for tables and columns)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t recreate;                  // for tables only, true if marked @recreate</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR recreate_group_name;         // for tables only, the name of the recreate group if they are in one</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR region;                      // the schema region, if applicable; null means unscoped (default)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *used_symbols;             // for select statements, we need to know which of the ids in the select list was used, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  list_item *index_list;            // for tables we need the list of indices that use this table (so we can recreate them together if needed)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct eval_node *value;          // for enum values we have to store the evaluated constant value of each member of the enum</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_node;</span></div></div></div></div></div><ul><li><code>sem_type</code> : already discussed above, this tells you how to interpret everything else</li><li><code>name</code> : variables, columns, etc. have a canonical name -- when a name case-insensitivity resolves, the canonical name is stored here<ul><li>typically later passes emit the canonical variable name everywhere</li><li>e.g. because <code>FoO</code> and <code>fOO</code> might both resolve to an object declared as <code>foo</code>, we always emit <code>foo</code> in codegen</li></ul></li><li><code>kind</code> : in CQL any type can be discriminated as in <code>declare foo real&lt;meters&gt;</code>, the kind here is <code>meters</code><ul><li>two expressions of the same core type (e.g. <code>real</code>) are incompatible if they have a <code>kind</code> and the <code>kind</code> does not match</li><li>e.g. if you have <code>bar real&lt;liters&gt;</code> then <code>set foo := bar;</code> this is an error even though both are <code>real</code> because <code>foo</code> above is <code>real&lt;meters&gt;</code></li></ul></li><li><code>sptr</code> : if the item&#x27;s core type is <code>SEM_TYPE_STRUCT</code> then this is populated (see below)</li><li><code>jptr</code> : if the item&#x27;s core type is <code>SEM_TYPE_JOIN</code> then this is populated (see below)</li></ul><p>If the object is a structure type then this is simply an array of names, kinds, and semantic types.  In fact the semantic types will be all be unitary, possibly modified by <code>NOT_NULL</code> or <code>SENSITIVE</code> but none of the other flags apply.  A single <code>sptr</code> directly corresponds to the notion of a &quot;shape&quot; in the analyzer.  Shapes come from anything
that looks like a table, such as a cursor, or the result of a <code>SELECT</code> statement.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for tables and views and the result of a select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_struct {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR struct_name;               // struct name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // field names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *kinds;                    // the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *semtypes;                // typecode for each field</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_struct;</span></div></div></div></div></div><p>If the object is a join type (such as the parts of the <code>FROM</code> clause) then the <code>jptr</code> field will be populated. This is nothing more than a named list of struct types.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for the data type of (parts of) the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// sometimes I refer to as a &quot;joinscope&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_join {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of table/views in the join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // names of the table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct **tables;     // struct type of each table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_join;</span></div></div></div></div></div><p>With these building blocks we can represent the type of anything in the CQL language.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initiating-semantic-analysis"></a>Initiating Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initiating-semantic-analysis" title="Direct link to heading">#</a></h3><p>The semantic analysis pass runs much the same way as the AST emitter.  In <code>sem.c</code> there is the essential function <code>sem_main</code>. It suffices
to call <code>sem_main</code> on the root of the AST. That root node is expected to be a <code>stmt_list</code> node.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This method loads up the global symbol tables in either empty state or</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the appropriate tokens ready to go.  Using our own symbol tables for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// dispatch saves us a lot of if/else string comparison verbosity.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void sem_main(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // restore all globals and statics we own</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_cleanup();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  eval_init();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>As you can see, <code>sem_main</code> begins by resetting all the global state.  You can of course do this yourself after calling <code>sem_main</code> (when you&#x27;re done with the results).</p><p><code>sem_main</code> sets a variety of useful and public global variables that describe the results of the analysis.  The ones in <code>sem.h</code> are part of the contract and
you should feel free to use them in a downstream code-generator.  Other items are internal and should be avoided.
The internal items are typically defined statically in <code>sem.c</code>. The essential outputs will be described in the last section of this part.</p><p>The cleanup has this structure:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This method frees all the global state of the semantic analyzer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void sem_cleanup() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  eval_cleanup();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(deployable_validations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(recreate_annotations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(schema_annotations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(funcs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(globals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(indices);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_ad_hoc_list = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_functions_list = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div></div></div></div></div><p>This basically deallocates everything and resets all the globals to <code>NULL</code>.</p><p><code>sem_main</code> of course has to walk the AST and it does so in much the same way as we saw in <code>gen_sql.c</code>. There is a series of symbol tables
whose key is an AST type and whose value is a function plus arguments to dispatch (effectively a lambda.)  The semantic analyzer doesn&#x27;t
have to think about things like &quot;should I emit parentheses?&quot; so the signature of each type of lambda can be quite a bit simpler.  We&#x27;ll
go over each kind with some examples.</p><p>First we have the non-SQL statements, these are basic flow control or other things that SQLite will never see directly.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *syms = non_sql_stmts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(leave_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><p>Here <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>if_stmt</code> and the function <code>sem_if_stmt</code>.  This lets us dispatch any part of the AST
to its handler directly.</p><p>Next we have the SQL statements.  These get analyzed in the same way as the others, and with functions that have the same signature, however,
if you use one of these it means that procedure that contained this statement must get a database connection in order to run.  Use of the database
will require the procedure&#x27;s signature to change; this is recorded by the setting the <code>SEM_TYPE_DML_PROC</code> flag bit to be set on the procedure&#x27;s AST node.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  syms = sql_stmts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_index_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(delete_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(update_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(insert_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><p>Again <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>delete_stmt</code> and the function <code>sem_delete_stmt</code> so we can dispatch to the handler.</p><p>Next we have expression types. These are set up with <code>EXPR_INIT</code>.  Many of the operators require exactly the same kinds of verification, so in order to be
able to share the code, the expression analysis functions get an extra argument for the operator in question.  Typically the string of the operator
is only needed to make a good quality error message with validation being otherwise identical.  Here are some samples...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, sem_expr_num, &quot;NUM&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, sem_expr_str, &quot;STR&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(blob, sem_expr_blob, &quot;BLB&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, sem_expr_null, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, sem_expr_dot, &quot;DOT&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(const, sem_expr_const, &quot;CONST&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, sem_binary_math, &quot;*&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, sem_binary_integer_math, &quot;%&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, sem_unary_logical, &quot;NOT&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(is_true, sem_unary_is_true_or_false, &quot;IS TRUE&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, sem_unary_integer_math, &quot;~&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, sem_unary_math, &quot;-&quot;);</span></div></div></div></div></div><p>Looking at the very first entry as an example, we see that <code>EXPR_INIT</code> creates a mapping between the AST type <code>num</code>
and the analysis function <code>sem_expr_num</code> and that function will get the text <code>&quot;NUM&quot;</code> as an extra argument.
As it happens <code>sem_expr_num</code> doesn&#x27;t need the extra argument, but <code>sem_binary_math</code> certainly needs the <code>&quot;*&quot;</code>
as that function handles a large number of binary operators.</p><p>Let&#x27;s quickly go over this list as these are the most important analyzers:</p><ul><li><code>sem_expr_num</code> : analyzes any numeric constant</li><li><code>sem_expr_str</code> : analyzes any string literal or identifier</li><li><code>sem_expr_blob</code> : analyzes any blob literal</li><li><code>sem_expr_null</code> : analyzes the NULL literal (and nothing else)</li><li><code>sem_expr_dot</code> : analyzes a compound name like <code>T1.id</code></li><li><code>sem_expr_const</code> : analyzes a <code>const(...)</code> expression, doing the constant evaluation</li><li><code>sem_binary_math</code> : analyzes any normal binary math operator like &#x27;+&#x27;, &#x27;-&#x27;, &#x27;/&#x27; etc.</li><li><code>sem_binary_integer_math</code> : analyzes any binary math operator where the operands must be integers like &#x27;%&#x27; or &#x27;|&#x27;</li><li><code>sem_unary_logical</code> : analyzes any unary logical operator (the result is a bool) -- this is really only <code>NOT</code></li><li><code>sem_unary_is_true_or_false</code> : analyzes any of the <code>IS TRUE</code>, <code>IS FALSE</code> family of postfix unary operators</li><li><code>sem_unary_integer_math</code> : analyzes any unary operator where the operand must be an integer -- this is really only <code>~</code></li><li><code>sem_unary_math</code> : analyzes any any math unary operator, presently only negation (but in the future unary <code>+</code> too)</li></ul><p>The last group of normal associations are for builtin functions, like these:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(changes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(strftime);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(date);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(time);</span></div></div></div></div></div><p>Each of these is dispatched when a function call is found in the tree.  By way of example <code>FUNC_INIT(changes)</code>
causes the <code>changes</code> function to map to <code>sem_func_changes</code> for validation.</p><p>There are a few other similar macros for more exotic cases but the general pattern should be clear now.  With these in place
it&#x27;s very easy to traverse arbitrary statement lists and arbitrary expressions with sub expressions and have the correct function
invoked without having large <code>switch</code> blocks all over.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="semantic-errors"></a>Semantic Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#semantic-errors" title="Direct link to heading">#</a></h3><p>Some of the following examples will show the handling of semantic errors more precisely but the theory is pretty simple.  Each of the analyzers that has
been registered is responsible for putting an appropriate <code>sem_node</code> into the AST it is invoked on.  The caller will look to see if that <code>sem_node</code>
is of type <code>SEM_TYPE_ERROR</code> using <code>is_error(ast)</code>.  If it is, the caller will mark its own AST as errant using <code>record_error(ast)</code> and this continues all
the way up the tree.  The net of this is that wherever you begin semantic analysis, you can know if there were any problems by checking for an error at the
top of the tree you provided.</p><p>At the point of the initial error, the analyzer is expected to also call <code>report_error</code> providing a suitable message.  This will be logged to <code>stderr</code>.
In test mode it is also stored in the AST so that verification steps can confirm that errors were reported at exactly the right place.</p><p>If there are no errors, then a suitable <code>sem_node</code> is created for the resulting type or else, at minimum, <code>record_ok(ast)</code> is used to place the shared &quot;OK&quot; type on the node.
The &quot;OK&quot; type indicates no type information, but no errors either.  &quot;OK&quot; is helpful for statements that don&#x27;t involve expressions like <code>DROP TABLE Foo</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-primitive-types"></a>The Primitive Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-primitive-types" title="Direct link to heading">#</a></h3><p>Perhaps the simplest analysis of all happens at the leaves of the AST.  By way of example, here is the code for expression nodes of type <code>num</code>, the numeric literals.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expression type for numeric primitives</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_expr_num(ast_node *ast, CSTR cstr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_num(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NUM_TYPE(num_type, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (num_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_BOOL:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_INT:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_LONG:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  default:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // this is all that&#x27;s left</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(num_type == NUM_REAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_REAL | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>As you can see the code simply looks at the AST node, confirming first that it is a <code>num</code> node.  Then it extracts the <code>num_type</code>.
Then <code>ast-&gt;sem</code> is set to a semantic node of the matching type adding in <code>SEM_TYPE_NOTNULL</code> because literals are never null.</p><p>The <code>new_sem</code> function is used to make an empty <code>sem_node</code> with the <code>sem_type</code> filled in as specified.  Nothing can go wrong creating a literal so there are no failure modes.</p><p>It doesn&#x27;t get much simpler unless maybe...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expression type for constant NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_expr_null(ast_node *ast, CSTR cstr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It&#x27;s hard to get simpler than doing semantic analysis of the <code>NULL</code> literal.  Its code should be clear with no further explanation needed.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="unary-operators"></a>Unary Operators<a aria-hidden="true" tabindex="-1" class="hash-link" href="#unary-operators" title="Direct link to heading">#</a></h3><p>Let&#x27;s dive in to a simple case that does require some analysis -- the unary operators.  There are comparatively few and there isn&#x27;t much code required to handle them all.</p><p>Here&#x27;s the code for the unary math operators:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The only unary math operators are &#x27;-&#x27; and &#x27;~&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Reference types are not allowed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_unary_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_unary_prep(ast, &amp;core_type, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_validate_numeric(ast, core_type, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The result of unary math promotes to integer.  Basically this converts</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // bool to integer.  Long integer and Real stay as they are.  Text is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // already ruled out.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_result = sem_combine_types(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (core_type | combined_flags));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(sem_type_result);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;kind = ast-&gt;left-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // note ast-&gt;sem-&gt;name is NOT propagated because SQLite doesn&#x27;t let you refer to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the column &#x27;x&#x27; in &#x27;select -x&#x27; -- the column name is actually &#x27;-x&#x27; which is useless</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so we have no name once you apply unary math (unless you use &#x27;as&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // hence ast-&gt;sem-&gt;name = ast-&gt;left-&gt;sem-&gt;name is WRONG here and it is not missing on accident</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><em>Unary Prep</em></p><p>OK already we need to pause because there is a &quot;prep&quot; pattern here common to most of the shared operators that we should discuss.
The prep step takes care of most of the normal error handling which is the same for all the unary operators
and the same pattern happens in binary operators.  Let&#x27;s take a look at <code>sem_unary_prep</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The unary operators all have a similar prep to the binary.  We need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to visit the left side (it&#x27;s always the left node even if the operator goes on the right)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if that&#x27;s ok then we need the combined_flags and core type.  There is only</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the one.  Returns true if everything is ok.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_unary_prep(ast_node *ast, sem_t *core_type, sem_t *combined_flags) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // op left | left op</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(ast-&gt;left)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *combined_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_node *sem = ast-&gt;left-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type = core_type_of(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *combined_flags = not_nullable_flag(sem_type) | sensitive_flag(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Reviewing the steps:</p><ul><li>first we analyze the operand, it will be in <code>ast-&gt;left</code></li><li>if that&#x27;s an error, we just return the error code from the prep steps</li><li>now that it&#x27;s not an error, we pull the core type out of the operand</li><li>then we pull the not nullable and sensitive flag bits out of the operand</li><li>finally return a boolean indicating the presence of an error (or not) for convenience</li></ul><p>This is useful setup for all the unary operators, and as we&#x27;ll see, the binary operators have a similar prep step.</p><p><em>Back to Unary Processing</em></p><p>Looking at the overall steps we see:</p><ul><li><code>sem_unary_prep</code> : verifies that the operand is not an error, and gets its core type and flag bits</li><li><code>sem_validate_numeric</code> : verifies that the operand is a numeric type<ul><li>recall these are the math unary operators, so the operand must be numeric</li></ul></li><li><code>sem_combine_types</code> : creates the smallest type that holds two compatible types<ul><li>by combining with &quot;integer not null&quot; we ensure that the resulting type is at least as big as an integer</li><li>if the argument is of type <code>long</code> or <code>real</code> then it will be the bigger type and the resulting type will be <code>long</code> or <code>real</code> as appropriate</li><li>in short, <code>bool</code> is promoted to <code>int</code>, everything else stays the same</li><li><code>sem_combine_types</code> also combines the nullability and sensitivity appropriately</li></ul></li><li>a new <code>sem_node</code> of the combined type is created<ul><li>the type &quot;kind&quot; of the operand is preserved (e.g. the <code>meters</code> in <code>real&lt;meters&gt;</code>)</li><li>any column alias or variable name is not preserved, the value is now anonymous</li></ul></li></ul><p>These primitives are designed to combine well, for instance, consider <code>sem_unary_integer_math</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_unary_integer_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_unary_math(ast, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_reject_real(ast, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The steps are:</p><ul><li><code>sem_unary_math</code> : do the sequence we just discussed</li><li><code>sem_reject_real</code> : report/record an error if the result type is <code>real</code> otherwise do nothing</li></ul><p>Note that in all cases the <code>op</code> string simply gets pushed down to the place where the errors happen.  Let&#x27;s take a quick look at one of
the sources of errors in the above.  Here&#x27;s the numeric validator:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_validate_numeric(ast_node *ast, sem_t core_type, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_blob(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0045: blob operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0046: object operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_text(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0047: string operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>That function is pretty much dumb as rocks.  The non-numeric types are blob, object, and text.  There is a custom error for each type (it could have been shared
but specific error messages seem to help users.)  This code doesn&#x27;t know its context, but all it needs is <code>op</code> to tell it what the numeric-only
operator was and it can produce a nice error message.  It leaves an error in the AST using <code>record_error</code>. Its caller can then simply <code>return</code>
if anything goes wrong.</p><p>It&#x27;s not hard to guess how <code>sem_reject_real</code> works:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Some math operators like &lt;&lt; &gt;&gt; &amp; | % only make sense on integers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function does the extra checking to ensure they do not get real values</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// as arguments.  It&#x27;s a post-pass after the normal math checks.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_reject_real(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!is_error(ast)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_t core_type = core_type_of(ast-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (core_type == SEM_TYPE_REAL) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      report_error(ast, &quot;CQL0001: operands must be an integer type, not real&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>if the AST node isn&#x27;t already an error, and the node is of type &quot;real&quot;, report an error</li><li>it assumes the type is already known to be numeric</li><li>the pre-check for errors is to avoid double reporting; if something has already gone wrong, the core type will be <code>SEM_TYPE_ERROR</code><ul><li>no new error recording is needed in that case, as obviously an error was already recorded</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="binary-operators"></a>Binary Operators<a aria-hidden="true" tabindex="-1" class="hash-link" href="#binary-operators" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="binary-prep"></a>Binary Prep<a aria-hidden="true" tabindex="-1" class="hash-link" href="#binary-prep" title="Direct link to heading">#</a></h4><p>With the knowledge we have so far, this code pretty much speaks for itself, but we&#x27;ll walk through it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// All the binary ops do the same preparation -- they evaluate the left and the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// right expression, then they check those for errors.  Then they need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the types of those expressions and the combined_flags of the result.  This</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// does exactly that for its various callers.  Returns true if all is well.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_binary_prep(ast_node *ast, sem_t *core_type_left, sem_t *core_type_right, sem_t *combined_flags) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(left, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(right, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // left op right</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(left) || is_error(right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type_left = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type_right = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *combined_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type_left = core_type_of(left-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type_right = core_type_of(right-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *combined_flags = combine_flags(left-&gt;sem-&gt;sem_type, right-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type_left));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type_right));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_expr</code> : used to recursively walk the left and right nodes</li><li><code>is_error</code> : checks if either side had errors, and, if so, simply propagates the error</li><li>extract the left and right core types</li><li>combine nullability and sensitivity flags</li></ul><p>And that&#x27;s it!  These are the standard prep steps for all binary operators. With this done,
the caller has the core types of the left and right operands plus combined flags on a silver platter
and one check is needed to detect if anything went wrong.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-is-or-is-not"></a>Example: Is or Is Not<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-is-or-is-not" title="Direct link to heading">#</a></h4><p>This analyzer is the simplest of all the binaries</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// IS and IS NOT are special in that they return a not null boolean.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_binary_is_or_is_not(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type_left, core_type_right, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_binary_prep(ast, &amp;core_type_left, &amp;core_type_right, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the result of is or is not is always a bool and never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | sensitive_flag(combined_flags));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_binary_prep</code> : checks for errors in the left or right</li><li><code>sem_verify_compat</code> : ensures that left and right operands are type compatible (discussed later)</li><li>the result is always of type <code>bool not null</code></li></ul><p>If either step goes wrong the error will naturally propagate.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-binary-math"></a>Example: Binary Math<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-binary-math" title="Direct link to heading">#</a></h4><p>This is the general worker for binary math operations, the most common operations like &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27; and so forth.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// For all math operations, we combine the types and yield the type that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// holds both using the helper.  If any text, that&#x27;s an error.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_binary_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type_left, core_type_right, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_binary_prep(ast, &amp;core_type_left, &amp;core_type_right, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_object(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_blob_types(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_text_types(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type = sem_combine_types(core_type_left, core_type_right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kind = sem_combine_kinds(ast-&gt;right, ast-&gt;left-&gt;sem-&gt;kind);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(ast-&gt;right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(core_type | combined_flags);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;kind = kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s have a look at those steps:</p><ul><li><code>sem_binary_prep</code> : checks for errors on the left or right</li><li><code>error_any_object</code> : reports an error if the left or right is of type object</li><li><code>error_any_blob_types</code> : reports an error if the left or right is of type blob</li><li><code>error_any_text_types</code> : reports an error if the left or right is of type text</li><li><code>sem_combine_type</code> : computes the combined type, the smallest numeric type that holds both left and right<ul><li>note the operands are now known to be numeric</li><li>the three type error checkers give nice tight errors about the left or right operand</li></ul></li><li><code>sem_combine_kinds</code> : tries to create a single type <code>kind</code> for both operands<ul><li>if their <code>kind</code> is incompatible, records an error on the right</li></ul></li><li><code>new_sem</code> : creates a <code>sem_node</code> with the combined type, flags, and then the <code>kind</code> is set</li></ul><p>At this point it might help to look at a few more of the base validators -- they are rather unremarkable.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator-error_any_object"></a>Example Validator: error_any_object<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator-error_any_object" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If either of the types is an object, then produce an error on the ast.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t error_any_object(ast_node *ast, sem_t core_type_left, sem_t core_type_right, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type_left)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0002: left operand cannot be an object in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type_right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;right, &quot;CQL0003: right operand cannot be an object in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>is_object</code> : checks a <code>sem_type</code> against <code>SEM_TYPE_OBJECT</code><ul><li>if the left or right child is an object, an appropriate error is generated</li></ul></li><li>there is no strong convention for returning <code>true</code> if ok, or <code>true</code> if error; it&#x27;s pretty ad hoc<ul><li>this doesn&#x27;t seem to cause a lot of problems</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator-sem_combine_kinds"></a>Example Validator: sem_combine_kinds<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator-sem_combine_kinds" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we check that type&lt;Foo&gt; only combines with type&lt;Foo&gt; or type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is a current object type, then the next item must match</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is no such type, then an object type that arrives becomes the required type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if they ever don&#x27;t match, record an error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CSTR sem_combine_kinds_general(ast_node *ast, CSTR kleft, CSTR kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (kleft) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (strcmp(kleft, kright)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        CSTR errmsg = dup_printf(&quot;CQL0070: expressions of different kinds can&#x27;t be mixed: &#x27;%s&#x27; vs. &#x27;%s&#x27;&quot;, kright, kleft);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        report_error(ast, errmsg, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return kright;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return kleft;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// helper to crack the ast nodes first and then call the normal comparisons</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CSTR sem_combine_kinds(ast_node *ast, CSTR kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kleft = ast-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_combine_kinds_general(ast, kleft, kright);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_combine_kinds</code> : uses the worker <code>sem_combine_kinds_general</code> after extracting the <code>kind</code> from the left node<ul><li>usually you already have one <code>kind</code> and you want to know if another <code>kind</code> is compatible, hence this helper</li></ul></li><li><code>sem_combine_kinds_general</code> : applies the general rules for &quot;kind&quot; strings:<ul><li>NULL + NULL =&gt; NULL</li><li>NULL + x  =&gt; x</li><li>x + NULL =&gt; x</li><li>x + x =&gt; x</li><li>x + y =&gt; error (if x != y)</li></ul></li><li>this is one of the rare functions that creates a dynamic error message</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--is_numeric_compat"></a>Example Validator : is_numeric_compat<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--is_numeric_compat" title="Direct link to heading">#</a></h4><p>This helper is frequently called several times in the course of other semantic checks.
This one produces no errors, that&#x27;s up to the caller. Often there is a numeric path
and a non-numeric path so this helper can&#x27;t create the errors as it doesn&#x27;t yet know
if anything bad has happened.  Most of the <code>is_something</code> functions are the same way.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport bool_t is_numeric_compat(sem_t sem_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_type = core_type_of(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_type &gt;= SEM_TYPE_NULL &amp;&amp; sem_type &lt;= SEM_TYPE_REAL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>is_numeric_compat</code> operates by checking the core type for the numeric range.
Note that <code>NULL</code> is compatible with numerics because expressions like <code>NULL + 2</code>
have meaning in SQL.  The type of that expression is nullable integer and
the result is <code>NULL</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--sem_combine_types"></a>Example Validator : sem_combine_types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--sem_combine_types" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The second workhorse of semantic analysis, given two types that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// are previously known to be compatible, it returns the smallest type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// that holds both.  If either is nullable, the result is nullable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note: in the few cases where that isn&#x27;t true, the normal algorithm for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// nullability result must be overridden (see coalesce, for instance).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static sem_t sem_combine_types(sem_t sem_type_1, sem_t sem_type_2) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... too much code ... summary below</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This beast is rather lengthy but unremarkable. It follows these rules:</p><ul><li>text is only compatible with text</li><li>object is only compatible with object</li><li>blob is only compatible with blob</li><li>numerics are only compatible with other numerics and NULL<ul><li>NULL promotes the other operand, whatever it is (might still be NULL)</li><li>bool promotes to integer if needed</li><li>integer promotes to long integer if needed</li><li>long integer promotes to real if needed</li><li>the combined type is the smallest numeric type that holds left and right according to the above rules</li></ul></li></ul><p>Some examples might be helpful:</p><ul><li>1 + 2L  -&gt;  long</li><li>false + 3.1 -&gt; real</li><li>2L + 3.1 -&gt; real</li><li>true + 2 -&gt; integer</li><li>&#x27;x&#x27; + 1 -&gt; not compatible</li></ul><p>Note that <code>sem_combine_types</code> assumes the types have already been checked for compatibility and will use <code>Contract</code> to enforce
this.  You should be using other helpers like <code>is_numeric_compat</code> and friends to ensure the types agree before computing
the combined type.  A list of values that must be compatible with each other (e.g. in <code>needle IN (haystack)</code>) can be
checked using <code>sem_verify_compat</code> repeatedly.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--sem_verify_assignment"></a>Example Validator : sem_verify_assignment<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--sem_verify_assignment" title="Direct link to heading">#</a></h4><p>The <code>sem_verify_assignment</code> function is used any time there is something like a logical <code>assignment</code> going on.  There are
two important cases:</p><ul><li><code>SET x := y</code> : an actual assignment</li><li><code>call foo(x)</code> : the expression <code>x</code> must be &quot;assignable&quot; to the formal variable for the argument of <code>foo</code></li></ul><p>This is a lot like normal binary operator compatibility with one extra rule: the source expression must
not be a bigger type than the target.  e.g. you cannot assign a <code>long</code> to an <code>integer</code>, nor pass a long
expression to a function that has an integer parameter.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This verifies that the types are compatible and that it&#x27;s ok to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the expression to the variable.  In practice that means:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable type core type and kind must be compatible with the expression core type and kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable must be nullable if the expression is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable must be sensitive if the assignment is sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable type must be bigger than the expression type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here ast is used only to give a place to put any errors.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_verify_assignment(ast_node *ast, sem_t sem_type_needed, sem_t sem_type_found, CSTR var_name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_compat(ast, sem_type_needed, sem_type_found, var_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_safeassign(ast, sem_type_needed, sem_type_found, var_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type_found) &amp;&amp; is_not_nullable(sem_type_needed)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0013: cannot assign/copy possibly null expression to not null target&quot;, var_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (sensitive_flag(sem_type_found) &amp;&amp; !sensitive_flag(sem_type_needed)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0014: cannot assign/copy sensitive expression to non-sensitive target&quot;, var_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_verify_compat</code> : checks for standard type compatibility between the left and the right</li><li><code>sem_verify_safeassign</code> : checks that if the types are different the right operand is the smaller of the two</li><li>nullability checks ensure you aren&#x27;t trying to assign a nullable value to a not null variable</li><li>sensitivity checks ensure you aren&#x27;t trying to assign a sensitive value to a not sensitive variable</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="simple-statement-validation"></a>Simple Statement Validation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#simple-statement-validation" title="Direct link to heading">#</a></h3><p>With the expression building blocks, most of the usual kind of language statements become quite simple to check
for correctness.  It&#x27;s probably easiest to illustrate this with an example. Let&#x27;s look at validation for
the <code>WHILE</code> statement:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// While semantic analysis is super simple.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the condition must be numeric</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the statement list must be error-free</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * loop_depth is increased allowing the use of interior leave/continue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_numeric_expr(expr, ast, &quot;WHILE&quot;, SEM_EXPR_CONTEXT_NONE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (stmt_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loop_depth++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loop_depth--;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_error(stmt_list)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>EXTRACT*</code> : pulls out the tree parts we need</li><li><code>sem_numeric_expr</code> : verifies the loop expression is numeric</li><li><code>sem_stmt_list</code> : recursively validates the body of the loop</li></ul><p>Note: the while expression is one of the loop constructs which means that <code>LEAVE</code> and <code>CONTINUE</code> are legal inside it.
The <code>loop_depth</code> global tracks the fact that we are in a loop so that analysis for <code>LEAVE</code> and <code>CONTINUE</code> can report errors if we are not.</p><p>It&#x27;s not hard to imagine that <code>sem_stmt_list</code> will basically walk the AST, pulling out statements and dispatching them using the <code>STMT_INIT</code> tables previously discussed.
You might land right back in <code>sem_while_stmt</code> for a nested <code>WHILE</code> -- it&#x27;s turtles all the way down.</p><p>If <code>SEM_EXPR_CONTEXT_NONE</code> is a mystery, don&#x27;t worry, it&#x27;s covered in the next section.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-contexts"></a>Expression Contexts<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-contexts" title="Direct link to heading">#</a></h3><p>It turns out that in the SQL language some expression types are only valid in some parts of a SQL statement (e.g. aggregate functions can&#x27;t appear in a <code>LIMIT</code> clause) and so there is always a context for any numeric expression.  When a new root expression is being evaluated, it sets the expression context per the caller&#x27;s specification.</p><p>The expression contexts are as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_NONE           0x0001</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WHERE          0x0004</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_ON             0x0008</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_HAVING         0x0010</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_LIMIT          0x0080</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_OFFSET         0x0100</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_TABLE_FUNC     0x0200</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WINDOW         0x0400</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000</span></div></div></div></div></div><p>The idea here is simple: when calling a root expression, the analyzer provides the context value that has the bit that corresponds to the current context.
For instance, the expression being validated in is the <code>WHERE</code> clause -- the code will provide <code>SEM_EXPR_CONTEXT_WHERE</code>.
The inner validators check this context, in particular anything that is only available in some contexts has a bit-mask of that is the union
of the context bits where it can be used.  The validator can check those possibilities against the current context with one bitwise &quot;and&quot; operation.
A zero result indicates that the operation is not valid in the current context.</p><p>This bitwise &quot;and&quot; is performed by one of these two helper macros which makes the usage a little clearer:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context &amp; (x)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context &amp; (x)))</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-context-example--concat"></a>Expression Context Example : Concat<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-context-example--concat" title="Direct link to heading">#</a></h4><p>The concatenation operator <code>||</code> is challenging to successfully emulate because it does many different kinds of
numeric to string conversions automatically.  Rather than perennially getting this wrong, we simply do not support
this operator in a context where SQLite isn&#x27;t going to be doing the concatenation.  So typically users
use &quot;printf&quot; instead to get formatting done outside of a SQL context.  The check for invalid use of <code>||</code> is very simple
and it happens, of course, in <code>sem_concat</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0241: CONCAT may only appear in the context of a SQL statement&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-context-example--in"></a>Expression Context Example : IN<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-context-example--in" title="Direct link to heading">#</a></h4><p>A slightly more complex example happens processing the <code>IN</code> operator.  This operator has two forms:
the form with an expression list, which can be used anywhere, and the form with a <code>SELECT</code> statement.
The latter form can only appear in some sections of SQL, and not at all in loose expressions.  For
instance, that form may not appear in the <code>LIMIT</code> or <code>OFFSET</code> sections of a SQLite statement.</p><p>We use this construct to do the validation:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    uint32_t valid = SEM_EXPR_CONTEXT_SELECT_LIST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_WHERE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_ON</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_HAVING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_TABLE_FUNC;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (CURRENT_EXPR_CONTEXT_IS_NOT(valid)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      report_error( ast, &quot;CQL0078: [not] in (select ...) is only allowed inside &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         &quot;of select lists, where, on, and having clauses&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>If the reader is interested in a simple learning exercise, run down the purpose of <code>SEM_EXPR_CONTEXT_TABLE_FUNC</code> -- it&#x27;s simple,
but important, and it only has one use case so it&#x27;s easy to find.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="name-resolution"></a>Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#name-resolution" title="Direct link to heading">#</a></h3><p>We&#x27;ve gotten pretty far without talking about the elephant in the room: name resolution.</p><p>Like SQL, many statements in CQL have names in positions where the type of the name is completely unambiguous.  For instance
nobody could be confused what sort of symbol <code>Foo</code> is in <code>DROP INDEX Foo</code>.</p><p>This type, with a clear name category, is the easiest name resolutions, and there are a lot in this form.  Let&#x27;s do an example.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-index-name-resolution"></a>Example: Index Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-index-name-resolution" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the basic checking for the drop index statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the index must exist (have been declared) in some version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * it could be deleted now, that&#x27;s ok, but the name has to be valid</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_drop_index_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_drop_index_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *index_ast = find_usable_index(name, name_ast,  &quot;CQL0112: index in drop statement was not declared&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!index_ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Well, this is interesting.  But what&#x27;s going on with <code>find_usable_index</code>? What is usable?  Why aren&#x27;t we just looking up the index
name in some name table? Let&#x27;s have a look at the details of <code>find_usable_index</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// returns the node only if it exists and is not restricted by the schema region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static ast_node *find_usable_index(CSTR name, ast_node *err_target, CSTR msg) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *index_ast = find_index(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!index_ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(err_target, msg, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_validate_object_ast_in_current_region(name, index_ast, err_target, msg)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return index_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We haven&#x27;t discussed schema regions yet but what you need to know about them for now is this:</p><ul><li>any object can be in a region.</li><li>a region may depend on other regions</li></ul><p>If an object is in a region, then it may only use schema parts that are in
the same region, or the region&#x27;s dependencies (transitively).</p><p>The point of this is that you might have a rather large schema and you probably don&#x27;t want any piece
of code to use just any piece of schema.  You can use regions to ensure that the code for feature &quot;X&quot; doesn&#x27;t
try to use schema designed exclusively for feature &quot;Y&quot;.  That &quot;X&quot; code probably has no business even
knowing of the existence of &quot;Y&quot; schema.</p><p>So now <code>usable</code> simply means this:</p><ul><li><code>find_index</code> can find the name in the symbol table for indices</li><li>the found index is accessible in the current region</li></ul><p>If we had used an example that was looking up a table name, the same region considerations would apply,
however, additionally tables can be deprecated with <code>@delete</code> so there would be additional checks to make
sure we&#x27;re talking about a live table and not a table&#x27;s tombstone.</p><p>In short, these simple cases just require looking up the entity and verifying that it&#x27;s accessible in the current context.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flexible-name-resolution"></a>Flexible Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flexible-name-resolution" title="Direct link to heading">#</a></h4><p>The &quot;hard case&quot; for name resolution is where the name is occurring in an expression.  Such a name can refer to
all manner of things. It could be a global variable, a local variable, an argument, a table column, a field in a cursor,
and others.  The general name resolver goes through several phases looking for the name.  Each phase can either report
an affirmative success or error (in which case the search stops), or it may simply report that the name was not found
but the search should continue.</p><p>We can demystify this a bit by looking at the most common way to get name resolution done.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Resolves a (potentially qualified) identifier, writing semantic information</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// into `ast` if successful, or reporting and recording an error for `ast` if</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// not.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_resolve_id(ast_node *ast, CSTR name, CSTR scope) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_id(ast) || is_ast_dot(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We have no use for `type` and simply throw it away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *type = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_resolve_id_with_type(ast, name, scope, &amp;type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The name resolver works on either a vanilla name (e.g. <code>x</code>) or a scoped name (e.g. <code>T1.x</code>).  The name and scope are provided.
The <code>ast</code> parameter is used only as a place to report errors; there is no further cracking of the AST needed to resolve
the name.  As you can see <code>sem_resolve_id</code> just calls the more general function <code>sem_resolve_id_with_type</code> and is used
in the most common case where you don&#x27;t need to be able to mutate the semantic type info for the identifier.  That&#x27;s the 99% case.</p><p>So let&#x27;s move on to the &quot;real&quot; resolver.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function is responsible for resolving both unqualified identifiers (ids)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and qualified identifiers (dots). It performs the following two roles:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// - If an optional `ast` is provided, it works the same way most semantic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   analysis functions work: semantic information will be written into the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   ast, errors will be reported to the user, and errors will be recorded in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   the AST.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// - `*type_ptr` will be set to mutable type (`sem_t *`) in the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   environment if the identifier successfully resolves to a type. (There are,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   unfortunately, a few exceptions in which a type will be successfully</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   resolved and yet `*type_ptr` will not be set. These include when a cursor is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   in an expression position, when the expression is `rowid` (or similar), and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   when the id resolves to an enum case. The reason no mutable type is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   returned in these cases is that a new type is allocated as part of semantic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   analysis, and there exists no single, stable type in the environment to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   which a pointer could be returned. This is a limitation of this function,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   albeit one that&#x27;s currently not problematic.)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  Resolution is attempted in the order that the `sem_try_resolve_*` functions</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  appear in the `resolver` array. Each takes the same arguments: An (optional)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  identifier provided to one of these resolvers is resolved successfully, *or*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  if the correct resolver was found but there was an error in the program,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  `SEM_RESOLVE_STOP` is returned and resolution is complete, successful or not.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  If a resolver is tried and it determines that it is not the correct resolver</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned and the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  next resolver is tried.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function should not be called directly. If one is interested in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// performing semantic analysis, call `sem_resolve_id` (or, if within an</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expression, `sem_resolve_id_expr`.) Alternatively, if one wants to get a</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// mutable type from the environment, call `find_mutable_type`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_resolve_id_with_type(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(type_ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *type_ptr = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_resolve (*resolver[])(ast_node *ast, CSTR, CSTR, sem_t **) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_arguments,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_column,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_rowid,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_cursor_as_expression,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_variable,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_enum,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_cursor_field,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_arg_bundle,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (uint32_t i = 0; i &lt; sizeof(resolver) / sizeof(void *); i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (resolver[i](ast, name, scope, type_ptr) == SEM_RESOLVE_STOP) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  report_resolve_error(ast, &quot;CQL0069: name not found&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_resolve_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This function is well described in its own comments.  We can easily see the &quot;mini-resolvers&quot;
which attempt to find the name in order:</p><ul><li><code>sem_try_resolve_arguments</code> : an argument in the argument list</li><li><code>sem_try_resolve_column</code> : a column name (possibly scoped)</li><li><code>sem_try_resolve_rowid</code> : the virtual rowid column (possibly scoped)</li><li><code>sem_try_resolve_cursor_as_expression</code> : use of a cursor as a boolean -- the bool is true if the cursor has data</li><li><code>sem_try_resolve_variable</code> : local or global variables</li><li><code>sem_try_resolve_enum</code> : the constant value of an enum (must be scoped)</li><li><code>sem_try_resolve_cursor_field</code> : a field in a cursor (must be scoped)</li><li><code>sem_try_resolve_arg_bundle</code> : a field in an argument bundle (must be scoped)</li></ul><p>These all use this enum to communicate progress:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indicate that the correct resolver was found. Continuing implies that no</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// failure has (yet) occurred, but stopping implies neither success nor failure.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef enum {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SEM_RESOLVE_CONTINUE = 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SEM_RESOLVE_STOP = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_resolve;</span></div></div></div></div></div><p>Each of these mini-resolvers will have a series of rules, for example <code>sem_try_resolve_cursor_field</code> is going to have to do
something like this:</p><ul><li>if there is no scope, it can&#x27;t be a cursor field, return <code>CONTINUE</code></li><li>if the scope is not the name of a cursor, return <code>CONTINUE</code></li><li>if the name is a field in the cursor, return <code>STOP</code> with success</li><li>else, report that the name is not a valid member of the cursor, and return <code>STOP</code> with an error</li></ul><p>All the mini-resolvers are similarly structured, generically:</p><ul><li>if it&#x27;s not my case, return <code>CONTINUE</code></li><li>if it is my case return <code>STOP</code> (maybe with an error)</li></ul><p>Some of the mini-resolvers have quite a few steps, but any one mini-resolver is only about a screenful of code
and it does one job.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flow-analysis"></a>Flow Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flow-analysis" title="Direct link to heading">#</a></h3><p>CQL implements a basic form of control flow analysis in &quot;flow.c&quot;. The header
&quot;flow.h&quot; exposes a small set of primitives used by &quot;sem.c&quot; during semantic
analysis.</p><p>Flow analysis in CQL involves two important concepts: <strong>flow contexts</strong> and
<strong>improvements</strong>. These are rather entangled concepts â€” one is useless without the
other â€” and so the approach to describing them here will alternate between giving
a bit of background on one and then the other, with a greater level of detail
about the specific types of improvements being supplied later on.</p><p>A flow context is used, in essence, to create a boundary around a portion of a
user&#x27;s program. At the moment, there are four types of contexts.</p><p>The first type of context is called, rather boringly, a <strong>normal</strong> context.
Normal contexts are used for portions of a user&#x27;s code that may be entered
conditionally. A good example of this is in <code>SELECT</code> expressions: When a <code>WHERE</code>
clause is present, the expression list is only evaluated when the <code>WHERE</code> clause
is true. If we look at <code>sem_select_expr_list_con</code>, we can get an idea of how
this works in terms of flow contexts:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_expr_list_con</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Analyze the FROM portion (if it exists).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_from</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_from_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">is_error</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_from_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Push a flow context to contain improvements made via the WHERE clause that</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// will be in effect for the SELECT expression list.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_NORMAL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain">error</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_sensitive </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_where_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_from_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">where_expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain">error</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_expr_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_expr_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_NORMAL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>While very much simplified above, it can be seen that the steps are essentially
as follows:</p><ol><li>Analyze the <code>FROM</code> clause.</li><li>Push a new normal context.</li><li>Analyze the <code>WHERE</code> clause.</li><li>Set improvements given the <code>WHERE</code> clause (ultimately by calling
<code>flow_set_flag_for_type</code>); we&#x27;ll come back to this part shortly.</li><li>Analyze the expression list with the improvements from the <code>WHERE</code> in effect.</li><li>Pop the context, un-setting the improvements from the <code>WHERE</code>.</li></ol><p>This, of course, only begins to make sense once one understands what we mean by
improvements.</p><p>CQL, at the moment, supports two forms of improvements: nullability improvements
and initialization improvements. Both of these will be discussed in more detail
later, but the basic idea is that an improvement upgrades the type of some value
within a particular flow context. For example, in the expression <code>SELECT x + x
FROM t WHERE x IS NOT NULL</code>, we can reason that <code>x + x</code> can safely be given a
nonnull type because of the <code>WHERE</code> clause. This is exactly what we do in
<code>sem_select_expr_list_con</code>: We make a context to hold the improvements that may
come from the <code>WHERE</code>, analyze the <code>WHERE</code>, set the appropriate improvements
given the <code>WHERE</code>, analyze the expression list, and then pop the context to
unset the improvements (as they must not affect any enclosing expressions).</p><p>In addition to normal contexts, there are also <strong>branch contexts</strong> and <strong>branch
group contexts</strong>. These two context types are designed to work together for
handling <code>IF</code>, <code>CASE</code>, <code>IIF</code>, <code>SWITCH</code>, et cetera.</p><p>Like normal contexts, branch contexts assume that they are entered when some
condition is true. The difference is that branch contexts lie within a branch
group context, and branch groups know that <em>at most</em> one branch of a given set
of branches will be entered. A great example of this can be found in
<code>sem_if_stmt</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_if_stmt</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Each branch gets its own flow context in `sem_cond_action` where its</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// condition is known to be true. We also create one more context for the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// entire set of branches. In addition to grouping the branches together, this</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// outer context holds all of the negative improvements that result from the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// knowledge that, if a given branch&#x27;s statements are being evaluated, all</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// previous branches&#x27; conditions must have been false.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_BRANCH_GROUP</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// IF [cond_action]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_cond_action</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">cond_action</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elseif</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_elseif_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elseif</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elsenode</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// ELSE [stmt_list]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">flow_set_context_branch_group_covers_all_cases</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">true</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">EXTRACT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> elsenode</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">sem_stmt_list_in_current_flow_context</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">flow_context_branch_group_add_empty_branch</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">record_ok</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elsenode</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_BRANCH_GROUP</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>It&#x27;s instructive to look at <code>sem_cond_action</code> as well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_cond_action</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// [expr] THEN stmt_list</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Add improvements for `stmt_list` where `expr` must be true.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_stmt_list_in_current_flow_context</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">flow_context_branch_group_add_empty_branch</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// If a later branch will be taken, `expr` must be false. Add its negative</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements to the context created in `sem_if_stmt` so that all later</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// branches will be improved by the OR-linked spine of IS NULL checks in</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `expr`.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_false_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>Putting all of this together, we can see that the basic steps for analyzing an
<code>IF</code> statement are as follows:</p><ol><li>Push a new branch group context to hold all of the branch contexts that are
to come.</li><li>Analyze the condition in the <code>IF condition THEN</code> portion of the statement.</li><li>Push a new branch context to hold the nullability improvements from the
condition (e.g., in <code>IF x IS NOT NULL THEN</code>, we can improve <code>x</code> to have a
nonnull type in the statement list after the <code>THEN</code>).</li><li>Set the improvements.</li><li>Anaylze the statement list after the <code>THEN</code>.</li><li>Pop the branch context.</li><li>Set the <em>negative</em> improvements resulting from the knowledge that <code>condition</code><em>must have been false</em> if the previous branch wasn&#x27;t entered (e.g., in <code>IF y
IS NULL THEN</code>, we know that <code>y</code> must be nonnull from just after the end of
the branch until the end of the current branch group).</li><li>Repeat for the <code>ELSE IF</code> and <code>ELSE</code> branches (if any).</li><li>Pop the branch group context.</li></ol><p>What makes all of this work are the following:</p><ul><li><p>When a branch context is popped, it <em>resets all improvements</em> such that they
become exactly what they were before the branch was analyzed. This is done to
reflect the fact that, because at most one branch will be entered, neither
adding improvements (via <code>flow_set_flag_for_type</code>) nor removing existing
improvements (via <code>flow_unset_flag_for_type</code>) in a branch should affect any of
the other branches in the group.</p></li><li><p>When a branch group context is popped, it <em>merges</em> the effects of all of its
branches. This is a key step that allows CQL to retain an improvement after a
branch group is popped whenever the same improvement is made within every one
of its branches <em>and</em> when the branches given cover all possible cases (which
is indicated by the call to <code>flow_set_context_branch_group_covers_all_cases</code>
in the code above).</p></li></ul><p>The final type of context is called a <strong>jump context</strong>. Jump contexts are a
maximally pessimistic form of context that assume every improvement that might
be unset within them will be unset and that every improvement that might be set
within them will not be set. Jump contexts are used to make semantic analysis
safe in the possible presence of control flow statements like <code>CONTINUE</code>,
<code>LEAVE</code>, and <code>THROW</code>, and so jump contexts are used for the analysis of
statements like <code>LOOP</code>, <code>WHILE</code>, and <code>TRY</code>. Take the following line-numbered
code as an example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token number" style="color:rgb(247, 140, 108)">001</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> x </span><span class="token keyword" style="font-style:italic">TEXT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">002</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;foo&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">003</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">WHILE</span><span class="token plain"> some_condition</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">004</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">005</span><span class="token plain">    </span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> another_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">006</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">007</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> yet_another_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">008</span><span class="token plain">        </span><span class="token keyword" style="font-style:italic">LEAVE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">009</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">010</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;bar&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">011</span><span class="token plain">    </span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">012</span><span class="token plain">      </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- do nothing</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">013</span><span class="token plain">    </span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">014</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">END</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">015</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">CALL</span><span class="token plain"> requires_text_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Here, even though the outer <code>IF</code> makes no change overall to the nullability
improvement to <code>x</code> from line 2 -- it unsets it on line 6 and then re-sets it on
line 10 and the <code>ELSE</code> does nothingâ€”there is no guarantee that line 10 will ever
be evaluated because we may jump straight from line 8 to line 15. As a result,
it is necessary that <code>x</code> be un-improved after the <code>WHILE</code> loop; a normal context
would not accomplish this, but a jump context does. See the comments within
<code>_flow_push_context_branch</code> for additional discussion.</p><p>While jump contexts are necessary for the safety of improvements in the presence
of loops, they are not sufficient: It&#x27;s actually necessary to analyze loops
<em>twice</em>. This is because execution of a loop might repeat, and so a statement
that results in the unsetting of an improvement later in a loop must affect
improvements earlier in that loop. For example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> x </span><span class="token keyword" style="font-style:italic">INT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">WHILE</span><span class="token plain"> some_condition</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- okay on the first analysis pass, but not the second</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">CALL</span><span class="token plain"> requires_int_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- must negatively affect the call on the line above</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Semantic analysis keeps track of whether or not it is currently reanalyzing the
statement list of a loop via the <code>current_loop_analysis_state</code> variable:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// The analysis of loops like LOOP and WHILE is done in two passes. First, we</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// analyze the loop to conservatively figure out every improvement that the loop</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// could possibly unset. After that, we reanalyze it with said improvements</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// unset to ensure that everything is safe. See `sem_stmt_list_within_loop` for</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// more information on why this is necessary.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">typedef</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">enum</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP_ANALYSIS_STATE_NONE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP_ANALYSIS_STATE_ANALYZE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP_ANALYSIS_STATE_REANALYZE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> loop_analysis_state</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Keeps tracks of the current loop analysis state. If this is equal to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `LOOP_ANALYSIS_STATE_ANALYZE`, we are analyzing with a non-final set of</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements. This is useful for two reasons:</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 1. Procedures that perform rewrites based on improvements (e.g.,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    `sem_resolve_id_expr`) can use this to verify whether a rewrite is safe to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    perform (`LOOP_ANALYSIS_STATE_NONE` or `LOOP_ANALYSIS_STATE_REANALYZE`) or</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    whether they should wait because they do not yet have definitive</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    information (`LOOP_ANALYSIS_STATE_ANALYZE`).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 2. Analyses that would otherwise fail if called during reanalysis (e.g.,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    `sem_verify_legal_variable_name`) can use this to check whether the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    current state is `LOOP_ANALYSIS_STATE_REANALYZE` and adjust their</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    behaviors accordingly.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> loop_analysis_state current_loop_analysis_state </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> LOOP_ANALYSIS_STATE_NONE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>As indicated in the first comment above, the comments within
<code>sem_stmt_list_within_loop</code> go into further detail.</p><p>At this point, we&#x27;ve only scratched the surface of control flow analysis in CQL.
Fortunately, the files &quot;flow.h&quot; and &quot;flow.c&quot; are heavily commented and can be
studied to deepen one&#x27;s understanding.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nullability-improvements"></a>Nullability Improvements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nullability-improvements" title="Direct link to heading">#</a></h3><p>Via a form of occurrence typing (also known as flow typing), CQL has the ability
to determine that, due to a prior conditional check, a nullable variable or
cursor field cannot be null within a particular context, and CQL will improve
its type in that context.</p><p>Unlike most forms of semantic analysis performed by CQL, the analysis for
nullability improvements, as is the case for all types of improvements, makes
heavy use of the <code>find_mutable_type</code> function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Returns the *mutable* type (`sem_t *`) for a given (potentially qualified)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// identifier if one exists in the environment. See the documentation for</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `sem_resolve_id_with_type` for limitations.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">sem_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token function" style="color:rgb(130, 170, 255)">find_mutable_type</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>This function allows us to look up the type of the original binding referred to
by a particular name/scope pair. In essence, it provides access to the current
type environment for whichever part of the program we are analyzing. It also
allows us to mutate that environment by virtue of the fact that it returns a
pointer to the type of the binding, not merely the type itself.</p><p>By using <code>find_mutable_type</code> to get a type pointer and toggling the
<code>SEM_TYPE_INFERRED_NOTNULL</code> flag via <code>flow_set_flag_for_type</code> and
<code>flow_unset_flag_for_type</code>, the procedures <code>sem_set_notnull_improved</code> and
<code>sem_unset_notnull_improved</code> are able to record that a nullable identifier or
cursor field is either temporarily nonnull or no longer nonnull respectively:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Enables a nonnull improvement, if possible.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// This needs to be called for everything that is no longer safe to consider NOT</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL due to a mutation. It is fine to call this for something not currently</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// subject to improvement, but it must only be called with a name/scope pair</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// referring to something that has a mutable type (e.g., it must not be an unbound</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// variable, a cursor used as an expression, an enum case, et cetera).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_unset_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Similarly, <code>sem_is_notnull_improved</code> uses <code>find_mutable_type</code> to check whether
or not something is currently improved:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Returns true if currently improved to be nonnull, else false.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_is_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Why does nullability inference use this approach? The reason is that the
alternative would be maintaining some sort of set of currently improved
identifiers and cursor fields and checking it whenever resolving an identifier
or cursor field. The problem would be that merely knowing that some identifier
&quot;x&quot; is improved would not be sufficient, however: We&#x27;d have to know <em>which</em> &quot;x&quot;.
Is it the local variable &quot;x&quot;? Is it the column &quot;x&quot; of the table from which we&#x27;re
currently selecting?  In essence, correctly maintaining an independent set of
all currently active improvements would involve re-implementing all of the
scoping rules of the language. By using <code>find_mutable_type</code>, we can simply
piggyback on the existing name resolution logic and avoid all of these issues.</p><p>A nullability improvement is always created within a particular flow context.
When an improvement is added via <code>sem_set_notnull_improved</code>, a record of that
improvement is recorded in the current context. When that context ends, that
same record is used to remove the improvement. It is also the case that
<code>sem_unset_notnull_improved</code> may be used to remove an improvement before a
context has ended due to a <code>SET</code>, <code>FETCH</code>, or call to a procedure or function
with an <code>OUT</code> argument resulting in the improvement no longer being safe.</p><p>Improvements can be introduced into the current context via
<code>sem_set_notnull_improved</code> directly (when a variable is <code>SET</code> to a value of a
nonnull type), but more commonly they are introduced via one of the following
two functions:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Given a conditional expression `ast` possibly containing AND-linked</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// subexpressions, set all of the applicable nullability and has-row</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements within the current flow context. Generally speaking, calls to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// this function should be bounded by a new flow context corresponding to the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// portion of the program for which the condition `ast` must be be true.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Improvements for known-false conditions are dual to improvements for</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// known-true conditions.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// For nullability, known-false conditions improve ids and dots verified to be</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL via `IS NULL` along the outermost spine of `OR` expressions, whereas</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// known-true conditions improve ids and dots verified to be nonnull via `IS NOT</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL` along the outermost spine of `AND` expressions. For example, the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// following two statements introduce the same improvements:</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   IF a IS NOT NULL AND b IS NOT NULL THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//     -- `a` and `b` are improved here because we know the condition is true</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   END IF;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   IF a IS NULL OR b IS NULL RETURN;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   -- `a` and `b` are improved here because we know the condition is false</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   -- since we must not have returned if we got this far</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// ...</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_false_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>These functions introduce improvements by gathering up all of the <code>IS NOT NULL</code>
checks (in the true case) or <code>IS NULL</code> checks (in the false case) and
introducing improvements appropriately. The true version is used when we enter a
context that will only be evaluated at runtime when some particular condition is
true; the false version, conversely, is used when we enter a context that will
only be evaluated at runtime when some particular condition is false:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> some_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- &quot;true&quot; improvements from `some_condition` are in</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- effect here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> another_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- &quot;false&quot; improvements from `some_condition` and true</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- improvements from `another_condition` are in effect</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- &quot;false&quot; improvements from both `some_condition` and</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `another_condition` are in effect here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Global variables in CQL require special treatment when it comes to nullability
improvements. This is because any procedure call could potentially mutate any
number of global variables, and so all currently improved globals must be
un-improved at every such call. The following list keeps track of which global
variables are currently improved:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">typedef</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">global_notnull_improvement_item</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token class-name" style="color:rgb(255, 203, 107)">sem_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">type</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">global_notnull_improvement_item</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">next</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> global_notnull_improvement_item</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Keeps track of all global variables that may currently be improved to be NOT</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL. We need this because we must un-improve all such variables after every</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// procedure call (because we don&#x27;t do interprocedural analysis and cannot know</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// which globals may have been set to NULL).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> global_notnull_improvement_item </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">global_notnull_improvements</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>The fact that we don&#x27;t do interprocedural analysis (as the comment above
indicates) is not a deficiency. Programmers should be able to reason locally
about nullability improvements, and an analysis that depended upon the details
of how other procedures were implemented would make that impossible.</p><p>So far, we have talked a lot about how improvements are set and unset, but we
haven&#x27;t talked about how the improvement actually happens in terms of code
generation. Since CQL represents values of nullable and nonnull types
differently (at least in the case of non-reference types), we cannot simply
treat a value of a nullable type as though it were of a nonnull type: We need to
actually change its representation.</p><p>The way this works is that, whenever we resolve a name/scope pair via
<code>sem_resolve_id_expr</code>, we check whether the pair is currently improved via
<code>sem_is_notnull_improved</code>. If it is, we call <code>rewrite_nullable_to_notnull</code> to
wrap the id or dot we&#x27;re resolving with a call to the function
<code>cql_inferred_notnull</code> (for which we generate code in
<code>cg_func_cql_inferred_notnull</code>):</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Wraps an id or dot in a call to cql_inferred_notnull.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">rewrite_nullable_to_unsafe_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">_Nonnull ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// The `cql_inferred_notnull` function is not used by the programmer directly,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// but rather inserted via a rewrite during semantic analysis to coerce a value</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// of a nullable type to be nonnull. The reason for this approach, as opposed to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// just changing the type directly, is that there are also representational</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// differences between values of nullable and nonnull types; some conversion is</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// required.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">cg_func_cql_inferred_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">call_ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> charbuf </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">is_null</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> charbuf </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">value</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>As the comment for <code>cg_func_cql_inferred_notnull</code> indicates, programmers do not
use <code>cql_inferred_notnull</code> directly: It is only inserted as a product of the
above-mentioned rewrite. In fact, we explicitly disallow its use by programmers
in the parser:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// We insert calls to `cql_inferred_notnull` as part of a rewrite so we expect</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// to see it during semantic analysis, but it cannot be allowed to appear in a</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// program. It would be unsafe if it could: It coerces a value from a nullable</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// type to a nonnull type without any runtime check.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">define</span><span class="token macro property"> </span><span class="token macro property macro-name function" style="color:rgb(130, 170, 255)">YY_ERROR_ON_CQL_INFERRED_NOTNULL</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression">x</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">  </span><span class="token macro property expression function" style="color:rgb(130, 170, 255)">EXTRACT_STRING</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression">proc_name</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token macro property expression"> x</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">  </span><span class="token macro property expression keyword" style="font-style:italic">if</span><span class="token macro property expression"> </span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression operator" style="color:rgb(137, 221, 255)">!</span><span class="token macro property expression function" style="color:rgb(130, 170, 255)">strcmp</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression">proc_name</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token macro property expression"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&quot;cql_inferred_notnull&quot;</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression"> </span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">    </span><span class="token macro property expression function" style="color:rgb(130, 170, 255)">yyerror</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property string" style="color:rgb(195, 232, 141)">&quot;Call to internal function is not allowed &#x27;cql_inferred_notnull&#x27;&quot;</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">  </span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>One subtle aspect of the rewrite is that the rewrite itself performs analysis to
validate the product of the rewrite (as do other many other rewrites). To avoid
going into a loop of rewriting, analyzing the result (which ultimately happens
in <code>sem_special_func_cql_inferred_notnull</code>), rewriting again because the result
contains a name that is improved, et cetera, we keep track of whether or not
we&#x27;re currently analyzing a subexpression under a call to <code>cql_inferred_notnull</code>
and avoid re-rewriting appropriately:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// This is true if we are analyzing a call to `cql_inferred_notnull`. This can</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// happen for three reasons:</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// * We just did a rewrite that produced a `cql_inferred_notnull` call and now</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   we&#x27;re computing its type.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// * We&#x27;re analyzing an expression that was already analyzed (e.g., in a CTE).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// * We&#x27;re analyzing the output of a previous CQL run within which calls to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   `cql_inferrred_notnull` may occur.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Regardless of the cause, if `is_analyzing_notnull_rewrite` is true, we do not</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// want to rewrite again.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> is_analyzing_notnull_rewrite</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_special_func_cql_inferred_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">uint32_t</span><span class="token plain"> arg_count</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">is_aggregate</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Since we&#x27;re checking a call to `cql_inferred_notnull`, its arguments have</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// already been rewritten and we don&#x27;t want to do it again. Setting</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `is_analyzing_notnull_rewrite` prevents that.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  is_analyzing_notnull_rewrite </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> true</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_arg_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">arg_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> IS_NOT_COUNT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  is_analyzing_notnull_rewrite </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> false</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Like `sem_resolve_id`, but specific to expression contexts (where nullability</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements are applicable).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_resolve_id_expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">is_analyzing_notnull_rewrite</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// If we&#x27;re analyzing the product of a rewrite and we&#x27;re already inside of a</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// call to `cql_inferred_notnull`, do not expand again.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// forever.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>At this point, you should have a decent understanding of how nullability
improvements function, both in terms of semantic analysis and in terms of code
generation. The implementation is heavily commented, so reading the code and
searching for calls to the core functions listed below should be sufficient to
fill in any gaps:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_is_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_unset_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_unset_global_notnull_improvements</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_false_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_special_func_cql_inferred_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">uint32_t</span><span class="token plain"> arg_count</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">is_aggregate</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">rewrite_nullable_to_unsafe_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">_Nonnull ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initialization-improvements"></a>Initialization Improvements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initialization-improvements" title="Direct link to heading">#</a></h3><p>Compared to nullability improvements, initialization improvements are relatively
simple.</p><p>The idea behind initialization improvements is that, if one declares a variable
of a reference type (<code>BLOB</code>, <code>OBJECT</code>, or <code>TEXT</code>) that is also <code>NOT NULL</code>, it is
not safe to use the variable until it has been given a value. For example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> x </span><span class="token keyword" style="font-style:italic">TEXT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">NOT</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> some_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> some_text_notnull_value</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `x` is safe to use here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `x` is NOT safe to use here (it might be uninitialized)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `x` is NOT safe to use here either (it might be uninitialized)</span></div></div></div></div></div><p>As with nullability improvements, initialization improvements rely heavily on
flow contexts. The function <code>sem_set_initialization_improved</code>, similarly to
<code>sem_set_notnull_improved</code> for nullability, is used to enable an initialization
improvement. (There is nothing analogous to <code>sem_unset_notnull_improved</code> for
initialization because nothing can ever be uninitialized once it has been given
a value.)</p><p>Unlike nullability improvements, initialization improvements use <em>two</em> flags:
<code>SEM_TYPE_INIT_REQUIRED</code> and <code>SEM_TYPE_INIT_COMPLETE</code>. Rather than assuming
everything is uninitalized by default and requiring the presence of some
<code>SEM_TYPE_INITIALIZED</code> flag before anything can be used, we explicitly tag
things that are not initialized but need to be with <code>SEM_TYPE_INIT_REQUIRED</code> and
later tag them with <code>SEM_TYPE_INIT_COMPLETE</code> once they&#x27;ve been initialized.
Doing it in this way has two benefits:</p><ol><li><p>It reduces the amount of noise in the AST output significantly: Code like
<code>LET x := 10;</code> can remain <code>{let_stmt}: x: integer notnull variable</code> in the
AST without the need of the extra noise of some <code>initialized</code> flag.</p></li><li><p>More importantly, it means we only have to deal with initialization in a tiny
portion of &quot;sem.c&quot;. For example, we must handle it in <code>sem_declare_vars_type</code>
to add the <code>SEM_TYPE_INIT_REQUIRED</code> flag and in <code>sem_assign</code> to add
<code>SEM_TYPE_INIT_COMPLETE</code>, but <code>sem_let_stmt</code> can remain blissfully ignorant
of initialization altogether.</p></li></ol><p>There are only three places in which a variable may be initialized: <code>sem_assign</code>
(as mentioned), <code>sem_fetch_stmt</code> (for the <code>FETCH...INTO</code> form), and
<code>sem_arg_for_out_param</code> (as passing a variable to a procedure requiring an <code>OUT</code>
argument of a <code>NOT NULL</code> type can initialize it).</p><p>Regarding <code>sem_arg_for_out_param</code>, we can only set initialization improvements
when a variable is passed as an <code>OUT</code> argument because we require that all
procedures initialize all of their <code>OUT</code> parameters of a nonnull reference type.
This is handled in two places:</p><ol><li><p>In <code>sem_param</code>, we set the <code>SEM_TYPE_INIT_REQUIRED</code> flag when
<code>param_should_require_initialization</code> is true.</p></li><li><p>In <code>sem_validate_current_proc_params_are_initialized</code>, which is called both
after analyzing the statement list of a procedure and for each return
statement within the procedure, we ensure that <code>SEM_TYPE_INIT_COMPLETE</code> is
present on all parameters that have <code>SEM_TYPE_INIT_REQUIRED</code>.</p></li></ol><p>There is only one wrinkle in all of this: the <code>cql:try_is_proc_body</code> attribute.
If <code>cql:try_is_proc_body</code> is present on a <code>TRY</code> statement, we call
<code>sem_validate_current_proc_params_are_initialized</code> at the end of the <code>TRY</code> and
<em>not</em> at the end of the procedure. The rationale for this is explained
thoroughly in the comments for
<code>sem_find_ast_misc_attr_trycatch_is_proc_body_callback</code>.</p><p>That&#x27;s all there is to it: &quot;flow.c&quot; does most of the hard work for us.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="structure-types-and-the-notion-of-shapes"></a>Structure types and the notion of Shapes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#structure-types-and-the-notion-of-shapes" title="Direct link to heading">#</a></h3><p>Earlier we discussed <code>SEM_TYPE_STRUCT</code> briefly. Recall the basic notion of the <code>structure</code> type:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for tables and views and the result of a select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_struct {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR struct_name;               // struct name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // field names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *kinds;                    // the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *semtypes;                // typecode for each field</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_struct;</span></div></div></div></div></div><p>The structure is nothing more than an array of names, types and kinds with a count.  But it creates the notion of
what&#x27;s usually called a &quot;shape&quot; in the codebase. Shapes can be used in a variety of ways as is described in
<a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the CQL Guide. But before we get
into shapes, let&#x27;s look at an example of how a structure type is created.</p><p>The code that follows is the back end of <code>sem_create_table_stmt</code>.  At this point the bulk of the analysis is
done and the columns all have their types.  We&#x27;re about to build the struct type for the table.  Let&#x27;s see how
that goes.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // now create a struct type with the correct number of columns</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the types have already been computed so all we have to do is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // check for duplicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_struct *sptr = new_sem_struct(name, cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *columns = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t col = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *item = col_key_list; item; item = item-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(is_ast_col_key_list(item));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(def, item-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_col_def(def)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(def-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(col &lt;= cols);  // it&#x27;s possible that the rest are deleted and we&#x27;re at the end.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // columns must be unique, including deleted columns</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (!symtab_add(columns, def-&gt;sem-&gt;name, NULL)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_NOTNULL(col_def_type_attrs, def-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_ANY_NOTNULL(col_def_ast, col_def_name_type-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        report_error(col_def_ast, &quot;CQL0142: duplicate column name&quot;, def-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        symtab_delete(columns);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        goto cleanup;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (is_deleted(def-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(col &lt; cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;names[col] = def-&gt;sem-&gt;name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;semtypes[col] = def-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;kinds[col] = def-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      col++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(columns);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(col == cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_STRUCT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;sptr = sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;jptr = sem_join_from_sem_struct(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;region = current_region;</span></div></div></div></div></div><ul><li><code>new_sem_struct</code> : makes a struct to hold the result, we already have the count of columns and the table name</li><li><code>symtab_new</code> : is going to give us a scratch symbol table so we can check for duplicate column names</li><li>we walk all the items in the table and use <code>is_ast_col_def(def)</code> to find the column definitions</li><li><code>Invariant(def-&gt;sem-&gt;name)</code> : claims that we must have already computed the semantic info for the column and it has its name populated<ul><li>this was done earlier</li></ul></li><li><code>symtab_add(columns, def-&gt;sem-&gt;name, NULL)</code> : adds a nil entry under the column name -- if this fails we have a duplicate column,<ul><li>in which case we report errors and stop</li></ul></li><li><code>is_deleted</code> : tells us if the column was marked with <code>@delete</code> in which case it no longer counts as part of the table</li><li>if all this is good we set the <code>names</code>, <code>kinds</code>, and <code>semtypes</code> from the column definition&#x27;s semantic info</li><li><code>symtab_delete</code> : cleans up the temporary symbol table</li><li><code>new_sem</code> : creates a <code>sem_node</code> of type <code>SEM_TYPE_STRUCT</code> which is filled in<ul><li><code>sem_join_from_sem_struct</code> will be discussed shortly, but it creates a <code>jptr</code> with one table in it</li></ul></li></ul><p>Structure types often come from the shape of a table, but other things can create a structure type.  For instance, the
columns of a view, or any select statement, are also described by a structure type and are therefore valid &quot;shapes&quot;.  The
return type of a procedure usually comes from a <code>SELECT</code> statement, so the procedure too can be the source of a shape.
The arguments of a procedure form a shape.  The fields of a cursor form a shape.  You can even have a named subset
of the arguments of a procedure and use them like a shape. All of these things are described by structure types.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="shapes-and-the-like-construct"></a>Shapes and the LIKE construct<a aria-hidden="true" tabindex="-1" class="hash-link" href="#shapes-and-the-like-construct" title="Direct link to heading">#</a></h4><p>There are many cases where you want to be able to capture or re-use something with a known shape and you don&#x27;t
want to have to fully re-declare the thing.  CQL uses the <code>LIKE</code> construct to do these sorts of things.  This is
more fully explained in <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the Guide,
but for now let&#x27;s look at two different cases that are of interest.</p><p>First, a cursor:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE C CURSOR LIKE Foo;  -- Foo something with a shape</span></div></div></div></div></div><p>So, in the above, Foo could be a table, a view, a procedure with a result, another cursor, and so forth.</p><p>How might we do this?  This is the business of <code>sem_declare_cursor_like_name</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we&#x27;re going to make a new value cursor using the indicated name for the shape.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The name has to be &quot;likeable&quot; meaning it refers to some named thing with a shape</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// such as a table, a view, another cursor, or a procedure that returns a result set.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These are the so called &quot;value cursors&quot; in that they have no underlying statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// that they move through.  You can just load them up with a row and pass them around.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_declare_cursor_like_name(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_declare_cursor_like_name(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(new_cursor_ast, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(new_cursor_name, new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(like_ast, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(name_ast, like_ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(like_name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // no duplicates allowed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_legal_variable_name(ast, new_cursor_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be a valid shape</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *found_shape = sem_find_likeable_ast(like_ast, LIKEABLE_FOR_VALUES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!found_shape) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // good to go, make our cursor, with storage.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name_ast-&gt;sem = like_ast-&gt;sem = found_shape-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem-&gt;sptr = found_shape-&gt;sem-&gt;sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem-&gt;name = new_cursor_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_cursor_ast-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_add(current_variables, new_cursor_name, new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>EXTRACT</code> : gets the pieces we need from the AST</li><li><code>sem_verify_legal_variable_name</code> : makes sure the cursor name is unique and doesn&#x27;t hide a table name</li><li><code>sem_find_likeable_ast</code> : searches for something with a suitable name that has a shape</li><li>we populate the name node with the  semantic type that we found</li><li><code>new_sem</code> : makes a new <code>sem_node</code> for the cursor variable with <code>SEM_TYPE_STRUCT</code><ul><li>set the <code>sptr</code> field using the discovered shape</li></ul></li></ul><p>Note: <code>name_ast-&gt;sem</code> isn&#x27;t actually used for anything but it is helpful for debugging. If the AST is printed it
shows the original unmodified semantic type which can be helpful.</p><p>Briefly <code>sem_find_likeable_ast</code> does these steps:</p><ul><li>if the right of the <code>LIKE</code> refers to procedure arguments (e.g. C LIKE Foo ARGUMENTS), get the args of the named procedure and use them as a shape</li><li>if the right is a local or global, and its a cursor, use the shape of that cursor for the new cursor</li><li>if the right is the name of an argument bundle, use the shape of the bundle<ul><li>e.g. in <code>CREATE PROC Foo(p1 like Person, p2 like Person)</code> <code>p1</code> and <code>p2</code> are the names of argument bundles shaped like <code>Person</code></li></ul></li><li>if the right is the name of a table or view, use that shape</li><li>if the right is the name of a procedure with a structure result, use that shape</li><li>if it&#x27;s none of these, produce an error</li></ul><p>This is the primary source of shape reuse.  Let&#x27;s look at how we might use that.</p><p>Suppose we want to write a procedure that inserts a row into the table <code>Foo</code>, we could certainly list the columns of <code>Foo</code> as arguments like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC InsertIntoFoo(id integer, t text, r real, b blob)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSERT INTO Foo(id, t, r, b) VALUES(id, t, r, b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>But that approach is going to get a lot less exciting when there are lots of columns and it will be increasingly a maintenance headache.</p><p>Compare that with the following:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC InsertIntoFoo(row LIKE Foo)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSERT INTO Foo FROM row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Those two versions of <code>InsertIntoFoo</code> compile into the same code.  The semantic analyzer expands the <code>(row LIKE Foo)</code> into
<code>(row_id integer, row_t text, row_r real, row_b blob)</code> and then replaces <code>FROM row</code> with
<code>(row_id, row_t, row_r, row_b)</code>.  In both case it simply looked up the shape using <code>sem_find_likeable_ast</code>
and then altered the AST to the canonical pattern.  This kind of &quot;shape sugar&quot; is all over CQL and
greatly increases maintainability while eliminating common errors.  The most common operation is simply
to expland a &quot;shape&quot; into a list of arguments or columns (maybe with or without type names).  SQLite doesn&#x27;t
know any of this shape magic so by the time SQLite sees the code it has to look &quot;normal&quot; -- the shapes
are all resolved.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="join-types"></a>Join Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#join-types" title="Direct link to heading">#</a></h3><p>The last of the type building data structure is the join type.  Recall that we have this shape:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for the data type of (parts of) the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// sometimes I refer to as a &quot;joinscope&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_join {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of table/views in the join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // names of the table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct **tables;     // struct type of each table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_join;</span></div></div></div></div></div><p>This is an array of named structure types, which is exactly what you get when you do something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select * from T1 INNER JOIN T2;</span></div></div></div></div></div><p>The result has all of the columns of <code>T1</code> and all of the columns of <code>T2</code>.  They can be referred to with scoped
names like <code>T1.x</code> which means &quot;find the <code>sptr</code> corresponding to the name <code>T1</code> then within that structure
find the column named <code>x</code>&quot;.  In general, when we join, we take a <code>jptr</code> on the left and concatenate it
with a <code>jptr</code> on the right.  For all this to work we have to start somewhere, usually single tables.</p><p>As we saw when we make a table we use <code>sem_join_from_sem_struct</code> to make its initial <code>jptr</code>.  Let&#x27;s
have a look at that now:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create a base join type from a single struct.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static sem_join *sem_join_from_sem_struct(sem_struct *sptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_join *jptr = new_sem_join(1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  jptr-&gt;names[0] = sptr-&gt;struct_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  jptr-&gt;tables[0] = new_sem_struct_strip_table_flags(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return jptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It doesn&#x27;t get much simpler than the above, here are the steps briefly:</p><ul><li><code>new_sem_join</code> : gives us an empty <code>sem_join</code> with room for 1 table</li><li>we use the struct name for the name and the table&#x27;s <code>sptr</code> for the shape</li><li><code>new_sem_struct_strip_table_flags</code> : copies the table&#x27;s <code>sptr</code> keeping only the essential flags<ul><li><code>SEM_TYPE_HIDDEN_COL</code></li><li><code>SEM_FLAG_NOTNULL</code></li><li><code>SEM_FLAG_SENSITIVE</code></li></ul></li></ul><p>The other flags (e.g. <code>SEM_TYPE_PK</code>) have no value in doing type checking and were only needed to help validate the table itself.
Those extra flags would be harmless but they would also contaminate all of the debug output, so they are stripped.  As a result
the type of columns as they appear in say <code>SELECT</code> statements is simpler than how they appear in a <code>CREATE TABLE</code> statement.</p><p>When we need to create a new join type we simply (*) make a new <code>sem_join</code> that is the concatenation of the left and right sides of the join
operation.</p><ul><li>some join types change the nullability of columns like <code>LEFT JOIN</code>, so we have to handle that too</li><li>the names of the tables in the new concatenated joinscope have to be unambiguous so there is also error checking to do</li><li>but basically it&#x27;s just a concatenation</li></ul><p>Importantly, we call the thing a &quot;joinscope&quot; because it creates a namespace.  When we are evaluating names inside of the <code>FROM</code> clause or
even later in, say, a <code>WHERE</code> clause, the joinscope that we have created so far controls the <code>table.column</code> combinations that you can
use in expressions.  This changes again when there is a subquery, so the joinscopes can be pushed and popped as needed.</p><p>By way of example, you&#x27;ll see these two patterns in the code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PUSH_JOIN(from_scope, select_from_etc-&gt;sem-&gt;jptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error = sem_select_orderby(select_orderby);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  POP_JOIN();</span></div></div></div></div></div><ul><li><code>PUSH_JOIN</code> : use the <code>jptr</code> from the <code>FROM</code> clause to put things back in scope for the <code>ORDER BY</code> clause</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PUSH_JOIN_BLOCK();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_numeric_expr(ast-&gt;left, ast, &quot;LIMIT&quot;, SEM_EXPR_CONTEXT_LIMIT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  POP_JOIN();</span></div></div></div></div></div><ul><li><code>PUSH_JOIN_BLOCK</code> : causes the name search to stop -- nothing deeper in the stack is searched</li><li>in this case we do not allow <code>LIMIT</code> expressions to see any joinscopes, as they may not use any columns<ul><li>even if the <code>LIMIT</code> clause is appearing in a subquery it can&#x27;t refer to columns in the parent query</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-regions"></a>Schema Regions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-regions" title="Direct link to heading">#</a></h3><p>We touched briefly on schema regions earlier in this section.  The purpose and language for regions
is described more fully in <a href="https://cgsql.dev/cql-guide/ch10#schema-regions" target="_blank" rel="noopener noreferrer">Chapter 10</a> of the Guide.
In this section we&#x27;ll deal with how they are implemented and what you should expect to see in the code.</p><p>When a region declaration is found this method is used:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// A schema region is an partitioning of the schema such that it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// only uses objects in the same partition or one of its declared</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// dependencies.  One schema region may be upgraded independently</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// from any others (assuming they happen such that dependents are done first).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we validate:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the region name is unique</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the dependencies (if any) are unique and exist</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_declare_schema_region_stmt(ast_node *ast)  { ... }</span></div></div></div></div></div><p>The general rules are described in the comment, but effectively it accumulates the list of
the declared region&#x27;s dependencies.  Sometimes these are called the antecedent regions.  Since
a region can only depend on regions that have already been declared, it&#x27;s not possible
to make any cycles. Regions are declared before you put anything into them.</p><p>Pieces of schema or procedures (or anything really) can go into a region by putting that code
inside a begin/end pair for the named region.  Like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token variable" style="color:rgb(191, 199, 213)">@begin_schema_region</span><span class="token plain"> your_region</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- your stuff</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token variable" style="color:rgb(191, 199, 213)">@end_schema_region</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Now whatever happens to be in &quot;your stuff&quot; is:</p><ul><li>limited to seeing only the things that <code>your_region</code> is allowed to see, and</li><li>contributes its contents to <code>your_region</code> thereby limiting how others will be able to use &quot;your stuff&quot;</li></ul><p>To see how this happens, let&#x27;s have a look at <code>sem_begin_schema_region_stmt</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Entering a schema region makes all the objects that follow part of that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// region.  It also means that all the contained objects must refer to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// only pieces of schema that are in the same region or a dependent region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we validate that region we are entering is in fact a valid region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and that there isn&#x27;t already a schema region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_begin_schema_region_stmt(ast_node * ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_begin_schema_region_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(name, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // @BEGIN_SCHEMA_REGION name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!verify_schema_region_out_of_proc(ast)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (current_region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0246: schema regions do not nest; end the current region before starting a new one&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *region = find_region(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0244: unknown schema region&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Get the canonical name of the region (case adjusted)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_region(region));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(region_name, region-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // we already know we are not in a region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(!current_region_image);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  current_region_image = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_accumulate_public_region_image(current_region_image, region_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this is the one and only text pointer value for this region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  current_region = region_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We see these basic steps:</p><ul><li><code>EXTRACT</code> : gets the region name</li><li><code>verify_schema_region_out_of_proc</code> : makes sure we are out of any procedure (we have to be at the top level)<ul><li>errors if in a procedure</li></ul></li><li><code>current_region</code> : is tested to make sure we are not already in a region (no nesting)<ul><li>errors if already in a region</li></ul></li><li><code>find_region</code> : is used to find the region AST by name<ul><li>errors if the region name isn&#x27;t valid</li></ul></li><li><code>EXTRACT</code> : is used again to get the canonical name of the region<ul><li>you could write <code>@begin_schema_region YoUr_ReGION;</code> but we want the canonical name <code>your_region</code>, as it was declared</li></ul></li><li><code>symtab_new</code> : creates a new symbol table <code>current_region_image</code></li><li><code>sem_accumulate_public_region_image</code> : populates <code>current_region_image</code> by recursively walking this region adding the names of all the regions we find along the way<ul><li>note the regions form a DAG so we might find the same name twice; we can stop if we find a region that is already in the image symbol table</li></ul></li><li><code>current_region</code> : set it to the now new current region</li></ul><p>Now we&#x27;re all set up.</p><ul><li>We can use <code>current_region</code> to set the <code>region</code> in the <code>sem_node</code> of anything we encounter</li><li>We can use <code>current_region_image</code> to quickly see if we are allowed to use any given region<ul><li>if it&#x27;s in the symbol table we can use it</li></ul></li></ul><p>Recall that at the end of <code>sem_create_table_stmt</code> we do this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_STRUCT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;sptr = sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;jptr = sem_join_from_sem_struct(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;region = current_region;</span></div></div></div></div></div><p>That should make a lot more sense now.</p><p>When doing the symmetric check in <code>sem_validate_object_ast_in_current_region</code> we see this pattern:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Validate whether or not an object is usable with a schema region. The object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can only be a table, view, trigger or index.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_validate_object_ast_in_current_region(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_ast,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *err_target,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR msg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We&#x27;re in a non-region therefore no validation needed because non-region stmt</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // can reference schema in any region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!current_region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (table_ast-&gt;sem &amp;&amp; table_ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // if we have a current region then the image is always computed!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(current_region_image);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!symtab_find(current_region_image, table_ast-&gt;sem-&gt;region)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // The target region is not accessible from this region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // while in schema region &#x27;%s&#x27;, accessing an object that isn&#x27;t in a region is invalid</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>I&#x27;ve elided some of the code here, but only the part that generates error messages.  The essential logic is:</p><ul><li>if we are not in a region we can access anything</li><li>if we&#x27;re in a region then...<ul><li>the thing we&#x27;re trying to access must also be in a region, and</li><li>that region must be in <code>current_region_image</code></li><li>otherwise, we can&#x27;t access it</li></ul></li></ul><p>This is enough to do all the region validation we need.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="results-of-semantic-analysis"></a>Results of Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#results-of-semantic-analysis" title="Direct link to heading">#</a></h3><p>Semantic Analysis leaves a lot of global state ready for the remaining stages to harvest.  If the state
is defined in <code>sem.h</code> then it&#x27;s ok to harvest.  Here we&#x27;ll highlight some of the most important things you
can use in later passes.  These are heavily used in the code generators.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_tables_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_functions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_views_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_indices_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_triggers_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_regions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_ad_hoc_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_select_functions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_enums_list );</span></div></div></div></div></div><p>These linked lists are authoritiative; they let you easily enumerate all the objects of the specified type.  For
instance, if you wanted to do some validation of all indices, you could simply walk <code>all_indices_list</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_proc(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_region(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_func(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_table_or_view_even_deleted(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_enum(CSTR name);</span></div></div></div></div></div><p>These functions give you access to the core name tables (which are still valid!) so that you can look up procedures, functions,
tables, etc. by name.</p><p>Finally, information about all the schema annotations is invaluable for building schema upgraders.  These
two buffers hold dense arrays of annotation records as shown below.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( bytebuf *schema_annotations );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( bytebuf *recreate_annotations );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct recreate_annotation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR target_name;               // the name of the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR group_name;                // group name or &quot;&quot; if no group (not null, safe to sort)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *target_ast;           // top level target (table, view, or index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *annotation_ast;       // the actual annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t ordinal;                // when sorting we want to use the original order (reversed actually) within a group</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} recreate_annotation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct schema_annotation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t version;                // the version number (always &gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *target_ast;           // top level target (table, view, or index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR target_name;               // the name of the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t annotation_type;       // one of the codes below for the type of annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *annotation_ast;       // the actual annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t column_ordinal;         // -1 if not a column</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *column_ast;           // a particular column if column annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} schema_annotation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note: schema annotations are processed in the indicated order: the numbers matter!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_INVALID 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_FIRST 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_UNSUB 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_CREATE_TABLE 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_CREATE_COLUMN 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_TRIGGER 4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_VIEW 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_INDEX 6</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_COLUMN 7</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_TABLE 8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_AD_HOC 9</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_RESUB 10</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_LAST 10</span></div></div></div></div></div><p>And of course, each &quot;back end&quot; is provided with the root of the AST so that it can also search
and/or walk the AST in its own manner.  We will see examples of this in later sections.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>At present, there are nearly 20000 lines in <code>sem.c</code> and it would no doubt take more than 20000 lines of text
to explain what they all do, and that would be more imprecise than the source code, and probably less
readable.  <code>sem.c</code> includes over 4000 lines of comments, and probably should have more.  While there
is a lot of code there, it&#x27;s very readable and I encourage you to do just that -- read it -- to get your answers.</p><p>The point of this part of the Internals Guide isn&#x27;t to fully explain all 400+ error checks in about
as many semantic error checking functions, it is to showcase the key concepts shared by all of them. Things like:</p><ul><li>errors are reported largely in the AST and percolate up</li><li>expressions and statements have general purpose dispatch logic for continuing a statement walk</li><li><code>EXTRACT</code> macros are used to keep the tree walk on track and correct in the face of changes</li><li>regions are used for visibility</li><li>versioning contributes to visibility</li><li>nullability and sensitivity are tracked throughout using type bits</li><li>type &quot;kind&quot; is managed by a simple string in the <code>sem_node</code> payload</li><li>the three main payloads are<ul><li><code>sem_node</code> for basic info, and</li><li><code>sem_struct</code> or <code>sem_join</code> for the non-unitary types</li></ul></li></ul><p>This isn&#x27;t everything but it should leave you well armed to begin your own exploration of <code>sem.c</code>.</p><p>Note: details on unsub/resub are forthcoming.  This code is under development.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-05-05T17:00:48.000Z" class="docLastUpdatedAt_217_">5/5/2022</time> by <strong>Josh Leibsly</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int01"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 1: Lexing, Parsing, and the AST</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cql-guide/int03"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Part 3: C Code Generation Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#semantic-analysis" class="table-of-contents__link">Semantic Analysis</a><ul><li><a href="#decorated-ast-examples" class="table-of-contents__link">Decorated AST examples</a></li><li><a href="#the-base-data-structures" class="table-of-contents__link">The Base Data Structures</a></li><li><a href="#initiating-semantic-analysis" class="table-of-contents__link">Initiating Semantic Analysis</a></li><li><a href="#semantic-errors" class="table-of-contents__link">Semantic Errors</a></li><li><a href="#the-primitive-types" class="table-of-contents__link">The Primitive Types</a></li><li><a href="#unary-operators" class="table-of-contents__link">Unary Operators</a></li><li><a href="#binary-operators" class="table-of-contents__link">Binary Operators</a></li><li><a href="#simple-statement-validation" class="table-of-contents__link">Simple Statement Validation</a></li><li><a href="#expression-contexts" class="table-of-contents__link">Expression Contexts</a></li><li><a href="#name-resolution" class="table-of-contents__link">Name Resolution</a></li><li><a href="#flow-analysis" class="table-of-contents__link">Flow Analysis</a></li><li><a href="#nullability-improvements" class="table-of-contents__link">Nullability Improvements</a></li><li><a href="#initialization-improvements" class="table-of-contents__link">Initialization Improvements</a></li><li><a href="#structure-types-and-the-notion-of-shapes" class="table-of-contents__link">Structure types and the notion of Shapes</a></li><li><a href="#join-types" class="table-of-contents__link">Join Types</a></li><li><a href="#schema-regions" class="table-of-contents__link">Schema Regions</a></li><li><a href="#results-of-semantic-analysis" class="table-of-contents__link">Results of Semantic Analysis</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/metaOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Meta Platforms Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2022 Meta Platforms, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.58a786a3.js"></script>
<script src="/runtime~main.6e310b00.js"></script>
<script src="/main.f2c34c0c.js"></script>
<script src="/1.fae5e295.js"></script>
<script src="/2.0eb37f9a.js"></script>
<script src="/3.5c2742cc.js"></script>
<script src="/1be78505.bc52d199.js"></script>
<script src="/106.5c1aa3b0.js"></script>
<script src="/5456faf3.c3a29041.js"></script>
<script src="/17896441.5a19be7f.js"></script>
<script src="/e2f0474c.4127e1ca.js"></script>
</body>
</html>