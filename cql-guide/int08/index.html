<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 8: Test Helpers | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 8: Test Helpers | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int08"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int08"><link rel="stylesheet" href="/styles.9ec987f3.css">
<link rel="preload" href="/styles.58a786a3.js" as="script">
<link rel="preload" href="/runtime~main.1fab1047.js" as="script">
<link rel="preload" href="/main.f2c34c0c.js" as="script">
<link rel="preload" href="/1.fae5e295.js" as="script">
<link rel="preload" href="/2.0eb37f9a.js" as="script">
<link rel="preload" href="/3.5c2742cc.js" as="script">
<link rel="preload" href="/1be78505.bc52d199.js" as="script">
<link rel="preload" href="/106.5c1aa3b0.js" as="script">
<link rel="preload" href="/5456faf3.c3a29041.js" as="script">
<link rel="preload" href="/17896441.5a19be7f.js" as="script">
<link rel="preload" href="/21c29d6a.4a037561.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div class="announcementBar_1l0Z" style="background-color:#20232a;color:#fff" role="banner"><div class="announcementBarContent_1xni">Support Ukraine ðŸ‡ºðŸ‡¦ <a target="_blank" rel="noopener noreferrer" href="https://opensource.fb.com/support-ukraine"> Help Provide Humanitarian Aid to Ukraine</a>.</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x10">Appendix 10: CQL Working Example</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x11">Appendix 11: Production Considerations</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int04">Part 4: Testing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int05">Part 5: CQL Runtime</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int06">Part 6: Schema Management</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int07">Part 7: JSON Generation</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int08">Part 8: Test Helpers</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 8: Test Helpers</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 8 continues with a discussion of the Test Helper  generation code.
As in the previous sections, the goal here is not to go over every detail but rather to give
a sense of how helpers are created in general -- the core strategies and implementation choices --
so that when reading the source you will have an idea how it all hangs together.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="test-helpers"></a>Test Helpers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#test-helpers" title="Direct link to heading">#</a></h2><p>The testability features are described in <a href="https://cgsql.dev/cql-guide/ch12" target="_blank" rel="noopener noreferrer">Chapter 12</a> of the Guide
So, we won&#x27;t be discussing all the details of what can be created.  Instead we&#x27;re going to go over
the theory of how the generator works. This generator is somewhat different than others in that
it only concerns itself with procedures and only those that have been suitably annotated --
there are large parts of the tree that are of no interest to the test helper logic, including,
importantly the body of procedures.  Only the signature matters.  As we&#x27;ll see there is a fairly
large family of generators that are like this.</p><p>We&#x27;ll have one section for every kind of output, but really only the <code>dummy_test</code> helper is
worthy of detailed discussion the others, as we&#x27;ll see, are very simple.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initialization"></a>Initialization<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initialization" title="Direct link to heading">#</a></h3><p>The generator is wired like the others with a suitable main, this one is pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for test_helpers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_test_helpers_main(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(options.file_names_count == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_exit_on_semantic_errors(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  exit_on_validating_schema();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_reset_globals();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(output_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_th_output = &amp;output_buf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;%s&quot;, rt-&gt;source_prefix);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_stmt_list(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], cg_th_output-&gt;ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(output_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_reset_globals();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The text output will be ultimately put into <code>output_buf</code> defined here and <code>helper_flags</code> will track which kinds of helpers
we saw.  This helps us to emit the right sections of output as we&#x27;ll see.</p><p>The code iterates the AST looking at the top level statement list only and in particular looking for <code>CREATE PROC</code>
statements.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Iterate through statement list</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_test_helpers_stmt_list(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_stmt_list(head));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_all_trigger_per_table();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_all_indexes_per_table();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(procs_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(decls_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_th_procs = &amp;procs_buf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_th_decls = &amp;decls_buf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *ast = head; ast; ast = ast-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_create_proc_stmt(stmt)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      EXTRACT_STRING(proc_name, stmt-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_test_helpers_create_proc_stmt(stmt, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;%s&quot;, decls_buf.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;%s&quot;, procs_buf.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(decls_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(procs_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(all_tables_with_triggers);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_tables_with_triggers = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(all_tables_with_indexes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_tables_with_indexes = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>There are some preliminaries:</p><ul><li>we make a symbol table that maps from tables names to the list of triggers on that table by walking all the triggers</li><li>we make a symbol table that maps from tables names to the list of indices on that table by walking all the indices</li><li>we&#x27;ll need two buffers one for declarations (that must go first) and one for procedure bodies</li><li>each <code>CREATE PROC</code> statement potentially contributes to both sections</li><li><code>cg_test_helpers_create_proc_stmt</code> checks for the helper attributes and sets up the dispatch to emit the test helpers</li></ul><p>To do this we have to walk any misc attributes on the procedure we&#x27;re looking for things of the form <code>@attribute(cql:autotest=xxx)</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_test_helpers_create_proc_stmt(ast_node *stmt, ast_node *misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_create_proc_stmt(stmt));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dummy_test_infos = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    find_misc_attrs(misc_attrs, test_helpers_find_ast_misc_attr_callback, stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    symtab_delete(dummy_test_infos);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dummy_test_infos = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>find_misc_attrs</code> calls <code>test_helpers_find_ast_misc_attr_callback</code>.  We&#x27;re going to keep track of
which kinds of helpers we have found to help us with the output.  This is where <code>helper_flags</code>
comes in. The flags are:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_TABLE           1 // dummy_table attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_INSERT          2 // dummy_insert attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_SELECT          4 // dummy_select attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_RESULT_SET      8 // dummy_result_set attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_TEST         0x10 // dummy_test attribute flag</span></div></div></div></div></div><p>And now we&#x27;re ready for actual dispatch:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is invoked for every misc attribute on every create proc statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// in this translation unit.  We&#x27;re looking for attributes of the form cql:autotest=(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and we ignore anything else.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void test_helpers_find_ast_misc_attr_callback(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR _Nullable misc_attr_prefix,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR _Nonnull misc_attr_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *_Nullable ast_misc_attr_value_list,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable context)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *stmt = (ast_node *)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_create_proc_stmt(stmt));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (misc_attr_prefix &amp;&amp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      misc_attr_name &amp;&amp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      !Strcasecmp(misc_attr_prefix, &quot;cql&quot;) &amp;&amp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      !Strcasecmp(misc_attr_name, &quot;autotest&quot;)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The main dispatch looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// In principle, any option can be combined with any other but some only make sense for procs with</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// a result.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">EXTRACT_STRING(autotest_attr_name, misc_attr_value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (is_autotest_dummy_test(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_dummy_test(stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// these options are only for procs that return a result set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (has_result_set(stmt) || has_out_stmt_result(stmt) || has_out_union_stmt_result(stmt)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_autotest_dummy_table(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_TABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_table(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_autotest_dummy_insert(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_INSERT;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_insert(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_autotest_dummy_select(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_SELECT;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_select(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_autotest_dummy_result_set(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_RESULT_SET;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_result_set(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Most of these options are very simple indeed.   <code>cg_test_helpers_dummy_test</code> is the trickiest
by far and we&#x27;ll save it for last, let&#x27;s dispense with the easy stuff.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="dummy-table-dummy-insert-dummy-select-dummy-result-set"></a>Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set<a aria-hidden="true" tabindex="-1" class="hash-link" href="#dummy-table-dummy-insert-dummy-select-dummy-result-set" title="Direct link to heading">#</a></h3><p>All of these are a very simple template.  The language includes just the right features
to emit these procedures as nearly constant strings. The <code>LIKE</code> construct was literally
designed to make these patterns super simple.  You can see all the patterns
in <a href="https://cgsql.dev/cql-guide/ch12" target="_blank" rel="noopener noreferrer">Chapter 12</a> but let&#x27;s look at the code for
the first one.  This is &quot;dummy table&quot;.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit an open proc which creates a temp table in the form of the original proc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a close proc which drops the temp table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_test_helpers_dummy_table(CSTR name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;CREATE PROC open_%s()\n&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;  CREATE TEMP TABLE test_%s(LIKE %s);\n&quot;, name, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;END;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;CREATE PROC close_%s()\n&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;  DROP TABLE test_%s;\n&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;END;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The purpose of this is to create helper functions that can create a temporary
table with the same columns in it as the procedure you are trying to mock.
You can then select rows out of that table (with <code>dummy_select</code>) or insert
rows into the table (with <code>dummy_insert</code>).  Or you can make a single
row result set (often enough) with <code>dummy_result_set</code>.</p><p>As we can see we simply prepend <code>open_</code> to the procedure name and use
that to create a test helper that make the temporary table.  The table&#x27;s
columns are defined to be <code>LIKE</code> the result shape of the procedure under
test.  Recall this helper is only available to procedures that return a result set.
The temporary table gets a <code>test_</code> prefix.  Assuming the procedure with the
annotation is <code>foo</code> then this code is universal:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">CREATE</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TEMP</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TABLE</span><span class="token plain"> test_foo</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">LIKE</span><span class="token plain"> foo</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Is universal, no matter the result shape of <code>foo</code> you get a table with those columns.</p><p>For this to work we need to emit a declaration of <code>foo</code> before this code.  However,
since we have the full definition of <code>foo</code> handy that is no problem.  We remember
that we&#x27;ll need it by setting a flag in <code>helper_flags</code>.</p><p>The code for <code>close_foo</code> is even simpler if that&#x27;s possible.  The great thing is
all need to know the columns of <code>foo</code> has been removed from the test helper.  The
CQL compiler handles this as a matter of course and it is generally useful.
See <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a>
for more examples.</p><p>All the others are equally simple and use similar tricks.  These were the first
test helpers.  They&#x27;re actually not that popular because they are so easy to create
yourself anyway.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="dummy-test"></a>Dummy Test<a aria-hidden="true" tabindex="-1" class="hash-link" href="#dummy-test" title="Direct link to heading">#</a></h3><p>The dummy test code emitter is non-trivial.  Let&#x27;s quickly review the things it has to
do and then we can go over how each of these is accomplished.  Assuming we have an procedure
<code>your_proc</code> that has been annotated like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@attribute(cql:autotest=(dummy_test))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">create proc your_proc(..args...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">begin</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  -- assorted references to tables and views</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">end;</span></div></div></div></div></div><p>Dummy test will produce the following:</p><ul><li><code>test_your_proc_create_tables</code><ul><li>a procedure that creates all the tables and views that <code>your_proc</code> needs</li></ul></li><li><code>test_your_proc_drop_tables</code><ul><li>a procedure that drops those same tables and views</li></ul></li><li><code>test_your_proc_create_indexes</code><ul><li>a procedure that creates your indices, in a test you may or may not want to create the indices</li></ul></li><li><code>test_your_proc_drop_indexes</code><ul><li>a procedure the drops those same indices</li></ul></li><li><code>test_your_proc_create_triggers</code><ul><li>a procedure that creates your trigger, in a test you may or may not want to create the triggers</li></ul></li><li><code>test_your_proc_drop_triggers</code><ul><li>a procedure the drops those same triggers</li></ul></li><li><code>test_your_proc_read_table1</code><ul><li>for each table or view in the <code>create_tables</code> a procedure that selects all the data out of that object is created in case you need it</li></ul></li><li><code>test_your_proc_populate_tables</code><ul><li>a procedure that loads all the tables from <code>create_tables</code> with sample data</li><li>FK relationships are obeyed</li><li>user data may be specified in an attribute and that data will be used in preference to auto-generated data</li></ul></li></ul><p>These are more fully discussed in <a href="https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern" target="_blank" rel="noopener noreferrer">Chapter 12</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="building-the-trigger-and-index-mappings"></a>Building the Trigger and Index mappings<a aria-hidden="true" tabindex="-1" class="hash-link" href="#building-the-trigger-and-index-mappings" title="Direct link to heading">#</a></h4><p>In order to know which indices and triggers we might need we have to be able to map from the tables/views in <code>your_proc</code> to the indices.
To set up for this a general purpose reverse mapping is created.  We&#x27;ll look at the triggers version. The indices version is nearly identical.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Walk through all triggers and create a dictionnary of triggers per tables.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void init_all_trigger_per_table() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(all_tables_with_triggers == NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_tables_with_triggers = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = all_triggers_list; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(create_trigger_stmt, item-&gt;ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_body_vers, create_trigger_stmt-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_def, trigger_body_vers-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_condition, trigger_def-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_op_target, trigger_condition-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_target_action, trigger_op_target-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(table_name_ast, trigger_target_action-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(table_name, table_name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (create_trigger_stmt-&gt;sem-&gt;delete_version &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // dummy_test should not emit deleted trigger</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    symtab_append_bytes(all_tables_with_triggers, table_name, &amp;create_trigger_stmt, sizeof(create_trigger_stmt));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The steps are pretty simple:</p><ul><li>we make a symbol table that will map from the table name to an array of statements</li><li>there is a convenient <code>all_triggers</code> list that has all the triggers</li><li>from each trigger we <code>EXTRACT</code> the table or view name (named <code>table_name</code> even if it&#x27;s a view)</li><li>we append the trigger statement pointer to the end of such statements for the table</li><li>any triggers marked with <code>@delete</code> are not included for obvious reasons</li></ul><p>At the end of this looking up the table name will give you a list of trigger statement AST pointers.  From there
of course you can get everything you need.</p><p>The index version is basically the same, the details of the <code>EXTRACT</code> ops to go from index to table name are different
and of course we start from the <code>all_indices_list</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="computing-the-dependencies-of-a-procedure"></a>Computing The Dependencies of a Procedure<a aria-hidden="true" tabindex="-1" class="hash-link" href="#computing-the-dependencies-of-a-procedure" title="Direct link to heading">#</a></h4><p>Sticking with our particular example, in order to determine that tables/views that <code>your_proc</code> might need,
the generator has to walk its entire body looking for things that are tables.  This is handled by the
<code>find_all_table_nodes</code> function.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void find_all_table_nodes(dummy_test_info *info, ast_node *node) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  table_callbacks callbacks = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .callback_any_table = found_table_or_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .callback_any_view = found_table_or_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .callback_context = info,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .notify_table_or_view_drops = true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .notify_fk = true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .notify_triggers = true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  info-&gt;callbacks  = &amp;callbacks;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  find_table_refs(&amp;callbacks, node);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // stitch the views to the tables to make one list, views first</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = info-&gt;found_views; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     if (!item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       item-&gt;next = info-&gt;found_tables;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       info-&gt;found_tables = info-&gt;found_views;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this shouldn&#x27;t be used after it&#x27;s been linked in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  info-&gt;found_views = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This code uses the general dependency walker in <code>cg_common.c</code> to visit all tables and views. It is a recursive
walk and the general steps for prosecution go something like this:</p><ul><li>starting from <code>your_proc</code> the entire body of the procedure is visited</li><li>references to tables or views in update, delete, insert, select etc. statements are identified</li><li>each such table/view is added to the found tables list (at most once)</li><li>for views, the recursion proceeds to the body of the view as though the body had been inline in the procedure</li><li>for tables, the recursion proceeds to the body of the table to discover any FK relationships that need to be followed</li><li>if any found item has triggers, the trigger body is walked, any tables/views mentioned there become additional found items</li><li>any given table/view and hence trigger is only visited once</li></ul><p>The net of all this, the &quot;found items&quot;, is a list of all the tables and views that the procedure uses, directly
or indirectly.  As discussed in <a href="https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern" target="_blank" rel="noopener noreferrer">Chapter 12</a>
this walk does not include tables and views used by procedures that <code>your_proc</code> calls.</p><p>To get the dependencies in the correct order, the tables have been walked following the foreign key chain and all
views go after all tables.  The views are stitched together.  The business of diving into views/tables/triggers and
maintainence of the found items is done by the callback function <code>found_table_or_view</code>.  The actual source
is more descriptive comments than code but the code is included here as it is brief.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// comments elided for brevity, the why of all this is described in the code</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void found_table_or_view(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR _Nonnull table_or_view_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *_Nonnull table_or_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable context)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  dummy_test_info *info = (dummy_test_info *)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool deleted = table_or_view-&gt;sem-&gt;delete_version &gt; 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!deleted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    continue_find_table_node(info-&gt;callbacks, table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_create_view_stmt(table_or_view)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      add_item_to_list(&amp;info-&gt;found_views, table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      add_item_to_list(&amp;info-&gt;found_tables, table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    find_all_triggers_node(info, table_or_view_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The general purpose walker notifies exactly once on each visited table/view and <code>continue_find_table_node</code> is used to
dive into the bodies of views/tables that would otherwise not be searched.  Likewise <code>find_all_triggers_node</code>
dives into the body of any triggers that are on the found item.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="emitting-indices-and-triggers"></a>Emitting Indices and Triggers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#emitting-indices-and-triggers" title="Direct link to heading">#</a></h4><p>With the &quot;found tables&quot; computed (creatively stored in a field called <code>found_tables</code>) it&#x27;s very easy to loop over these
and generate the necessary indices for each found table (keeping in mind the &quot;found table&quot; can be a view).</p><p>The <code>create index statement</code> is emitted by the usual <code>gen_statement_with_callbacks</code> form that echos the AST.</p><p>The <code>drop index</code> can be trivially created by name.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit create and drop index statement for all indexes on a table.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_emit_index_stmt(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR table_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *gen_create_indexes,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *gen_drop_indexes,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callbacks *callback)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_entry *indexes_entry = symtab_find(all_tables_with_indexes, table_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf *buf = indexes_entry ? (bytebuf *)indexes_entry-&gt;val : NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node **indexes_ast = buf ? (ast_node **)buf-&gt;ptr : NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t count = buf ? buf-&gt;used / sizeof(*indexes_ast) : 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_set_output_buffer(gen_create_indexes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int32_t i = 0; i &lt; count; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *index_ast = indexes_ast[i];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(create_index_stmt, index_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(create_index_on_list, create_index_stmt-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(index_name_ast, create_index_on_list-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(index_name, index_name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_statement_with_callbacks(index_ast, callback);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(gen_create_indexes, &quot;;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(gen_drop_indexes, &quot;DROP INDEX IF EXISTS %s;\n&quot;, index_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Triggers are done in exactly the same way except that instead of looping over found tables we can
actually generate them as they are discovered inside of <code>find_all_triggers_node</code>.  Recal that we
had to visit the triggers when computing the found tables anyway.  We did not have to visit the indices
hence the difference.</p><p>These walks allow us to produce: <code>test_your_proc_create_indexes</code>, <code>test_your_proc_drop_indexes</code>, <code>test_your_proc_create_triggers</code>, <code>test_your_proc_drop_triggers</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="emitting-tables-and-views"></a>Emitting Tables and Views<a aria-hidden="true" tabindex="-1" class="hash-link" href="#emitting-tables-and-views" title="Direct link to heading">#</a></h4><p>Starting from the found tables, again it is very easy to generate the code to create and drop the tables and views.  The only trick here is that the
tables depend on one another so order is important.  The tables are discovered with the deepest dependency first, new found items are added to the head
of the found tables but it&#x27;s a post-order walk so that means that the deepest tables/views are at the front of the list.  This means the list
is naturally in the order that it needs to be to delete the tables (parent tables at the end).  So the algorithm goes like this:</p><ul><li>emit the drop tables/views in the found order</li><li>reverse the list</li><li>emit the create tables/views in the reverse order</li><li>for each table/view emit the reader `test<em>your_proc_read</em>[item]</li><li>for tables we emit an insertion fragment into <code>test_your_proc_populate_tables</code> using <code>cg_dummy_test_populate</code><ul><li>population is discussed in the following sections</li></ul></li></ul><p>As in the other cases <code>gen_statement_with_callbacks</code> is used to create the DDL statements:</p><ul><li><code>CREATE TABLE</code></li><li><code>CREATE VIEW</code></li><li><code>CREATE VIRTUAL TABLE</code></li></ul><p>The delete side is easily created with ad hoc <code>DROP TABLE</code> or <code>DROP VIEW</code> statements.</p><p>The reading procedure is always of the form <code>SELECT * FROM foo</code> so that too is trivial to generate with a fixed template.  The &quot;echoing&quot; system
once again is doing a lot of the heavy lifting.</p><p>These walks give us <code>test_your_proc_create_tables</code>, <code>test_your_proc_drop_tables</code>, and <code>test_your_proc_read_[item]</code> and drive the population process</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="gathering-ad-hoc-data-to-be-inserted"></a>Gathering Ad Hoc Data To Be Inserted<a aria-hidden="true" tabindex="-1" class="hash-link" href="#gathering-ad-hoc-data-to-be-inserted" title="Direct link to heading">#</a></h4><p>Before we get into the mechanics of the population code, we have to visit one more area.  It&#x27;s possible to include data in the the
<code>dummy_test</code> annotaiton itself.  This is data that you want to have populated.  This data will be included in the overall data populator.
If there is enough of it (at least 2 rows per candidate table) then it might be all the data you get.  Now the data format here is
not designed to be fully general, after all it&#x27;s not that hard to just write <code>INSERT ... VALUES</code> for all your tables anyway.  The goal
is to provide something that will help you not have to remember all the FK relationships and maybe let you economically specify some leaf
data you need and get the rest for free.  It&#x27;s also possible to manually create dummy data that just won&#x27;t work, again, scrubbing all
this is way beyond the ability of a simple test helper.  When the code runs you&#x27;ll get SQLite errors which can be readily addressed.</p><p>So keeping in mind this sort of &quot;entry level data support&quot; as the goal, we can take a look at how the system works -- it&#x27;s all
in the function <code>collect_dummy_test_info</code> which includes this helpful comment on structure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the data attribute looks kind of like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// @attribute(cql:autotest = (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   .. other auto test attributes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   (dummy_test,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     (table_name1, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     (table_name2, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   .. other auto test attributes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// we&#x27;re concerned with the dummy_test entries here, they have a very specific format</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// i.e. first the table then the column names, and then a list of matching columns and values</span></div></div></div></div></div><p>So we&#x27;re going to walk a list of attributes each one begins with a table name, then a list of columns, and then a list of values.</p><p>All of the data is in the symbol table <code>dummy_test_infos</code> which is indexed by table name.  For each table name we find
we ensure there is a symbol table at that slot.  So <code>dummy_test_infos</code> is a symbol table of symbol tables.  It&#x27;s actually
going to be something like <code>value_list = dummy_test_infos[&#x27;table&#x27;][&#x27;column&#x27;]</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // collect table name from dummy_test info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_list = dummy_attr-&gt;left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(table_name, table_list-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *col_syms = symtab_ensure_symtab(dummy_test_infos, table_name);</span></div></div></div></div></div><p>Next we&#x27;re going to find the column names, they are the next entry in the list so we go <code>right</code> to get the <code>column_name_list</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// collect column names from dummy_test info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *column_name_list = table_list-&gt;right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (ast_node *list = column_name_list-&gt;left; list; list = list-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(column_name, list-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t col_type = find_column_type(table_name, column_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // store the column meta data, create space to hold values in databuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf_append_var(&amp;col_data_buf, column_values);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf_append_var(&amp;col_type_buf, col_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf_append_var(&amp;col_name_buf, column_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The primary purpose of this part of the loop is then to add the column names to <code>col_syms</code> so that they are linked to the dummy info for this table.
The line <code>bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);</code> does this.  And this also creates the byte buffer that will hold
the eventual values.</p><p>We also keep a side set of buffers that has the column name, type, and the values in the <code>col_name</code>, <code>col_type</code>, and <code>col_data</code> buffers respectively.
These are used to handle the foreign key work shortly and they allow us to not have to look up all the names over and over.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// collect column value from dummy_test info. We can have multiple rows of column value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (ast_node *values_ast = column_name_list-&gt;right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     values_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     values_ast = values_ast-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t column_index = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // collect one row of column value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *list = values_ast-&gt;left; list; list = list-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *misc_attr_value = list-&gt;left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(col_data_buf.used);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bytebuf *column_values = ((bytebuf **) col_data_buf.ptr)[column_index];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_t column_type = ((sem_t *) col_type_buf.ptr)[column_index];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CSTR column_name = ((CSTR *) col_name_buf.ptr)[column_index];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bytebuf_append_var(column_values, misc_attr_value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    column_index++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...foreign key stuff goes here...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .. some cleanup</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The most important part is <code>bytebuf_append_var(column_values, misc_attr_value);</code> this is where the
attribute value is added to the list of values that are on the column.</p><p>Finally, the &quot;foreign key stuff&quot;.  What we need to do here is check the column name in the table to see if it&#x27;s part of a foreign
key and if it is we recursively add the current data value to the referenced column in the reference table.  That way
if you add an initalizer to a leaf table you don&#x27;t also have to add it to all the parent tables.  If it wasn&#x27;t for this
feature the manual data wouldn&#x27;t be very useful at all, hand written <code>INSERT</code> statements would be just as good.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If a column value is added to dummy_test info for a foreign key column then</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// we need to make sure that same column value is also added as a value in the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the referenced table&#x27;s dummy_test info.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// e.g.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   create table A(id integer primary key);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   create table B(id integer primary key references A(id));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is sample data provided for B.id then we must also ensure that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the value provided for B.id is also add as a sample row in A with the same</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// value for id.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (is_foreign_key(column_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_value_to_referenced_table(table_name, column_name, column_type, misc_attr_value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>When this is a done all of the initializers will have been added to the appropriate column of the appropriate table.
Again the overall structure is something like: <code>value_list = dummy_test_infos[&#x27;table&#x27;][&#x27;column&#x27;]</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="emitting-the-table-population-fragments"></a>Emitting the Table Population Fragments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#emitting-the-table-population-fragments" title="Direct link to heading">#</a></h4><p>With any custom initalizers in the <code>dummy_test_infos</code> structure we can do the population fragment for any given table.</p><p>The general algorithm here goes like this:</p><ul><li>the total number of rows we will generate will be the number of column values in the initializers or else <code>DUMMY_TEST_INSERT_ROWS</code>, whichever is larger</li><li>the insert statement generated will include <code>dummy_seed([value_seed])</code> where value_seed starts at 123 and goes up 1 for every row generated<ul><li>dummy_seed will create values for any missing columns using the seed so any combination of included columns is ok, we&#x27;ll always get a complete insert</li></ul></li><li>foreign key columns use a provided intializer from the parent table if there is one, or else they use 1, 2, 3 etc.<ul><li>likewise if a column is referenceable by some other table it uses the known sequence 1, 2, 3 etc. for its value rather than the varying seed</li><li>in this way child tables can know that partent tables will have a value they can use since both tables will have at least <code>DUMMY_TEST_INSERT_ROWS</code> and any rows that were not manually initialized will match</li><li>note that foreign key columns always get this treatment, whether they were mentioned or not</li></ul></li><li>to mix things up the <code>dummy_nullables</code> and <code>dummy_defaults</code> are added on every other row which makes missing values be NULL and/or the default value if one is present</li></ul><p>This is enough to generate a set of insert statements for the table in question and since the fragments are generated in the table creation order the resulting insert statements will have the parent tables first so the foreign keys of later tables will be correct.</p><p>This can go wrong if the manual initializations use keys that conflict with the default generation or if the manual intializations have PK conflicts or other such things.  No attempt is made to sort that out.  The run time errors should be clear and these are, after all, only test helpers.  It&#x27;s very easy to avoid these hazards
and you get a pretty clear error message if you don&#x27;t so that seems good enough.</p><p>These fragments are ultimately combined to make the body of the procedure <code>test_your_proc_populate_tables</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>The test helpers in <code>cg_test_helpers.c</code> are very simple nearly-constant templates with the exception of <code>dummy_test</code> which includes:</p><ul><li>table and view creation</li><li>index creation</li><li>trigger creation</li><li>data population</li></ul><p>Topics covered included:</p><ul><li>how the candidate procedures are discovered</li><li>how the attributes are scanned for test directives</li><li>how each dummy test type is dispatched</li><li>how <code>dummy_test</code> handles data initialization</li><li>how <code>dummy_test</code> does its dependency analysis</li></ul><p>As with the other parts, no attempt was made to cover every function in detail.  That is
best done by reading the source code. But there is overall structure here and an understanding
of the basic principles is helpful before diving into the source code.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-05-03T21:36:45.000Z" class="docLastUpdatedAt_217_">5/3/2022</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int07"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 7: JSON Generation</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#test-helpers" class="table-of-contents__link">Test Helpers</a><ul><li><a href="#initialization" class="table-of-contents__link">Initialization</a></li><li><a href="#dummy-table-dummy-insert-dummy-select-dummy-result-set" class="table-of-contents__link">Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set</a></li><li><a href="#dummy-test" class="table-of-contents__link">Dummy Test</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/metaOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Meta Platforms Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2022 Meta Platforms, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.58a786a3.js"></script>
<script src="/runtime~main.1fab1047.js"></script>
<script src="/main.f2c34c0c.js"></script>
<script src="/1.fae5e295.js"></script>
<script src="/2.0eb37f9a.js"></script>
<script src="/3.5c2742cc.js"></script>
<script src="/1be78505.bc52d199.js"></script>
<script src="/106.5c1aa3b0.js"></script>
<script src="/5456faf3.c3a29041.js"></script>
<script src="/17896441.5a19be7f.js"></script>
<script src="/21c29d6a.4a037561.js"></script>
</body>
</html>