<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 3: C Code Generation | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 3: C Code Generation | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int03"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int03"><link rel="stylesheet" href="/styles.efe3e8f9.css">
<link rel="preload" href="/styles.4a61b4b3.js" as="script">
<link rel="preload" href="/runtime~main.bb0a59ae.js" as="script">
<link rel="preload" href="/main.9cd58f71.js" as="script">
<link rel="preload" href="/1.bac24c28.js" as="script">
<link rel="preload" href="/2.29ab4659.js" as="script">
<link rel="preload" href="/3.9ee6d42d.js" as="script">
<link rel="preload" href="/1be78505.ae32d621.js" as="script">
<link rel="preload" href="/87.9cf8ff91.js" as="script">
<link rel="preload" href="/5456faf3.d3330067.js" as="script">
<link rel="preload" href="/17896441.923fd9c6.js" as="script">
<link rel="preload" href="/c27d1879.2061e017.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 3: C Code Generation</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every detail of code generation but rather to give
a sense of how codegen happens in general -- the core strategies and implementation choices --
so that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish
this, various key data structures will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="c-code-generation"></a>C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#c-code-generation" title="Direct link to heading">#</a></h2><p>There are several key pieces of C code that we have to generate to make working CQL procedures using C
functions.  This all happens in <code>cg_c.c</code>.  From a big picture perspective, these are the essential problems:</p><ul><li>we have to compile SQL expressions into C<ul><li>including expressions with variables that are nullable</li><li>including SQL expressions that are highly complex like <code>CASE..WHEN..THEN..END</code> and <code>IN (..)</code></li></ul></li><li>we have to generate control flow for things like <code>IF</code>, <code>WHILE</code> and, <code>SWITCH</code></li><li>we have to make result sets<ul><li>including the code to slurp up all the rows from a SQL statement into an array of values</li><li>we want to do this very economically</li></ul></li><li>we have to be able to create the text for every SQLite statement and bind any variables to it</li><li>we have to check every SQLite API for errors and throw exceptions consistently and deal with them<ul><li>including constructs that allow users to handle exceptions, such as <code>TRY/CATCH</code></li></ul></li><li>we have to track any reference types carefully so that retain/release pairs are done consistently<ul><li>even in the presence of SQLite errors or other exceptions</li></ul></li><li>we have to produce a <code>.h</code> and a <code>.c</code> file for the C compiler<ul><li>contributions to these files could come from various places</li><li>the <code>.c</code> file will itself have various sections and we might need to contribute to them at various points in the compilation</li></ul></li><li>we want to do this all in one pass over the AST</li><li>we get to assume that the program is error free, codegen never runs unless semantic analysis reports zero errors<ul><li>so nothing can be wrong by the time the codegen pass runs, we never detect errors here</li><li>sometimes we add <code>Contract</code> and <code>Invariant</code> statements to <code>cg.c</code> that make our assumptions clear and prevent regressions</li></ul></li></ul><p>There are some very important building blocks used to solve these problems we will start with those, then move to
a discussion of each of the essential kinds of code generation that we have to do to get working programs.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="character-buffers-and-byte-buffers"></a>Character Buffers and Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#character-buffers-and-byte-buffers" title="Direct link to heading">#</a></h3><p>The first kind of text output that CQL could produce was the AST echoing.  This was original done directly with <code>fprintf</code> but
that was not flexible enough as the output had to be captured to be emitted into other places like comments or the text of
SQL statements to go to SQLite.  This forces that pass to use character buffers, which we touched on in Part 1.  Code generation
has a more profound dependency on character buffers -- they are literally all over <code>cg_c.c</code> and we need to go over how hey are used.</p><p>The public interace is in <code>charbuf.h</code> and it&#x27;s really quite simple.  You allocate a <code>charbuf</code> and then you can <code>bprintf</code> into it.
Let&#x27;s be a bit more specific:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_INTERNAL_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_GROWTH_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct charbuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char *ptr;      // pointer to stored data, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t used;  // bytes used in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t max;   // max bytes in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // builtin buffer storage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char internal[CHARBUF_INTERNAL_SIZE];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} charbuf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( int32_t charbuf_open_count );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bopen(charbuf* b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bclose(charbuf *b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bprintf(charbuf *b, const char *format, ...);</span></div></div></div></div></div><p>The typical pattern goes something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf foo;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;foo);</span></div></div></div></div></div><p>Note that <code>charbuf</code> includes <code>CHARBUF_INTERNAL_SIZE</code> of storage that does not
have to be allocated with <code>malloc</code> and it doesn&#x27;t grow very aggressively.
This reflects that fact that most <code>charbuf</code> instances are very small.
Of course a <code>charbuf</code> could go on the heap if it needs to outlive
the function it appears in, but this is exceedingly rare.</p><p>To make sure buffers are consistently closed (and this is a problem because
there are often a lot of them.  They are allocated with these simple helper
macros.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_OPEN(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t __saved_charbuf_count##x = charbuf_open_count; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf x; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_CLOSE(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;x); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(__saved_charbuf_count##x == charbuf_open_count)</span></div></div></div></div></div><p>the earlier example would be written more properly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(foo);</span></div></div></div></div></div><p>If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure.</p><p>It&#x27;s normal to create several buffers in the course of doing code generation.  In fact some of these buffers
become &quot;globally&quot; visible and get swapped out as needed.  For instance this kind of chaining is normal.
Inside of <code>cg_create_proc_stmt</code> there is these sequence:</p><p>Make new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_fwd_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_body);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_cleanup);</span></div></div></div></div></div><p>Save what we got...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_main = cg_main_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_decls = cg_declarations_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_scratch = cg_scratch_vars_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_cleanup = cg_cleanup_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_fwd_ref = cg_fwd_ref_output;</span></div></div></div></div></div><p>Switch to the new...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fwd_ref_output = &amp;proc_fwd_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_main_output = &amp;proc_body;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_declarations_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_vars_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_cleanup_output = &amp;proc_cleanup;</span></div></div></div></div></div><p>And of course the code puts the original values back when it&#x27;s done and closes the buffers.</p><p>This means that while processing a procedure the codegen that declares say scratch variables,
which would go to <code>cg_scratch_vars_output</code> is going to target the <code>proc_locals</code> buffer
which will be emitted before the <code>body</code>.  By the time <code>cg_stmt_list</code> is invoked the
<code>cg_main_output</code> variable will be pointing to the procedure body, thus any statements
will go into there rather than being acculated at the global level -- it&#x27;s possible to
have code that is not in a procedure (see <a href="https://cgsql.dev/cql-guide/x1#--global_proc-name" target="_blank" rel="noopener noreferrer"><code>--global_proc</code></a>).</p><p>But in general, it&#x27;s very useful to have different buffers going on at the same time.  New local variables
or scratch variables can be added to their own buffer which goes before the code runs.  New cleanup
steps that are necessary can be added to the cleanup output which will appear at the end.  The final
function combines all of these pieces with maybe some glue.  Everything works like this, <code>IF</code> statements,
expressions, all of it.</p><p>One interesting but unexpected feature of <code>charbuf</code> is that it provides helper methods for indenting
buffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C
code because of course you want (e.g.) the body of an <code>if</code> statement to be indented.  CQL tries to create
well formatted code that is readable by humans as much as possible.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="byte-buffers"></a>Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#byte-buffers" title="Direct link to heading">#</a></h4><p>These are less commonly used but there is a peer to <code>charbuf</code> creatively called <code>bytebuf</code>.  This gives you
a growable binary buffer.  It&#x27;s often used to hold arrays of structures.  Interestingly, <code>cg_c.c</code> doesn&#x27;t
currently consume byte buffers, the presence of <code>bytebuf.c</code> actually came late to the CQL compiler. However
the CQL runtime <code>cqlrt.c</code> (and <code>cqlrt_common.c</code>) provide <code>cql_bytebuf_open</code>, <code>cql_bytebuf_alloc</code> and,
<code>cql_bytebuf_close</code> which are akin to the <code>charbuf</code> methods.  These functions are used in the generated
code to create result sets at runtime.  The <code>bytebuf</code> was so useful that it found its way back from the
runtime into the compiler itself, and is used by other code-generators like the schema upgrader.   The
semantic analyzer also uses it to help with query fragments and to track the various upgrade annotations.</p><p>Both <code>charbuf</code> and <code>bytebuf</code> are simple enough that they don&#x27;t need discussion. It&#x27;s easier to just read
the code and the comments.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expressions"></a>Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expressions" title="Direct link to heading">#</a></h3><p>Many of the output needs of CQL stemmed from the base case of creating expressions.  A simple CQL
expression like</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>seems innocuous enough, we&#x27;d like this to compile to this code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div></div></div></div></div><p>And indeed, it might.  Here&#x27;s some actual output from the compiler:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>(*) the output above was created by using <code>out/cql --in x --cg x.h x.c --nolines</code> to avoid all the # directives</p><p>Looks easy enough.  And indeed if all expressions were like this, you could do expression compilation pretty simply --
every binary operator would look something like this:</p><ul><li>recurse left</li><li>emit infix operator</li><li>recurse right</li></ul><p>This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have
the whole expression.</p><p>This doesn&#x27;t work at all.  To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result
is telling:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>All that&#x27;s happened in the above is that <code>x</code> and <code>y</code> became nullable variables, that is the <code>NOT NULL</code> was
removed from the declaration.  This makes all the difference in the world, and this is a fairly easy case.
The problem is that nullable value types like cql_nullable_int32 have an integer and a boolean and these
don&#x27;t flow into expressions that use operators like <code>+</code>, <code>-</code>, <code>/</code> and so forth.  This means that even
simple expressions involving nullable types actually expand into several statements.  And, in general,
these statements need a place to put their temporary results to accumulate the answer, so scratch variables
are required to make all this work.</p><p>Here&#x27;s a more realistic example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET result := 5 * x + 3 * y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;combine&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)result, 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(*result); // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div></div></div></div></div><ul><li><code>_tmp_n_int_1</code> holds the product of x and 5, it&#x27;s null if <code>x.is_null</code> is true</li><li><code>_tmp_n_int_2</code> holds the product of y and 3, it&#x27;s null if <code>y.is_null</code> is true</li><li><code>*result</code> holds the answer, it&#x27;s null if either of <code>_tmp_n_int_1.is_null</code>, <code>_tmp_n_int_2.is_null</code> is true<ul><li>otherwise it&#x27;s <code>_tmp_n_int_1.value + _tmp_n_int_2.value</code></li></ul></li></ul><p>So, in general, we need to emit arbitarily many statements in the course of evaluating even simple looking expressions
and we need good mechanisms to manage that.  This is what we&#x27;ll talk about in the coming sections.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="managing-scratch-variables"></a>Managing Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#managing-scratch-variables" title="Direct link to heading">#</a></h4><p>The function that actually assigns scratch variables is <code>cg_scratch_var</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch variable helper uses the given sem_type and the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stack level to create a temporary variable name for that type at that level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the variable does not already have a declaration (as determined by the masks)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// then a declaration is added to the scratch_vars section.  This is one of the root</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ways of getting an .is_null and .value back.  Note that not null variables always</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// have a .is_null of &quot;0&quot; which becomes important when deciding how to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// one result to another.  Everything stays uniform.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)</span></div></div></div></div></div><p>The signature is a bit unexpected so we&#x27;ll go over this, some of this will make more
sense as we learn about expressions generally but this is as good an introduction as any.</p><ul><li><code>ast</code> holds a reference to a variable we want to assign to, this is normally <code>NULL</code> for scratch variables, it&#x27;s not null for the <code>RESULT</code> macros which we&#x27;ll study later, so for now ignore this</li><li><code>sem_type</code> holds the type of the variable we need, it must be a unitary type, optionally with <code>SEM_TYPE_NOTNULL</code> set</li><li><code>var</code> is a character buffer that will get the name of the variable</li><li><code>is_null</code> is a character buffer that will get the <code>is_null</code> expression for this variable (more below)</li><li><code>value</code> is a character buffer that will get the <code>value</code> expression for this variable (more below)</li></ul><p>And this is a good time to talk about <code>is_null</code> and <code>value</code> because they will be everywhere.</p><p>Every expression evaluation in the C code generator has two essential results, the text that corresponds to the current
value so far (e.g. &quot;(1+2)*3&quot;) and the text for the current expression that will tell you if the result is null,
this could be as simple as &quot;0&quot; for a expression that is known to be not null.  So let&#x27;s make this a little more concrete:</p><p>Suppose you ask for a scratch not null integer we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_n_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;0&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_n_int_1&quot;</code></li></ul><p>Meaning: if you want the value, use the text &quot;_tmp_n_int_1&quot; if you want to know if the variable is null, use the text &quot;0&quot;
Note: many parts of <code>cg_c.c</code> special case an <code>is_null</code> value of <code>&quot;0&quot;</code> to make better code because such a thing is known to
be not null at compile time.</p><p>Now let&#x27;s suppose you ask for a scratch nullable integer, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;_tmp_int_1.is_null&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_int_1.value&quot;</code></li></ul><p>So again, you have exactly the text you need to test for null and the test you need to get the value.</p><p>Additional notes:</p><ul><li>scratch variables can be re-used, they are on a &quot;stack&quot;</li><li>a bitmask is used to track which scratch variables have aleady had a declaration emitted, so they are only declared once</li><li>the variable name is based on the current value of the <code>stack_level</code> variable which is increased in a push/pop fashion as temporaries come in and out of scope</li><li>this strategy isn&#x27;t perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad</li><li>importantly there is one stacklevel variable for all temporaries not one stacklevel for every type of temporary, this seemed like a reasonable simplification</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocating-scratch-variables"></a>Allocating Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocating-scratch-variables" title="Direct link to heading">#</a></h4><p>The most common reason for a scratch variable is that a temporary is needed for some part of the computation.
The most common reason for a temporary variable is to hold an intermediate result of a computation involving
nullable arithmetic.</p><p>These temporaries are created with <code>CG_PUSH_TEMP</code> which simply creates the three <code>charbuf</code> variables you need and then asks for a
scratch variable of the type you need.  The variables follow a simple naming convention.  The stack level is increased.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the text needed to refer to the variable.  cg_scratch_var picks the name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// based on stack level-and type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_TEMP(name, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(NULL, sem_type, &amp;name, &amp;name##_is_null, &amp;name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>Symetrically, <code>CG_POP_TEMP</code> releases the charbufs and restores the stack level.  As with the other macros, these are designed to
make it impossible to forget to free your buffers or get the stack wrong.  In fact, the stack is checked at strategic places
to ensure its back to baseline.  You can always just snapshot <code>stacklevel</code>, do some work that should be clean, and then
add an <code>Invariant</code> that <code>stacklevel</code> is back to where it was.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffers for the temporary, restore the stack level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_TEMP(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level--;</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursing-sub-expressions"></a>Recursing Sub-expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursing-sub-expressions" title="Direct link to heading">#</a></h4><p>Now that we understand that we can create scratch variables as needed, it&#x27;s time to take a look at the typical evaluation patterns
and how the evaluation works within that pattern.  This is everywhere in <code>cg_c.c</code>.</p><p>So let&#x27;s look at an actual evaluator, the simplest of them all, this one does code generation for the <code>NULL</code> literal.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_null(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(expr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(value, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Now this may be looking familiar.  The signature of the code generator is very much like the signature of the semantic
analyzer for the same AST fragment.</p><ul><li><code>expr</code> : the AST we are generating code for</li><li><code>op</code> : the relevant operator if any (operators share code)</li><li><code>is_null</code> : a <code>charbuf</code> into which we can write the <code>is_null</code> expression text</li><li><code>value</code> : a <code>charbuf</code> into which we can write the <code>value</code> expression text</li><li><code>pri</code> : the binding strength of the node above this one</li><li><code>pri_new</code> : the binding strength of this node</li></ul><p><code>pri</code> and <code>pri_new</code> work exactly like they did in the echoing code (Part 1), they are used to allow the codegen
to decide if it needs to emit parentheses.  Note that the binding strengths now will be the C binding strengths
NOT the SQL binding strengths.  The placement of parens frequently has to change because the order of operations
is different in C.  For instance in SQL <code>NOT</code> is very weak but in C logical not (<code>!</code>) is very strong.</p><p>This particular generator is going to produce <code>&quot;NULL&quot;</code> for the value and <code>&quot;1&quot;</code> for the is_null expression.</p><p>The caller will use these to create its own expression results.</p><p>Let&#x27;s look at one of the simplest examples, this is the <code>IS NULL</code> operator handled by <code>cg_expr_is_null</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The code-gen for is_null is one of the easiest.  The recursive call</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// produces is_null as one of the outputs.  Use that.  Our is_null result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is always zero because IS NULL is never, itself, null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_expr = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // expr IS NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;0&quot;); // the result of is null is never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The fact that this is not constant not null for not null reference types reflects</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the weird state of affairs with uninitualized reference variables which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be null even if they are typed not null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_not_nullable(sem_type_expr) &amp;&amp; !is_ref_type(sem_type_expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Note, sql has no side-effects so we can fold this away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;0&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;%s&quot;, expr_is_null.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>So walking through this:</p><ul><li>the result of <code>IS NULL</code> is never null, so we can immediately put &quot;0&quot; into the <code>is_null</code> buffer</li><li>if the operand is a not-null numeric type then the result of <code>IS NULL</code> is <code>0</code></li><li>if the operand might actually be null then<ul><li>use <code>CG_PUSH_EVAL</code> to recursively do codegen for it</li><li>copy its <code>expr_is_null</code> text into our <code>value</code> text</li></ul></li></ul><p>Note: the code reveals one of the big CQL secrets that not null reference variables can be null...  C has the same issue with <code>_Nonnull</code> globals.</p><p>Now let&#x27;s look at those helper macros, they are pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical naming convention</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// burn the stack slot so that any type and numbered temporary that was needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// won&#x27;t be re-used until this scope is over.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>The push macro simply creates buffers to hold the <code>is_null</code> and <code>value</code> results, then it calls <code>cg_expr</code> to dispatch the indicated expression.
The <code>pri</code> value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is your <code>pri_new</code>
value but often you can use <code>C_EXPR_PRI_ROOT</code> if you know that, because of your current context, the callee will never need parentheses.</p><p>How do we know this here? It seems like the operand of <code>IS NULL</code> could be anything surely it might need parentheses?  Let&#x27;s consider:</p><ul><li>if the operand is of not null numeric type then we aren&#x27;t even going to evaluate it, we&#x27;re on the easy &quot;no it&#x27;s not null&quot; path</li><li>if the operand is nullable then the only place the answer can be stored is in a scratch variable and its <code>is_null</code> expression will be exactly like <code>var.is_null</code></li><li>if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is <code>is_null</code> expression will be like <code>!var</code></li></ul><p>None of these require further wrapping regardless of what is above this node in the tree because of he strength of the <code>.</code> and <code>!</code> operators.</p><p>Other cases are usually simpler, such as &quot;no parentheses need to be added by the child node becasue it will be used as the argument to a helper
function so there will always be parens hard-coded anyway&quot;.  However these things need to be carefully tested hence the huge variety of codegen tests.</p><p>Note that after calling <code>cg_expr</code> the stack level was artificially increased.  We&#x27;ll get to that in the next section.  For now, looking at <code>POP_EVAL</code> we
can see it&#x27;s very straightforward:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Close the buffers used for the above.  Return the stack level to its original state.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Numbered scratch variables are re-used as though they were a stack.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_EVAL(expr) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level--;</span></div></div></div></div></div><p><code>CG_POP_EVAL</code> simply closes the buffers and restores the stack.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-variables"></a>Result Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-variables" title="Direct link to heading">#</a></h4><p>When recursion happens in the codegen, the common place that the result will be found is
in a temporary variable -- the generated code will use one or more statements to arrange for the correct
answer to be in that variable.  To do this, the codegen needs to first get the name of a suitable
result variable of a suitable type.  This is the &quot;other&quot; reason for making scratch variables.</p><p>There are three macros that make this pretty simple.  The first is <code>CG_RESERVE_RESULT_VAR</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a scratch variable to hold the final result of an evaluation.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// It may or may not be used.  It should be the first thing you put</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// so that it is on the top of your stack.  This only saves the slot.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_RESERVE_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_reserved = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">sem_t sem_type_reserved = sem_type; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *ast_reserved = ast; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>If this looks a lot like <code>PUSH_TEMP</code> that shouldn&#x27;t be surprising.  The name of the variable
and the expression parts always go into <code>charbuf</code> variables named <code>result_var</code> <code>result_var_is_null</code> and <code>result_var_value</code>
but the scratch variable isn&#x27;t actually allocated!  However -- we burn the stack_level as though it had been
allocated.  What&#x27;s up with that?</p><p>The name might be a clue, this macro reserves stack level slot for the result variable, it&#x27;s used if you might
need a result variable, but you might not.  When you want it we can artificially move the stack level back
to this spot where the slot was burned, allocate the scratch variable, and then put the stack back.
The <code>CG_USE_RESULT_VAR</code> macro does exactly that.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable is going to be used, this writes its name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and .value and .is_null into the is_null and value fields.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_USE_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_now = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_reserved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_now; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Invariant(result_var.used &gt; 1); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(is_null, &quot;%s&quot;, result_var_is_null.ptr); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(value, &quot;%s&quot;, result_var_value.ptr)</span></div></div></div></div></div><p>Once the code generator decides that it will in fact be using a result variable to represent the answer, then
the <code>is_null</code> and <code>value</code> buffers can be immediately populated to whatever the values were
for the result variable.  That text will be correct regardless of what codegen is used
to populate the variable.</p><p>There is a simpler macro that reserves and uses the result variable in one step, it&#x27;s very common.  The
&quot;reserve&quot; pattern is only necessary when there are some paths that need a result variable and some
that don&#x27;t.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This does reserve and use in one step</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_SETUP_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CG_RESERVE_RESULT_VAR(ast, sem_type); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CG_USE_RESULT_VAR();</span></div></div></div></div></div><p>And now armed with this knowledge we can go back to a previous mystery, let&#x27;s look at <code>CG_PUSH_EVAL</code> again</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical naming convention</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// burn the stack slot so that any type and numbered temporary that was needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// won&#x27;t be re-used until this scope is over.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>The reason that <code>CG_PUSH_EVAL</code> includes <code>stack_level++</code> is that it is entirely possible, even likely,
that the result of <code>cg_expr</code> is in a result variable.  The convention is that if the codegen
requires a result variable it is allocated <em>first</em> before any other temporaries.  This is why
there is a way to reserve a variable that you <em>might</em> need.  When the codegen is complete,
and before anything else happens, <code>stack_level</code> is increased so that the temporary that is
holding the result will not be re-used!  Any other temporaries are available but the result
is still live.  This might be easy to get wrong but the macros make it easy to get it right.</p><p>Now, armed with the knowledge that there a result variables and temporary variables and both
come from the scratch variable we can resolve the last mystery we left hanging.  Why does
the scratch variable API accept an AST pointer?</p><p>The only place that pointer can be not null is in the <code>CG_USE_RESULT_VAR</code> macro, it was
this line:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value);</span></div></div></div></div></div><p>And <code>ast_reserved</code> refers to the AST that we are trying to evaluate.  There&#x27;s an important
special case that we want to optimize that saves a lot of scratch variables.  It&#x27;s handled
by this code in <code>cg_scratch_var</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_assignment_target_reusable(ast, sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(ast &amp;&amp; ast-&gt;parent &amp;&amp; ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_out_parameter(name_ast-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;*%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The idea is that if the generator is doing an assignment like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := a + b;</span></div></div></div></div></div><p>Then the code generator doesn&#x27;t need a scratch variable to hold the result of the expression <code>a + b</code> like it would
in many other contexts.  It can use <code>x</code> as the result variable!  The <code>SET</code> codegen will discover
that the value it&#x27;s supposed to set is already in <code>x</code> so it does nothing and everything just
works out.  The price of this is a call to <code>is_assignment_target_reusable</code> and then some
logic to handle the case where <code>x</code> is an out argument (hence call by reference, hence needs to be used as <code>*x</code>).</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-08-19T17:45:00.000Z" class="docLastUpdatedAt_217_">8/19/2021</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int02"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 2: Semantic Analysis</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#c-code-generation" class="table-of-contents__link">C Code Generation</a><ul><li><a href="#character-buffers-and-byte-buffers" class="table-of-contents__link">Character Buffers and Byte Buffers</a></li><li><a href="#expressions" class="table-of-contents__link">Expressions</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Facebook Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2021 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4a61b4b3.js"></script>
<script src="/runtime~main.bb0a59ae.js"></script>
<script src="/main.9cd58f71.js"></script>
<script src="/1.bac24c28.js"></script>
<script src="/2.29ab4659.js"></script>
<script src="/3.9ee6d42d.js"></script>
<script src="/1be78505.ae32d621.js"></script>
<script src="/87.9cf8ff91.js"></script>
<script src="/5456faf3.d3330067.js"></script>
<script src="/17896441.923fd9c6.js"></script>
<script src="/c27d1879.2061e017.js"></script>
</body>
</html>