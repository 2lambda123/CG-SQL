<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 3: C Code Generation | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 3: C Code Generation | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int03"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int03"><link rel="stylesheet" href="/styles.4959ceee.css">
<link rel="preload" href="/styles.5dc5ab0d.js" as="script">
<link rel="preload" href="/runtime~main.92784f52.js" as="script">
<link rel="preload" href="/main.2de251bc.js" as="script">
<link rel="preload" href="/1.cd5cf55e.js" as="script">
<link rel="preload" href="/2.004730db.js" as="script">
<link rel="preload" href="/3.8420923d.js" as="script">
<link rel="preload" href="/1be78505.4576dc45.js" as="script">
<link rel="preload" href="/95.e85dd30d.js" as="script">
<link rel="preload" href="/5456faf3.095cdb83.js" as="script">
<link rel="preload" href="/17896441.652528aa.js" as="script">
<link rel="preload" href="/c27d1879.91567b92.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x10">Appendix 10: CQL Working Example</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int04">Part 4: Testing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int05">Part 5: CQL Runtime</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int06">Part 6: Schema Management</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int07">Part 7: JSON Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int08">Part 8: Test Helpers</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 3: C Code Generation</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every detail of code generation but rather to give
a sense of how codegen happens in general -- the core strategies and implementation choices --
so that when reading the code you will have an idea how smaller pieces would fit into the whole. To accomplish
this, various key data structures will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="c-code-generation"></a>C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#c-code-generation" title="Direct link to heading">#</a></h2><p>There are several key pieces of C code that we have to generate to make working CQL procedures using C
functions.  This all happens in <code>cg_c.c</code>.  From a big picture perspective, these are the essential problems:</p><ul><li>we have to compile SQL expressions into C<ul><li>including expressions with variables that are nullable</li><li>including SQL expressions that are highly complex like <code>CASE..WHEN..THEN..END</code> and <code>IN (..)</code></li></ul></li><li>we have to generate control flow for things like <code>IF</code>, <code>WHILE</code> and, <code>SWITCH</code></li><li>we have to make result sets<ul><li>including the code to slurp up all the rows from a SQL statement into an array of values</li><li>we want to do this very economically</li></ul></li><li>we have to be able to create the text for every SQLite statement and bind any variables to it</li><li>we have to check every SQLite API for errors and throw exceptions consistently and deal with them<ul><li>including constructs that allow users to handle exceptions, such as <code>TRY/CATCH</code></li></ul></li><li>we have to track any reference types carefully so that retain/release pairs are done consistently<ul><li>even in the presence of SQLite errors or other exceptions</li></ul></li><li>we have to produce a <code>.h</code> and a <code>.c</code> file for the C compiler<ul><li>contributions to these files could come from various places, not necessarily in order</li><li>the <code>.c</code> file will itself have various sections and we might need to contribute to them at various points in the compilation</li></ul></li><li>we want to do this all in one pass over the AST</li><li>we get to assume that the program is error-free -- codegen never runs unless semantic analysis reports zero errors<ul><li>so nothing can be wrong by the time the codegen pass runs, we never detect errors here</li><li>sometimes we add <code>Contract</code> and <code>Invariant</code> statements to <code>cg.c</code> to make our assumptions clear and to prevent regressions</li></ul></li></ul><p>There are some very important building blocks used to solve these problems: we will start with those, then move to
a discussion of each of the essential kinds of code generation that we have to do to get working programs.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="launching-the-code-generator"></a>Launching the Code Generator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#launching-the-code-generator" title="Direct link to heading">#</a></h3><p>Once semantic analysis is done, all of the code generators have the same contract: they
have a main function like <code>cg_c_main</code> for the C code generator.  It gets the root of
the AST and it can use the public interface of the semantic analyzer to get additional
information.  See <a href="https://cgsql.dev/cql-guide/int02" target="_blank" rel="noopener noreferrer">Part 2</a> for those details.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for code-gen.  This will set up the buffers for the global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variables and any loose calls or DML.  Any code that needs to run in the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// global scope will be added to the global_proc.  This is the only codegen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// error that is possible.  If you need global code and you don&#x27;t have a global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// proc then you can&#x27;t proceed.  Semantic analysis doesn&#x27;t want to know that stuff.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Otherwise all we do is set up the most general buffers for the global case and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// spit out a function with the correct name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_c_main(ast_node *head) { ... }</span></div></div></div></div></div><p>In addition to initializing its scratch storage, the main entry point also sets up a
symbol table for AST dispatch just like the <code>gen_</code> and <code>sem_</code> functions do.  Here
are some samples from that table with the most common options:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_view_stmt);</span></div></div></div></div></div><p>The DDL (Data Definition Language) statements all get the same handling:  The text of the statement
is generated from the AST. Any variables are bound and then the statement is executed.  The work
is done with <code>cg_bound_sql_statement</code> which will be discussed later.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DDL invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We don&#x27;t minify the aliases because DDL can have views and the view column names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can be referred to in users of the view.  Loose select statements can have</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// no external references to column aliases.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_any_ddl_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>DML (Data Manipulation Language) statements are declared similarly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(begin_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(commit_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(rollback_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(savepoint_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(delete_stmt);</span></div></div></div></div></div><p>The DML statements are handled by <code>cg_std_dml_exec_stmt</code>; the processing is identical to
DDL except <code>CG_MINIFY_ALIASES</code> is specified.  This allows the code generator
to remove unused column aliases in <code>SELECT</code> statements to save space.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DML invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_std_dml_exec_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Note that this flag difference only matters for the <code>CREATE VIEW</code> statement
but for symmetry all the DDL is handled with one macro and all the DML
with the second macro.</p><p>Next, the easiest case... there are a bunch of statements that create
no code-gen at all.  These statements are type definitions that are interesting
only to the semantic analyzer, or other control statements.  Some examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_enum_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_named_type);</span></div></div></div></div></div><p>Next, the general purpose statement handler.  <code>STMT_INIT</code> creates mappings
such as the <code>if_stmt</code> AST node mapping to <code>cg_if_stmt</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(assign);</span></div></div></div></div></div><p>The next group of declarations are the expressions, with precedence and operator specified.
There is a lot of code sharing between AST types as you can see from this sample:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, cg_expr_num, &quot;num&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, cg_expr_str, &quot;STR&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, cg_expr_null, &quot;NULL&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, cg_expr_dot, &quot;DOT&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, cg_binary, &quot;*&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(div, cg_binary, &quot;/&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, cg_binary, &quot;%&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(add, cg_binary, &quot;+&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(sub, cg_binary, &quot;-&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, cg_unary, &quot;!&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, cg_unary, &quot;~&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, cg_unary, &quot;-&quot;, C_EXPR_PRI_UNARY);</span></div></div></div></div></div><p>Most (not all) of the binary operators are handled with one function <code>cg_binary</code> and likewise
most unary operators are handled with <code>cg_unary</code>.</p><p>Note: the precedence constants are the <code>C_EXPR_PRI_*</code> flavor because, naturally, parentheses
will be generated based on the C rules during C codegen.  Importantly, the AST still, and always,
authoritatively encodes the user-specified order of operations -- there&#x27;s no change there.  The
only thing that changes is where parentheses are needed to get the desired result.  Some parens
may need to be added, and some that were present in the original text might no longer be needed.</p><p>Here are some helpful examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* NOT is weaker than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET x := (NOT 1) + (NOT 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := NOT 1 + 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* ! is stronger than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! 1 + ! 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! (1 + 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Finally, many built-in functions need special codegen, such as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(coalesce);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div></div></div></div></div><p><code>FUNC_INIT(coalesce)</code> creates a mapping between the function name <code>coalesce</code> and the generator <code>cg_func_coalesce</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="character-buffers-and-byte-buffers"></a>Character Buffers and Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#character-buffers-and-byte-buffers" title="Direct link to heading">#</a></h3><p>The first kind of text output that CQL could produce was the AST echoing.  This was originally done directly with <code>fprintf</code> but
that was never going to be flexible enough -- we have to be able to emit that output into other places like comments, or the text of
SQL statements.  This need forces that pass to use character buffers, which we touched on in Part 1.  C Code generation
has a more profound dependency on character buffers -- they are literally all over <code>cg_c.c</code> and we need to go over how they are used
if we&#x27;re going to understand the codegen passes.</p><p>The public  interface for <code>charbuf</code> is in <code>charbuf.h</code> and it&#x27;s really quite simple.  You allocate a <code>charbuf</code> and then you can
<code>bprintf</code> into it. Let&#x27;s be a bit more specific:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_INTERNAL_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_GROWTH_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct charbuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char *ptr;      // pointer to stored data, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t used;  // bytes used in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t max;   // max bytes in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // builtin buffer storage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char internal[CHARBUF_INTERNAL_SIZE];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} charbuf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( int32_t charbuf_open_count );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bopen(charbuf* b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bclose(charbuf *b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bprintf(charbuf *b, const char *format, ...);</span></div></div></div></div></div><p>The typical pattern goes something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf foo;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;foo);</span></div></div></div></div></div><p>Note that <code>charbuf</code> includes <code>CHARBUF_INTERNAL_SIZE</code> of storage that does not
have to be allocated with <code>malloc</code> and it doesn&#x27;t grow very aggressively.
This economy reflects that fact that most <code>charbuf</code> instances are very small.
Of course a <code>charbuf</code> could go on the heap if it needs to outlive
the function it appears in, but this is exceedingly rare.</p><p>To make sure buffers are consistently closed -- and this is a problem because
there are often a lot of them -- they are allocated with these simple helper
macros:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_OPEN(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t __saved_charbuf_count##x = charbuf_open_count; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf x; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_CLOSE(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;x); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(__saved_charbuf_count##x == charbuf_open_count)</span></div></div></div></div></div><p>The earlier example would be written more properly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(foo);</span></div></div></div></div></div><p>If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure.</p><p>It&#x27;s normal to create several buffers in the course of doing code generation.  In fact some of these buffers
become &quot;globally&quot; visible and get swapped out as needed.  For instance, the kind of chaining we see
inside of <code>cg_create_proc_stmt</code> is normal, here is the sequence:</p><p>Make new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_fwd_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_body);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_cleanup);</span></div></div></div></div></div><p>Save the current buffer pointers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_main = cg_main_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_decls = cg_declarations_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_scratch = cg_scratch_vars_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_cleanup = cg_cleanup_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_fwd_ref = cg_fwd_ref_output;</span></div></div></div></div></div><p>Switch to the new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fwd_ref_output = &amp;proc_fwd_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_main_output = &amp;proc_body;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_declarations_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_vars_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_cleanup_output = &amp;proc_cleanup;</span></div></div></div></div></div><p>And of course the code puts the original values back when it&#x27;s done and then closes what it opened.</p><p>This means that while processing a procedure the codegen that declares say scratch variables,
which would go to <code>cg_scratch_vars_output</code>, is going to target the <code>proc_locals</code> buffer
which will be emitted before the <code>proc_body</code>.  By the time <code>cg_stmt_list</code> is invoked the
<code>cg_main_output</code> variable will be pointing to the procedure body, thus any statements
will go into there rather than being accumulated at the global level.</p><p>Note: it&#x27;s possible to have code that is not in a procedure (see <a href="https://cgsql.dev/cql-guide/x1#--global_proc-name" target="_blank" rel="noopener noreferrer"><code>--global_proc</code></a>).</p><p>In general, it&#x27;s very useful to have different buffers open at the same time.  New local variables
or scratch variables can be added to their own buffer. New cleanup steps that are necessary can be added to
<code>cg_cleanup_output</code> which will appear at the end of a procedure. The final steps of procedure codegen
combines all of these pieces plus a little glue to make a working procedure.</p><p>All codegen works like this -- statements, expressions, all of it.</p><p>One interesting but unexpected feature of <code>charbuf</code> is that it provides helper methods for indenting
a buffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C
code because of course we want (e.g.) the body of an <code>if</code> statement to be indented.  CQL tries to create
well formatted code that is readable by humans as much as possible.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="byte-buffers"></a>Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#byte-buffers" title="Direct link to heading">#</a></h4><p>The byte buffers type, creatively called <code>bytebuf</code> is less commonly used.  It is a peer to <code>charbuf</code>
and provides a growable binary buffer.  <code>bytebuf</code> is often used to hold arrays of structures.
Interestingly, <code>cg_c.c</code> doesn&#x27;t currently consume byte buffers, the presence of <code>bytebuf.c</code> actually
came late to the CQL compiler. However the CQL runtime <code>cqlrt.c</code> (and <code>cqlrt_common.c</code>) provide
<code>cql_bytebuf_open</code>, <code>cql_bytebuf_alloc</code> and, <code>cql_bytebuf_close</code> which are akin to the <code>charbuf</code> methods.
These functions <em>are</em> used in the generated code to create result sets at runtime.</p><p><code>bytebuf</code> was so useful that it found its way back from the runtime into the compiler itself, and is used by
other code-generators like the schema upgraded.   The semantic analyzer also uses it to help with query
fragments and to track the various upgrade annotations.</p><p>Both <code>charbuf</code> and <code>bytebuf</code> are simple enough that they don&#x27;t need special discussion. Surveying
their code and comments is an excellent exercise for the reader.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expressions"></a>Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expressions" title="Direct link to heading">#</a></h3><p>Many of the output needs of CQL stemmed from the base case of creating the code for CQL expressions.
A simple CQL expression like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>seems innocuous enough, and we&#x27;d like that expression to compile to this code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div></div></div></div></div><p>And indeed, it does.  Here&#x27;s some actual output from the compiler:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>(*) the output above was created by using <code>out/cql --in x --cg x.h x.c --nolines</code> to avoid all the <code>#</code> directives</p><p>That expression looks easy enough. And indeed if all expressions were like this, we could do expression compilation
pretty simply -- every binary operator would look something like this:</p><ul><li>recurse left</li><li>emit infix operator</li><li>recurse right</li></ul><p>This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have
the whole expression.</p><p>This doesn&#x27;t work at all.</p><p>To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result is telling:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>In this new example above, <code>x</code> and <code>y</code> became nullable variables i.e. the <code>NOT NULL</code> was
removed from their declarations -- this makes all the difference in the world.</p><p>Let&#x27;s take a quick look at <code>cql_nullable_int32</code> and we&#x27;ll see the crux of the problem immediately:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_nullable_int32 {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> cql_bool is_null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> cql_int32 value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_nullable_int32;</span></div></div></div></div></div><p>The problem is that nullable value types like <code>cql_nullable_int32</code> have both their <code>value</code> field
and a boolean <code>is_null</code> and these don&#x27;t flow into expressions that use operators like <code>+</code>, <code>-</code>, <code>/</code> and so forth.
This means that even simple expressions involving nullable types actually expand into several statements.  And, in general,
these statements need a place to put their temporary results to accumulate the correct answer, so scratch variables
are required to make all this work.</p><p>Here&#x27;s a more realistic example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET result := 5 * x + 3 * y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;combine&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)result, 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(*result); // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div></div></div></div></div><ul><li><code>_tmp_n_int_1</code> : holds the product of x and 5, it&#x27;s null if <code>x.is_null</code> is true</li><li><code>_tmp_n_int_2</code> : holds the product of y and 3, it&#x27;s null if <code>y.is_null</code> is true</li><li><code>*result</code> : holds the answer, it&#x27;s null if either of <code>_tmp_n_int_1.is_null</code>, <code>_tmp_n_int_2.is_null</code> is true<ul><li>otherwise it&#x27;s <code>_tmp_n_int_1.value + _tmp_n_int_2.value</code></li></ul></li></ul><p>So, in general, we need to emit arbitrarily many statements in the course of evaluating even simple looking expressions
and we need good mechanisms to manage that.  This is what we&#x27;ll talk about in the coming sections.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="managing-scratch-variables"></a>Managing Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#managing-scratch-variables" title="Direct link to heading">#</a></h4><p>The function that actually assigns scratch variables is <code>cg_scratch_var</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch variable helper uses the given sem_type and the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stack level to create a temporary variable name for that type at that level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the variable does not already have a declaration (as determined by the masks)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// then a declaration is added to the scratch_vars section.  This is one of the root</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ways of getting an .is_null and .value back.  Note that not null variables always</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// have a .is_null of &quot;0&quot; which becomes important when deciding how to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// one result to another.  Everything stays uniform.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)</span></div></div></div></div></div><p>The signature is a bit unexpected so we&#x27;ll go over it, some of below will make more
sense as we learn about expressions generally, but this is as good an introduction as any.</p><ul><li><code>ast</code> : holds a reference to a variable we want to assign to<ul><li>this argument is normally <code>NULL</code> for scratch variables</li><li><code>ast</code> is not null for the <code>RESULT</code> macros which we&#x27;ll study later</li><li>for now, we can basically ignore this argument</li></ul></li><li><code>sem_type</code> : holds the type of the variable we need<ul><li>it must be a unitary type, optionally with <code>SEM_TYPE_NOTNULL</code> set</li></ul></li><li><code>var</code> : a character buffer that will get the name of the variable</li><li><code>is_null</code> : a character buffer that will get the <code>is_null</code> expression for this variable (more below)</li><li><code>value</code> : a character buffer that will get the <code>value</code> expression for this variable (more below)</li></ul><p>And this is a good time to talk about <code>is_null</code> and <code>value</code> because they will be everywhere.</p><p>The codegen for expressions in the C code generator produces two results:</p><ul><li>the text that corresponds to the current value so far (e.g. &quot;(1+2)*3&quot;), and,</li><li>the text that will tell you if the current value is null<ul><li>this could be as simple as &quot;0&quot; for an expression that is known to be not null</li></ul></li></ul><p>Let&#x27;s make this a little more concrete:</p><p>Suppose we ask for a scratch &quot;not null integer&quot;, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_n_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;0&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_n_int_1&quot;</code></li></ul><p>Meaning: if we want the value, use the text <code>&quot;_tmp_n_int_1&quot;</code> if we want to know if the variable is null, we use the text <code>&quot;0&quot;</code></p><p>Note: many parts of <code>cg_c.c</code> special case an <code>is_null</code> value of <code>&quot;0&quot;</code> to make better code because such a thing is known to
be not null at compile time.</p><p>Now let&#x27;s suppose we ask for a scratch nullable integer, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;_tmp_int_1.is_null&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_int_1.value&quot;</code></li></ul><p>So again, we have exactly the text we need to test for null, and the test we need to get the value.</p><p>Additional notes:</p><ul><li>scratch variables can be re-used, they are on a &quot;stack&quot;</li><li>a bitmask is used to track which scratch variables have already had a declaration emitted, so they are only declared once</li><li>the variable name is based on the current value of the <code>stack_level</code> variable which is increased in a push/pop fashion as temporaries come in and out of scope<ul><li>this strategy isn&#x27;t perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad</li><li>importantly, there is one <code>stack_level</code> variable for all temporaries not one <code>stack_level</code> for every type of temporary, this seemed like a reasonable simplification</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocating-scratch-variables"></a>Allocating Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocating-scratch-variables" title="Direct link to heading">#</a></h4><p>The most common reason to create a &quot;scratch&quot; variable is that a temporary variable is needed for some part of the computation.
The most common reason for a temporary variable is to hold an intermediate result of a computation involving nullable arithmetic.</p><p>These temporaries are created with <code>CG_PUSH_TEMP</code> which simply creates the three <code>charbuf</code> variables needed and then asks for a
scratch variable of the required type.  The variables follow a simple naming convention.  The stack level is increased after
each temporary is allocated.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the text needed to refer to the variable.  cg_scratch_var picks the name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// based on stack level-and type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_TEMP(name, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_var(NULL, sem_type, &amp;name, &amp;name##_is_null, &amp;name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  stack_level++;</span></div></div></div></div></div><p>Symmetrically, <code>CG_POP_TEMP</code> closes the <code>charbuf</code> variables and restores the stack level.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffers for the temporary, restore the stack level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_TEMP(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  stack_level--;</span></div></div></div></div></div><p>As with the other <code>PUSH/POP</code> <code>OPEN/CLOSE</code> macro types, these macros are designed to make it impossible
to forget to free the buffers, or to get the stack level wrong.  The stack level can be (and is) checked
at strategic places to ensure it&#x27;s back to baseline -- this is easy because the code can always just
snapshot <code>stack_level</code>, do some work that should be clean, and then check that <code>stack_level</code> is back to
where it&#x27;s supposed to be with an <code>Invariant</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursing-sub-expressions"></a>Recursing Sub-expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursing-sub-expressions" title="Direct link to heading">#</a></h4><p>Now that we understand that we can create scratch variables as needed, it&#x27;s time to take a look at the typical evaluation patterns
and how the evaluation works within that pattern.  This is everywhere in <code>cg_c.c</code>.</p><p>So let&#x27;s look at an actual evaluator, the simplest of them all, this one does code generation for the <code>NULL</code> literal.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_null(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *expr,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR op,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *is_null,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *value,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t pri,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t pri_new)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(expr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(value, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Now this may be looking familiar: the signature of the code generator is something very much like the
signature of the the <code>gen_</code> functions in the echoing code.  That&#x27;s really because in some sense
the echoing code is a very simple code generator itself.</p><ul><li><code>expr</code> : the AST we are generating code for</li><li><code>op</code> : the relevant operator if any (operators share code)</li><li><code>is_null</code> : a <code>charbuf</code> into which we can write the <code>is_null</code> expression text</li><li><code>value</code> : a <code>charbuf</code> into which we can write the <code>value</code> expression text</li><li><code>pri</code> : the binding strength of the node above this one</li><li><code>pri_new</code> : the binding strength of this node</li></ul><p>This particular generator is going to produce <code>&quot;NULL&quot;</code> for the <code>value</code> and <code>&quot;1&quot;</code> for the <code>is_null</code> expression.</p><p><code>is_null</code> and <code>value</code> are the chief outputs, and the caller will use these to create its own expression results
with recursive logic.  But the expression logic can also write into the statement stream, the cleanup stream,
even into the header file stream, and as we&#x27;ll see, it does.</p><p><code>pri</code> and <code>pri_new</code> work exactly like they did in the echoing code (see <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>),
they are used to allow the code generator to decide if it needs to emit parentheses.  But recall that the binding strengths
now will be the C binding strengths NOT the SQL binding strengths (discussed above).</p><p>Let&#x27;s look at one of the simplest operators: the <code>IS NULL</code> operator handled by <code>cg_expr_is_null</code></p><p>Note: this code has a simpler signature because it&#x27;s actually part of codegen for <code>cg_expr_is</code> which
has the general contract.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The code-gen for is_null is one of the easiest.  The recursive call</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// produces is_null as one of the outputs.  Use that.  Our is_null result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is always zero because IS NULL is never, itself, null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_expr = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // expr IS NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;0&quot;); // the result of is null is never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The fact that this is not constant not null for not null reference types reflects</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the weird state of affairs with uninitialized reference variables which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be null even if they are typed not null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_not_nullable(sem_type_expr) &amp;&amp; !is_ref_type(sem_type_expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Note, sql has no side-effects so we can fold this away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;0&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;%s&quot;, expr_is_null.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>So walking through the above:</p><ul><li>the result of <code>IS NULL</code> is never null, so we can immediately put &quot;0&quot; into the <code>is_null</code> buffer</li><li>if the operand is a not-null numeric type then the result of <code>IS NULL</code> is <code>0</code></li><li>if the operand might actually be null then<ul><li>use <code>CG_PUSH_EVAL</code> to recursively do codegen for it</li><li>copy its <code>expr_is_null</code> text into our <code>value</code> text</li></ul></li></ul><p>Note: the code reveals one of the big CQL secrets -- that not null reference variables can be null...  C has the same issue with <code>_Nonnull</code> globals.</p><p>Now let&#x27;s look at those helper macros, they are pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// naming convention.  This might exit having burned some stack slots</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for its result variables, that&#x27;s normal.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri);</span></div></div></div></div></div><p>The push macro simply creates buffers to hold the <code>is_null</code> and <code>value</code> results, then it calls <code>cg_expr</code> to dispatch the indicated expression.
The <code>pri</code> value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is the <code>pri_new</code> of the caller.
but often <code>C_EXPR_PRI_ROOT</code> can be used if the current context implies that the callee will never need parentheses.</p><p>How do we know that parens are not needed here? It seems like the operand of <code>IS NULL</code> could be anything, surely it might need parentheses?  Let&#x27;s consider:</p><ul><li>if the operand is of not null numeric type then we aren&#x27;t even going to evaluate it, we&#x27;re on the easy &quot;no it&#x27;s not null&quot; path<ul><li>no parens there</li></ul></li><li>if the operand is nullable then the only place the answer can be stored is in a scratch variable and its <code>is_null</code> expression will be exactly like <code>var.is_null</code><ul><li>no parens there</li></ul></li><li>if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is <code>is_null</code> expression will be like <code>!var</code><ul><li>no parens there</li></ul></li></ul><p>So, none of these require further wrapping regardless of what is above the <code>IS NULL</code> node in the tree because of the high strength of the <code>.</code> and <code>!</code> operators.</p><p>Other cases are usually simpler, such as &quot;no parentheses need to be added by the child node because it will be used as the argument to a helper
function so there will always be parens hard-coded anyway&quot;.  However these things need to be carefully tested hence the huge variety of codegen tests.</p><p>Note that after calling <code>cg_expr</code> the temporary stack level might be increased.  We&#x27;ll get to that in the next section.  For now, looking at <code>POP_EVAL</code> we
can see it&#x27;s very straightforward:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Close the buffers used for the above.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch stack is not restored so that any temporaries used in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the evaluation of expr will not be re-used prematurely.  They</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can&#x27;t be used again until either the expression is finished,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// or they have been captured in a less-nested result variable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_EVAL(expr) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_is_null);</span></div></div></div></div></div><p><code>CG_POP_EVAL</code> simply closes the buffers, leaving the stack level unchanged.  More on this in the coming section.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-variables"></a>Result Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-variables" title="Direct link to heading">#</a></h4><p>When recursion happens in the codegen, a common place that the result will be found is
in a temporary variable i.e. the generated code will use one or more statements to arrange for the correct
answer to be in a variable.  To do this, the codegen needs to first get the name of a
result variable of a suitable type.  This is the &quot;other&quot; reason for making scratch variables.</p><p>There are three macros that make this pretty simple.  The first is <code>CG_RESERVE_RESULT_VAR</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a scratch variable to hold the final result of an evaluation.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// It may or may not be used.  It should be the first thing you put</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// so that it is on the top of your stack.  This only saves the slot.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If you use this variable you can reclaim other temporaries that come</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// from deeper in the tree since they will no longer be needed.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_RESERVE_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_reserved = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">sem_t sem_type_reserved = sem_type; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *ast_reserved = ast; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>If this looks a lot like <code>PUSH_TEMP</code> that shouldn&#x27;t be surprising.  The name of the variable
and the expression parts always go into <code>charbuf</code> variables named <code>result_var</code>, <code>result_var_is_null</code>, and <code>result_var_value</code>
but the scratch variable isn&#x27;t actually allocated!  However -- we burn the stack_level as though it had been
allocated.</p><p>The name of the macro provides a clue: this macro reserves a slot for the result variable, it&#x27;s used if the codegen might
need a result variable, but it might not.  If/when the result variable is needed, it we can artificially move the stack level
back to the reserved spot, allocate the scratch variable, and then put the stack level back.  When the name is set we know
that the scratch variable was actually used.</p><p>The <code>CG_USE_RESULT_VAR</code> macro does exactly this operation.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable is going to be used, this writes its name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and .value and .is_null into the is_null and value fields.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_USE_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_now = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_reserved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_now; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Invariant(result_var.used &gt; 1); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(is_null, &quot;%s&quot;, result_var_is_null.ptr); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(value, &quot;%s&quot;, result_var_value.ptr)</span></div></div></div></div></div><p>Once the code generator decides that it will in fact be using a result variable to represent the answer, then
the <code>is_null</code> and <code>value</code> buffers can be immediately populated to whatever the values were
for the result variable.  That text will be correct regardless of what codegen is used
to populate the variable.  The variable is the result.</p><p>There is a simpler macro that reserves and uses the result variable in one step, it&#x27;s used frequently.
The &quot;reserve&quot; pattern is only necessary when there are some paths that need a result variable and some
that don&#x27;t.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This does reserve and use in one step</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_SETUP_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_RESERVE_RESULT_VAR(ast, sem_type); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_USE_RESULT_VAR();</span></div></div></div></div></div><p>And now armed with this knowledge we can look at the rest of the scratch stack management.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffer holding the name of the variable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable was used, we can re-use any temporaries</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with a bigger number.  They&#x27;re no longer needed since they</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// are captured in this result.  We know it was used if it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// has .used &gt; 1 (there is always a trailing null so empty is 1).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_CLEANUP_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (result_var.used &gt; 1) stack_level = stack_level_reserved + 1; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(result_var);</span></div></div></div></div></div><p>As it happens when you use <code>CG_PUSH_EVAL</code> it is entirely possible, even likely,
that the result of <code>cg_expr</code> is in a result variable.  The convention is that if the codegen
requires a result variable it is allocated <em>first</em>, before any other temporaries.  This is why
there is a way to reserve a variable that you <em>might</em> need.</p><p>Now if it turns out that you used the result variable at your level it means that any
temporary result variables from deeper levels have been used and their values plus
whatever math was needed is now in your result variable.  This means that the <code>stack_level</code>
variable can be decreased to one more than the level of the present result.  This is
in the fact the only time it is safe to start re-using result variables because
you otherwise never know how many references to result variables that were &quot;deep in the tree&quot;
are left in the contents of <code>expr_value</code> or <code>expr_is_null</code>.</p><p>Now, armed with the knowledge that there are result variables and temporary variables and both
come from the scratch variables we can resolve the last mystery we left hanging.  Why does
the scratch variable API accept an AST pointer?</p><p>The only place that AST pointer can be not null is in the <code>CG_USE_RESULT_VAR</code> macro, it was
this line:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value);</span></div></div></div></div></div><p>And <code>ast_reserved</code> refers to the AST that we are trying to evaluate.  There&#x27;s an important
special case that we want to optimize that saves a lot of scratch variables.  That case is handled
by this code in <code>cg_scratch_var</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_assignment_target_reusable(ast, sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(ast &amp;&amp; ast-&gt;parent &amp;&amp; ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_out_parameter(name_ast-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;*%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The idea is that if the generator is doing an assignment like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := a + b;</span></div></div></div></div></div><p>Then the code generator doesn&#x27;t need a scratch variable to hold the result of the expression <code>a + b</code> like it would
in many other contexts.  It can use <code>x</code> as the result variable!  The <code>SET</code> codegen will discover
that the value it&#x27;s supposed to set is already in <code>x</code> so it does nothing and everything just
works out.  The price of this is a call to <code>is_assignment_target_reusable</code> and then some
logic to handle the case where <code>x</code> is an out argument (hence call by reference, hence needs to be used as <code>*x</code>).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="basic-control-flow-patterns"></a>Basic Control Flow Patterns<a aria-hidden="true" tabindex="-1" class="hash-link" href="#basic-control-flow-patterns" title="Direct link to heading">#</a></h3><p>To get a sense of how the compiler generates code for statements, we can look at some of the easiest cases.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;While&quot; suffers from the same problem as IF and as a consequence</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// generating while (expression) would not generalize.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The overall pattern for while has to look like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    prep statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    condition = final expression;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    if (!condition) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note that while can have leave and continue substatements which have to map</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to break and continue.   That means other top level statements that aren&#x27;t loops</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// must not create a C loop construct or break/continue would have the wrong target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;for (;;) {\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!cql_is_nullable_true(%s, %s)) break;\n&quot;, expr_is_null.ptr, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!(%s)) break;\n&quot;, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t loop_saved = cg_in_loop;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = loop_saved;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The comment before the <code>cg_while_stmt</code> actually describes the situation pretty clearly;
the issue with this codegen is that the expression in the while statement might actually
require many C statements to evaluate.  There are many cases of this sort of thing, but the
simplest is probably when any nullable types are in that expression.  A particular example
illustrates this pretty clearly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>which generates:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* in trickier cases there would be code right here */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(x &lt; 5)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    x = x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>In this case, a <code>while</code> statement could have been used because the condition is simply <code>x &lt; 5</code>
so this more general pattern is overkill.  But consider this program, just a tiny bit different:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER;  -- x is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>which produces:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_bool _tmp_n_bool_0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_bool_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_notnull(x, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_bool_0, x.is_null, x.value &lt; 5);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_nullable(x, x.is_null, x.value + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Even for this small little case, the nullable arithmetic macros have to be used to keep <code>x</code> up to date.
The result of <code>x &lt; 5</code> is of type <code>BOOL</code> rather than <code>BOOL NOT NULL</code> so a temporary variable captures
the result of the expression.  This is an easy case, but similar things happen if the expression
includes e.g. <code>CASE...WHEN...</code> or <code>IN</code> constructs.  There are many other cases.</p><p>So with this in mind, let&#x27;s reconsider what <code>cg_while_stmt</code> is doing:</p><ul><li>we start the <code>for</code> statement in the output<ul><li>there&#x27;s a bprintf for that</li></ul></li><li>we evaluate the while expression, the details will be in <code>is_null</code> and <code>value</code><ul><li>we use CG_PUSH_EVAL for that</li></ul></li><li>if the result is nullable there is a helper macro <code>cql_is_nullable_true</code> that tells us if the value is not null and true</li><li>if the result is not nullable we can use <code>expr_value.ptr</code> directly</li><li>we make a note that we&#x27;re in a loop (this matters for statement cleanup, more on that later)</li><li>we recurse to do more statements with <code>cg_stmt_list</code></li><li>finally we end the <code>for</code> that we began</li></ul><p>This kind of structure is common to all the control flow cases.  Generally, we have to deal with the
fact that CQL expressions often become C statements so we use a more general flow control strategy.
But with this in mind, it&#x27;s easy to imagine how the <code>IF</code>, <code>LOOP</code>, and <code>SWITCH</code> switch statements are
handled.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cleanup-and-errors"></a>Cleanup and Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cleanup-and-errors" title="Direct link to heading">#</a></h3><p>There are a number of places where things can go wrong when running a CQL procedure.  The most
common sources are: (1) SQLite APIs, almost all of which can fail, and, (2) calling other procedures
which also might fail.  Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC something_that_might_fail (arg TEXT) USING TRANSACTION;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Which generates:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look at those fragments carefully:</p><ul><li>first, we had to declare <code>something_that_might_fail</code><ul><li>the declaration included <code>USING TRANSACTION</code> indicating the procedure uses the database</li><li>we didn&#x27;t provide the procedure definition, this is like an <code>extern ... foo(...);</code> declaration</li></ul></li><li>there is a string literal named <code>_literal_1_test_p</code> that is auto-created<ul><li><code>cql_string_literal</code> can expand into a variety of things, whatever you want &quot;make a string literal&quot; to mean</li><li>it&#x27;s defined in <code>cqlrt.h</code> and it&#x27;s designed to be replaced</li></ul></li><li><code>cql_set_string_ref(&amp;arg, _literal_1_test_p);</code> is expected to &quot;retain&quot; the string (+1 ref count)</li><li><code>cql_cleanup</code> is the exit label, this cleanup code will run on all exit paths<ul><li>cleanup statements are accumulated by writing to <code>cg_cleanup_output</code> which usually writes to the <code>proc_cleanup</code> buffer</li><li>because cleanup is in its own buffer you can add to it freely whenever a new declaration that requires cleanup arises</li><li>in this case the declaration of the string variable caused the <code>C</code> variable <code>arg</code> to be created and also the cleanup code</li></ul></li><li>now we call <code>something_that_might_fail</code> passing it our database pointer and the argument</li><li>the hidden <code>_db_</code> pointer is passed to all procedures that use the database</li><li>these procedures are also the ones that can fail</li><li>any failed return code (not <code>SQLITE_OK</code>) causes two things:<ul><li>the <code>cql_error_trace()</code> macro is invoked (this macro typically expands to nothing)</li><li>the code is redirected to the cleanup block via <code>goto cql_cleanup;</code></li></ul></li></ul><p>The essential sequence is this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div></div></div></div></div><p>The C code generator consistently uses this pattern to check if anything went wrong and to exit with an error code.
Extensive logging can be very expensive, but in debug builds it&#x27;s quite normal for <code>cql_error_trace</code> to expand
into something like <code>fprintf(stderr, &quot;error %d in %s %s:%d\n&quot;, _rc_, _PROC_, __FILE__, __LINE_)</code> which is probably
a lot more logging than you want in a production build but great if you&#x27;re debugging.  Recall that CQL generates
something like <code>#define _PROC_ &quot;p&quot;</code> before every procedure.</p><p>This error pattern generalizes well and indeed if we use the exception handling pattern, we get a lot of control.
Let&#x27;s generalize this example a tiny bit:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (OUT success BOOL NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN TRY</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END TRY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN CATCH</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END CATCH;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>CQL doesn&#x27;t have complicated exception objects or anything like that, exceptions are just simple
control flow.  Here&#x27;s the code for the above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_bool *_Nonnull success) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)success, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *success = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    goto catch_end_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_start_1: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_end_1:;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The code in this case is nearly the same as the previous example.  Let&#x27;s look at the essential differences:</p><ul><li>If there is an error, <code>goto catch_start_1</code> will run</li><li>If the try block succeeds, <code>goto catch_end_1</code> will run</li><li>both the <code>TRY</code> and <code>CATCH</code> branches set the <code>success</code> out parameter</li><li>since an out argument was added, CQL generated an error check to ensure that <code>success</code> is not null<ul><li><code>cql_contract_argument_notnull((void *)success, 1)</code>, the 1 means &quot;argument 1&quot; and will appear in the error message if this test fails</li><li>the hidden <code>_db_</code> argument doesn&#x27;t count for error message purposes, so <code>success</code> is still the first argument</li></ul></li></ul><p>How does this happen?  Let&#x27;s look at <code>cg_trycatch_helper</code> which does this work:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Very little magic is needed to do try/catch in our context.  The error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// handlers for all the sqlite calls check _rc_ and if it&#x27;s an error they</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;goto&quot; the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Inside the try block, the cleanup handler is changed to the catch block.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The catch block puts it back.  Otherwise, generate nested statements as usual.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_start);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We need unique labels for this block</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ++catch_block_count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_start, &quot;catch_start_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_end, &quot;catch_end_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Divert the error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR saved_error_target = error_target;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t saved_error_target_used = error_target_used;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target = catch_start.ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> ...</span></div></div></div></div></div><p>The secret is the <code>error_target</code> global variable.
All of the error handling will emit a goto <code>error_target</code> statement. The
try/catch pattern simply changes the current error target.  The rest of
the code in the helper is just to save the current error target and to
create unique labels for the try/catch block.</p><p>The important notion is that, if anything goes wrong, whatever it is,
the generator simply does a <code>goto error_target</code> and that will either
hit the catch block or else go to cleanup.</p><p>The <code>THROW</code> operation illustrates this well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Convert _rc_ into an error code.  If it already is one keep it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Then go to the current error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_throw_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_throw_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_best_error(%s);\n&quot;, rcthrown_current);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;goto %s;\n&quot;, error_target);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  rcthrown_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>first we make sure <code>_rc_</code> has some kind of error in it, either <code>rcthrown_current</code> or else <code>SQLITE_ERROR</code></li><li>then we go to the current error target</li><li><code>error_target_used</code> tracks whether if the error label was used, this is just to avoid C compiler errors about unused labels.<ul><li>if the label is not used it won&#x27;t be emitted</li><li>the code never jumps back to an error label, so we&#x27;ll always know if the label was used before we need to emit it</li></ul></li></ul><p>Note: every catch block captures the value of <code>_rc_</code> in a local variable whose name is in <code>rcthrown_current</code>.
This captured value is the current failing result code accessible by <code>@RC</code> in CQL.</p><p>A catch block can therefore do stuff like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">@RC</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  THROW</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">call</span><span class="token plain"> attempt_retry</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>This entire mechanism is built with basically just a few state variables that nest.  There is no complicated stack walking
or anything like that.  All the code has to do is chain the error labels together and let users create new catch blocks
with new error labels.  All that together gives you very flexible try/catch behaviour with very little overhead.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="string-literals"></a>String Literals<a aria-hidden="true" tabindex="-1" class="hash-link" href="#string-literals" title="Direct link to heading">#</a></h3><p>Before we move on to more complex statements we have to discuss string literals a little bit.  We&#x27;ve mentioned before
that the compiler is going to generate something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div></div></div></div></div><p>To create a reference counted object <code>_literal_1_test_p</code> that it can use.  Now we&#x27;re going to talk about how
the text <code>&quot;test&quot;</code> was created and how that gets more complicated.</p><p>The first thing to remember is that the generator creates C programs.  That means
no matter what kind of literal we might be processing it&#x27;s ending up encoded as a C string for the C
compiler.  The C compiler will be the first thing the decodes the text the generator produces and
puts the byte we need into the final programs data segment or wherever.  That means if we have
SQL format strings that need to go to SQLite they will be twice-encoded, the SQL string is escaped
as needed for SQLite and <em>that</em> is escaped again for the C compiler.</p><p>An example might make this clearer consider the following SQL:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &#x27;&quot;x&#x27;&#x27;y&quot;&#x27; AS a, &quot;&#x27;y&#x27;\n&quot; AS b;</span></div></div></div></div></div><p>The generated text for this statement will be:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;SELECT &#x27;\&quot;x&#x27;&#x27;y\&quot;&#x27;, &#x27;&#x27;&#x27;y&#x27;&#x27;\n&#x27;&quot;</span></div></div></div></div></div><p>Let&#x27;s review that in some detail:</p><ul><li><p>the first string &quot;a&quot; is a standard SQL string</p><ul><li>it is represented unchanged in the AST, it is <em>not</em> unescaped</li><li>even the outer single quotes are preserved, CQL has no need to change it at all</li><li>when we emit it into our output it will be read by the C compiler, so</li><li>at that time it is escaped <em>again</em> into C format<ul><li>the double quotes which required no escaping in SQL become <code>\&quot;</code></li></ul></li><li>the single quote character requires no escape but there are still two of them because SQLite will also process this string</li></ul></li><li><p>the second string &quot;b&quot; is a C formatted string literal</p><ul><li>SQLite doesn&#x27;t support this format or its escapes, therefore</li><li>as discussed in <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>, it is decoded to plain text, then re-encoded as a SQL escaped string</li><li>internal newlines do not require escaping in SQL, they are in the string as the newline character not &#x27;\n&#x27; or anything like that<ul><li>to be completely precise the byte value 0x0a is in the string unescaped</li></ul></li><li>internal single quotes don&#x27;t require escaping in C, these have to be doubled in a SQL string</li><li>the outer double quotes are removed and replaced by single quotes during this process</li><li>the AST now has a valid SQL formatted string possibly with weird characters in it</li><li>as before, this string has to be formatted for the C compiler so now it has to be escaped again</li><li>the single quotes require no further processing, though now there are quite a few of them</li><li>the embedded newline is converted to the escape sequence &quot;\n&quot; so we&#x27;re back to sort of where we started<ul><li>the C compiler will convert this back to the byte 0x0a which is what ends up in the data segment</li></ul></li></ul></li></ul><p>In the above example we were making one overall string for the <code>SELECT</code> statement so the outer double quotes
are around the whole statement.  That was just for the convenience of this example.  If the literals had
been in some other loose context then individual strings would be produced the same way.  Except, not so fast,
not every string literal is heading for SQLite.  Some are just making regular strings.  In that case even
if they are destined for SQLite they will go as bound arguments to a statement not in the text of the SQL.
That means <em>those</em> strings do not need SQL escaping.</p><p>Consider:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET a := &#x27;&quot;x&#x27;&#x27;y&quot;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET b := &quot;&#x27;y&#x27;\n&quot;;</span></div></div></div></div></div><p>To do those assignments we need:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_x_y_p, &quot;\&quot;x&#x27;y\&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_2_y_p, &quot;&#x27;y&#x27;\n&quot;);</span></div></div></div></div></div><p>In both of these cases the steps are:</p><ul><li>unescape the escaped SQL string in the AST to plain text<ul><li>removing the outer single quotes of course</li></ul></li><li>re-escape the plain text (which might include newlines and such) as a C string<ul><li>emit that text, including its outer double quotes</li></ul></li></ul><p>Trivia: the name of the string literal variables include a fragment of the string to make them a little easier to spot.</p><p><code>encoders.h</code> has the encoding functions</p><ul><li><code>cg_decode_string_literal</code></li><li><code>cg_encode_string_literal</code></li><li><code>cg_encode_c_string_literal</code></li><li><code>cg_decode_c_string_literal</code></li></ul><p>As well as similar functions for single characters to make all this possible.  Pretty much every combination
of encoding and re-encoding happens in some path through the code generator.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="executing-sqlite-statements"></a>Executing SQLite Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#executing-sqlite-statements" title="Direct link to heading">#</a></h3><p>By way of example let&#x27;s consider a pretty simple piece of SQL we might want to run.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE TABLE foo(id INTEGER, t TEXT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER, t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  UPDATE foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t = t_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>To make this happen we&#x27;re going to have to do the following things:</p><ul><li>create a string literal with the statement we need</li><li>the references to <code>id_</code> and <code>t_</code> have to be replaced with <code>?</code></li><li>we prepare that statement</li><li>we bind the values of <code>id_</code> and <code>t_</code></li><li>we <code>step</code> the statement</li><li>we <code>finalize</code> the statement</li><li>suitable error checks have to be done at each stage</li></ul><p>That&#x27;s quite a bit of code and it&#x27;s easy to forget a step, this is an area where CQL shines.  The
code we had to write in CQL was very clear and all the error checking is implicit.</p><p>This is the generated code.  We&#x27;ll walk through it and discuss how it is created.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 id_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nullable t_)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_temp_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;_temp_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;UPDATE foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SET t = ? &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multibind(&amp;_rc_, _db_, &amp;_temp_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_INT32, &amp;id_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_STRING, t_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>the functions signature includes the hidden <code>_db_</code> parameter plus the two arguments</li><li>we need a hidden <code>_rc_</code> variable to hold the result codes from SQLite</li><li>we need a scratch <code>sqlite3_stmt *</code> named <code>_temp_stmt</code> to talk to SQLite<ul><li>when this is created, the cleanup section gets <code>cql_finalize_stmt(&amp;_temp_stmt);</code></li><li><code>cql_finalize_stmt</code> sets the statement to null and does nothing if it&#x27;s already null</li></ul></li><li>the string <code>&quot;INSERT INTO foo(id, t) VALUES(?, ?)&quot;</code> is created from the AST<ul><li>recall that we have <code>variables_callback</code> as an option, it&#x27;s used here to track the variables and replace them with <code>?</code></li><li>more on this shortly</li></ul></li><li><code>cql_multibind</code> is used to bind the values of <code>id_</code> and <code>t_</code><ul><li>this is just a varargs version of the normal SQLite binding functions, it&#x27;s only done this way to save space</li><li>only one error check is needed for any binding failure</li><li>the type of binding is encoded very economically</li><li>the &quot;2&quot; here refers to two arguments</li></ul></li><li>the usual error processing happens with <code>cql_error_trace</code> and <code>goto cql_cleanup</code></li><li>the statement is executed with <code>sqlite3_step</code></li><li>temporary statements are finalized immediately with <code>cql_finalize_stmt</code><ul><li>in this case its redundant because the code is going to fall through to cleanup anyway</li><li>in general there could be many statements and we want to finalize immediately</li><li>this is an optimization opportunity, procedures with just one statement are very common</li></ul></li></ul><p>Most of these steps are actually hard coded.  There is no variability in the sequence
after the <code>multibind</code> call, so that&#x27;s just boiler-plate the compiler can inject.</p><p>We don&#x27;t want to declare <code>_temp_stmt</code> over and over so there&#x27;s a flag that records
whether it has already been declared in the current procedure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a declaration for the temporary statement _temp_stmt_ if we haven&#x27;t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// already done so.  Also emit the cleanup once.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void ensure_temp_statement() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!temp_statement_emitted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_declarations_output, &quot;sqlite3_stmt *_temp_stmt = NULL;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_cleanup_output, &quot;  cql_finalize_stmt(&amp;_temp_stmt);\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    temp_statement_emitted = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This is a great example of how, no matter where the processing happens to be,
the generator can emit things into the various sections.  Here it adds
a declaration and an cleanup with no concern about what else might be going on.</p><p>So most of the above is just boiler-plate, the tricky part is:</p><ul><li>getting the text of the SQL</li><li>binding the variables</li></ul><p>All of this is the business of this function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the most important function for sqlite access;  it does the heavy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// lifting of generating the C code to prepare and bind a SQL statement.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If cg_exec is true (CG_EXEC) then the statement is executed immediately</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and finalized.  No results are expected.  To accomplish this we do the following:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * figure out the name of the statement, either it&#x27;s given to us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     or we&#x27;re using the temp statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * call get_statement_with_callback to get the text of the SQL from the AST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     * the callback will give us all the variables to bind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     * count the variables so we know what column numbers to use (the list is backwards!)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * bind any variables</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * if there are variables CG_EXEC will step and finalize</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_flags)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The core of this function looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callbacks callbacks;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_gen_sql_callbacks(&amp;callbacks);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  callbacks.variables_callback = cg_capture_variables;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  callbacks.variables_context = &amp;vars;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ... more flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(temp);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_set_output_buffer(&amp;temp);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_statement_with_callbacks(stmt, &amp;callbacks);</span></div></div></div></div></div><p>It&#x27;s set up the callbacks for variables and it calls the echoing function on the buffer.  We&#x27;ve
talked about <code>gen_statement_with_callbacks</code> in  <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>.</p><p>Let&#x27;s take a look at that callback function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the callback method handed to the gen_ method that creates SQL for us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// it will call us every time it finds a variable that needs to be bound.  That</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variable is replaced by ? in the SQL output.  We end up with a list of variables</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to bind on a silver platter (but in reverse order).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  list_item **head = (list_item**)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_item_to_list(head, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(buffer, &quot;?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The <code>context</code> variable was set to be <code>vars</code>, we convert it back to the correct type
and add the current ast to that list.  <code>add_item_to_list</code> always puts things at the
head so the list will be in reverse order.</p><p>With this done, we&#x27;re pretty much set.  We&#x27;ll produce the statement with a sequence
like this one (there are a couple of variations, but this is the most general)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_prepare(_db_, %s%s_stmt,\n  &quot;, amp, stmt_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_pretty_quote_plaintext(temp.ptr, cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;);\n&quot;);</span></div></div></div></div></div><p><code>cg_pretty_quote_plaintext</code> is one of the C string encoding formats, it could have been just the regular C string encoding
but that would have been a bit wasteful and it wouldn&#x27;t have looked as nice.  This function does a little transform.</p><p>The normal echo of the update statement in question looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  UPDATE foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t = ?</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = ?;</span></div></div></div></div></div><p>Note that it has indenting and newlines embedded in it.  The standard encoding of that would look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;  UPDATE foo\n  SET t = ?\n    WHERE id = ?;&quot;</span></div></div></div></div></div><p>That surely works, but it&#x27;s wasteful and ugly. The pretty format instead produces:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;UPDATE foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SET t = ? &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;</span></div></div></div></div></div><p>So, the newlines are gone from the string (they aren&#x27;t needed), instead the string literal was broken into lines for readability.
The indenting is gone from the string, instead the string fragments are indented.  So what you get is a string literal that
reads nicely but doesn&#x27;t have unnecessary whitespace for SQLite.  Obviously you can&#x27;t use pretty-quoted literals in all cases,
it&#x27;s exclusively for SQLite formatting.</p><p>All that&#x27;s left to do is bind the arguments.  Remember that arg list is in reverse order:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = vars; item; item = item-&gt;next, count++) ;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  reverse_list(&amp;vars);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;cql_multibind(&amp;_rc_, _db_, %s%s_stmt, %d&quot;, amp, stmt_name, count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Now emit the binding args for each variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (list_item *item = vars; item; item = item-&gt;next)  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Contract(item-&gt;ast-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(cg_main_output, &quot;,\n              &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_bind_column(item-&gt;ast-&gt;sem-&gt;sem_type, item-&gt;ast-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;);\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><ul><li>first compute the count, we don&#x27;t need to bind if there are no variables</li><li><code>reverse_list</code> does exactly what is sounds like (finally a real-world use-case for reverse-list-in-place)</li><li><code>cg_bind_column</code> creates one line of the var-args output: column type and variable name<ul><li>the type and name information is right there on the <code>AST</code> in the <code>sem_node</code></li></ul></li></ul><p>And that&#x27;s it.  With those few helpers we can bind any SQLite statement the same way.  All of the
<code>DDL_STMT_INIT</code> and <code>DML_STMT_INIT</code> statements are completely implemented by this path.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reading-single-values"></a>Reading Single Values<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reading-single-values" title="Direct link to heading">#</a></h3><p>In many cases you need just one value</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER NOT NULL, OUT t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t_ := ( SELECT t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FROM foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_ );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This is going to be very similar to the examples we&#x27;ve seen so far:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_int32 id_, cql_string_ref _Nullable *_Nonnull t_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)t_, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _tmp_text_0 = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_temp_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *(void **)t_ = NULL; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;_temp_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT t &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;FROM foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multibind(&amp;_rc_, _db_, &amp;_temp_stmt, 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_column_string_ref(_temp_stmt, 0, &amp;_tmp_text_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;*t_, _tmp_text_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(_tmp_text_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>_db_</code> : incoming arg for a procedure that uses the database same as always, check</li><li><code>*(void **)t_ = NULL;</code> : out args are always set to NULL on entry, note, there is no <code>release</code> here<ul><li>argument is assumed to be garbage, that&#x27;s the ABI</li><li>if argument is non-garbage caller must release it first, that&#x27;s the ABI</li></ul></li><li><code>_rc_</code> : same as always, check</li><li><code>_tmp_text_0</code> : new temporary text, including cleanup (this could have been avoided)</li><li><code>_temp_stmt</code> : as before, including cleanup</li><li><code>cql_prepare</code> : same as always, check</li><li><code>cql_multibind</code> : just one integer bound this time</li><li><code>sqlite3_step</code> : as before, we&#x27;re stepping once, this time we want the data</li><li><code>if (_rc_ != SQLITE_ROW)</code> new error check and goto cleanup if no row<ul><li>this is the same as the <code>IF NOTHING THROW</code> variant of construct, that&#x27;s the default</li></ul></li><li><code>cql_column_string_ref</code> : reads one string from <code>_temp_stmt</code></li><li><code>cql_finalize_stmt</code> : as before</li><li><code>cql_set_string_ref(&amp;*t_, _tmp_text_0)</code> : copy the temporary string to the out arg<ul><li>includes retain, out arg is NULL so <code>cql_set_string_ref</code> will do no release</li><li>if this were (e.g.) running in a loop, the out arg would not be null and there would be a release, as expected</li><li>if something else had previously set the out arg, again, there would be a release as expected</li></ul></li></ul><p>There are variations of this form such as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER NOT NULL, OUT t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t_ := ( SELECT t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FROM foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    IF NOTHING &#x27;&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This simply changes the handling of the case where there is no row.  The that part of the code
ends up looking like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ == SQLITE_ROW) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_column_string_ref(_temp_stmt, 0, &amp;_tmp_text_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_string_ref(&amp;_tmp_text_0, _tmp_text_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_string_ref(&amp;_tmp_text_0, _literal_1_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><ul><li>any error code leads to cleanup</li><li><code>SQLITE_ROW</code> : leads to the same fetch as before</li><li><code>SQLITE_DONE</code> : leads to the no row case which sets <code>_tmp_text_0</code> to the empty string<ul><li><code>cql_string_literal(_literal_1_p, &quot;&quot;);</code> is included as a data declaration</li></ul></li></ul><p>There is also the <code>IF NOTHING OR NULL</code> variant which is left as an exercise to the reader.
You can find all the flavors in <code>cg_c.c</code> in the this function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is a nested select expression.  To evaluate we will</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * prepare a temporary to hold the result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * generate the bound SQL statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * extract the exactly one argument into the result variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    which is of exactly the right type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * use that variable as the result.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The helper methods take care of sqlite error management.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_select(...</span></div></div></div></div></div><p>This handles all of the <code>(select ...)</code> expressions and it has the usual expression handler
syntax. Another great example of a CQL expressions that might require many C statements
to implement.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reading-rows-with-cursors"></a>Reading Rows With Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reading-rows-with-cursors" title="Direct link to heading">#</a></h3><p>This section is about the cases where we are expecting results back from SQLite.  By results here
I mean the results of some kind of query, not like a return code.  SQLite does this by giving
you a <code>sqlite3_stmt *</code> which you can then use like a cursor to read out a bunch of rows.  So
it should be no surprise that CQL cursors map directly to SQLite statements.</p><p>Most of the code to get a statement we&#x27;ve already seen before, we only saw the <code>_temp_stmt</code>
case and we did very little with it.  Let&#x27;s look at the code for something a little bit more
general and we&#x27;ll see how little it takes to generalize.</p><p>First, let&#x27;s look at how a CQL cursor is initialized:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Now in this case there can only be one row in the result, but it would be no different if there were more.</p><p>Here&#x27;s the C code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _C_has_row_ = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;C_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT 1, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look over that code very carefully and see what is necessary to make it happen.</p><ul><li><code>_db_</code> : incoming arg for a procedure that uses the database same as always, check</li><li><code>_rc_</code> : same as always, check</li><li><code>C_stmt</code> : we need to generate this instead of using <code>_temp_stmt</code><ul><li><code>cql_finalize_stmt(&amp;C_stmt)</code> in cleanup, just like <code>_temp_stmt</code></li></ul></li><li><code>cql_prepare</code> : same as always, check</li><li><code>cql_multibind</code> : could have been binding, not none needed here, but same as always anyway, check</li><li>no step, no finalize (until cleanup) : that boiler-plate is removed</li></ul><p>And that&#x27;s it, we now have a statement in <code>C_stmt</code> ready to go.  We&#x27;ll see later that <code>_C_has_row_</code>
will track whether or not the cursor has any data in it.</p><p>How do we make this happen?  Well you could look at <code>cg_declare_cursor</code> and your eye might hurt at
first.  The truth is there are many kinds of cursors in CQL and this method handles all of them.
We&#x27;re going to go over the various flavors but for now we&#x27;re only discussing the so-called
&quot;statement cursor&quot;, so named because it simply holds a SQLite statement.  This was the
first, and for a while only, type of cursor added to the CQL language.</p><p>OK so how do we make a statement cursor.  It&#x27;s once again <code>cg_bound_sql_statement</code> just like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_bound_sql_statement(cursor_name, select_stmt, CG_PREPARE|CG_MINIFY_ALIASES);</span></div></div></div></div></div><p>The entire difference is that the first argument is the cursor name rather than NULL.  If you
pass NULL it means use the temporary statement.</p><p>And you&#x27;ll notice that even in this simple example the SQLite text was altered a bit:
the text that went to SQLite was <code>&quot;SELECT 1, 2&quot;</code> -- that&#x27;s CG_MINIFY_ALIASES at work.
SQLite didn&#x27;t need to see those column aliases, it makes no difference in the result.
Column aliases are often long and numerous.  Even in this simple example we saved 4 bytes.
But the entire query was only 12 bytes long (including trailing null) so that&#x27;s 25%.
It&#x27;s not a huge savings in general but it&#x27;s something.</p><p>The other flag <code>CG_PREPARE</code> tells the binder that it should not step or finalize the query.
The alternative is <code>CG_EXEC</code> (which was used in the previous section for the <code>UPDATE</code> example).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="fetching-data-from-cursors"></a>Fetching Data From Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#fetching-data-from-cursors" title="Direct link to heading">#</a></h3><p>The first cursor reading primitive that was implemented as <code>FETCH [cursor] INTO [variables]</code> and
it&#x27;s the simplest to understand so let&#x27;s start there.</p><p>We change the example just a bit:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C INTO x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>For simplicity I will only include the code that is added.  The rest is the same.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // same as before</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _C_has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div></div></div></div></div><p>Do to the <code>FETCH</code> we do the following:</p><ul><li>step the cursor</li><li>set the <code>_C_has_row_</code> variable so to indicate if we got a row or not</li><li>use the varargs <code>cql_multifetch</code> to read 2 columns from the cursor<ul><li>this helper simply uses the usual <code>sqlite3_*_column</code> functions to read the data out</li><li>again, we do it this way so that there is less error checking needed in the generated code</li><li>also, there are fewer function calls so the code is overall smaller</li><li>trivia: <code>multibind</code> and <code>multifetch</code> are totally references to <em>The Fifth Element</em><ul><li>hence, they should be pronounced like Leeloo saying &quot;multipass&quot;</li></ul></li></ul></li><li><code>multifetch</code> uses the varargs to clobber the contents of the target variables if there is no row according to <code>_rc_</code></li><li><code>multifetch</code> uses the <code>CQL_DATA_TYPE_NOT_NULL</code> to decide if it should ask SQLite first if the column is null</li></ul><p>So now this begs the question, in the CQL, how do you know if a row was fetched or not?</p><p>The answer is, you can use the cursor name like a boolean.  Let&#x27;s complicate this up a little more.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROCEDURE printf NO CHECK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C INTO x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH C INTO x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Again here is what is now added, we&#x27;ve seen the <code>WHILE</code> pattern before:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(_C_has_row_)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _C_has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>So, if you use the cursors name in an ordinary expression that is converted to a reference to
the boolean <code>_C_has_row_</code>.  Within the loop we&#x27;re going to print some data and then fetch the next row.
The internal fetch is of course the same as the first.</p><p>The next improvement that was added to the language was the <code>LOOP</code> statement.  Let&#x27;s take a look:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C INTO x, y</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The generated code is very similar:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _C_has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!_C_has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>This is done by:</p><ul><li>emit the <code>for (;;) {</code> to start the loop</li><li>generate the <code>FETCH</code> just as if it was standalone</li><li>emit <code>if (!_C_has_row_) break;</code> (with the correct cursor name)</li><li>use <code>cg_stmt_list</code> to emit the internal statement list (<code>CALL printf</code> in this case)</li><li>close the loop with <code>}</code> and we&#x27;re done</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cursors-with-storage"></a>Cursors With Storage<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cursors-with-storage" title="Direct link to heading">#</a></h3><p>We now come to the big motivating reasons for having the notion of shapes in the CQL language.
This particular case was the first such example in the language and it&#x27;s very commonly
used and saves you a lot of typing.  Like the other examples it&#x27;s only sugar in that
it doesn&#x27;t give you any new language powers you didn&#x27;t have, but it does give clarity
and maintenance advantages.  And it&#x27;s just a lot less to type.</p><p>Let&#x27;s go back to one of the earlier examples, but write it the modern way:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>And the generated C code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { 0 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;C_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT 1, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look at what&#x27;s different here:</p><ul><li><code>struct p_C_row</code> has been created, it contains:<ul><li><code>_has_row_</code> for the cursor</li><li><code>x</code> and <code>y</code> the data fields</li><li><code>_refs_count</code> the number of reference fields in the cursor (0 in this case)</li><li><code>_refs_offset</code> the offset of the references fields (they always go at the end)</li><li>because the references are together a cursor with lots of reference fields can be cleaned up easily</li></ul></li><li>in the generated code the variable <code>C</code> refers to the current data that has been fetched<ul><li>convenient for debugging <code>p C</code> in lldb shows you the row</li></ul></li><li>references to <code>x</code> and <code>y</code> became <code>C.x</code> and <code>C.y</code></li><li>references to <code>_C_has_row_</code> became <code>C._has_row_</code></li></ul><p>That&#x27;s pretty much it.  The beauty of this is that you can&#x27;t get the declarations of your locals wrong
and you don&#x27;t have to list them all no matter how big the data is.  If the data shape changes the
cursor change automatically changes to accommodate it.  Everything is still statically typed.</p><p>Now lets look at the loop pattern:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %d\n&quot;, C.x, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Note that the columns of the cursor were defined by the column aliases of the <code>SELECT</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!C._has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%d, %d\n&quot;, C.x, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The loop is basically the same except <code>x</code> and <code>y</code> have been replaced with <code>C.x</code> and <code>C.y</code>
and again <code>_C_has_row_</code> is now <code>C._has_row_</code>.</p><p>The code generator knows that it should allocate storage for the <code>C</code> cursor if it has
the flag <code>SEM_TYPE_HAS_SHAPE_STORAGE</code> on it. The semantic analyzer adds that flag
if it ever finds <code>FETCH C</code> with no <code>INTO</code> part.</p><p>Finally let&#x27;s look at an example with cleanup required.  We&#x27;ll just change the test case a tiny bit.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, &quot;2&quot; AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %s\n&quot;, C.x, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The <code>x</code> column is now text.  We&#x27;ll get this code which will be studied below:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;C_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT &#x27;1&#x27;, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!C._has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_alloc_cstr(_cstr_1, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%s, %d\n&quot;, _cstr_1, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_free_cstr(_cstr_1, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It&#x27;s very similar to what we had before, let&#x27;s quickly review the differences.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1</span></div></div></div></div></div><ul><li><code>x</code> is now <code>cql_string_ref _Nonnull x;</code> rather than <code>cql_int32</code></li><li><code>x</code> has moved to the end (because it&#x27;s a reference type)</li><li>the offset of the first ref is computed in a constant</li></ul><p>Recall the reference types are always at the end and together.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div></div></div></div></div><ul><li><code>p_C_row</code> is now initialized to to ref count 1 and refs offset <code>p_C_refs_offset</code> defined above</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div></div></div></div></div><ul><li>C.x is now of type string</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_alloc_cstr(_cstr_1, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%s, %d\n&quot;, _cstr_1, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_free_cstr(_cstr_1, C.x);</span></div></div></div></div></div><ul><li>C.x has to be converted to a C style string before it can be used with <code>printf</code> as a <code>%s</code> argument</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div></div></div></div></div><ul><li>the cleanup section has to include code to teardown the cursor, this will release all of its reference variables in bulk<ul><li>remember we know the count, and the offset of the first one -- that&#x27;s all we need to do them all</li></ul></li></ul><p>With these primitives we can easily create cursors of any shape and load them up with data.  We don&#x27;t have to
redundantly declare locals that match the shape of our select statements which is both error prone and
a hassle.</p><p>All of this is actually very easy for the code-generator.  The semantic analysis phase knows if the cursor needs
shape storage.  And it also recognizes when a variable reference like <code>C.x</code> happens, the variable references are
re-written in the AST so that the code-generator doesn&#x27;t even have to know there was a cursor reference, from
its perspective the variable IS <code>C.x</code> (which it sort of is).  The code generator does have to create the
storage for the cursor but it knows it should do so because the cursor variable is marked with <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>.
A cursor without this marking only gets its statement (but not always as we&#x27;ll see later) and its <code>_cursor_has_row_</code>
hidden variable.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flowing-sqlite-statements-between-procedures"></a>Flowing SQLite Statements Between Procedures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flowing-sqlite-statements-between-procedures" title="Direct link to heading">#</a></h3><p>Earlier we saw that we can get a cursor from a SQLite <code>SELECT</code> statement.  The cursor is used to iterate
over the <code>sqlite3_stmt *</code> that SQLite provides to us.  This process can be done between procedures.  Here&#x27;s a
simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@ATTRIBUTE(cql:private)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This is the first example of a procedure that return a result set that we&#x27;ve seen.  The wiring for this is
very simple.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CQL_WARN_UNUSED cql_code q(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_Nullable *_Nonnull _result_stmt)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *_result_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, _result_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT &#x27;1&#x27;, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ == SQLITE_OK &amp;&amp; !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>First note that there are now <em>two</em> hidden parameters to <code>q</code>:</p><ul><li><code>_db_</code> : the database pointer as usual,</li><li><code>_result_stmt</code> : the statement produced by this procedure</li></ul><p>The rest of the code is just like any other bound SQL statement.  Note that if
<code>_result_stmt</code> isn&#x27;t otherwise set by the code it will be initialized to a statement
that will return zero rows.</p><p>All of this is pretty much old news except for the new hidden variable.  Note let&#x27;s look how we might use
this.  We can write a procedure that calls <code>q</code>, like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR CALL q();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This generates:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = q(_db_, &amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>All of the above is <em>exactly</em> the same as the previous cases where we got
data from the database except that instead of using <code>cql_prepare</code> the
compiler produced <code>_rc_ = q(_db_, &amp;C_stmt);</code>  That function call gives us,
of course, a ready-to-use <code>sqlite3_stmt *</code> which we can then step, and
use to fetch values.  The shape of the cursor <code>C</code> is determined by the
result type of procedure <code>q</code> -- hence they always match.</p><p>If q was in some other module, it could be declared with:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC q () (x TEXT NOT NULL, y INTEGER NOT NULL);</span></div></div></div></div></div><p>This is a procedure that takes no arguments and returns a result with the indicated shape.</p><p>CQL can generate this declaration for you if you add <code>--generate_exports</code> to the command line.  Note
that in this case <code>q</code> was marked with <code>@attribute(cql:private)</code> which caused <code>q</code> to be <code>static</code>
in the output. Hence it can&#x27;t be called outside this translation unit and <code>--generate_exports</code>
won&#x27;t provide the declaration.</p><p>If the private annotation were removed, the full exports for this file would be:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC q () (x TEXT NOT NULL, y INTEGER NOT NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC p () USING TRANSACTION;</span></div></div></div></div></div><p>And these would allow calling both procedures from elsewhere.  Simply <code>#include</code> the exports file.</p><p>There is a special function in the echoing code that can emit a procedure that was created in the
form that is needed to declare it, this is <code>gen_declare_proc_from_create_proc</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="value-cursors"></a>Value Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#value-cursors" title="Direct link to heading">#</a></h3><p>Once CQL had the ability to fetch rows into a cursor with no need to declare all the locals
it was clear that it could benefit from the ability to save a copy of any given row. That is
basic cursor operations seemed like they should be part of the calculus of CQL.  Here&#x27;s a
simple sample program that illustrates this.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE D CURSOR LIKE C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH D from C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>We already have a good idea what is going to happen with <code>C</code> in this program.  Let&#x27;s look at the
generated code focusing just on the parts that involve <code>D</code>.</p><p>First there is a row defintion for <code>D</code>. Unsurprisingly it is exactly the samea as the one for <code>C</code>.
This must be the case since we specified <code>D CURSOR LIKE C</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_D_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_D_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_D_refs_offset cql_offsetof(p_D_row, x) // count = 1</span></div></div></div></div></div><p>Then the <code>D</code> cursor variables will be needed:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">p_D_row D = { ._refs_count_ = 1, ._refs_offset_ = p_D_refs_offset };</span></div></div></div></div></div><p>The above also implies the cleanup code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(D);</span></div></div></div></div></div><p>finally, we fetch <code>D</code> from <code>C</code>.  That&#x27;s just some assignments:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  D._has_row_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;D.x, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  D.y = C.y;</span></div></div></div></div></div><p>Importantly, there is no <code>D_stmt</code> variable.  <code>D</code> is <em>not</em> a statement cursor like <code>C</code>, it&#x27;s
a so-called &quot;value&quot; cursor.  In that it can only hold values.</p><p>A value cursor can actually be loaded from anywhere, it just holds data.  You don&#x27;t
loop over it (attempts to do so will result in errors).</p><p>The general syntax for loading such a cursor is something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> FETCH D(x, y) FROM VALUES(C.x, C.y);</span></div></div></div></div></div><p>And indeed the form <code>FETCH D FROM C</code> was rewritten automatically into the general form.
The short form is just sugar.</p><p>Once loaded, <code>D.x</code> and <code>D.y</code> can be used as always.  The data type of <code>D</code> is similar to <code>C</code>.</p><p>The AST would report:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{declare_cursor_like_name}: D: select: { x: text notnull, y: integer notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   variable shape_storage value_cursor</span></div></div></div></div></div><p>meaning <code>D</code> has the flags <code>SEM_TYPE_STRUCT</code>, <code>SEM_TYPE_VARIABLE</code>, <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>, and <code>SEM_TYPE_VALUE_CURSOR</code>.
That last flag indicates that there is no statement for this cursor, it&#x27;s just values. And all such cursors must have
<code>SEM_TYPE_HAS_SHAPE_STORAGE</code> -- if they had no statement and no storage they would be -- nothing.</p><p>Value cursors are enormously helpful and there is sugar for loading them from all kinds of sources with a shape.
These forms are described more properly in <a href="https://cgsql.dev/cql-guide/ch05" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the Guide but they
all end up going through the general form, making the codegen considerably simpler. There are many examples where the semantic
analyzer rewrites a sugar form to a canonical form to keep the codegen from forking into dozens of special cases
and most of them have to do with shapes and cursors.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="returning-value-cursors"></a>Returning Value Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#returning-value-cursors" title="Direct link to heading">#</a></h3><p>Let&#x27;s look at an example that is similar to the previous one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@ATTRIBUTE(cql:private)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR LIKE SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C USING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   &quot;foo&quot; x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   3 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  OUT C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FETCH FROM CALL q();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  -- do something with C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Let&#x27;s discuss some of what is above, first looking at <code>q</code>:</p><ul><li><code>DECLARE C CURSOR LIKE SELECT &quot;1&quot; AS x, 2 AS y;</code> : this makes an empty value cursor<ul><li>note the shape is <code>LIKE</code> the indicated <code>SELECT</code>, the <code>SELECT</code> does not actually run</li></ul></li><li><code>FETCH ... USING</code> : this form is sugar, it lets you put the column names <code>x</code> and <code>y</code> adjacent to the values but is otherwise equivalent to the canonical form<ul><li><code>FETCH C(x, y) FROM VALUES(&quot;foo&quot;, 3);</code> is the canonical form</li><li>codegen only ever sees the canonical form</li></ul></li><li><code>OUT C</code> is new, we&#x27;ll cover this shortly</li></ul><p>Now let&#x27;s look at the C for <code>q</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct q_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} q_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define q_refs_offset cql_offsetof(q_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_foo_q, &quot;foo&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct q_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} q_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define q_C_refs_offset cql_offsetof(q_C_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void q(q_row *_Nonnull _result_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  memset(_result_, 0, sizeof(*_result_));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_C_row C = { ._refs_count_ = 1, ._refs_offset_ = q_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C._has_row_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;C.x, _literal_1_foo_q);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C.y = 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;_has_row_ = C._has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;_refs_count_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;_refs_offset_ = q_refs_offset;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;_result_-&gt;x, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;y = C.y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>the <code>_result_</code> variable is clobbed with zeros, it is assumed to be junk coming in<ul><li>if it had valid data, the caller is expected to use <code>cql_teardown_row</code> to clean it up <em>before</em> calling</li></ul></li><li><code>q_row</code> : this is new, this is the structure type for the result of <code>q</code><ul><li>it&#x27;s exactly the same shape as C</li><li>it has its own <code>q_refs_offset</code> like other shapes</li></ul></li><li><code>q_C_row</code> : this is the same old same old row structure for cursor C</li><li><code>static void q(q_row *_Nonnull _result_)</code> : q now accepts a q_row to fill in!<ul><li>note that <code>q</code> does not have the <code>_db_</code> parameter, it doesn&#x27;t use the database!</li><li>it is entirely possible to fill value cursors from non-database sources, e.g. constants, math, whatever</li></ul></li><li><code>C</code> : the value cursor is declared as usual</li><li><code>C.x</code> and <code>C.y</code> are loaded, this resolves the <code>FETCH</code> statement</li><li>the <code>_result_</code> fields are copied from <code>C</code>, this resolves the <code>OUT</code> statement</li><li><code>C</code> can be torn down</li><li>there is no cleanup label, there are no error cases, nothing can go wrong!</li></ul><p>The net of all this is that we have loaded a value cursor that was passed in to the procedure via
a hidden argument and it has retained references as appropriate.</p><p>Now let&#x27;s look at <code>p</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q((q_row *)&amp;C); // q_row identical to cursor type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // usually you do something with C at this point</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>p_C_row</code> : the cursor type for <code>C</code> in the procedure <code>p</code> is defined</li><li><code>p_C_refs_offset</code> : the refs offset for <code>C</code> in <code>p</code> as usual</li><li><code>C = {...}</code> : the usual initialization for a cursor with shape<ul><li>note that <code>C</code> is a value cursor, so it has no <code>C_stmt</code></li></ul></li><li><code>cql_teardown_row(C)</code> : releases any references in C, there are none<ul><li>this pattern is general purpose, the call to <code>q</code> might be in a loop or something</li><li>in this instance the teardown here is totally redundant, but harmless</li></ul></li><li><code>q((q_row *)&amp;C)</code> : fetch <code>C</code> by calling <code>q</code><ul><li><code>p_C_row</code> has been constructed to be exactly the same as <code>q_row</code> so this cast is safe</li><li>there are no error checks because <code>q</code> can&#x27;t fail!</li></ul></li><li>some code that would use <code>C</code> is absent for this sample, it would go where the comment is</li><li>the cleanup label is missing because there are no error cases, emitting the label would just cause warnings<ul><li>such warnings are often escalated to errors in production builds...</li></ul></li><li><code>cql_teardown_row(C)</code> is needed as always,<ul><li>even though there is no cleanup label the <code>teardown</code> is in the cleanup section</li><li>the <code>teardown</code> was added as usual when <code>C</code> was declared</li></ul></li></ul><p>So with just normal value cursor codegen we can pretty easily create a situation where
procedures can move structures from one to another.  As we saw, the source of value cursors
may or may not be the database.  Value cursors are frequently invaluable in test code
as they can easily hold mock rows based on any kind of computation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-sets"></a>Result Sets<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-sets" title="Direct link to heading">#</a></h3><p>In addition to returning a single row into a value cursor, or returning a statement to consume with a statement cursor,
it&#x27;s possible to generate a result set.  So far the samples have included <code>@attribute(cql:private)</code> to suppress that
code.  This pattern is intended to let regular C code access the data so <code>private</code> suppresses it.</p><p>Let&#x27;s consider a simple example, this example returns only one row but the mechanism works for any number of rows,
we&#x27;re just using this form because it&#x27;s what we&#x27;ve used so far and its simple.  Let&#x27;s begin:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The core generated function is this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *_result_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, _result_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT &#x27;1&#x27;, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ == SQLITE_OK &amp;&amp; !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We&#x27;ve seen this before, it creates the SQLite statement.  But that isn&#x27;t all the code that was generated,
let&#x27;s have a look at what else we got in our outputs:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p_fetch_results(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_result_set_ref _Nullable *_Nonnull result_set)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_profile_start(CRC_p, &amp;p_perf_index);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code rc = p(_db_, &amp;stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_fetch_info info = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .rc = rc,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .db = _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .stmt = stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .data_types = p_data_types,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .col_offsets = p_col_offsets,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .refs_count = 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .refs_offset = p_refs_offset,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .encode_context_index = -1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .rowsize = sizeof(p_row),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .crc = CRC_p,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .perf_index = &amp;p_perf_index,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cql_fetch_all_results(&amp;info, (cql_result_set_ref *)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>p_fetch_results</code> does two main things:</p><ul><li><code>cql_code rc = p(_db_, &amp;stmt)</code> : it calls the underlying function to get the statement</li><li><code>cql_fetch_all_results</code> : it calls a standard helper to read all the results from the statement and put them into <code>result_set</code><ul><li>to do the fetch, it sets up a <code>cql_fetch_info</code> for this result set, this has all the information needed to do the fetch</li><li>the intent here is that even a complex fetch with lots of columns can be done economically, and</li><li>the code that does the fetching is shared</li></ul></li></ul><p>Let&#x27;s look at the things that are needed to load up that <code>info</code> structure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">uint8_t p_data_types[p_data_types_count] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // x</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // y</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_refs_offset cql_offsetof(p_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static cql_uint16 p_col_offsets[] = { 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_offsetof(p_row, x),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_offsetof(p_row, y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div></div></div><ul><li><code>p_row</code> : the row structure for this result set, same as always, reference types last</li><li><code>p_data_types</code> : an array with the data types encoded as bytes</li><li><code>p_refs_offset</code> : the offset of the first reference type</li><li><code>p_col_offsets</code> : this is the offset of each column within the row structure<ul><li>these are in column order, not offset order</li></ul></li></ul><p>Code generation creates a <code>.c</code> file and a <code>.h</code> file, we haven&#x27;t talked much about the <code>.h</code>
because it&#x27;s mostly prototypes for the functions in the <code>.c</code> file.  But in this case we have
a few more interesting things.  We need just two of them:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CRC_p -6643602732498616851L</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_data_types_count 2</span></div></div></div></div></div><p>Now we&#x27;re armed to discuss loading the <code>info</code> structure:</p><ul><li><code>.rc</code> : the fetcher needs to know if <code>p</code> was successful, it won&#x27;t read from the statement if it wasn&#x27;t</li><li><code>.db</code> : the database handle, the fetcher needs this to call SQLite APIs</li><li><code>.stmt</code> : the statement that came from <code>p</code> that is to be enumerated</li><li><code>.data_types</code> : types of the columns, this tells the fetcher what columns to read to the statement in what order</li><li><code>.col_offsets</code> : the column offsets, this tells the fetcher were to store the column data within each row</li><li><code>.refs_count</code> : the number of references in the row, this is needed to tear down the rows in the result set when it is released</li><li><code>.refs_offset</code> : the first reference offset, as usual this tells the fetcher where the references that need to be released are</li><li><code>.encode_context_index</code> : it&#x27;s possible to have sensitive fields encoded, this identifies an optional column that will be combined with the sensitive data
. <code>.rowsize</code> : the size of <code>p_row</code>, this is needed to allocate rows in a growable buffer</li><li><code>.crc</code> : this is a CRC of the code of <code>p</code>, it&#x27;s used to uniquely identify <code>p</code> economically, performance logging APIs typically use this CRC in a begin/end logging pair</li><li><code>.perf_index</code> : performance data for stored procedures is typically stored in an array of stats, CQL provides storage for the index for each procedure</li></ul><p>With this data (which is in the end pretty small) the <code>cql_fetch_all_results</code> can do all the things it needs to do:</p><ul><li><code>cql_profile_start</code> has already been called, it can call <code>cql_profile_end</code> once the data is fetched<ul><li><code>cql_profile_start</code> and <code>_end</code> do nothing by default, but those macros can be defined to log performance data however you like</li></ul></li><li>it can allocate a <code>bytebuf</code> with <code>cql_bytebuf_open</code> and then grow it with <code>cql_bytebuf_alloc</code><ul><li>in the end all the rows are in one contiguous block of storage</li></ul></li><li><code>cql_multifetch_meta</code> is used to read each row from the result set, it&#x27;s similar to <code>cql_multifetch</code><ul><li>the <code>meta</code> version uses <code>data_types</code> and <code>column_offsets</code> instead of varargs but is otherwise the same</li><li>the first member of the <code>col_offsets</code> array is the count of columns</li></ul></li></ul><p>With this background, <code>cql_fetch_all_results</code> should be very approachable.  There&#x27;s a good bit of work but it&#x27;s all very simple.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// By the time we get here, a CQL stored proc has completed execution and there is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// now a statement (or an error result).  This function iterates the rows that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// come out of the statement using the fetch info to describe the shape of the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected results.  All of this code is shared so that the cost of any given</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stored procedure is minimized.  Even the error handling is consolidated.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_code cql_fetch_all_results(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_fetch_info *_Nonnull info,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_result_set_ref _Nullable *_Nonnull result_set) {...}</span></div></div></div></div></div><p>The core of that function looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bytebuf_open(&amp;b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    rc = sqlite3_step(stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (rc == SQLITE_DONE) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (rc != SQLITE_ROW) goto cql_error;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    count++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    row = cql_bytebuf_alloc(&amp;b, rowsize);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    memset(row, 0, rowsize);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch_meta((char *)row, info);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_profile_stop(info-&gt;crc, info-&gt;perf_index);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><ul><li><code>cql_bytebuf_open</code> : open the buffer, get ready to start appending rows</li><li><code>sqlite3_step</code> : keep reading while we get <code>SQLITE_ROW</code>, stop on <code>SQLITE_DONE</code></li><li><code>cql_bytebuf_alloc</code> : allocate a new row in the buffer</li><li><code>memset</code> : zero the row</li><li><code>cql_multifetch_meta</code> : read the data from the the statement into the row</li><li><code>cql_profile_stop</code> : signals that processing is done and profiling can stop</li><li>if all goes well, <code>SQLITE_OK</code> is returned as usual</li></ul><p>The remaining logic is largely about checking for errors and tearing down the result set
if anything goes wrong.  There is not very much to it, and it&#x27;s worth a read.</p><p>Now recall that the way <code>cql_fetch_all_results</code> was used, was as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cql_fetch_all_results(&amp;info, (cql_result_set_ref *)result_set)</span></div></div></div></div></div><p>And <code>result_set</code> was the out-argument for the the <code>p_fetch_results</code> method.</p><p>So <code>p_fetch_results</code> is used to get that result set.  But what can you do with it?
Well, the result set contains copy of all the selected data, ready to use in with a C-friendly API.
The interface is in the generated <code>.h</code> file.  Let&#x27;s look at that now, it&#x27;s the final piece of the puzzle.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#ifndef result_set_type_decl_p_result_set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define result_set_type_decl_p_result_set 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_result_set_type_decl(p_result_set, p_result_set_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_string_ref _Nonnull p_get_x(p_result_set_ref _Nonnull result_set, cql_int32 row);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_int32 p_get_y(p_result_set_ref _Nonnull result_set, cql_int32 row);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_int32 p_result_count(p_result_set_ref _Nonnull result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern CQL_WARN_UNUSED cql_code p_fetch_results(sqlite3 *_Nonnull _db_, p_result_set_ref _Nullable *_Nonnull result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_row_hash(result_set, row) cql_result_set_get_meta( \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (cql_result_set_ref)(result_set))-&gt;rowHash((cql_result_set_ref)(result_set), row)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_row_equal(rs1, row1, rs2, row2) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_result_set_get_meta((cql_result_set_ref)(rs1))-&gt;rowsEqual( \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (cql_result_set_ref)(rs1), \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    row1, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (cql_result_set_ref)(rs2), \</span></div></div></div></div></div><ul><li><code>cql_result_set_type_decl</code> : declares <code>p_result_set_ref</code><ul><li>to avoid being defined more than once, the declaration is protected by <code>#ifndef result_set_type_decl_p_result_set</code></li></ul></li><li><code>p_get_x</code>, <code>p_get_y</code> : allow access to the named fields of the result set at any given row</li><li><code>p_result_count</code> :  provides the count of rows in the result set</li><li><code>p_fetch_results</code> : the declaration of the fetcher (previously discussed)</li><li><code>p_row_hash</code> : provides a hash of any given row, useful for detecting changes between result sets</li><li><code>p_row_equal</code> : tests two rows in two results sets of the same shape for equality</li></ul><p>The getters are defined very simply:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull p_get_x(p_result_set_ref _Nonnull result_set, cql_int32 row) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_row *data = (p_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data[row].x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int32 p_get_y(p_result_set_ref _Nonnull result_set, cql_int32 row) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_row *data = (p_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data[row].y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The <code>p_row</code> is exactly the right size, and of course the right shape, the final access looks something like <code>data[row].x</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-sets-from-the-out-statement"></a>Result Sets from the OUT statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-sets-from-the-out-statement" title="Direct link to heading">#</a></h4><p>Recalling this earlier example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR LIKE SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C USING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   &quot;foo&quot; x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   3 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  OUT C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The original example had <code>@attribute(cql:private)</code> to suppress the result set, but normally a one-row result is
is generated from such a method.  The C API is almost identical.  However, there count is always 0 or 1.</p><p>The getters do not have the row number:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_string_ref _Nonnull q_get_x(q_result_set_ref _Nonnull result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_int32 q_get_y(q_result_set_ref _Nonnull result_set);</span></div></div></div></div></div><p>The actual getters are nearly the same as well</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull q_get_x(q_result_set_ref _Nonnull result_set) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_row *data = (q_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data-&gt;x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int32 q_get_y(q_result_set_ref _Nonnull result_set) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_row *data = (q_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data-&gt;y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Basically <code>data[row].x</code> just became <code>data-&gt;x</code> and the rest is nearly the same.
Virtually all the code for this is shared.</p><p>You can find all this and more in <code>cg_c.c</code> by looking here:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If a stored procedure generates a result set then we need to do some extra work</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to create the C friendly rowset creating and accessing helpers.  If stored</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// proc &quot;foo&quot; creates a row set then we need to:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * emit a struct &quot;foo_row&quot; that has the shape of each row</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    * this isn&#x27;t used by the client code but we use it in our code-gen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * emit a function &quot;foo_fetch_results&quot; that will call &quot;foo&quot; and read the rows</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    from the statement created by &quot;foo&quot;.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    * this method will construct a result set object via cql_result_create and store the data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    * the remaining functions use cql_result_set_get_data and _get_count to get the data back out</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * for each named column emit a function &quot;foo_get_[column-name]&quot; which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    gets that column out of the rowset for the indicated row number.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * prototypes for the above go into the main output header file</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_proc_result_set(ast_node *ast)</span></div></div></div></div></div><p>There are many variations in that function to handle the cases mentioned so far, but they are
substantially similar to each other with a lot of shared code.  There is one last variation
we should talk about and that is the <code>OUT UNION</code> form.  It is the most flexible of them all.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-sets-from-the-out-union-statement"></a>Result Sets from the OUT UNION statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-sets-from-the-out-union-statement" title="Direct link to heading">#</a></h4><p>The <code>OUT</code> statement, allows the programmer to produce a result set that has exactly one row,
<code>OUT UNION</code> instead accumulates rows.  This is very much like writing your own <code>fetcher</code> procedure
with your own logic.  The data could come from the database, by, for instance, enumerating
a cursor.  Or it can come from some computation or a mix of both.  Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR LIKE SELECT 1 AS x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET i := 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE i &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH C(x) FROM VALUES(i);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    OUT UNION C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET i := i + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Let&#x27;s look at the code for the above, it will be very similar to other examples we&#x27;ve seen so far:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct q_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} q_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void q_fetch_results(q_result_set_ref _Nullable *_Nonnull _result_set_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bytebuf _rows_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bytebuf_open(&amp;_rows_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *_result_set_ = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_C_row C = { 0 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 i = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_profile_start(CRC_q, &amp;q_perf_index);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  i = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(i &lt; 5)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C.x = i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_retain_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (C._has_row_) cql_bytebuf_append(&amp;_rows_, (const void *)&amp;C, sizeof(C));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    i = i + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_results_from_data(SQLITE_OK, &amp;_rows_, &amp;q_info, (cql_result_set_ref *)_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>q_C_row</code> : the shape of the cursor, as always</li><li><code>_rows_</code> : the <code>bytebuf</code> that will hold our data</li><li><code>cql_bytebuf_open(&amp;_rows_);</code> : initializes the buffer</li><li><code>cql_profile_start(CRC_q, &amp;q_perf_index);</code> : start profiling as before</li><li><code>for (;;)</code> : the while pattern as before</li><li><code>C.x = i;</code> : loads the cursor</li><li><code>cql_retain_row(C);</code> : retains any references in the cursor (there are none)<ul><li>we&#x27;re about to copy the cursor into the buffer so all refs need to be +1</li></ul></li><li><code>cql_bytebuf_append</code> : append the the cursor&#x27;s bytes into the buffer</li><li>the loop does its repetitions until finally</li><li><code>cql_results_from_data</code> : used instead of <code>cql_fetch_all_results</code> because all the data is already prepared<ul><li>in this particular example there is nothing to go wrong so it always gets <code>SQLITE_OK</code></li><li>in a more complicated example, <code>cql_results_from_data</code> frees any partly created result set in case of error</li><li><code>cql_results_from_data</code> also performs any encoding of sensitive data that might be needed</li></ul></li><li><code>q_info</code> : created as before, but it can be static as it&#x27;s always the same now</li></ul><p>Importantly, when using <code>OUT UNION</code> the codegen only produces <code>q_fetch_results</code>, there is no <code>q</code>.
If you try to call <code>q</code> from CQL you will instead call <code>q_fetch_results</code>. But since
many results as possible, a cursor is needed to make the call.</p><p>Here&#x27;s an example, here <code>p</code> calls the <code>q</code> method above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (OUT s INTEGER NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR CALL q();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET s := s + C.x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>And the relevant code for this is as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull s) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)s, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_result_set_ref C_result_set_ = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 C_row_num_ = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 C_row_count_ = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { 0 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *s = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_fetch_results(&amp;C_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C_row_num_ = C_row_count_ = -1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C_row_num_++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = C_row_num_ &lt; C_row_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!C._has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *s = (*s) + C.x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_object_release(C_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>p_C_row</code> : the cursor row as always</li><li><code>cql_contract_argument_notnull((void *)s, 1)</code> : verify that the out arg pointer is not null</li><li><code>C_result_set_</code> : this will hold the result set from <code>q_fetch_results</code></li><li><code>C_row_num_</code> : the current row number being processed in the result set</li><li><code>C_row_count_</code> : the total number of rows in the result set</li><li>other locals are intialized as usual</li><li><code>*s = 0;</code> : set the out arg to non-garbage as usual</li><li><code>q_fetch_results</code> : get the result set from <code>q_fetch_results</code><ul><li>in this case no database access was required so this API can&#x27;t fail</li><li><code>C_row_num</code> : set to -1</li><li><code>C_row_count</code> : set to the row count</li></ul></li><li><code>cql_copyoutrow</code> : copies one row from the result set into the cursor</li><li><code>*s = (*s) + C.x;</code> : computes the sum</li><li><code>cql_object_release</code> : the result set is torn down</li><li>if there are any reference fields in the cursor there would have been a <code>cql_teardown_row(C)</code></li></ul><p>In short, this is another form of cursor, it&#x27;s a value cursor, so it has no statement but
it also needs a result set, a count and an index to go with it so that it can enumerate the result set.</p><p>In the AST it looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{name C}: C: select: { x: integer notnull } variable shape_storage uses_out_union</span></div></div></div></div></div><p>This implies we have the semantic flags: <code>SEM_TYPE_STRUCT</code>, <code>SEM_TYPE_VARIABLE</code>, <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>, and <code>SEM_TYPE_USES_OUT_UNION</code>.</p><p>The difference is of course the presence of <code>SEM_TYPE_USES_OUT_UNION</code>.</p><p>This is the last of the cursor forms and the final complication of <code>cg_proc_result_set</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>At present <code>cg_c.c</code> is a little over 7400 lines of code, maybe 1500 of those lines are comments.   So <code>cg_c.c</code> is actually quite a
bit smaller and simpler than <code>sem.c</code> (roughly 1/3 the size).  It is, however, the most complex of the code generators by far.
Part 3 of the internals guide has come out a lot larger than Part 2 but that&#x27;s mainly because there are a few more cases worth
discussing in detail and the code examples of Part 3 are bigger than the AST examples of Part 2.</p><p>Topics covered included:</p><ul><li>compiling expressions into C, including nullable types</li><li>techniques used to generate control flow</li><li>creation of result sets, including:<ul><li>various helpers to do the reading economically</li><li>the use of <code>cql_bytebuf</code> to manage the memory</li></ul></li><li>create the text for SQLite statements and binding variables to that text</li><li>error management, and how it relates to <code>TRY</code> and <code>CATCH</code> blocks</li><li>use of cleanup sections to ensure that references and SQLite statement lifetime is always correct</li><li>the contents of the <code>.c</code> and <code>.h</code> files and the key sections in them</li><li>the use of <code>charbuf</code> to create and assemble fragments</li></ul><p>As with the other parts, this is not a complete discussion of the code but a useful survey that
should give readers enough context to understand <code>cg_c.c</code> and the runtime helpers in <code>cqlrt.c</code>
and <code>cqlrt_common.c</code>.  Good luck in your personal exploration!</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-12-30T19:55:24.000Z" class="docLastUpdatedAt_217_">12/30/2021</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int02"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 2: Semantic Analysis</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cql-guide/int04"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Part 4: Testing Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#c-code-generation" class="table-of-contents__link">C Code Generation</a><ul><li><a href="#launching-the-code-generator" class="table-of-contents__link">Launching the Code Generator</a></li><li><a href="#character-buffers-and-byte-buffers" class="table-of-contents__link">Character Buffers and Byte Buffers</a></li><li><a href="#expressions" class="table-of-contents__link">Expressions</a></li><li><a href="#basic-control-flow-patterns" class="table-of-contents__link">Basic Control Flow Patterns</a></li><li><a href="#cleanup-and-errors" class="table-of-contents__link">Cleanup and Errors</a></li><li><a href="#string-literals" class="table-of-contents__link">String Literals</a></li><li><a href="#executing-sqlite-statements" class="table-of-contents__link">Executing SQLite Statements</a></li><li><a href="#reading-single-values" class="table-of-contents__link">Reading Single Values</a></li><li><a href="#reading-rows-with-cursors" class="table-of-contents__link">Reading Rows With Cursors</a></li><li><a href="#fetching-data-from-cursors" class="table-of-contents__link">Fetching Data From Cursors</a></li><li><a href="#cursors-with-storage" class="table-of-contents__link">Cursors With Storage</a></li><li><a href="#flowing-sqlite-statements-between-procedures" class="table-of-contents__link">Flowing SQLite Statements Between Procedures</a></li><li><a href="#value-cursors" class="table-of-contents__link">Value Cursors</a></li><li><a href="#returning-value-cursors" class="table-of-contents__link">Returning Value Cursors</a></li><li><a href="#result-sets" class="table-of-contents__link">Result Sets</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Meta Platforms Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2021 Meta Platforms, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.5dc5ab0d.js"></script>
<script src="/runtime~main.92784f52.js"></script>
<script src="/main.2de251bc.js"></script>
<script src="/1.cd5cf55e.js"></script>
<script src="/2.004730db.js"></script>
<script src="/3.8420923d.js"></script>
<script src="/1be78505.4576dc45.js"></script>
<script src="/95.e85dd30d.js"></script>
<script src="/5456faf3.095cdb83.js"></script>
<script src="/17896441.652528aa.js"></script>
<script src="/c27d1879.91567b92.js"></script>
</body>
</html>