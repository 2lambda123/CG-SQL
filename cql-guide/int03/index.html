<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 3: C Code Generation | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 3: C Code Generation | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int03"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int03"><link rel="stylesheet" href="/styles.efe3e8f9.css">
<link rel="preload" href="/styles.4a61b4b3.js" as="script">
<link rel="preload" href="/runtime~main.7f4ba451.js" as="script">
<link rel="preload" href="/main.9cd58f71.js" as="script">
<link rel="preload" href="/1.bac24c28.js" as="script">
<link rel="preload" href="/2.29ab4659.js" as="script">
<link rel="preload" href="/3.9ee6d42d.js" as="script">
<link rel="preload" href="/1be78505.ae32d621.js" as="script">
<link rel="preload" href="/87.9cf8ff91.js" as="script">
<link rel="preload" href="/5456faf3.d3330067.js" as="script">
<link rel="preload" href="/17896441.923fd9c6.js" as="script">
<link rel="preload" href="/c27d1879.7742b602.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 3: C Code Generation</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every detail of code generation but rather to give
a sense of how codegen happens in general -- the core strategies and implementation choices --
so that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish
this, various key data structures will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="c-code-generation"></a>C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#c-code-generation" title="Direct link to heading">#</a></h2><p>There are several key pieces of C code that we have to generate to make working CQL procedures using C
functions.  This all happens in <code>cg_c.c</code>.  From a big picture perspective, these are the essential problems:</p><ul><li>we have to compile SQL expressions into C<ul><li>including expressions with variables that are nullable</li><li>including SQL expressions that are highly complex like <code>CASE..WHEN..THEN..END</code> and <code>IN (..)</code></li></ul></li><li>we have to generate control flow for things like <code>IF</code>, <code>WHILE</code> and, <code>SWITCH</code></li><li>we have to make result sets<ul><li>including the code to slurp up all the rows from a SQL statement into an array of values</li><li>we want to do this very economically</li></ul></li><li>we have to be able to create the text for every SQLite statement and bind any variables to it</li><li>we have to check every SQLite API for errors and throw exceptions consistently and deal with them<ul><li>including constructs that allow users to handle exceptions, such as <code>TRY/CATCH</code></li></ul></li><li>we have to track any reference types carefully so that retain/release pairs are done consistently<ul><li>even in the presence of SQLite errors or other exceptions</li></ul></li><li>we have to produce a <code>.h</code> and a <code>.c</code> file for the C compiler<ul><li>contributions to these files could come from various places</li><li>the <code>.c</code> file will itself have various sections and we might need to contribute to them at various points in the compilation</li></ul></li><li>we want to do this all in one pass over the AST</li><li>we get to assume that the program is error free, codegen never runs unless semantic analysis reports zero errors<ul><li>so nothing can be wrong by the time the codegen pass runs, we never detect errors here</li><li>sometimes we add <code>Contract</code> and <code>Invariant</code> statements to <code>cg.c</code> that make our assumptions clear and prevent regressions</li></ul></li></ul><p>There are some very important building blocks used to solve these problems we will start with those, then move to
a discussion of each of the essential kinds of code generation that we have to do to get working programs.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="launching-the-code-generator"></a>Launching the Code Generator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#launching-the-code-generator" title="Direct link to heading">#</a></h3><p>Once semantic analysis is done all of the code generators have the same contract: they
have a main function like <code>cg_c_main</code> for the C code generator.  It gets the root of
the AST and it can use the public interface of the semantic analyzer to get additional
information.  See <a href="https://cgsql.dev/cql-guide/int02" target="_blank" rel="noopener noreferrer">Part 2</a> for those details.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for code-gen.  This will set up the buffers for the global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variables and any loose calls or DML.  Any code that needs to run in the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// global scope will be added to the global_proc.  This is the only codegen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// error that is possible.  If you need global code and you don&#x27;t have a global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// proc then you can&#x27;t proceed.  Semantic analysis doÆ’esn&#x27;t want to know that stuff.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Otherwise all we do is set up the most general buffers for the global case and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// spit out a function with the correct name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_c_main(ast_node *head) { ... }</span></div></div></div></div></div><p>In addition to initializing its scratch storage, the main entry point also sets up a
symbol table for AST dispatch just like the <code>gen_</code> and <code>sem_</code> functions do.  Here
are some samples from that table with the most common options:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_view_stmt);</span></div></div></div></div></div><p>The DDL (Data Definition Lanaguage) statements all get the same handling:  The text of the statement
is generated from the AST. Any variables are bound and then the statement is executed.  The work
is done with <code>cg_bound_sql_statement</code> which will be discussed later.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DDL invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We don&#x27;t minify the aliases because DDL can have views and the view column names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can be referred to in users of the view.  Loose select statements can have</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// no external references to column aliases.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_any_ddl_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>DML (Data Manipulation Language) statements are declared similarly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(begin_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(commit_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(rollback_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(savepoint_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(delete_stmt);</span></div></div></div></div></div><p>They are handled by <code>cg_std_dml_exec_stmt</code>; the processing is identical to
DDL except <code>CG_MINIFY_ALIASES</code> is specified.  This allows the code generator
to remove unused column aliases in select statements to save space.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DML invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_std_dml_exec_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Note that this flag difference only matters for the <code>create view</code> statement
but for symmetry all the DDL is handled with one macro and all the DML
with the second macro.</p><p>Next, the easiest case... there are a bunch of statements that create
no code-gen at all.  These are type defintions that are interesting
only to the semantic analyzer or other control statements.  Some examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_enum_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_named_type);</span></div></div></div></div></div><p>Next, the general purpose statement handler.  This creates a mapping
from the <code>if_stmt</code> AST node to <code>cg_if_stmt</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(assign);</span></div></div></div></div></div><p>The next group is the expressions, with precedence and operator specified. There is a lot of code sharing
as you can see from this sample:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, cg_expr_num, &quot;num&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, cg_expr_str, &quot;STR&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, cg_expr_null, &quot;NULL&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, cg_expr_dot, &quot;DOT&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, cg_binary, &quot;*&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(div, cg_binary, &quot;/&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, cg_binary, &quot;%&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(add, cg_binary, &quot;+&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(sub, cg_binary, &quot;-&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, cg_unary, &quot;!&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, cg_unary, &quot;~&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, cg_unary, &quot;-&quot;, C_EXPR_PRI_UNARY);</span></div></div></div></div></div><p>Most (not all) of the binary operators are handled with one function <code>cg_binary</code> and likewise
most unary operators are handled with <code>cg_unary</code>.</p><p>Note: the precedence constants are the <code>C_EXPR_PRI_*</code> flavor because parentheses will be
generated based on the C rules at this point.  Importantly, the AST still, and always
has the user-specified order of operations encoded in it, there&#x27;s no change there.  The
only thing that changes is where parentheses are needed to get the desired result.  Parens
may need to be added and some that were present in the original text might no longer be needed.</p><p>e.g.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* NOT is weaker than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET x := (NOT 1) + (NOT 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := NOT 1 + 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* ! is stronger than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! 1 + ! 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! (1 + 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Finally, many built-in functions need special codegen.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(coalesce);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div></div></div></div></div><p><code>FUNC_INIT(coalesce)</code> creates a mapping between the function name <code>coalesce</code> and the generator <code>cg_func_coalesce</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="character-buffers-and-byte-buffers"></a>Character Buffers and Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#character-buffers-and-byte-buffers" title="Direct link to heading">#</a></h3><p>The first kind of text output that CQL could produce was the AST echoing.  This was original done directly with <code>fprintf</code> but
that was not flexible enough as the output had to be captured to be emitted into other places like comments or the text of
SQL statements to go to SQLite.  This forces that pass to use character buffers, which we touched on in Part 1.  Code generation
has a more profound dependency on character buffers -- they are literally all over <code>cg_c.c</code> and we need to go over how hey are used.</p><p>The public interace is in <code>charbuf.h</code> and it&#x27;s really quite simple.  You allocate a <code>charbuf</code> and then you can <code>bprintf</code> into it.
Let&#x27;s be a bit more specific:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_INTERNAL_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_GROWTH_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct charbuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char *ptr;      // pointer to stored data, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t used;  // bytes used in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t max;   // max bytes in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // builtin buffer storage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char internal[CHARBUF_INTERNAL_SIZE];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} charbuf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( int32_t charbuf_open_count );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bopen(charbuf* b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bclose(charbuf *b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bprintf(charbuf *b, const char *format, ...);</span></div></div></div></div></div><p>The typical pattern goes something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf foo;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;foo);</span></div></div></div></div></div><p>Note that <code>charbuf</code> includes <code>CHARBUF_INTERNAL_SIZE</code> of storage that does not
have to be allocated with <code>malloc</code> and it doesn&#x27;t grow very aggressively.
This reflects that fact that most <code>charbuf</code> instances are very small.
Of course a <code>charbuf</code> could go on the heap if it needs to outlive
the function it appears in, but this is exceedingly rare.</p><p>To make sure buffers are consistently closed (and this is a problem because
there are often a lot of them.  They are allocated with these simple helper
macros.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_OPEN(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t __saved_charbuf_count##x = charbuf_open_count; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf x; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_CLOSE(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;x); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(__saved_charbuf_count##x == charbuf_open_count)</span></div></div></div></div></div><p>the earlier example would be written more properly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(foo);</span></div></div></div></div></div><p>If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure.</p><p>It&#x27;s normal to create several buffers in the course of doing code generation.  In fact some of these buffers
become &quot;globally&quot; visible and get swapped out as needed.  For instance this kind of chaining is normal.
Inside of <code>cg_create_proc_stmt</code> there is these sequence:</p><p>Make new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_fwd_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_body);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_cleanup);</span></div></div></div></div></div><p>Save what we got...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_main = cg_main_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_decls = cg_declarations_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_scratch = cg_scratch_vars_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_cleanup = cg_cleanup_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_fwd_ref = cg_fwd_ref_output;</span></div></div></div></div></div><p>Switch to the new...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fwd_ref_output = &amp;proc_fwd_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_main_output = &amp;proc_body;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_declarations_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_vars_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_cleanup_output = &amp;proc_cleanup;</span></div></div></div></div></div><p>And of course the code puts the original values back when it&#x27;s done and closes the buffers.</p><p>This means that while processing a procedure the codegen that declares say scratch variables,
which would go to <code>cg_scratch_vars_output</code> is going to target the <code>proc_locals</code> buffer
which will be emitted before the <code>body</code>.  By the time <code>cg_stmt_list</code> is invoked the
<code>cg_main_output</code> variable will be pointing to the procedure body, thus any statements
will go into there rather than being acculated at the global level -- it&#x27;s possible to
have code that is not in a procedure (see <a href="https://cgsql.dev/cql-guide/x1#--global_proc-name" target="_blank" rel="noopener noreferrer"><code>--global_proc</code></a>).</p><p>But in general, it&#x27;s very useful to have different buffers going on at the same time.  New local variables
or scratch variables can be added to their own buffer which goes before the code runs.  New cleanup
steps that are necessary can be added to the cleanup output which will appear at the end.  The final
function combines all of these pieces with maybe some glue.  Everything works like this, <code>IF</code> statements,
expressions, all of it.</p><p>One interesting but unexpected feature of <code>charbuf</code> is that it provides helper methods for indenting
buffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C
code because of course you want (e.g.) the body of an <code>if</code> statement to be indented.  CQL tries to create
well formatted code that is readable by humans as much as possible.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="byte-buffers"></a>Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#byte-buffers" title="Direct link to heading">#</a></h4><p>These are less commonly used but there is a peer to <code>charbuf</code> creatively called <code>bytebuf</code>.  This gives you
a growable binary buffer.  It&#x27;s often used to hold arrays of structures.  Interestingly, <code>cg_c.c</code> doesn&#x27;t
currently consume byte buffers, the presence of <code>bytebuf.c</code> actually came late to the CQL compiler. However
the CQL runtime <code>cqlrt.c</code> (and <code>cqlrt_common.c</code>) provide <code>cql_bytebuf_open</code>, <code>cql_bytebuf_alloc</code> and,
<code>cql_bytebuf_close</code> which are akin to the <code>charbuf</code> methods.  These functions are used in the generated
code to create result sets at runtime.  The <code>bytebuf</code> was so useful that it found its way back from the
runtime into the compiler itself, and is used by other code-generators like the schema upgrader.   The
semantic analyzer also uses it to help with query fragments and to track the various upgrade annotations.</p><p>Both <code>charbuf</code> and <code>bytebuf</code> are simple enough that they don&#x27;t need discussion. It&#x27;s easier to just read
the code and the comments.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expressions"></a>Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expressions" title="Direct link to heading">#</a></h3><p>Many of the output needs of CQL stemmed from the base case of creating expressions.  A simple CQL
expression like</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>seems innocuous enough, we&#x27;d like this to compile to this code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div></div></div></div></div><p>And indeed, it might.  Here&#x27;s some actual output from the compiler:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>(*) the output above was created by using <code>out/cql --in x --cg x.h x.c --nolines</code> to avoid all the # directives</p><p>Looks easy enough.  And indeed if all expressions were like this, you could do expression compilation pretty simply --
every binary operator would look something like this:</p><ul><li>recurse left</li><li>emit infix operator</li><li>recurse right</li></ul><p>This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have
the whole expression.</p><p>This doesn&#x27;t work at all.  To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result
is telling:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>All that&#x27;s happened in the above is that <code>x</code> and <code>y</code> became nullable variables, that is the <code>NOT NULL</code> was
removed from the declaration.  This makes all the difference in the world, and this is a fairly easy case.
The problem is that nullable value types like cql_nullable_int32 have an integer and a boolean and these
don&#x27;t flow into expressions that use operators like <code>+</code>, <code>-</code>, <code>/</code> and so forth.  This means that even
simple expressions involving nullable types actually expand into several statements.  And, in general,
these statements need a place to put their temporary results to accumulate the answer, so scratch variables
are required to make all this work.</p><p>Here&#x27;s a more realistic example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET result := 5 * x + 3 * y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;combine&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)result, 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(*result); // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div></div></div></div></div><ul><li><code>_tmp_n_int_1</code> holds the product of x and 5, it&#x27;s null if <code>x.is_null</code> is true</li><li><code>_tmp_n_int_2</code> holds the product of y and 3, it&#x27;s null if <code>y.is_null</code> is true</li><li><code>*result</code> holds the answer, it&#x27;s null if either of <code>_tmp_n_int_1.is_null</code>, <code>_tmp_n_int_2.is_null</code> is true<ul><li>otherwise it&#x27;s <code>_tmp_n_int_1.value + _tmp_n_int_2.value</code></li></ul></li></ul><p>So, in general, we need to emit arbitarily many statements in the course of evaluating even simple looking expressions
and we need good mechanisms to manage that.  This is what we&#x27;ll talk about in the coming sections.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="managing-scratch-variables"></a>Managing Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#managing-scratch-variables" title="Direct link to heading">#</a></h4><p>The function that actually assigns scratch variables is <code>cg_scratch_var</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch variable helper uses the given sem_type and the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stack level to create a temporary variable name for that type at that level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the variable does not already have a declaration (as determined by the masks)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// then a declaration is added to the scratch_vars section.  This is one of the root</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ways of getting an .is_null and .value back.  Note that not null variables always</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// have a .is_null of &quot;0&quot; which becomes important when deciding how to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// one result to another.  Everything stays uniform.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)</span></div></div></div></div></div><p>The signature is a bit unexpected so we&#x27;ll go over this, some of this will make more
sense as we learn about expressions generally but this is as good an introduction as any.</p><ul><li><code>ast</code> holds a reference to a variable we want to assign to, this is normally <code>NULL</code> for scratch variables, it&#x27;s not null for the <code>RESULT</code> macros which we&#x27;ll study later, so for now ignore this</li><li><code>sem_type</code> holds the type of the variable we need, it must be a unitary type, optionally with <code>SEM_TYPE_NOTNULL</code> set</li><li><code>var</code> is a character buffer that will get the name of the variable</li><li><code>is_null</code> is a character buffer that will get the <code>is_null</code> expression for this variable (more below)</li><li><code>value</code> is a character buffer that will get the <code>value</code> expression for this variable (more below)</li></ul><p>And this is a good time to talk about <code>is_null</code> and <code>value</code> because they will be everywhere.</p><p>Every expression evaluation in the C code generator has two essential results, the text that corresponds to the current
value so far (e.g. &quot;(1+2)*3&quot;) and the text for the current expression that will tell you if the result is null,
this could be as simple as &quot;0&quot; for a expression that is known to be not null.  So let&#x27;s make this a little more concrete:</p><p>Suppose you ask for a scratch not null integer we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_n_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;0&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_n_int_1&quot;</code></li></ul><p>Meaning: if you want the value, use the text &quot;_tmp_n_int_1&quot; if you want to know if the variable is null, use the text &quot;0&quot;
Note: many parts of <code>cg_c.c</code> special case an <code>is_null</code> value of <code>&quot;0&quot;</code> to make better code because such a thing is known to
be not null at compile time.</p><p>Now let&#x27;s suppose you ask for a scratch nullable integer, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;_tmp_int_1.is_null&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_int_1.value&quot;</code></li></ul><p>So again, you have exactly the text you need to test for null and the test you need to get the value.</p><p>Additional notes:</p><ul><li>scratch variables can be re-used, they are on a &quot;stack&quot;</li><li>a bitmask is used to track which scratch variables have aleady had a declaration emitted, so they are only declared once</li><li>the variable name is based on the current value of the <code>stack_level</code> variable which is increased in a push/pop fashion as temporaries come in and out of scope</li><li>this strategy isn&#x27;t perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad</li><li>importantly there is one stacklevel variable for all temporaries not one stacklevel for every type of temporary, this seemed like a reasonable simplification</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocating-scratch-variables"></a>Allocating Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocating-scratch-variables" title="Direct link to heading">#</a></h4><p>The most common reason for a scratch variable is that a temporary is needed for some part of the computation.
The most common reason for a temporary variable is to hold an intermediate result of a computation involving
nullable arithmetic.</p><p>These temporaries are created with <code>CG_PUSH_TEMP</code> which simply creates the three <code>charbuf</code> variables you need and then asks for a
scratch variable of the type you need.  The variables follow a simple naming convention.  The stack level is increased.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the text needed to refer to the variable.  cg_scratch_var picks the name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// based on stack level-and type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_TEMP(name, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(NULL, sem_type, &amp;name, &amp;name##_is_null, &amp;name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>Symetrically, <code>CG_POP_TEMP</code> releases the charbufs and restores the stack level.  As with the other macros, these are designed to
make it impossible to forget to free your buffers or get the stack wrong.  In fact, the stack is checked at strategic places
to ensure its back to baseline.  You can always just snapshot <code>stacklevel</code>, do some work that should be clean, and then
add an <code>Invariant</code> that <code>stacklevel</code> is back to where it was.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffers for the temporary, restore the stack level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_TEMP(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level--;</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursing-sub-expressions"></a>Recursing Sub-expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursing-sub-expressions" title="Direct link to heading">#</a></h4><p>Now that we understand that we can create scratch variables as needed, it&#x27;s time to take a look at the typical evaluation patterns
and how the evaluation works within that pattern.  This is everywhere in <code>cg_c.c</code>.</p><p>So let&#x27;s look at an actual evaluator, the simplest of them all, this one does code generation for the <code>NULL</code> literal.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_null(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(expr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(value, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Now this may be looking familiar: the signature of the code generator is something very much like the
signature of the the <code>gen_</code> functions in the echoing code.  That&#x27;s really because in some sense
the echoing code is like a very simple code generator itself.</p><ul><li><code>expr</code> : the AST we are generating code for</li><li><code>op</code> : the relevant operator if any (operators share code)</li><li><code>is_null</code> : a <code>charbuf</code> into which we can write the <code>is_null</code> expression text</li><li><code>value</code> : a <code>charbuf</code> into which we can write the <code>value</code> expression text</li><li><code>pri</code> : the binding strength of the node above this one</li><li><code>pri_new</code> : the binding strength of this node</li></ul><p>This particular generator is going to produce <code>&quot;NULL&quot;</code> for the <code>value</code> and <code>&quot;1&quot;</code> for the <code>is_null</code> expression.</p><p><code>is_null</code> and <code>value</code> are the chief outputs, and the caller will use these to create its own expression results
with recursive logic.  But the expression logic can also write into the statement stream, and as we&#x27;ll see,
it does.</p><p><code>pri</code> and <code>pri_new</code> work exactly like they did in the echoing code (see <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>),
they are used to allow the code generator to decide if it needs to emit parentheses.  But recall that the binding strengths
now will be the C binding strengths NOT the SQL binding strengths (discussed above).</p><p>Let&#x27;s look at one of the simplest operators: the <code>IS NULL</code> operator handled by <code>cg_expr_is_null</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The code-gen for is_null is one of the easiest.  The recursive call</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// produces is_null as one of the outputs.  Use that.  Our is_null result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is always zero because IS NULL is never, itself, null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_expr = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // expr IS NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;0&quot;); // the result of is null is never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The fact that this is not constant not null for not null reference types reflects</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the weird state of affairs with uninitualized reference variables which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be null even if they are typed not null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_not_nullable(sem_type_expr) &amp;&amp; !is_ref_type(sem_type_expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Note, sql has no side-effects so we can fold this away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;0&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;%s&quot;, expr_is_null.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>So walking through this:</p><ul><li>the result of <code>IS NULL</code> is never null, so we can immediately put &quot;0&quot; into the <code>is_null</code> buffer</li><li>if the operand is a not-null numeric type then the result of <code>IS NULL</code> is <code>0</code></li><li>if the operand might actually be null then<ul><li>use <code>CG_PUSH_EVAL</code> to recursively do codegen for it</li><li>copy its <code>expr_is_null</code> text into our <code>value</code> text</li></ul></li></ul><p>Note: the code reveals one of the big CQL secrets that not null reference variables can be null...  C has the same issue with <code>_Nonnull</code> globals.</p><p>Now let&#x27;s look at those helper macros, they are pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical naming convention</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// burn the stack slot so that any type and numbered temporary that was needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// won&#x27;t be re-used until this scope is over.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>The push macro simply creates buffers to hold the <code>is_null</code> and <code>value</code> results, then it calls <code>cg_expr</code> to dispatch the indicated expression.
The <code>pri</code> value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is your <code>pri_new</code>
value but often you can use <code>C_EXPR_PRI_ROOT</code> if you know that, because of your current context, the callee will never need parentheses.</p><p>How do we know this here? It seems like the operand of <code>IS NULL</code> could be anything surely it might need parentheses?  Let&#x27;s consider:</p><ul><li>if the operand is of not null numeric type then we aren&#x27;t even going to evaluate it, we&#x27;re on the easy &quot;no it&#x27;s not null&quot; path</li><li>if the operand is nullable then the only place the answer can be stored is in a scratch variable and its <code>is_null</code> expression will be exactly like <code>var.is_null</code></li><li>if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is <code>is_null</code> expression will be like <code>!var</code></li></ul><p>None of these require further wrapping regardless of what is above this node in the tree because of he strength of the <code>.</code> and <code>!</code> operators.</p><p>Other cases are usually simpler, such as &quot;no parentheses need to be added by the child node becasue it will be used as the argument to a helper
function so there will always be parens hard-coded anyway&quot;.  However these things need to be carefully tested hence the huge variety of codegen tests.</p><p>Note that after calling <code>cg_expr</code> the stack level was artificially increased.  We&#x27;ll get to that in the next section.  For now, looking at <code>POP_EVAL</code> we
can see it&#x27;s very straightforward:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Close the buffers used for the above.  Return the stack level to its original state.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Numbered scratch variables are re-used as though they were a stack.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_EVAL(expr) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level--;</span></div></div></div></div></div><p><code>CG_POP_EVAL</code> simply closes the buffers and restores the stack.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-variables"></a>Result Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-variables" title="Direct link to heading">#</a></h4><p>When recursion happens in the codegen, the common place that the result will be found is
in a temporary variable -- the generated code will use one or more statements to arrange for the correct
answer to be in that variable.  To do this, the codegen needs to first get the name of a suitable
result variable of a suitable type.  This is the &quot;other&quot; reason for making scratch variables.</p><p>There are three macros that make this pretty simple.  The first is <code>CG_RESERVE_RESULT_VAR</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a scratch variable to hold the final result of an evaluation.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// It may or may not be used.  It should be the first thing you put</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// so that it is on the top of your stack.  This only saves the slot.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_RESERVE_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_reserved = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">sem_t sem_type_reserved = sem_type; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *ast_reserved = ast; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>If this looks a lot like <code>PUSH_TEMP</code> that shouldn&#x27;t be surprising.  The name of the variable
and the expression parts always go into <code>charbuf</code> variables named <code>result_var</code> <code>result_var_is_null</code> and <code>result_var_value</code>
but the scratch variable isn&#x27;t actually allocated!  However -- we burn the stack_level as though it had been
allocated.  What&#x27;s up with that?</p><p>The name might be a clue, this macro reserves stack level slot for the result variable, it&#x27;s used if you might
need a result variable, but you might not.  When you want it we can artificially move the stack level back
to this spot where the slot was burned, allocate the scratch variable, and then put the stack back.
The <code>CG_USE_RESULT_VAR</code> macro does exactly that.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable is going to be used, this writes its name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and .value and .is_null into the is_null and value fields.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_USE_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_now = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_reserved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_now; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Invariant(result_var.used &gt; 1); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(is_null, &quot;%s&quot;, result_var_is_null.ptr); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(value, &quot;%s&quot;, result_var_value.ptr)</span></div></div></div></div></div><p>Once the code generator decides that it will in fact be using a result variable to represent the answer, then
the <code>is_null</code> and <code>value</code> buffers can be immediately populated to whatever the values were
for the result variable.  That text will be correct regardless of what codegen is used
to populate the variable.</p><p>There is a simpler macro that reserves and uses the result variable in one step, it&#x27;s very common.  The
&quot;reserve&quot; pattern is only necessary when there are some paths that need a result variable and some
that don&#x27;t.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This does reserve and use in one step</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_SETUP_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CG_RESERVE_RESULT_VAR(ast, sem_type); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CG_USE_RESULT_VAR();</span></div></div></div></div></div><p>And now armed with this knowledge we can go back to a previous mystery, let&#x27;s look at <code>CG_PUSH_EVAL</code> again</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical naming convention</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// burn the stack slot so that any type and numbered temporary that was needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// won&#x27;t be re-used until this scope is over.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>The reason that <code>CG_PUSH_EVAL</code> includes <code>stack_level++</code> is that it is entirely possible, even likely,
that the result of <code>cg_expr</code> is in a result variable.  The convention is that if the codegen
requires a result variable it is allocated <em>first</em> before any other temporaries.  This is why
there is a way to reserve a variable that you <em>might</em> need.  When the codegen is complete,
and before anything else happens, <code>stack_level</code> is increased so that the temporary that is
holding the result will not be re-used!  Any other temporaries are available but the result
is still live.  This might be easy to get wrong but the macros make it easy to get it right.</p><p>Now, armed with the knowledge that there a result variables and temporary variables and both
come from the scratch variable we can resolve the last mystery we left hanging.  Why does
the scratch variable API accept an AST pointer?</p><p>The only place that pointer can be not null is in the <code>CG_USE_RESULT_VAR</code> macro, it was
this line:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value);</span></div></div></div></div></div><p>And <code>ast_reserved</code> refers to the AST that we are trying to evaluate.  There&#x27;s an important
special case that we want to optimize that saves a lot of scratch variables.  It&#x27;s handled
by this code in <code>cg_scratch_var</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_assignment_target_reusable(ast, sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(ast &amp;&amp; ast-&gt;parent &amp;&amp; ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_out_parameter(name_ast-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;*%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The idea is that if the generator is doing an assignment like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := a + b;</span></div></div></div></div></div><p>Then the code generator doesn&#x27;t need a scratch variable to hold the result of the expression <code>a + b</code> like it would
in many other contexts.  It can use <code>x</code> as the result variable!  The <code>SET</code> codegen will discover
that the value it&#x27;s supposed to set is already in <code>x</code> so it does nothing and everything just
works out.  The price of this is a call to <code>is_assignment_target_reusable</code> and then some
logic to handle the case where <code>x</code> is an out argument (hence call by reference, hence needs to be used as <code>*x</code>).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="basic-control-flow-patterns"></a>Basic Control Flow Patterns<a aria-hidden="true" tabindex="-1" class="hash-link" href="#basic-control-flow-patterns" title="Direct link to heading">#</a></h3><p>To get a sense of how the compiler generates code for statements, we can look at some of the easiest cases.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;While&quot; suffers from the same problem as IF and as a consequence</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// generating while (expression) would not generalize.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The overall pattern for while has to look like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    prep statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    condition = final expression;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    if (!condition) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note that while can have leave and continue substatements which have to map</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to break and continue.   That means other top level statements that aren&#x27;t loops</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// must not create a C loop construct or break/continue would have the wrong target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;for (;;) {\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!cql_is_nullable_true(%s, %s)) break;\n&quot;, expr_is_null.ptr, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!(%s)) break;\n&quot;, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t loop_saved = cg_in_loop;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = loop_saved;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The comment before the <code>cg_while_stmt</code> actually says it pretty clearly; the issue is
that the expression in the while statement might actually require many C statements
to evaluate.  There are many cases of this sort of thing, but the simplest is
probably when any nullable types are in that expression.  A particular example
illustrates this pretty clearly.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* in trickier cases there would be code right here */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(x &lt; 5)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    x = x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>In this case, the <code>while</code> pattern could have been used because the condition is simply <code>x &lt; 5</code> so this whole pattern is
overkill.  But consider this program just a tiny bit different.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER;  -- x is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_bool _tmp_n_bool_0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_bool_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_notnull(x, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_bool_0, x.is_null, x.value &lt; 5);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_nullable(x, x.is_null, x.value + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Even for this small little case, the nullable arithmetic macros have to be used to keep <code>x</code> up to date.
The result of <code>x &lt; 5</code> is of type &quot;bool&quot; rather than &quot;bool not null&quot; so a temporary variable captures
the result of the expression.  This is an easy case but similar things happen if the expression
includes <code>CASE...WHEN...</code> or <code>IN</code> constructs.  There are many other cases.</p><p>So with this in mind, let&#x27;s reconsider what <code>cg_while_stmt</code> is doing:</p><ul><li>we start the <code>for</code> statement in the output<ul><li>there&#x27;s a bprintf for that</li></ul></li><li>we evaluate the while expression, the details will be in <code>is_null</code> and <code>value</code><ul><li>we use CG_PUSH_EVAL for that</li></ul></li><li>if the result is nullable there is a helper macro <code>cql_is_nullable_true</code> that tells us if the value is not null and true</li><li>if the result is not nullable we can use <code>expr_value.ptr</code> directly</li><li>we make a note that we&#x27;re in a loop (this matters for statement cleanup, more on that later)</li><li>we recurse to do more statements with <code>cg_stmt_list</code></li><li>finally we end the <code>for</code> that we began</li></ul><p>This kind of structure is common to all the control flow cases.  Generally, we have to deal with the
fact that CQL expressions become C statements so we use a more general flow control strategy. But with this
in mind, it&#x27;s easy to imagine how <code>IF</code> <code>LOOP</code> and <code>SWITCH</code> are handled.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cleanup-and-errors"></a>Cleanup and Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cleanup-and-errors" title="Direct link to heading">#</a></h3><p>There are a number of places where things can go wrong when running a CQL procedure.  The most
common sources are: (1) SQLite APIs, almost all of which can fail, and, (2) calling other procedures
which also might fail.  Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC something_that_might_fail (arg TEXT) USING TRANSACTION;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look at this carefully:</p><ul><li>first, we had to declare <code>something_that_might_fail</code><ul><li>the declaration includes <code>USING TRANSACTION</code> indicating the procedure uses the database</li><li>we didn&#x27;t provide the definition, that will lead to a link time error but we&#x27;re ignoring that for now</li></ul></li><li>there is a string literal named <code>_literal_1_test_p</code> that is auto-created<ul><li><code>cql_string_literal</code> can expand into a variety of things, whatever you want &quot;make a string literal&quot; to mean</li><li>its defined in <code>cqlrt.h</code> and it&#x27;s designed to be replaced</li></ul></li><li><code>cql_set_string_ref(&amp;arg, _literal_1_test_p);</code> is expected to &quot;retain&quot; the string (+1 ref count)</li><li><code>cql_cleanup</code> is the exit label, this code will run for sure<ul><li>cleanup statements are accumulated by writing to <code>cg_cleanup_output</code> which usually writes to the <code>proc_cleanup</code> buffer</li><li>because cleanup is in its own buffer you can add to it freely whenever a new declaration that requires cleanup arises</li><li>in this case the declaration of the string literal caused the <code>C</code> variable <code>arg</code> to be created and also the cleanup code</li></ul></li><li>now we call <code>something_that_might_fail</code> passing it our database pointer and the argument</li><li>the hidden <code>_db_</code> pointer is passed to all procedures that use the database</li><li>these are also the ones that can fail</li><li>any failed return code (not <code>SQLITE_OK</code>) causes two things<ul><li>the <code>cql_error_trace()</code> macro is invoked (this macro typically expands to nothing)</li><li>the code stops what it&#x27;s doing and runs the cleanup code via <code>goto cql_cleanup;</code></li></ul></li></ul><p>The essential sequence is this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div></div></div></div></div><p>The C code generator uses this pattern all over to check if anything went wrong and to exit with an error code.
Extensive logging can be very expensive but in debug builds, it&#x27;s quite normal for <code>cql_error_trace</code> to expand
into something like <code>fprintf(stderr, &quot;error %d in %s %s:%d\n&quot;, _rc_, _PROC_, __FILE__, __LINE_)</code> which probably
a lot more logging than you want in a production build but great if you&#x27;re debugging.  Recall that CQL generates
<code>#define _PROC_ &quot;p&quot;</code> before every procedure.</p><p>This pattern generalizes well and indeed if we use the exception handling pattern, we get a lot of control.
Let&#x27;s generalize this a tiny bit.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (OUT success BOOL NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN TRY</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END TRY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN CATCH</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END CATCH;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>CQL doesn&#x27;t have complicated exception objects or anything like that, exceptions are just simple
control flow.  Here&#x27;s the code for the above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_bool *_Nonnull success) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)success, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *success = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    goto catch_end_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_start_1: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_end_1:;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The code is nearly the same.  Let&#x27;s look at the essential differences:</p><ul><li>If there is an error, the code hits <code>goto catch_start_1</code></li><li>If the try block succeeds, the code hits <code>goto catch_end_1</code></li><li>both branches set the <code>success</code> out parameter</li><li>we added that out argument, CQL generated an error check to ensure that arg 1 is not null<ul><li><code>cql_contract_argument_notnull((void *)success, 1)</code>, the 1 means arg 1</li><li>the hidden <code>_db_</code> arg doesn&#x27;t count</li></ul></li></ul><p>How does this happen?  <code>cg_trycatch_helper</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Very little magic is needed to do try/catch in our context.  The error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// handlers for all the sqlite calls check _rc_ and if it&#x27;s an error they</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;goto&quot; the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Inside the try block, the cleanup handler is changed to the catch block.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The catch block puts it back.  Otherwise, generate nested statements as usual.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_start);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We need unique labels for this block</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ++catch_block_count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_start, &quot;catch_start_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_end, &quot;catch_end_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Divert the error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR saved_error_target = error_target;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t saved_error_target_used = error_target_used;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target = catch_start.ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> ...</span></div></div></div></div></div><p>All of the error handling does goto <code>error_target</code> whatever that is.  The
try/catch pattern simply changes the current error target.  The rest of
the code is just to save the current error target and to create unique
labels for the the control flow.</p><p>The important notion is that, if anything goes wrong, whatever it is,
the generator simply does a <code>goto error_target</code> and that will either
hit the catch block or else go to cleanup.</p><p>The <code>THROW</code> operation illustrates this well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Convert _rc_ into an error code.  If it already is one keep it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Then go to the current error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_throw_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_throw_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_best_error(%s);\n&quot;, rcthrown_current);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;goto %s;\n&quot;, error_target);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  rcthrown_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>first we make sure <em>rc</em> has some kind of error in it either <code>rcthrown_current</code> or else <code>SQLITE_ERROR</code></li><li>then we goto the current error target</li><li><code>error_target_used</code> tracks whether there were any possible errors, this is just to avoid C compiler errors about unused labels.<ul><li>if the label is not used it won&#x27;t be emitted</li><li>the code never jump back to an error label so we&#x27;ll always know if it was used before we need to emit it</li></ul></li></ul><p>Note: every catch block captures the value of <code>_rc_</code> in a local variable whose name is in <code>rcthrown_current</code>.
This is the current failing result code accessible by <code>@RC</code> in CQL.</p><p>A catch block can therefore do stuff like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">@RC</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  THROW</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">call</span><span class="token plain"> attempt_retry</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>or something like that.</p><p>This entire mechanism is built with basically just a few state variables that nest.  There is no complicated stack walking
or anything like that.  All the code has to do is chain the error labels together and let users create new catch blocks
with new error labels.  All that together gives you very flexible try/catch behaviour.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="string-literals"></a>String Literals<a aria-hidden="true" tabindex="-1" class="hash-link" href="#string-literals" title="Direct link to heading">#</a></h3><p>Before we move on to more complex statements we have to discuss string literals a little bit.  We&#x27;ve mentioned before
that the compiler is going to generate something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div></div></div></div></div><p>To create a reference counted object <code>_literal_1_test_p</code> that it can use.  Now we&#x27;re going to talk about how
the text <code>&quot;test&quot;</code> was created and how that gets more complicated.</p><p>The first thing to remember is that the generator creates C programs.  That means
no matter what kind of literal we might be processing it&#x27;s ending up encoded as a C string for the C
compiler.  The C compiler will be the first thing the decodes the text the generator produces and
puts the byte we need into the final programs data segment or whereever.  That means if we have
SQL format strings that need to go to SQLite they will be twice-encoded, the SQL string is escaped
as needed for SQLite and <em>that</em> is escaped again for the C compiler.</p><p>An example might make this clearer consider the following SQL:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &#x27;&quot;x&#x27;&#x27;y&quot;&#x27; AS a, &quot;&#x27;y&#x27;\n&quot; AS b;</span></div></div></div></div></div><p>The generated text for this statement will be:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;SELECT &#x27;\&quot;x&#x27;&#x27;y\&quot;&#x27;, &#x27;&#x27;&#x27;y&#x27;&#x27;\n&#x27;&quot;</span></div></div></div></div></div><p>Let&#x27;s review that in some detail:</p><ul><li><p>the first string &quot;a&quot; is a standard SQL string</p><ul><li>it is represented unchanged in the AST, it is <em>not</em> unescaped</li><li>even the outer single quotes are preserved, CQL has no need to change it at all</li><li>when we emit it into our output it will be read by the C compiler, so</li><li>at that time it is escaped <em>again</em> into C format<ul><li>the double quotes which required no escaping in SQL become <code>\&quot;</code></li></ul></li><li>the single quote character requires no escape but there are still two of them because SQLite will also process this string</li></ul></li><li><p>the second string &quot;b&quot; is a C formatted string literal</p><ul><li>SQLite doesn&#x27;t support this format or its escapes, therefore</li><li>as discussed in <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>, it is decoded to plain text, then re-encoded as a SQL escaped string</li><li>internal newlines do not require escaping in SQL, they are in the string as the newline character not &#x27;\n&#x27; or anything like that<ul><li>to be completely precise the byte value 0x0a is in the string unescaped</li></ul></li><li>internal single quotes don&#x27;t require escaping in C, these have to be doubled in a SQL string</li><li>the outer double quotes are removed and replaced by single quoates during this process</li><li>the AST now has a valid SQL formatted string possibly with weird characters in it</li><li>as before, this string has to be formatted for the C compiler so now it has to be escaped again</li><li>the single quotes require no further processing, though now there are quite a few of them</li><li>the embedded newline is converted to the escape sequence &quot;\n&quot; so we&#x27;re back to sort of where we started<ul><li>the C compiler will convert this back to the byte 0x0a which is what ends up in the data segment</li></ul></li></ul></li></ul><p>In the above example we were making one overall string for the <code>SELECT</code> statement so the outer double quotes
are around the whole statement.  That was just for the convenience of this example.  If the literals had
been in some other loose context then individual strings would be produced the same way.  Except, not so fast,
not every string literal is heading for SQLite.  Some are just making regular strings.  In that case even
if they are destined for SQLite they will go as bound arguments to a statement not in the text of the SQL.
That means <em>those</em> strings do not need SQL escaping.</p><p>Consider:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET a := &#x27;&quot;x&#x27;&#x27;y&quot;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET b := &quot;&#x27;y&#x27;\n&quot;;</span></div></div></div></div></div><p>To do those assignments we need:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_x_y_p, &quot;\&quot;x&#x27;y\&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_2_y_p, &quot;&#x27;y&#x27;\n&quot;);</span></div></div></div></div></div><p>In both of these cases the steps are:</p><ul><li>unescape the escaped SQL string in the AST to plain text<ul><li>removing the outer single quotes of course</li></ul></li><li>re-escape the plain text (which might include newlines and such) as a C string<ul><li>emit that text, including its outer double quotes</li></ul></li></ul><p>Trivia: the name of the string literal variables include a fragment of the string to make them a little easier to spot.</p><p><code>encoders.h</code> has the encoding functions</p><ul><li><code>cg_decode_string_literal</code></li><li><code>cg_encode_string_literal</code></li><li><code>cg_encode_c_string_literal</code></li><li><code>cg_decode_c_string_literal</code></li></ul><p>As well as similar functions for single characters to make all this possible.  Pretty much every combination
of encoding and re-encoding happens in some path through the code generator.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="executing-sqlite-statements"></a>Executing SQLite Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#executing-sqlite-statements" title="Direct link to heading">#</a></h3><p>By way of example let&#x27;s consider a pretty simple piece of SQL we might want to run.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE TABLE foo(id INTEGER, t TEXT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER, t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  UPDATE foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t = t_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>To make this happen we&#x27;re going to have to do the following things:</p><ul><li>create a string literal with the statement we need</li><li>the references to <code>id_</code> and <code>t_</code> have to be replaced with <code>?</code></li><li>we prepare that statement</li><li>we bind the values of <code>id_</code> and <code>t_</code></li><li>we <code>step</code> the statement</li><li>we <code>finalize</code> the statement</li><li>suitable error checks have to be done at each stage</li></ul><p>That&#x27;s quite a bit of code and it&#x27;s easy to forget a step, this is an area where CQL shines.  The
code we had to write in CQL was very clear and all the error checking is implicit.</p><p>This is the generated code.  We&#x27;ll walk through it and discuss how it is created.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 id_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nullable t_)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_temp_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;_temp_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;UPDATE foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SET t = ? &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multibind(&amp;_rc_, _db_, &amp;_temp_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_INT32, &amp;id_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_STRING, t_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>the functions signature includes the hidden <code>_db_</code> parameter plus the two arguments</li><li>we need a hidden <code>_rc_</code> variable to hold the result codes from SQLite</li><li>we need a scratch <code>sqlite3_stmt *</code> named <code>_temp_stmt</code> to talk to SQLite<ul><li>when this is created, the cleanup section gets <code>cql_finalize_stmt(&amp;_temp_stmt);</code></li><li><code>cql_finalize_stmt</code> sets the statement to null and does nothing if it&#x27;s already null</li></ul></li><li>the string <code>&quot;INSERT INTO foo(id, t) VALUES(?, ?)&quot;</code> is created from the AST<ul><li>recall that we have <code>variables_callback</code> as an option, it&#x27;s used here to track the variables and replace them with <code>?</code></li><li>more on this shortly</li></ul></li><li><code>cql_multibind</code> is used to bind the values of <code>id_</code> and <code>t_</code><ul><li>this is just a varargs version of the normal SQLite binding functions, it&#x27;s only done this way to save space</li><li>only one error check is needed for any binding failure</li><li>the type of binding is encoded very economically</li><li>the &quot;2&quot; here refers to two arguments</li></ul></li><li>the usual error processing happens with <code>cql_error_trace</code> and <code>goto cql_cleanup</code></li><li>the statment is executed with <code>sqlite3_step</code></li><li>temporary statements are finalized immediately with <code>cql_finalize_stmt</code><ul><li>in this case its redundant because the code is going to fall through to cleanup anyway</li><li>in general there could be many statements and we want to finalize immediately</li><li>this is an optimization opportunity, procedures with just one statement are very common</li></ul></li></ul><p>Most of these steps are actually hard coded.  There is no variability in the sequence
after the <code>multibind</code> call, so that&#x27;s just boiler-plate the compiler can inject.</p><p>We don&#x27;t want to declare <code>_temp_stmt</code> over and over so there&#x27;s a flag that records
whether it has already been declared in the current procedure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a declaration for the temporary statement _temp_stmt_ if we haven&#x27;t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// already done so.  Also emit the cleanup once.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void ensure_temp_statement() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!temp_statement_emitted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_declarations_output, &quot;sqlite3_stmt *_temp_stmt = NULL;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_cleanup_output, &quot;  cql_finalize_stmt(&amp;_temp_stmt);\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    temp_statement_emitted = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This is a great example of how, no matter where the processing happens to be,
the generator can emit things into the various sections.  Here it adds
a declaration and an cleanup with no concern about what else might be going on.</p><p>So most of the above is just boiler-plate, the tricky part is:</p><ul><li>getting the text of the SQL</li><li>binding the variables</li></ul><p>All of this is the business of this function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the most important function for sqlite access;  it does the heavy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// lifting of generating the C code to prepare and bind a SQL statement.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If cg_exec is true (CG_EXEC) then the statement is executed immediately</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and finalized.  No results are expected.  To accomplish this we do the following:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * figure out the name of the statement, either it&#x27;s given to us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     or we&#x27;re using the temp statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * call get_statement_with_callback to get the text of the SQL from the AST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     * the callback will give us all the variables to bind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     * count the variables so we know what column numbers to use (the list is backwards!)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * bind any variables</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * if there are variables CG_EXEC will step and finalize</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_flags)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The core of this function looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callbacks callbacks;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_gen_sql_callbacks(&amp;callbacks);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  callbacks.variables_callback = cg_capture_variables;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  callbacks.variables_context = &amp;vars;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ... more flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(temp);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_set_output_buffer(&amp;temp);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_statement_with_callbacks(stmt, &amp;callbacks);</span></div></div></div></div></div><p>It&#x27;s set up the callbacks for variables and it calls the echoing function on the buffer.  We&#x27;ve
talked about <code>gen_statement_with_callbacks</code> in  <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>.</p><p>Let&#x27;s take a look at that callback function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the callback method handed to the gen_ method that creates SQL for us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// it will call us every time it finds a variable that needs to be bound.  That</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variable is replaced by ? in the SQL output.  We end up with a list of variables</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to bind on a silver platter (but in reverse order).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  list_item **head = (list_item**)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_item_to_list(head, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(buffer, &quot;?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The <code>context</code> variable was set to be <code>vars</code>, we convert it back to the correct type
and add the current ast to that list.  <code>add_item_to_list</code> always puts things at the
head so the list will be in reverse order.</p><p>With this done, we&#x27;re pretty much set.  We&#x27;ll produce the statement with a sequence
like this one (there are a couple of variations, but this is the most general)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_prepare(_db_, %s%s_stmt,\n  &quot;, amp, stmt_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_pretty_quote_plaintext(temp.ptr, cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;);\n&quot;);</span></div></div></div></div></div><p><code>cg_pretty_quote_plaintext</code> is one of the C string encoding formats, it could have been just the regular C string encoding
but that would have been a bit wasteful and it wouldn&#x27;t have looked as nice.  This function does a little transform.</p><p>The normal echo of the update statement in question looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  UPDATE foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t = ?</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = ?;</span></div></div></div></div></div><p>Note that it has indenting and newlines embedded in it.  The standard encoding of that would look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;  UPDATE foo\n  SET t = ?\n    WHERE id = ?;&quot;</span></div></div></div></div></div><p>That surely works, but it&#x27;s wasteful and ugly. The pretty format instead produces:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;UPDATE foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SET t = ? &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;</span></div></div></div></div></div><p>So, the newlines are gone from the string (they aren&#x27;t needed), instead the string literal was broken into lines for readability.
The indenting is gone from the string, instead the string fragments are indented.  So what you get is a string literal that
reads nicely but doesn&#x27;t have unnecessary whitespace for SQLite.  Obviously you can&#x27;t use pretty-quoted literals in all cases,
it&#x27;s exclusively for SQLite formatting.</p><p>All that&#x27;s left to do is bind the arguments.  Remember that arg list is in reverse order:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = vars; item; item = item-&gt;next, count++) ;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  reverse_list(&amp;vars);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;cql_multibind(&amp;_rc_, _db_, %s%s_stmt, %d&quot;, amp, stmt_name, count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Now emit the binding args for each variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (list_item *item = vars; item; item = item-&gt;next)  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Contract(item-&gt;ast-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(cg_main_output, &quot;,\n              &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_bind_column(item-&gt;ast-&gt;sem-&gt;sem_type, item-&gt;ast-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;);\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><ul><li>first compute the count, we don&#x27;t need to bind if there are no variables</li><li><code>reverse_list</code> does exactly what is sounds like (finally a real-world use-case for reverse-list-in-place)</li><li><code>cg_bind_column</code> creates one line of the var-args output: column type and variable name<ul><li>the type and name information is right there on the <code>AST</code> in the <code>sem_node</code></li></ul></li></ul><p>And that&#x27;s it.  With those few helpers we can bind any SQLite statement the same way.  All of the
<code>DDL_STMT_INIT</code> and <code>DML_STMT_INIT</code> statements are completely implemented by this path.</p><p>Next we&#x27;ll talk about the cases where some data comes back from SQLite.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-08-20T20:58:47.000Z" class="docLastUpdatedAt_217_">8/20/2021</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int02"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 2: Semantic Analysis</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#c-code-generation" class="table-of-contents__link">C Code Generation</a><ul><li><a href="#launching-the-code-generator" class="table-of-contents__link">Launching the Code Generator</a></li><li><a href="#character-buffers-and-byte-buffers" class="table-of-contents__link">Character Buffers and Byte Buffers</a></li><li><a href="#expressions" class="table-of-contents__link">Expressions</a></li><li><a href="#basic-control-flow-patterns" class="table-of-contents__link">Basic Control Flow Patterns</a></li><li><a href="#cleanup-and-errors" class="table-of-contents__link">Cleanup and Errors</a></li><li><a href="#string-literals" class="table-of-contents__link">String Literals</a></li><li><a href="#executing-sqlite-statements" class="table-of-contents__link">Executing SQLite Statements</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Facebook Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2021 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4a61b4b3.js"></script>
<script src="/runtime~main.7f4ba451.js"></script>
<script src="/main.9cd58f71.js"></script>
<script src="/1.bac24c28.js"></script>
<script src="/2.29ab4659.js"></script>
<script src="/3.9ee6d42d.js"></script>
<script src="/1be78505.ae32d621.js"></script>
<script src="/87.9cf8ff91.js"></script>
<script src="/5456faf3.d3330067.js"></script>
<script src="/17896441.923fd9c6.js"></script>
<script src="/c27d1879.7742b602.js"></script>
</body>
</html>