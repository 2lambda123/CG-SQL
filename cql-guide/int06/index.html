<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Part 6: Schema Management | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Part 6: Schema Management | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/int06"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/int06"><link rel="stylesheet" href="/styles.efe3e8f9.css">
<link rel="preload" href="/styles.ead03b59.js" as="script">
<link rel="preload" href="/runtime~main.939cc205.js" as="script">
<link rel="preload" href="/main.cdfa48d1.js" as="script">
<link rel="preload" href="/1.cf35a583.js" as="script">
<link rel="preload" href="/2.08e76adb.js" as="script">
<link rel="preload" href="/3.22158529.js" as="script">
<link rel="preload" href="/1be78505.7a0a43f3.js" as="script">
<link rel="preload" href="/91.a1c7096d.js" as="script">
<link rel="preload" href="/5456faf3.85d0087e.js" as="script">
<link rel="preload" href="/17896441.e655f3a5.js" as="script">
<link rel="preload" href="/62786a5f.690b0dfb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch05">Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Appendix 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x6">Appendix 6: CQL In 20 Minutes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x7">Appendix 7: CQL Anti-patterns</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x8">Appendix 8: CQL Best Practices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x9">Appendix 9: Using the CQL Amalgam</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int01">Part 1: Lexing, Parsing, and the AST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int02">Part 2: Semantic Analysis</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int03">Part 3: C Code Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int04">Part 4: Testing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int05">Part 5: CQL Runtime</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/int06">Part 6: Schema Management</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/int07">Part 7: JSON Generation</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Part 6: Schema Management</h1></header><div class="markdown"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>Part 6 continues with a discussion of the essentials of schema management in the CQL compiler.
As in the previous parts, the goal here is not to go over every detail of the system but rather to give
a sense of how schema management happens in general -- the core strategies and implementation choices --
so that when reading the management code you will have an idea how it all hangs together. To accomplish
this, various key data structures will be explained in detail and accompanied by examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-management"></a>Schema Management<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-management" title="Direct link to heading">#</a></h2><p>The primary goal of the schema management features of the CQL compiler is to provide the ability
to create a &quot;schema upgrader&quot; that can move a given user&#x27;s database from a previous version
of the schema to the current version.  Because of the limitations of SQL in general, and
SQLite in particular, not all transforms are possible; so additionally the system must correctly
detect and prevent upgrades that cannot be safely performed.</p><p>The full set of schema attributes and their meaning is described in <a href="https://cgsql.dev/cql-guide/ch10" target="_blank" rel="noopener noreferrer">Chapter 10</a>
and the full set of validations is described in <a href="https://cgsql.dev/cql-guide/ch11" target="_blank" rel="noopener noreferrer">Chapter 11</a>.  Briefly the
directives are:</p><ul><li><code>@create(n)</code>: indicates a table/column is to be created at version <code>n</code>.</li><li><code>@delete(n)</code>: indicates a table/column is to be deleted at version <code>n</code>.</li><li><code>@recreate</code>: indicates the table contents are not precious<ul><li>the table can be dropped and created when its schema changes</li><li>this does not combine with <code>@create</code></li><li>it applies only to tables</li><li>views, triggers, and indices are always on the <code>@recreate</code> plan and do not have to be marked so</li></ul></li></ul><p>Now the various annotations can occur substantially in any order as there are no rules that require that
tables that are created later in time appear later in the input.  This means the appearance order
of tables is in general very inconvenient for any upgrading logic.  However, the semantic validation
pass gathers all the annotations into two large <code>bytebuf</code> objects which can be readily sorted --
one for things on the <code>@create</code> plan and one for the <code>@recreate</code> plan.  These will be discussed below.</p><p>At this point it&#x27;s probably best to start looking at some of the code fragments. We&#x27;re going to be looking
at all the steps in the top level function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for schema upgrade code-gen.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_schema_upgrade_main(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(options.file_names_count == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Note that the schema upgrader code generator in CQL does not produce <code>C</code> but rather it produces
more <code>CQL</code> which then has to be compiled down to <code>C</code>.  This choice means that the codegen is a
lot more readable and gets the benefit of the usual CQL error checking and exception management.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="check-for-errors-check-for---global_proc"></a>Check for errors, check for <code>--global_proc</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#check-for-errors-check-for---global_proc" title="Direct link to heading">#</a></h3><p>We start with some simple error checks:  Any semantic errors abort the code-generation.
The <code>--global_proc</code> names the procedure that will do the upgrade. It is also used
as a prefix on all of the tables that the upgrader requires. This makes it possible,
if desired, to have separate upgraders for different parts of your schema, or to
combine upgraders from two different unrelated subsystems in the same database.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_exit_on_semantic_errors(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  exit_on_no_global_proc();</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preparing-the-attributes"></a>Preparing the Attributes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preparing-the-attributes" title="Direct link to heading">#</a></h3><p>The two arrays <code>schema_annotations</code> and <code>recreate_annotations</code> are sorted.
The item count can be easily computed using the allocated size of these items,
both of which are of type <code>bytebuf</code>.  The comparators provided to <code>qsort</code>
put these arrays in exactly the order needed.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // first sort the schema annotations according to version, type etc.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // we want to process these in an orderly fashion and the upgrade rules</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // are nothing like the declared order.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *base = schema_annotations-&gt;ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t schema_items_size = sizeof(schema_annotation);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t schema_items_count = schema_annotations-&gt;used / schema_items_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  schema_annotation *notes = (schema_annotation*)base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t max_schema_version = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (schema_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     qsort(base, schema_items_count, schema_items_size, annotation_comparator);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     max_schema_version = notes[schema_items_count - 1].version;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // likewise, @recreate annotations, in the correct upgrade order (see comparator)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  base = recreate_annotations-&gt;ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t recreate_items_size = sizeof(recreate_annotation);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t recreate_items_count = recreate_annotations-&gt;used / recreate_items_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (recreate_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    qsort(base, recreate_items_count, recreate_items_size, recreate_comparator);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  recreate_annotation *recreates = (recreate_annotation *)base;</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="creating-the-global-crc"></a>Creating the Global CRC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#creating-the-global-crc" title="Direct link to heading">#</a></h3><p>Schema upgrade is expensive, so we want to be able to quickly detect if the schema
installed is already the latest version. To do this we compute a single global
64-bit CRC for the current version of the schema.  This can be compared against a
stored schema CRC from the last run. If the CRCs match, no work needs to be done.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(all_schema);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // emit canonicalized schema for everything we will upgrade</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this will include the schema declarations for the ad hoc migrations, too;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_generate_schema_by_mode(&amp;all_schema, SCHEMA_TO_UPGRADE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // compute the master CRC using schema and migration scripts</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  llint_t schema_crc = (llint_t)crc_charbuf(&amp;all_schema);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(all_schema);</span></div></div></div></div></div><p>The schema generator is used to emit the full schema, including annotations, into
a buffer. A raw CRC of the buffer gives us the &quot;global&quot; or &quot;overall&quot; CRC for the
whole schema.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="output-fragments"></a>Output Fragments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#output-fragments" title="Direct link to heading">#</a></h3><p>A number of buffers will hold the various pieces of output.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(preamble);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(main);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(decls);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(pending);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(upgrade);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(baseline);</span></div></div></div></div></div><p>These will be assembled as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(output_file);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s\n&quot;, decls.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, preamble.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, main.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], output_file.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(output_file);</span></div></div></div></div></div><p>In short:</p><ul><li>first <code>decls</code>, this declares the schema among other things</li><li>then, <code>preamble</code>, this contains helper procedures</li><li>then, <code>main</code>, the primary upgrader steps go here</li></ul><p>We&#x27;ll go over all of these in subsequent sections.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="declarations-section"></a>Declarations Section<a aria-hidden="true" tabindex="-1" class="hash-link" href="#declarations-section" title="Direct link to heading">#</a></h3><p>The result type includes a customizable prefix string.  This is the first thing to go out.
Typically this is the appropriate copyright notice.  <code>rt.c</code> has this information and that
file is replaceable.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;%s&quot;, rt-&gt;source_prefix);</span></div></div></div></div></div><p>The schema upgrade script is in the business of creating tables from old versions and then altering them.
The table declarations will be for the final shape.  We need to emit <code>@SCHEMA_UPGRADE_SCRIPT</code> so that
the CQL compiler knows that there will be multiple declarations of the same table and they might not
be identical. The upgrade script is in the business of getting things to the end state.  Likewise
it is normal for the schema upgrade script to refer to columns that have been deleted, this is because
a column might be created in say version 5 and then deleted in version 10.  The upgrade code goes
through the columns lifecycle, so even though the declarations already say the column is doomed
to die in version 10, the creation code in version 5 is legal -- and necessary.  Schema migration steps
that run in version 6, 7, 8, or 9 might use the contents of the column as part of essential data migration.
We can never know what version we might find in a database that is being upgraded, it could be very far in
the past, at a time where a deleted column still existed.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- no columns will be considered hidden in this script\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- DDL in procs will not count as declarations\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;@SCHEMA_UPGRADE_SCRIPT;\n\n&quot;);</span></div></div></div></div></div><p>A convenience comment goes in the <code>decls</code> section with the CRC.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- schema crc %lld\n\n&quot;, schema_crc);</span></div></div></div></div></div><p>There are a set of functions that allow the creation of, and access to, an in-memory
cache of the facet state.  These functions are all defined in <code>cqlrt_common.c</code>.  But
they have to be declared to CQL to use them.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_emit_facet_functions(&amp;decls);</span></div></div></div></div></div><p>The table <code>sqlite_master</code> is used to read schema state.  That table has to be declared.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_emit_sqlite_master(&amp;decls);</span></div></div></div></div></div><p>The full schema may be used by the upgraders, we need a declaration of all of that.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- declare full schema of tables and views to be upgraded and their dependencies -- \n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_generate_schema_by_mode(&amp;decls, SCHEMA_TO_DECLARE);</span></div></div></div></div></div><p>At this point a quick side-step to the output modes and region arguments is appropriate.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-region-arguments"></a>Schema Region Arguments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-region-arguments" title="Direct link to heading">#</a></h4><p>The upgrader honors the arguments <code>--include_regions</code> and <code>--exclude_regions</code>.  If they are absent
that is the same as &quot;include everything&quot; and &quot;exclude nothing&quot;.  Recall that schema regions allow
you to group schema as you wish.  A typical use might be to define some &quot;core&quot; schema in a set
of regions (maybe just one) and then a set of &quot;optional&quot; schema in some additional regions.</p><p>An upgrader for just &quot;core&quot; could be created by adding <code>--include_regions core</code>.  When creating
upgraders for the optional parts, there are two choices:</p><ul><li><code>--include-regions optional1</code> : makes an upgrader for <code>optional1</code> and <code>core</code> (the assumption being that <code>optional1</code> was declared to depend on <code>core</code>)</li><li><code>--include-regions optional1</code> <code>--exclude-regions core</code> : makes an upgrader for <code>optional1</code> which should run after the standalone <code>core</code> upgrader has already run<ul><li>this allows you to share the &quot;core&quot; parts between any number of &quot;optional&quot; parts</li><li>and of course this can nest; there can be several &quot;core&quot; parts; and so forth</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-output-modes"></a>Schema Output Modes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-output-modes" title="Direct link to heading">#</a></h4><p>The flag bits are these:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We declare all schema we might depend on in this upgrade (this is the include list)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// e.g. we need all our dependent tables so that we can legally use them in an FK</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_TO_DECLARE 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We only emit schema that we are actually updating (this is include - exclude)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// e.g. a table on the exclude list is assumed to be upgraded by its own script</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// in a different run.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_TO_UPGRADE 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We get TEMP items IF and ONLY IF this bit is set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_TEMP_ITEMS 4</span></div></div></div></div></div><p>As we saw before, the schema we CRC is <code>SCHEMA_TO_UPGRADE</code>.  This is all the regions that were selected
but not their dependencies.  The point of this is that you might make an upgrader for say a &quot;core&quot;
part of your schema which can be shared and then make additional upgraders for various parts that
use the &quot;core&quot; but are otherwise &quot;optional&quot;.  Each of those &quot;optional&quot; upgraders needs its own CRC that
includes its schema but not the &quot;core&quot; schema.  However the &quot;optional&quot; schema can refer to &quot;core&quot;
schema (e.g. in foreign keys) so all of the tables are declared.  This is <code>SCHEMA_TO_DECLARE</code> mode.</p><ul><li>declare all schema you are allowed to refer to</li><li>CRC, and upgrade, only the parts selected by the region arguments</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-schema-helpers"></a>The Schema Helpers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-schema-helpers" title="Direct link to heading">#</a></h3><p>This bit generates the <code>facets</code> table, the full name is <code>your_global_proc_cql_schema_facets</code> where
<code>your_global_proc</code> is the <code>--global_proc</code> argument. This is referred to simply as the <code>facets</code> table.
There is an identical temporary table that is used to store the contents of the <code>facets</code> table
upon startup.  This allows the upgrader to produce a complete difference.  The <code>facets</code> table
is nothing more than a mapping between the name of some facet of the schema (like a table, a view,
a column) and its last known verison info -- usually its CRC.</p><ul><li>NOTE: this temp table predates the in-memory facets data structure so it could probably be removed<ul><li>the diff would have to work against the in-memory datastructure which is immutable hence just as good as a temp table</li><li>look for a change like this soon</li></ul></li></ul><p>The remaining procedures are for testing facet state or <code>sqlite_master</code> state.  All of them get the
usual global prefix.  For ease of discussion I will elide the prefix for the rest of this document.</p><ul><li><code>check_column_exists</code> : checks if the indicated column is present in <code>sqlite_master</code><ul><li>necessary because there is no <code>ALTER TABLE ADD COLUMN IF NOT EXISTS</code> command</li></ul></li><li><code>create_cql_schema_facets_if_needed</code> : actually creates the <code>facets</code> table if it does not exist</li><li><code>save_cql_schema_facets</code> : creates the <code>cql_schema_facets_saved</code> temp table and populates it</li><li><code>cql_set_facet_version</code> : sets one facet to the indicated value<ul><li>this writes to the database, not the in-memory version of the table</li></ul></li><li><code>cql_get_facet_version</code> : reads a facet value from the facet table<ul><li>this is only used to check the master schema value, after that the in-memory version is used</li></ul></li><li><code>cql_get_version_crc</code> : gets the CRC for a given schema version<ul><li>each schema version has its own CRC in addition to the global CRC</li><li>this information is stored in the facets table with a simple naming convention for the facet name</li><li>the in memory version of the table is always used here</li></ul></li><li><code>cql_set_version_crc</code> : sets the CRC for a given schema version in the facet table<ul><li>this writes to the database, not the in-memory version of the table</li></ul></li><li><code>cql_drop_legacy_triggers</code> : drops any triggers of the from <code>tr__*</code><ul><li>for historical reasons the original triggers did not include tombstones when deleted</li><li>this kludge is here to clean up legacy triggers and its peculiar to Messenger only</li><li>this should really be removed from the OSS version but it&#x27;s never been a priority</li><li>sorry...</li></ul></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_helpers(&amp;decls);</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="declared-upgrade-procedures"></a>Declared Upgrade Procedures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#declared-upgrade-procedures" title="Direct link to heading">#</a></h3><p>The annotations can include an upgrade procedure. The term &quot;migration&quot; procedure is sometimes used
as well and is synonymous.  This is some code that should run after the schema alteration has
been made to create/delete/move some data around in the new schema.  Each of these must be
declared before it is used and the declarations will be here, at the end of the <code>decls</code> section
after this introductory comment.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- declared upgrade procedures if any\n&quot;);</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-upgrading-workers"></a>The Upgrading Workers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-upgrading-workers" title="Direct link to heading">#</a></h3><p>The main upgrader will invoke these key workers to do its job.  This is where the <code>preamble</code>
section starts. It contains the meat of the upgrade steps wrapped in procedures that do
the job.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_emit_baseline_tables_proc(&amp;preamble, &amp;baseline);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t view_creates = 0, view_drops = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_manage_views(&amp;preamble, &amp;view_drops, &amp;view_creates);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t index_creates = 0, index_drops = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_manage_indices(&amp;preamble, &amp;index_drops, &amp;index_creates);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t trigger_creates = 0, trigger_drops = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_manage_triggers(&amp;preamble, &amp;trigger_drops, &amp;trigger_creates);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (recreate_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_schema_manage_recreate_tables(&amp;preamble, recreates, recreate_items_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t has_temp_schema = cg_schema_emit_temp_schema_proc(&amp;preamble);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t one_time_drop_needed = false;</span></div></div></div></div></div><p>These are the last of the worker methods:</p><ul><li><code>cg_schema_emit_baseline_tables_proc</code> : emits a procedure that will create the schema at its baseline version<ul><li>this means whatever &quot;v0&quot; of the schema was, no creates or deletes have yet happened</li></ul></li><li><code>cg_schema_manage_views</code> : creates the view management procedures<ul><li><code>cql_drop_all_views</code> : drops all views</li><li><code>cql_create_all_views</code> : creates all views</li><li>both of these run unless the global CRC matches</li></ul></li><li><code>cg_schema_manage_indices</code> : creates the index management procedures<ul><li><code>cql_drop_all_indices</code> : drops any index that exists and whose CRC changed</li><li><code>cql_create_all_indices</code> : creates any index whose CRC changed</li><li>recreating indices can be costly so it is only done if the index actually changed</li></ul></li><li><code>cg_schema_manage_triggers</code> : creates the trigger management procedures<ul><li><code>cql_drop_all_triggers</code> : drops all triggers</li><li><code>cql_create_all_triggers</code> : creates all triggers</li><li>both of these run unless the global CRC matches</li><li>additionally any legacy triggers will be deleted (see <code>cql_drop_legacy_triggers</code>)</li></ul></li><li><code>cg_schema_manage_recreate_tables</code> : creates the <code>cql_recreate_tables</code> worker<ul><li>the <code>recreate_annotations</code> array is used to find all the recreate tables</li><li>the entries are sorted by group, then name, so that annotations within a group are together</li><li>the procedure contains code to delete the procedure or group and recreate it if the CRC does not match</li><li>the CRC is computed using the code for create instructions and is stored in a facet with a suitable name</li><li>the easiest way to think of this code is that it always emits a chunk of recreates for a group<ul><li>ungrouped tables are a group of 1</li><li>group delete/create instructions accumulate until the next entry is in a different group</li></ul></li></ul></li><li><code>cg_schema_emit_temp_schema_proc</code> : emits a procedure to create any temporary schema<ul><li>temp tables are always created in full at the latest version</li><li>this code is run regardless of whether the global CRC matches or not</li></ul></li></ul><p>All of these functions semantic outputs like <code>all_indices_list</code>, <code>all_views_list</code>, etc. to do their job (except
<code>cg_schema_manage_recreate_tables</code> as noted). Generally they have all the data they need handed to them
on a silver platter by the semantic pass. This is not an accident.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reading-the-facets-into-memory"></a>Reading the Facets into Memory<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reading-the-facets-into-memory" title="Direct link to heading">#</a></h4><p>The <code>setup_facets</code> procedure simply selects out the entire <code>facets</code> table with a cursor
and uses <code>cql_facet_add</code> to get them into a hash table.  This is the primary source of
facets information during the run.  This is a good example of what the codegen looks like
so we&#x27;ll include this one in full.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // code to read the facets into the hash table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;@attribute(cql:private)\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;CREATE PROCEDURE %s_setup_facets()\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  BEGIN TRY\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    SET %s_facets := cql_facets_new();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    DECLARE C CURSOR FOR SELECT * from %s_cql_schema_facets;\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    LOOP FETCH C\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;      LET added := cql_facet_add(%s_facets, C.facet, C.version);\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    END;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  END TRY;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  BEGIN CATCH\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;   -- if table doesn&#x27;t exist we just have empty facets, that&#x27;s ok\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  END CATCH;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;END;\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">### The Main Upgrader</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">And now we come to the main upgrading procedure `perform_upgrade_steps`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">We&#x27;ll go over this section by section.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#### Standard Steps</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">```C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the main upgrade worker</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;\n@attribute(cql:private)\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;CREATE PROCEDURE %s_perform_upgrade_steps()\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;  DECLARE schema_version LONG INTEGER NOT NULL;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (view_drops) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    -- dropping all views --\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_drop_all_views();\n\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (index_drops) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    -- dropping condemned or changing indices --\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_drop_all_indices();\n\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (trigger_drops) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    -- dropping condemned or changing triggers --\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_drop_all_triggers();\n\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (baseline.used &gt; 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    llint_t baseline_crc = (llint_t)crc_charbuf(&amp;baseline);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    ---- install baseline schema if needed ----\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_get_version_crc(0, schema_version);\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    IF schema_version != %lld THEN\n&quot;, baseline_crc);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;      CALL %s_cql_install_baseline_schema();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;      CALL %s_cql_set_version_crc(0, %lld);\n&quot;, global_proc_name, baseline_crc);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    END IF;\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>First we deal with the preliminaries:</p><ul><li>drop the views if there are any</li><li>drop the indices that need dropping</li><li>drop the triggers if there are any</li><li>install the baseline schema if there is any</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="process-standard-annotations"></a>Process Standard Annotations<a aria-hidden="true" tabindex="-1" class="hash-link" href="#process-standard-annotations" title="Direct link to heading">#</a></h4><p>In this phase we walk the annotations from <code>schema_annotations</code> which are now stored in <code>notes</code>.</p><p>They have been sorted in exactly the right order to process them (by version, then type, then target).
We&#x27;ll create one set of instructions per version number as we simply accumulate instructions for any
version while we&#x27;re still on the same version then spit them all out.  Adding <code>target</code> to the sort
order ensures that the results have a total ordering (there are no ties that might yield an ambiguous order).</p><p>We set up a loop to walk over the annotations and we flush if we ever encounter an annotation for
a different version number.  We&#x27;ll have to force a flush at the end as well.  <code>cg_schema_end_version</code>
does the flush.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t prev_version = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int32_t i = 0; i &lt; schema_items_count; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    schema_annotation *note = &amp;notes[i];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *version_annotation = note-&gt;annotation_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    uint32_t type = note-&gt;annotation_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(type &gt;= SCHEMA_ANNOTATION_FIRST &amp;&amp; type &lt;= SCHEMA_ANNOTATION_LAST);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(is_ast_version_annotation(version_annotation));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_OPTION(vers, version_annotation-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(note-&gt;version == vers);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(vers &gt; 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (prev_version != vers) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_schema_end_version(&amp;main, &amp;upgrade, &amp;pending, prev_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      prev_version = vers;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>If we find any item that is in a region we are not upgrading, we skip it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CSTR target_name = note-&gt;target_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(type &gt;= SCHEMA_ANNOTATION_FIRST &amp;&amp; type &lt;= SCHEMA_ANNOTATION_LAST);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!include_from_region(note-&gt;target_ast-&gt;sem-&gt;region, SCHEMA_TO_UPGRADE)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>There are several annotation types.  Each one requires appropriate commands</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    switch (type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_CREATE_COLUMN: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... emit ALTER TABLE ADD COLUMN if the column does not already exist</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_COLUMN: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... it&#x27;s not possible to delete columns in SQLite (this is changing)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... we simply emit a comment and move on</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_CREATE_TABLE: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... if the table is moving from @recreate to @create we have to drop any stale version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... of it one time.  We emit a call to `cql_one_time_drop` and record that we need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... to generate that procedure in `one_time_drop_needed`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ...in all cases emit a CREATE TABLE IF NOT EXISTS</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_TABLE: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... emit DROP TABLE IF EXISTS for the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_INDEX:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_VIEW:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_TRIGGER:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... this annotation indicates there is a tombstone on the item</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... this was handled in the appropriate `manage` worker above, nothing needs</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... to be done here except run any migration procs (see below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_AD_HOC:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... ad hoc migration procs allow for code to be run one time when we hit</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... a particular schema version, this just allows the migration proc to run</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        // no annotation based actions other than migration proc (handled below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Contract(version_annotation-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bprintf(&amp;upgrade, &quot;      -- ad hoc migration proc %s will run\n\n&quot;, target_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>The above constitutes the bulk of the upgrading logic which, as you can see, isn&#x27;t that complicated.</p><p>Any of the above might have a migration proc.  If there is one in the node, then generate:</p><ul><li>emit a call to <code>cql_facet_find</code> to see if the migration proc has already run</li><li>emit a declaration for the migration proc into the <code>decls</code> section</li><li>emit a call to the procedure (it accept no arguments)</li><li>emit a call to <code>cql_set_facet_version</code> to record that the migrator ran</li></ul><p>When the loop is done, any pending migration code is flushed using <code>cg_schema_end_version</code> again.</p><p>At this point we can move on to the finalization steps.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="finalization-steps"></a>Finalization Steps<a aria-hidden="true" tabindex="-1" class="hash-link" href="#finalization-steps" title="Direct link to heading">#</a></h4><p>With the standard upgrade finished, there is just some house keeping left:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (recreate_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_recreate_tables();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (view_creates) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_create_all_views();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (index_creates) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_create_all_indices();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (trigger_creates) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_create_all_triggers();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;    CALL %s_cql_set_facet_version(&#x27;cql_schema_version&#x27;, %d);\n&quot;, global_proc_name, prev_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;    CALL %s_cql_set_facet_version(&#x27;cql_schema_crc&#x27;, %lld);\n&quot;, global_proc_name, schema_crc);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;END;\n\n&quot;);</span></div></div></div></div></div><ul><li><code>cql_recreate_tables</code> : must run if there are any tables marked recreate<ul><li>this procedure will have code to drop and recreate any changed tables</li><li>this procedure was created by <code>cg_schema_manage_recreate_tables</code> and that process is described above<ul><li>basically, it uses <code>recreate_annotations</code> to do the job</li></ul></li><li>any that were condemned by marking with <code>@delete</code> will not be created again here</li></ul></li><li><code>cql_create_all_views</code> : must run if there are any views, they need to be put back<ul><li>any that were condemned by marking with <code>@delete</code> are not created again here</li></ul></li><li><code>cql_create_all_indices</code> : must run if there are any indices, this will create any that are missing<ul><li>any that were changing were previously deleted, this is where they come back</li><li>any that were condemned by marking with <code>@delete</code> are not created again here</li></ul></li><li><code>cql_create_all_triggers</code> : must run if there are any triggers, they need to be put back<ul><li>any that were condemned by marking with <code>@delete</code> are not created again here</li><li>triggers might cause weird side-effects during upgrade hence they are always dropped</li><li>stale triggers especially could be problematic</li><li>any triggers that refer to views couldn&#x27;t possibly run as the views are gone</li><li>hence, triggers are always dropped and recreated</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-main-steps"></a>The &quot;Main&quot; Steps<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-main-steps" title="Direct link to heading">#</a></h4><p>We&#x27;re getting very close to the top level now</p><ul><li><p><code>perform_needed_upgrades</code> : this orchestrates the upgrade, if it is called there is one</p><ul><li><code>cql_facet_find</code> : is used to check for a schema &quot;downgrade&quot;<ul><li>abort with an error if that happens</li></ul></li><li><code>save_cql_schema_facets</code> : saves the facets as they exist so we can diff them</li><li><code>perform_upgrade_steps</code> : does the upgrade</li><li>a <code>LEFT OUTER JOIN</code> between <code>cql_schema_facets</code> and <code>cql_schema_facets_saved</code> reports differences</li><li>any errors will cause the normal CQL error flow</li></ul></li><li><p>the main entry point is named by <code>global_proc_name</code></p><ul><li><code>create_cql_schema_facets_if_needed</code> is used to create the <code>facets</code> table if it doesn&#x27;t already exist</li><li>the special facet <code>cql_schema_crc</code> is read from the <code>facets</code> table</li><li>if the CRC stored there matches our target then we return &quot;no differences&quot;, otherwise</li><li><code>setup_facets</code> : loads the in-memory version of the facets table</li><li><code>perform_needed_upgrades</code> : does the work and creates the diff</li><li><code>cql_facets_delete</code> is used to free the in-memory storage, even if there were errors in <code>perform_needed_upgrades</code></li></ul></li><li><p><code>cql_install_temp_schema</code> : installs temporary schema if there is any, regardless of the CRC</p></li><li><p>the <code>one_time_drop</code> code is emitted if it was needed</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="writing-the-buffer"></a>Writing the Buffer<a aria-hidden="true" tabindex="-1" class="hash-link" href="#writing-the-buffer" title="Direct link to heading">#</a></h4><p>At this point the main buffers <code>decls</code>, <code>preamble</code>, and <code>main</code> are ready to go.  We&#x27;re back to where we started
but we can quickly recap the overall flow.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(output_file);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s\n&quot;, decls.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, preamble.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, main.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], output_file.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(output_file);</span></div></div></div></div></div><p>There is nothing left but to <code>CHARBUF_CLOSE</code> the interim buffers we created.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>At present <code>cg_schema.c</code> accomplishes a lot and is fairly light at only 1313 lines (at present).
It is able to do so because it can leverage heavy lifting done in the semantic analysis phase
and schema generation that can be done like all other SQL generation by the echoing code
discussed in <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>.</p><p>Topics covered included:</p><ul><li>the essential sources of schema information from the semantic pass</li><li>the state tables used in the database and helpers for read/write of the same</li><li>the interaction with schema regions</li><li>the prosecution steps for tables, columns, views, triggers, indices</li><li>the key annotation types and what code they create</li><li>the handling of recreate tables, temp tables, and the base schema</li><li>how all of these are wired together starting from the upgrader&#x27;s &quot;main&quot;</li></ul><p>As with the other parts, no attempt was made to cover every function in detail.  That is
best done by reading the source code. But there is overall structure here and an understanding
of the basic principles is helpful before diving into the source code.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-10-01T06:38:45.000Z" class="docLastUpdatedAt_217_">10/1/2021</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/int05"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Part 5: CQL Runtime</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cql-guide/int07"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Part 7: JSON Generation Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preface" class="table-of-contents__link">Preface</a></li><li><a href="#schema-management" class="table-of-contents__link">Schema Management</a><ul><li><a href="#check-for-errors-check-for---global_proc" class="table-of-contents__link">Check for errors, check for <code>--global_proc</code></a></li><li><a href="#preparing-the-attributes" class="table-of-contents__link">Preparing the Attributes</a></li><li><a href="#creating-the-global-crc" class="table-of-contents__link">Creating the Global CRC</a></li><li><a href="#output-fragments" class="table-of-contents__link">Output Fragments</a></li><li><a href="#declarations-section" class="table-of-contents__link">Declarations Section</a></li><li><a href="#the-schema-helpers" class="table-of-contents__link">The Schema Helpers</a></li><li><a href="#declared-upgrade-procedures" class="table-of-contents__link">Declared Upgrade Procedures</a></li><li><a href="#the-upgrading-workers" class="table-of-contents__link">The Upgrading Workers</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Facebook Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2021 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.ead03b59.js"></script>
<script src="/runtime~main.939cc205.js"></script>
<script src="/main.cdfa48d1.js"></script>
<script src="/1.cf35a583.js"></script>
<script src="/2.08e76adb.js"></script>
<script src="/3.22158529.js"></script>
<script src="/1be78505.7a0a43f3.js"></script>
<script src="/91.a1c7096d.js"></script>
<script src="/5456faf3.85d0087e.js"></script>
<script src="/17896441.e655f3a5.js"></script>
<script src="/62786a5f.690b0dfb.js"></script>
</body>
</html>