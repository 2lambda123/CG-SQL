<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">internal | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="internal | CG/SQL"><meta data-react-helmet="true" name="description" content="Part 1: Lexing, Parsing, and the AST"><meta data-react-helmet="true" property="og:description" content="Part 1: Lexing, Parsing, and the AST"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/generated/internal"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/generated/internal"><link rel="stylesheet" href="/styles.9ec987f3.css">
<link rel="preload" href="/styles.a144e2e4.js" as="script">
<link rel="preload" href="/runtime~main.88fe9dcb.js" as="script">
<link rel="preload" href="/main.a8f5bad0.js" as="script">
<link rel="preload" href="/1.146bcdda.js" as="script">
<link rel="preload" href="/2.38f10475.js" as="script">
<link rel="preload" href="/3.356a0a8e.js" as="script">
<link rel="preload" href="/1be78505.7b59e2c1.js" as="script">
<link rel="preload" href="/104.e5f87727.js" as="script">
<link rel="preload" href="/5456faf3.142564bd.js" as="script">
<link rel="preload" href="/17896441.d78200b7.js" as="script">
<link rel="preload" href="/7d22b040.6f2a5b40.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div class="announcementBar_1l0Z" style="background-color:#20232a;color:#fff" role="banner"><div class="announcementBarContent_1xni">Support Ukraine ðŸ‡ºðŸ‡¦ <a target="_blank" rel="noopener noreferrer" href="https://opensource.fb.com/support-ukraine"> Help Provide Humanitarian Aid to Ukraine</a>.</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">internal</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-1-lexing-parsing-and-the-ast"></a>Part 1: Lexing, Parsing, and the AST<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-1-lexing-parsing-and-the-ast" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>The following is a summary of the implementation theory of the CQL compiler.  This is
an adjunct to the Guide proper, which describes the language, and to a lesser extent
the code that the compiler generates.</p><p>The actual code is heavily commented, so it&#x27;s better to read the code to see the details
of how any particular operation happens rather than try to guess from the language specification
or from this overview.  However, some things, like general principles, really are nowhere
(or everywhere) in the codebase and it&#x27;s important to understand how things hang together.</p><p>If you choose to go on adventures in the source code, especially if you aren&#x27;t already familiar
with compilers and how they are typically built, this document is a good place to start.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="general-structure"></a>General Structure<a aria-hidden="true" tabindex="-1" class="hash-link" href="#general-structure" title="Direct link to heading">#</a></h2><p>The CQL compiler uses a very standard lex+yacc parser, though to be more precise it&#x27;s flex+bison.
The grammar is a large subset of the SQLite dialect of SQL augmented with control flow and compiler
directives.  As a consequence, it&#x27;s a useful asset in-and-of-itself. If you&#x27;re looking for an
economical SQL grammar, you could do a lot worse than start with the one CQL uses.  The grammar is
of course in the usual <code>.y</code> format that bison consumes but it&#x27;s also extracted into more readable
versions for use in the railroad diagram and the Guide documentation.  Any of those sources would be
a good starting place for a modest SQL project in need of a grammar.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="lexical-analysis"></a>Lexical Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#lexical-analysis" title="Direct link to heading">#</a></h3><p>Inside of <code>cql.l</code> you&#x27;ll find the formal definition of all the tokens.  These of course correspond to the
various tokens needed to parse the SQL language, plus a few more of the CQL control flow extensions.
There&#x27;s no need to discuss the approximately 150 such tokens, but the following points are of general interest:</p><ul><li>the lexer expects plain text files, and all the tokens are defined in plain ASCII only, however<ul><li>the presence of UTF8 characters in places where any text is legal (such as string literals) should just work</li></ul></li><li>all of the tokens are case-insensitive<ul><li>this means only vanilla ASCII insensitivity; no attempt is made to understand more complex UNICODE code-points</li></ul></li><li>multi-word tokens typically are defined with an expression like this:  <code>IS[ \t]+NOT[ \t]+FALSE/[^A-Z_]</code><ul><li>in most cases, to avoid ambiguity, and to get order of operations correct, the entire word sequence is one token</li><li>only spaces and tabs are allowed between the words</li><li>the token ends on non-identifier characters, so the text &quot;X IS NOT FALSEY&quot; must become the tokens { <code>X</code>, <code>IS_NOT</code>, <code>FALSEY</code> } and not { <code>X</code>, <code>IS_NOT_FALSE</code>, <code>Y</code> }<ul><li>the second option is actually the longest token, so without the trailing qualifier it would be preferred</li><li>hence, where a continuation is possible, the trailing context must be specified in multi-word tokens</li></ul></li></ul></li><li>there is special processing needed to lex <code>/* ... */</code> comments correctly</li><li>there are token types for each of the sorts of literals that can be encountered<ul><li>special care is taken to keep the literals in string form so that no precision is lost</li><li>integer literals are compared against 0x7fffffff and if greater they automatically become long literals even if they are not marked with the trailing <code>L</code> as in <code>1L</code></li><li>string literals include the quotation marks in the token text which distinguishes them from identifiers; they are otherwise encoded similarly</li></ul></li><li>the character class <code>[-+&amp;~|^/%*(),.;!&lt;&gt;:=]</code> produces single character tokens for operators; other non-matching single characters (e.g. <code>&#x27;$&#x27;</code>) produce an error</li><li>line directives <code>^#line\ [0-9]+\ \&quot;[^&quot;]*\&quot;.*</code> or <code>^#\ [0-9]+\ \&quot;[^&quot;]*\&quot;.*</code> get special processing so that pre-processed input does not lose file and line number fidelity</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="parsing-and-the-abstract-syntax-tree"></a>Parsing and the Abstract Syntax Tree<a aria-hidden="true" tabindex="-1" class="hash-link" href="#parsing-and-the-abstract-syntax-tree" title="Direct link to heading">#</a></h3><p>Inside of <code>cql.y</code> you will find the token declarations, precedence rules, and all of the productions in the overall grammar. The grammar processing
does as little as possible in that stage to create an abstract syntax tree (AST). The AST itself is a simple binary tree; where nodes might require more than just
left and right children to specify the syntax fully, additional nodes are used in the tree shape rather than introduce n-ary nodes.  This means the tree is
sometimes bigger, but generally not very much bigger.  The benefit of this choice is that the AST can always be walked generically as a binary tree, so if you need
to find all the <code>table_factor</code> nodes it is easy to do so without having to worry about how every kind of node expands.  If new node types come along
the generic walkers can go through those new nodes as well.  All of the grammar productions simply make one or more AST nodes and link them together so that in the
end there is a single root for the entire program in a binary tree.</p><p>There are 4 kinds of AST nodes, they all begin with the following five fields. These represent the AST &quot;base type&quot;, if you like.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nonnull type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_node *_Nullable sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nullable parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t lineno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nonnull filename;</span></div></div></div></div></div><ul><li><code>type</code> : a string literal that uniquely identifies the node type<ul><li>the string literal is compared for identity (it&#x27;s an exact pointer match: you don&#x27;t <code>strcmp</code> types)</li></ul></li><li><code>sem</code> : begins as <code>NULL</code> this is where the semantic type goes once semantic processing happens</li><li><code>parent</code> : the parent node in the AST (not often used but sometimes indispensible)</li><li><code>lineno</code> : the line number of the file that had the text that led to this AST (useful for errors)</li><li><code>filename</code> : the name of the file that had the text that led to this AST (useful for errors)<ul><li>this string is durable, should not be mutated, and is shared between MANY nodes</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-generic-binary-ast-node-ast_node"></a>The Generic Binary AST node <code>ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-generic-binary-ast-node-ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nullable left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nullable right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} ast_node;</span></div></div></div></div></div><p>This node gives the tree its shape and is how all the expression operators and statements get encoded.  An example shows this more clearly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SET X := 1 + 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {assign}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name X}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 3}</span></div></div></div></div></div><p>In the above, &quot;assign&quot; and &quot;add&quot; are the generic nodes.  Note that this node type can be a leaf but usually is not.  The other types
are always leaves.</p><p>Note that in the above output, the node <code>type</code> was directly printed (because it&#x27;s a meaningful name).  Likewise, the type needs no decoding
when viewing the AST in a debugger.  Simply printing the node with something like <code>p *ast</code> in lldb will show you
all the node fields and the type in human-readable form.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-grammar-code-node-int_ast_node"></a>The Grammar Code Node <code>int_ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-grammar-code-node-int_ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct int_ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int64_t value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} int_ast_node;</span></div></div></div></div></div><p>This kind of node holds an integer that quantifies some kind of choice in the grammar.  Note that this does NOT hold numeric literals (see below).
The file <code>ast.h</code> includes many <code>#define</code> constants for this purpose such as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_INNER 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_CROSS 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_LEFT_OUTER 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_RIGHT_OUTER 4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_LEFT 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_RIGHT 6</span></div></div></div></div></div><p>The integer for this fragment will be one of those defined values.  It can be a bitmask, or an enumeration.  In this statement:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> x</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> a</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">LEFT</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">OUTER</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">JOIN</span><span class="token plain"> b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>a part of the AST will look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">| {join_clause}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">| | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">| | | {name a}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">| | {join_target_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|   | {join_target}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|     | {int 3}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|     | {table_join}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|       | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|         | {name b}</span></div></div></div></div></div><p>The <code>{int 3}</code> above is an <code>int_ast_node</code> and it corresponds to <code>JOIN_LEFT_OUTER</code>.</p><p>This node type is always a leaf.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-string-node-str_ast_node"></a>The String Node <code>str_ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-string-node-str_ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct str_ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nullable value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t cstr_literal;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} str_ast_node;</span></div></div></div></div></div><p>This node type holds:</p><ul><li><p>string literals</p></li><li><p>blob literals</p></li><li><p>identifiers</p></li><li><p><code>value</code> : the text of the string</p></li><li><p><code>cstr_literal</code> : true if the string was specified using &quot;C&quot; syntax (see below)</p></li></ul><p>CQL supports C style string literals with C style escapes such as <code>&quot;foo\n&quot;</code>.  These are normalized into the SQL version of the same literal
so that SQLite will see a literal it understands.  However, if the origin of the string was the C string form (i.e. like <code>&quot;foo&quot;</code> rather than <code>&#x27;bar&#x27;</code>)
then the <code>cstr_literal</code> boolean flag will be set.  When echoing the program back as plain text, the C string will be converted back to the C form
for display to a user. But when providing the string to Sqlite, it&#x27;s in SQL format.</p><p>Identifiers can be distinguished from string literals because the quotation marks (always <code>&#x27;&#x27;</code>) are still in the string.</p><p>This node type is always a leaf.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-number-node-num_ast_node"></a>The Number Node <code>num_ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-number-node-num_ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct num_ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t num_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nullable value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} num_ast_node;</span></div></div></div></div></div><ul><li><code>num_type</code> : the kind of numeric</li><li><code>value</code> : the text of the number</li></ul><p>All numerics are stored as strings so that there is no loss of precision.  This is important because it is entirely possible that
the CQL compiler is built with a different floating point library, than the target system, or different integer sizes.  As a result
CQL does not evaluate anything outside of an explicit <code>const(...)</code> expression.  This policy avoids integer overflows at compile time or loss
of floating point precision. Constants in the text of the output are emitted byte-for-byte as they appeared in the source code.</p><p>This node type is always a leaf.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="examples"></a>Examples<a aria-hidden="true" tabindex="-1" class="hash-link" href="#examples" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-1-a-let-statement-and-expression"></a>Example 1: A LET statement and expression<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-1-a-let-statement-and-expression" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">LET x := 1 + (3 - 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {sub}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {int 3}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {int 2}</span></div></div></div></div></div><p>Note that there are no parentheses in the AST but it exactly and authoritatively captures the precedence with its shape.
This means, among other things, that when CQL echos its input, any redundant parentheses will be gone.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-2-an-ifelse-construct"></a>Example 2: An IF/ELSE construct<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-2-an-ifelse-construct" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">IF x THEN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET x := 1.5e7;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ELSE IF y THEN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET y := &#x27;that&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ELSE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET z := &quot;this&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END IF;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {if_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {cond_action}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {stmt_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {dbl 1.5e7}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {if_alt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {elseif}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | | {cond_action}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |   | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |   | {stmt_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |     | {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |       | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |       | {strlit &#x27;that&#x27;}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {else}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {stmt_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        | {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          | {name z}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          | {strlit &#x27;this&#x27;}</span></div></div></div></div></div><p>Note that the string &quot;this&quot; was normalized to &#x27;this&#x27; (which was trivial in this case) but rest assured that
<code>cstr_literal</code> was set.  This is shown because the text of the statement came out with double quotes.
The text above was not the input to the compiler, the compiler was actually given this text:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">if x then let x := 1.5e7; else if y then let y := &#x27;that&#x27;; else let z := &quot;this&quot;; end if;</span></div></div></div></div></div><p>And it was normalized into what you see as part of the output.  We&#x27;ll talk about this output echoing in coming sections.
As you can see, the compiler can be used as a SQL normalizer/beautifier.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-3-a-select-statement"></a>Example 3: A SELECT statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-3-a-select-statement" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FROM foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INNER JOIN bar</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHERE foo.x = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">LIMIT 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {select_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_core_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {select_core}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {select_expr_list_con}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_expr_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {star}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_from_etc}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {join_clause}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | | | {name foo}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | | {join_target_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |   | {join_target}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |     | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |     | {table_join}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |       | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |         | {name bar}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {select_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {opt_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | | {eq}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | {dot}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | | {name foo}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {select_groupby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |           | {select_having}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_orderby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {select_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {opt_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | | {int 3}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {select_offset}</span></div></div></div></div></div><p>As you can see the trees rapidly get more complex.  The <code>SELECT</code> statement has many optional pieces and
so the AST actually has places in its skeleton where these could go but are absent (e.g. <code>GROUP BY</code>,
<code>HAVING</code>, <code>ORDER BY</code>, and <code>OFFSET</code> are all missing).</p><p>The shape of the AST is largely self-evident from the above, but you can easily cross check it against
what&#x27;s in <code>cql.y</code> for details and then look at <code>gen_sql.c</code> for decoding tips (discussed below).</p><p>The compiler can produce these diagrams in &#x27;dot&#x27; format which makes pretty pictures, but the reality is that
for non-trivial examples those pictures are so large as to be unreadable whereas the simple text format
remains readable even up to several hundred lines of output. The text is also readily searchable, and diffable.
The test suites for semantic analysis do pattern matching on the text of the AST to verify correctness.</p><p>We&#x27;ll discuss semantic analysis in <a href="https://cgsql.dev/cql-guide/int02" target="_blank" rel="noopener noreferrer">Part 2</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ast-definitions"></a>AST definitions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ast-definitions" title="Direct link to heading">#</a></h3><p><code>ast.h</code> defines all the tree types mentioned above. There are helper methods to create AST nodes
with type safety.  It includes helper functions for the various leaf types mentioned above
but also for the various &quot;normal&quot; types.  These are specified using the AST macros <code>AST</code>, <code>AST1</code>, and <code>AST0</code>.</p><p>Examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">AST0(star)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">AST1(not)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">AST(or)</span></div></div></div></div></div><p>This says that:</p><ul><li>the <code>star</code> AST node (used in <code>select *</code>) is a leaf, it has 0 children<ul><li>this means the left and right nodes will always be <code>NULL</code></li></ul></li><li>the <code>not</code> AST node (used in <code>select NOT x</code>) is unary<ul><li>this means only the left node is populated, the right is always <code>NULL</code></li><li>node many unary nodes have optional children, so the left node might still be <code>NULL</code></li></ul></li><li>the <code>or</code> AST node (used in <code>select x OR y</code>) is binary<ul><li>this means both its left and right children are populated</li><li>note that some binary nodes have optional children, so left or right still might be <code>NULL</code></li></ul></li></ul><p>At present there are about 300 unique AST node types.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="echoing-the-ast"></a>Echoing the AST<a aria-hidden="true" tabindex="-1" class="hash-link" href="#echoing-the-ast" title="Direct link to heading">#</a></h2><p>The first set of features that were built (after parsing) provided the ability to echo back the parse tree as SQL again.
This all happens in <code>gen_sql.c</code>. Since this code has to be able to echo back any tree, it often has the best
and simplest examples of how to crack the AST for any particular type of node you might be interested in.</p><p>There are several reasons why we might want to echo the SQL, but the inescapable one is this: any hunk of
SQL that appears as part of a CQL program (i.e. DDL/DML rather than control flow like <code>IF</code>/<code>WHILE</code>) has to go
to SQLite and SQLite expects that code to be plain text.  So the AST must be reformatted as plain text that is
exactly equivalent to the original input.  The process of parsing removes extra white space and parentheses, so
to get something that looks reasonable some standard formatting (including indenting) is applied to the output text.
This has the effect of normalizing the input and potentially beautifying it as well (especially if it was
poorly formatted initially).</p><p>To see these features, you need only run cql with no arguments. By default, it reads <code>stdin</code>, makes the AST, and
then emits the normalized, formatted text. If there are no syntax errors, the input and the output should be
equivalent.</p><p>Standard formatting is essential, but CQL also has a number of extra demands.</p><p>CQL includes a lot of versioning directives like <code>@create(...)</code> <code>@delete(...)</code> and so forth.  SQLite should
never see these things when the DDL for SQLite is emitted.  But when echoing the input they should be included.
Additionally, any local or global variables in a SQL statement should be replaced with <code>?</code> in the text
that goes to SQLite and then followed up with binding instructions.  We&#x27;ll cover the binding more in the
section code generation, but importantly this also has to significantly alter the output.
As a result the standard formatter includes extensive configurability to get these various results.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="configuring-the-output-with-callbacks-and-flags"></a>Configuring the Output with Callbacks and Flags<a aria-hidden="true" tabindex="-1" class="hash-link" href="#configuring-the-output-with-callbacks-and-flags" title="Direct link to heading">#</a></h3><p>Some of these features, like variable binding, require a callback to the formatter&#x27;s client.  The client
gets a notification, along with a few control variables, and it can then decide exactly what goes in the output.
The control structure is <code>struct gen_sql_callbacks</code>, and it is described below.  This structure includes the various
callbacks (all of which are optional) and each callback gets a &#x27;context&#x27; pointer of its choice.  The context pointer
is some arbitrary <code>void *</code> value that you provide, which will be given to your function along with the AST pointer
relevant to the call.  The callback also gets the current output buffer so it can choose to emit something (like &#x27;?&#x27;)
into the stream.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// signature for a callback, you get your context plus the ast</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if you return true then the normal output is suppressed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// in any case the output you provide is emitted</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef bool_t (*_Nullable gen_sql_callback)(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nonnull ast,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *_Nonnull output</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">);</span></div></div></div></div></div><p>The meaning of the <code>bool_t</code> return value varies depend on which callback it is.</p><p>The coarsest control is provided by the generation mode.  It is one of these values:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These modes control the overall style of the output</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">enum gen_sql_mode {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_mode_echo,          // Prints everything in the original, with standard whitespace and parentheses</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_mode_sql,           // Prints the AST formatted for SQLite consumption, omits anything CQL specific</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_mode_no_annotations // Equivalent to gen_mode_echo without versioning attributes or generic attributes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                          // * @create, @delete, @recreate, and @attribute are removed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                          // * statements like @echo are not affected, nor is the type specifier @sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div></div></div><p>The actual callbacks structure is optional, if it is <code>NULL</code> then a full echo of the AST with no changes will
be produced.  Otherwise the callbacks and flags alter the behavior of the echoer somewhat.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Callbacks allow you to significantly alter the generated sql, see the particular flags below.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct gen_sql_callbacks {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Each time a local/global variable is encountered in the AST, this callback is invoked</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this is to allow the variable reference to be noted and replaced with ? in the generated SQL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable variables_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable variables_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Each time a column definition is emitted this callback is invoked, it may choose to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // suppress that column.  This is used to remove columns that were added in later schema</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // versions from the baseline schema.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable col_def_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable col_def_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This callback is used to explain the * in select * or select T.*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable star_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable star_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This callback is used to force the &quot;IF NOT EXISTS&quot; form of DDL statements when generating</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // schema upgrade steps.  e.g. a &quot;CREATE TABLE Foo declarations get &quot;IF NOT EXISTS&quot; added</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // to them in upgrade steps.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable if_not_exists_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable if_not_exists_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If true, hex literals are converted to decimal.  This is for JSON which does not support hex literals.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t convert_hex;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If true casts like &quot;CAST(NULL as TEXT)&quot; are reduced to just NULL.  The type information is not needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // by SQLite so it just wasts space.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t minify_casts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If true then unused aliases in select statements are elided to save space.  This is safe because</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // CQL always binds the top level select statement by ordinal anyway.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t minify_aliases;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // mode to print cql statement: gen_mode_echo, gen_mode_sql, gen_mode_no_annotations.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // gen_mode_sql mode causes the AS part of virtual table to be suppressed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  enum gen_sql_mode mode;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If CQL finds a column such as &#x27;x&#x27; below&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // create table foo(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //   x long_int primary key autoincrement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // that column must be converted to this form:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // create table foo(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //   x integer primary key autoincrement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This is because SQLite mandates that autoincrement must be exactly</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // in the second example above however, it is also the case that in SQLite</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // an integer can store a 64 bit value.  So sending &quot;integer&quot; to SQLite while</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // keeping the sense that the column is to be treated as 64 bits in CQL works</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // just fine.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // However, when we are emitting CQL (rather than SQL) we want to keep</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the original long_int type so as not to lose fidelity when processing</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // schema for other semantic checks (such as matching FK data types).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This flag is for that purpose: It tells us that the target isn&#x27;t SQLite</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // and we don&#x27;t need to do the mapping (yet). Indeed, we shouldn&#x27;t, or the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // types will be messed up.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // In short, if CQL is going to process the output again, use this flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // to control the autoincrement transform.  It might be possible to fold</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this flag with the mode flag but it&#x27;s sufficiently weird that this</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // extra documentation and special handling is probably worth the extra</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // boolean storage.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t long_to_int_conv;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} gen_sql_callbacks;</span></div></div></div></div></div><p>Each callback can be best understood by reading the source, so we&#x27;ll avoid
trying to precisely define it here.  But it is helpful to give the gist
of these options.</p><ul><li><code>mode</code> : one of the three enum modes that control overall behavior</li><li><code>variables_callback</code> : invoked when a variable appears in the SQL, the caller can record the specific variable and then use it for binding</li><li><code>col_def_callback</code> : when creating the &quot;baseline&quot; schema you don&#x27;t want column definitions from later schema to be included, this gives you a chance to suppress them</li><li><code>star_callback</code> : normally the <code>*</code> in <code>select *</code> or <code>select T.*</code> is expanded when emitting for SQLite, this callback does the expansion when appropriate</li><li><code>if_not_exists_callback</code> : when generating DDL for schema upgrade you typically want to force <code>IF NOT EXISTS</code> to be added to the schema even if it wasn&#x27;t present in the declaration; this callback lets you do that</li><li><code>convert_hex</code> : if true, hex constants are converted to decimal; used when emitting JSON because JSON doesn&#x27;t understand hex constants</li><li><code>minify_casts</code> : minification converts casts like <code>CAST(NULL AS TEXT)</code> to just <code>NULL</code> -- the former is only useful for type information, SQLite does need to see it</li><li><code>minify_aliases</code> : unused column aliases as in <code>select foo.x as some_really_long_alias</code> can be removed from the output when targeting SQLite to save space</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="invoking-the-generator"></a>Invoking the Generator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#invoking-the-generator" title="Direct link to heading">#</a></h3><p>There are several generation functions but they all follow a similar pattern, the differences are essentially what fragment of the AST
they expect to begin on.  We&#x27;ll just cover one here.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_statement_with_callbacks(ast_node *_Nonnull ast, gen_sql_callbacks *_Nullable _callbacks);</span></div></div></div></div></div><p>This has the typical signature for all these generators:</p><ul><li><code>ast</code> : the part of the tree to print</li><li><code>_callbacks</code> : the optional callbacks described above</li></ul><p>To use these you&#x27;ll need to these functions as well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_init(void);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_cleanup(void);</span></div></div></div></div></div><p>You&#x27;ll want to call <code>gen_init()</code> one time before doing any generation.  That sets up the necessary tables.
When you&#x27;re done use <code>gen_cleanup()</code> to release any memory that was allocated in setup.
You don&#x27;t have to do the cleanup step if the process is going to exit anyway, however, because of the amalgam
options, <code>cql_main()</code> assumes it might be called again and so it tidies things up rather than risk leaking.</p><p>With the one time initialization in place there are these preliminaries:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void init_gen_sql_callbacks(gen_sql_callbacks *_Nullable callbacks);</span></div></div></div></div></div><p>Use <code>init_gen_sql_callbacks</code> to fill in your callback structure with the normal defaults.  This give you normal echo for SQL by default.
To get a full echo, a <code>NULL</code> callback may be used.  And of course other options are possible.</p><p>Finally,</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_set_output_buffer(struct charbuf *_Nonnull buffer);</span></div></div></div></div></div><p>Use this before the call to <code>gen_&lt;something&gt;_with_callbacks</code> to redirect the output into a growable character buffer of your choice.</p><p>The buffers can then be written where they are needed.  Maybe further processed into a C string literal for compiler output, or into
a C style comment, or just right back to stdout.</p><p>There are a few simplified versions of this sequence like this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_stmt_list_to_stdout(ast_node *_Nullable ast);</span></div></div></div></div></div><p>This uses <code>NULL</code> for the callbacks and emits directly to stdout with no extra steps.  The extra wiring is done for you.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generator-internals"></a>Generator Internals<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generator-internals" title="Direct link to heading">#</a></h3><p>The generator has to be able to walk the entire tree and emit plain text, and in many areas the tree is very flexible
so we want a simple dynamic dispatch mechanism that can call the right formatting function from anywhere in the tree.</p><p>It turns out two different signatures are needed to do this properly, one for formatting statements and the other
for expressions -- the difference being that expressions have to concern themselves with the precedence of the various
operators so that parentheses can be correctly (re)inserted into the output.</p><p>To do this there are two symbol tables that map from an AST node type string to a formatting function.  They are initialized
with a series of statements similar to these:</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generating-expressions"></a>Generating Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generating-expressions" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_init() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_stmts = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_exprs = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, gen_binary, &quot;*&quot;, EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(div, gen_binary, &quot;/&quot;, EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, gen_binary, &quot;%&quot;, EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(add, gen_binary, &quot;+&quot;, EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(sub, gen_binary, &quot;-&quot;, EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, gen_unary, &quot;NOT &quot;, EXPR_PRI_NOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, gen_unary, &quot;~&quot;, EXPR_PRI_TILDE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>These statements populate the symbol tables.</p><ul><li>For statements, the entry maps <code>if_stmt</code> to the function <code>gen_if_stmt</code></li><li>For expressions, the entry maps <code>mul</code> to <code>gen_binary</code> including the metadata <code>&quot;*&quot;</code> and <code>EXPR_PRI_MUL</code></li></ul><p>As you can see, nearly all binary operators are handled identically as are all unary operators.
Let&#x27;s look at those two in detail.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_binary(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We add parens if our priority is less than the parent priority</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // meaning something like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // * we&#x27;re a + node, our parent is a * node</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // * we need parens because the tree specifies that the + happens before the *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Also, grouping of equal operators is left to right</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so for so if our right child is the same precedence as us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // that means there were parens there in the original expression</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // e.g.  3+(4-7);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // effectively it&#x27;s like we&#x27;re one binding strength higher for our right child</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so we call it with pri_new + 1.  If it&#x27;s equal to us it must emit parens</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;(&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_expr(ast-&gt;left, pri_new);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot; %s &quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_expr(ast-&gt;right, pri_new + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;)&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The convention gives us:</p><ul><li><code>ast</code> : pointer to the current AST node</li><li><code>op</code> : the text of the operator (<code>CSTR</code> is simply <code>const char *</code>)</li><li><code>pri</code> : the binding strength of the node above us</li><li><code>pri_new</code> : the binding strength of this node (the new node)</li></ul><p>So generically, if the binding strength of the current operator <code>pri_new</code> is weaker than the context it is contained in <code>pri</code>,
then parentheses are required to preserve order of operations. See the comment for more details.</p><p>With parens taken care of, we emit the left expression, the operator, and the right expression.</p><p>And as you can see below, unary operators are much the same.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_unary(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;(&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot;%s&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_expr(ast-&gt;left, pri_new);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;)&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>There are special case formatters for some of the postfix operators and other cases that are special
like <code>CASE... WHEN... THEN... ELSE... END</code> but they operate on the same principles down to the leaf nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generating-statements"></a>Generating Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generating-statements" title="Direct link to heading">#</a></h4><p>With no binding strength to worry about, statement processing is quite a bit simpler.</p><p>Here&#x27;s the code for the <code>IF</code> statement mentioned above.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_if_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_if_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NOTNULL(cond_action, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NOTNULL(if_alt, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(elseif, if_alt-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NAMED(elsenode, else, if_alt-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot;IF &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_cond_action(cond_action);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (elseif) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_elseif_list(elseif);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (elsenode) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_printf(&quot;ELSE\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(stmt_list, elsenode-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot;END IF&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>There is a general boilerplate sort of recursive form to all of these; they follow the same basic shape.
These patterns are designed to make it impossible to walk the tree incorrectly. If the tree shape changes
because of a grammar change, you get immediate concrete failures where the tree walk has to change.  Since
there are test cases to cover every tree shape you can always be sure you have it exactly right if the
macros do not force assertion failures.</p><p>The steps were:</p><ul><li>use <code>Contract</code> to assert that the node we are given is the type we expect</li><li>use <code>EXTRACT</code> macros (detailed below) to get the tree parts you want starting from your root</li><li>use <code>gen_printf</code> to emit the constant pieces of the statement</li><li>use recursion to print sub-fragments (like the IF condition in this case)</li><li>test the tree fragments where optional pieces are present, emit them as needed</li></ul><p>It might be instructive to include <code>gen_cond_action</code>; it is entirely unremarkable:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_cond_action(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_cond_action(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_root_expr(ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot; THEN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>A <code>cond_action</code> node has an expression on the left and a statement list on the right; it can appear
in the base <code>IF x THEN y</code> part of the <code>IF</code> or as <code>ELSE IF x THEN y</code>.  Either case is formatted the same.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="extraction-macros"></a>Extraction Macros<a aria-hidden="true" tabindex="-1" class="hash-link" href="#extraction-macros" title="Direct link to heading">#</a></h4><p>These macros are used by all the parts of CQL that walk the AST.  They are designed to make it impossible
for you to get the tree shape wrong without immediately failing.  We do not ever want to walk off
the tree in some exotic way and then continue to several levels of recursion before things go wrong.  CQL
locks this down by checking the node type at every step -- any problems are found immediately, exactly
at the extraction site, and can be quickly corrected.  Again 100% coverage of all the tree shapes makes
this rock solid, so CQL never compromises on 100% code coverage.  The most common macros all appear in this
example:</p><ul><li><code>EXTRACT_NOTNULL(cond_action, ast-&gt;left);</code><ul><li>read ast-&gt;left, assert that it is of type <code>cond_action</code>, it must not be NULL</li><li>declare a local variable named <code>cond_action</code> to hold the result</li></ul></li><li><code>EXTRACT_NOTNULL(if_alt, ast-&gt;right);</code><ul><li>read ast-&gt;right, assert that it is of type <code>if_alt</code>, it must not be NULL</li><li>declare a local variable named <code>if_alt</code> to hold the result</li></ul></li><li><code>EXTRACT(elseif, if_alt-&gt;left);</code><ul><li>read <code>if_alt-&gt;left</code>, assert that it is either NULL or else of type <code>elseif</code></li><li>declare a variable named <code>elseif</code> to hold the result</li></ul></li><li><code>EXTRACT_NAMED(elsenode, else, if_alt-&gt;right);</code><ul><li>read <code>if_alt-&gt;right</code>, assert that it is either NULL or else of type <code>else</code></li><li>declare a variable named <code>elsenode</code> to hold the result</li><li>note that we can&#x27;t use a variable named <code>else</code> because <code>else</code> is a keyword in C</li></ul></li></ul><p>Other options:</p><ul><li><code>EXTRACT_NAMED_NOTNULL</code> : like the <code>NAMED</code> variant</li><li><code>EXTRACT_ANY</code> : if the tree type is not known (e.g. <code>expr-&gt;left</code> could be any expression type)</li><li><code>EXTRACT_ANY_NOTNULL</code> : as above but not optional</li><li><code>EXTRACT_NUM_TYPE</code> : extracts the num_type field from a numeric AST node</li></ul><p>The <code>ANY</code> variants are usually re-dispatched with something like <code>gen_expr</code> that uses the name table again (and that will check the type) or
else the extracted value is checked with ad hoc logic immediately after extraction if it&#x27;s perhaps one of two or three variations.
In all cases the idea is to force a failure very quickly.  <code>gen_root_expr()</code> for instance in the <code>if_cond</code> example will fail immediately
if the node it gets is not an expression type.</p><p>Because of the clear use of <code>EXTRACT</code>, the <code>gen_</code> family of functions are often the best/fastest way to understand the shape of the AST.
You can dump a few samples and look at the <code>gen_</code> function and quickly see exactly what the options are authoritatively.  As a result
it&#x27;s very normal to paste the extraction code from a <code>gen_</code> function into a new/needed semantic analysis or code-generation function.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-2-semantic-analysis"></a>Part 2: Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-2-semantic-analysis" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-1"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-1" title="Direct link to heading">#</a></h3><p>Part 2 continues with a discussion of the essentials of the semantic analysis pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every single rule but rather to give
a sense of how semantic analysis happens in general -- the core strategies and implementation choices --
so that when reading the code you will have an idea of how smaller pieces fit into the whole. To accomplish
this, various key data structures will be explained in detail and selected examples of their use are included.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="semantic-analysis"></a>Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#semantic-analysis" title="Direct link to heading">#</a></h2><p>The overall goal of the semantic analysis pass is to verify that a correct program has been submitted
to the compiler. The compiler does this by &quot;decorating&quot; the AST with semantic information.  This information
is mainly concerned with the &quot;types&quot; of the various things in the program.  A key function of the semantic
analyzer, the primary &quot;weapon&quot; in computing these types, if you will, is name resolution.  The semantic analyzer
decides what any given name means in any context and then uses that meaning, which is itself based on the
AST constructs that came before, to compute types and then check those types for errors.</p><p>Broadly speaking, the errors that can be discovered are of these forms:</p><ul><li>mentioned names do not exist<ul><li>e.g. using a variable or table or column without declaring it</li></ul></li><li>mentioned names are not unique, or are ambiguous<ul><li>e.g. every view must have a unique name</li><li>e.g. table names need to be unique, or aliased when joining tables</li></ul></li><li>operands are not compatible with each other or with the intended operation<ul><li>e.g. you can&#x27;t add a string to a real</li><li>e.g. you can&#x27;t do the <code>%</code> operation on a real</li><li>e.g. the expression in a <code>WHERE</code> clause must result in a numeric</li><li>e.g. the first argument to <code>printf</code> must be a string literal</li><li>e.g. you can&#x27;t assign a long value to an integer variable</li><li>e.g. you can&#x27;t assign a possibly null result to a not-null variable</li></ul></li><li>there are too many or two few operands for an operation<ul><li>e.g. an <code>INSERT</code> statement must include sufficiently many columns and no extras</li><li>e.g. a function or procedure call must have the correct number of operands</li></ul></li><li>an operation is happening in a context where it is not allowed<ul><li>e.g. use of aggregate functions in the <code>WHERE</code> clause</li><li>e.g. use of unique SQLite functions outside of a SQL statement</li></ul></li></ul><p>There are several hundred possible errors, and no attempt will be made to cover them all here but we will
talk about how errors are created, recorded, and reported.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="decorated-ast-examples"></a>Decorated AST examples<a aria-hidden="true" tabindex="-1" class="hash-link" href="#decorated-ast-examples" title="Direct link to heading">#</a></h3><p>Recalling the AST output from <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>, this is what that same tree
looks like with semantic information attached:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">LET X := 1 + 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {let_stmt}: X: integer notnull variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name X}: X: integer notnull variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 3}: integer notnull</span></div></div></div></div></div><p>And here&#x27;s an example with some structure types:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SELECT 1 AS x, 3.2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {select_stmt}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_core_list}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {select_core}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {select_expr_list_con}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_expr_list}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {select_expr}: x: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | | {int 1}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | | {opt_as_alias}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | |   | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {select_expr_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |   | {select_expr}: y: real notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |     | {dbl 3.2}: real notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |     | {opt_as_alias}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |       | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_from_etc}: ok</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {select_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {select_groupby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |           | {select_having}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_orderby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {select_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {select_offset}</span></div></div></div></div></div><p>These can be generated by adding <code>--sem --ast</code> to the CQL command line along with <code>--in your_file.sql</code>.</p><p>Keep these shapes in mind as we discuss the various sources of type information.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-base-data-structures"></a>The Base Data Structures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-base-data-structures" title="Direct link to heading">#</a></h3><p>First recall that every AST node has this field in it:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct sem_node *_Nullable sem;</span></div></div></div></div></div><p>This is the pointer to the semantic information for that node. Semantic analysis happens immediately
after parsing and before any of the code-generators run.  Importantly, code generators never run
if semantic analysis reported any errors.  Before we get into the shape of the semantic node, we
should start with the fundamental unit of type info <code>sem_t</code> which is usually stored in a variable
called <code>sem_type</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef uint64_t sem_t;</span></div></div></div></div></div><p>The low order bits of a <code>sem_t</code> encode the core type and indeed there is a helper function
to extract the core type from a <code>sem_t</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Strips out all the flag bits and gives you the base/core type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport sem_t core_type_of(sem_t sem_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_type &amp; SEM_TYPE_CORE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The core bits are as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_NULL 0         // the subtree is a null literal (not just nullable)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BOOL 1         // the subtree is a bool</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_INTEGER 2      // the subtree is an integer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_LONG_INTEGER 3 // the subtree is a long integer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_REAL 4         // the subtree is a real</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_TEXT 5         // the subtree is a text type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BLOB 6         // the subtree is a blob type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OBJECT 7       // the subtree is any object type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_STRUCT 8       // the subtree is a table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_JOIN 9         // the subtree is a join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_ERROR 10       // marks the subtree as having a problem</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OK 11          // sentinel for ok but no type info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_PENDING 12     // sentinel for type calculation in flight</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_REGION 13      // the ast is a schema region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CORE 0xff      // bit mask for the core types</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) // the last unitary type</span></div></div></div></div></div><p>These break into a few categories:</p><ul><li><code>NULL</code> to <code>OBJECT</code> are the &quot;unitary&quot; types -- these are the types that a single simple variable can be<ul><li>a column can be any of these except <code>OBJECT</code> or <code>NULL</code></li><li>the <code>NULL</code> type comes only from the <code>NULL</code> literal which has no type</li><li>instances of, say, a <code>TEXT</code> column might have a <code>NULL</code> value but they are known to be <code>TEXT</code></li></ul></li><li><code>STRUCT</code> indicates that the object has many fields, like a table, or a cursor</li><li><code>JOIN</code> indicates that the object is the concatenation of many <code>STRUCT</code> types<ul><li>e.g. <code>T1 inner join T2</code> is a <code>JOIN</code> type with <code>T1</code> and <code>T2</code> being the parts</li><li>a <code>JOIN</code> could be flattened to <code>STRUCT</code>, but this is typically not done</li><li>the type of a <code>SELECT</code> statement will be a <code>STRUCT</code> representing the expressions that were selected</li><li>those expressions in turn used columns from the <code>JOIN</code> that was the <code>FROM</code> clause</li></ul></li><li><code>ERROR</code> indicates that the subtree had an error<ul><li>the error will have been already reported</li><li>the error type generally cascades up the AST to the root</li></ul></li><li><code>OK</code> indicates that there is no type information but there was no problem<ul><li>e.g. a correct <code>IF</code> statement will resolve to simply <code>OK</code> (no error)</li></ul></li><li><code>PENDING</code> is used sometimes while a type computation is in progress<ul><li>this type doesn&#x27;t appear in the AST, but has its own unique value so as to not conflict with any others</li></ul></li><li><code>REGION</code> is used to identify AST fragments that correspond to schema regions<ul><li>see <a href="https://cgsql.dev/cql-guide/ch10" target="_blank" rel="noopener noreferrer">Chapter 10</a> of the Guide for more information on regions</li></ul></li><li><code>CORE</code> is the mask for the core parts, <code>0xf</code> would do the job but for easy reading in the debugger we use <code>0xff</code><ul><li>new core types are not added very often, adding a new one is usually a sign that you are doing something wrong</li></ul></li></ul><p>The core type can be modified by various flags.  The flags, in principle, can be combined in any way but in practice many combinations make no sense.
For instance, <code>HAS_DEFAULT</code> is for table columns and <code>CREATE_FUNC</code> is for function declarations. There is no one object that could require both of these.</p><p>The full list as of this writing is as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_NOTNULL               _64(0x0100) // set if and only if null is not possible</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) // set for table columns with a default</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) // set for table columns with autoinc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VARIABLE              _64(0x0800) // set for variables and parameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_IN_PARAMETER          _64(0x1000) // set for in parameters (can mix with below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) // set for out parameters (can mix with above)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DML_PROC              _64(0x4000) // set for stored procs that have DML/DDL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) // set for a cursor with simplified fetch syntax</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CREATE_FUNC          _64(0x10000) // set for a function that returns a created object +1 ref</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_SELECT_FUNC          _64(0x20000) // set for a sqlite UDF function declaration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DELETED              _64(0x40000) // set for columns that are not visible in the current schema version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VALIDATED            _64(0x80000) // set if item has already been validated against previous schema</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_USES_OUT            _64(0x100000) // set if proc has a one rowresult using the OUT statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) // set if proc uses the OUT UNION form for multi row result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_PK                  _64(0x400000) // set if column is a primary key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_FK                  _64(0x800000) // set if column is a foreign key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_UK                 _64(0x1000000) // set if column is a unique key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) // set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_SENSITIVE          _64(0x4000000) // set if the object is privacy sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) // set if the object is a deployable region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BOXED             _64(0x10000000) // set if a cursor&#x27;s lifetime is managed by a box object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_CHECK         _64(0x20000000) // set for table column with a &quot;check&quot; clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) // set for table column with a &quot;collate&quot; clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) // set if inferred to not be nonnull (but was originally nullable)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VIRTUAL          _64(0x100000000) // set if and only if this is a virtual table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) // set if and only if hidden column on a virtual table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_TVF              _64(0x400000000) // set if and only table node is a table valued function</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_IMPLICIT         _64(0x800000000) // set if and only the variable was declare implicitly (via declare out)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) // set if proc calls an out union proc for</span></div></div></div></div></div><p>Note: <code>_64(x)</code> expands to either a trailing <code>L</code> or a trailing <code>LL</code> depending on the bitness of the compiler, whichever yields an <code>int64_t</code>.</p><p>Going over the meaning of all of the above is again beyond the scope of this document; some of the flags are very specialized and essentially the validation
just requires a bit of storage in the tree to do its job so that storage is provided with a flag.  However two flag bits are especially important and
are computed almost everywhere <code>sem_t</code> is used.  These are <code>SEM_TYPE_NOTNULL</code> and <code>SEM_TYPE_SENSITIVE</code>.</p><ul><li><code>SEM_TYPE_NOTNULL</code> indicates that the marked item is known to be <code>NOT NULL</code>, probably because it was declared as such, or directly derived from a not null item<ul><li>Typically when two operands are combined both must be marked <code>NOT NULL</code> for the result to still be <code>NOT NULL</code> (there are exceptions like <code>COALESCE</code>)</li><li>Values that might be null cannot be assigned to targets that must not be null</li></ul></li><li><code>SEM_TYPE_SENSITIVE</code> indicates that the marked item is some kind of PII or other sensitive data.<ul><li>Any time a sensitive operand is combined with another operand the resulting type is sensitive</li><li>There are very few ways to &quot;get rid&quot; of the sensitive bit -- it corresponds to the presence of <code>@sensitive</code> in the data type declaration</li><li>Values that are sensitive cannot be assigned to targets that are not marked sensitive</li></ul></li></ul><p>The semantic node <code>sem_node</code> carries all the possible semantic info we might need, and the <code>sem_type</code> holds the flags above and tells us how to interpret the rest of the node.
There are many fields -- we&#x27;ll talk about some of the most important ones here to give you a sense of how things hang together.</p><p>Note that <code>CSTR</code> is simply an alias for <code>const char *</code>.  <code>CSTR</code> is used extensively in the codebase for brevity.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type;                   // core type plus flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR name;                        // for named expressions in select columns, etc.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kind;                        // the Foo in object&lt;Foo&gt;, not a variable or column name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR error;                       // error text for test output, not used otherwise</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct *sptr;          // encoded struct if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_join *jptr;            // encoded join if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t create_version;           // create version if any (really only for tables and columns)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t delete_version;           // delete version if any (really only for tables and columns)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t recreate;                  // for tables only, true if marked @recreate</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR recreate_group_name;         // for tables only, the name of the recreate group if they are in one</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR region;                      // the schema region, if applicable; null means unscoped (default)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *used_symbols;             // for select statements, we need to know which of the ids in the select list was used, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  list_item *index_list;            // for tables we need the list of indices that use this table (so we can recreate them together if needed)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct eval_node *value;          // for enum values we have to store the evaluated constant value of each member of the enum</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_node;</span></div></div></div></div></div><ul><li><code>sem_type</code> : already discussed above, this tells you how to interpret everything else</li><li><code>name</code> : variables, columns, etc. have a canonical name -- when a name case-insensitivity resolves, the canonical name is stored here<ul><li>typically later passes emit the canonical variable name everywhere</li><li>e.g. because <code>FoO</code> and <code>fOO</code> might both resolve to an object declared as <code>foo</code>, we always emit <code>foo</code> in codegen</li></ul></li><li><code>kind</code> : in CQL any type can be discriminated as in <code>declare foo real&lt;meters&gt;</code>, the kind here is <code>meters</code><ul><li>two expressions of the same core type (e.g. <code>real</code>) are incompatible if they have a <code>kind</code> and the <code>kind</code> does not match</li><li>e.g. if you have <code>bar real&lt;liters&gt;</code> then <code>set foo := bar;</code> this is an error even though both are <code>real</code> because <code>foo</code> above is <code>real&lt;meters&gt;</code></li></ul></li><li><code>sptr</code> : if the item&#x27;s core type is <code>SEM_TYPE_STRUCT</code> then this is populated (see below)</li><li><code>jptr</code> : if the item&#x27;s core type is <code>SEM_TYPE_JOIN</code> then this is populated (see below)</li></ul><p>If the object is a structure type then this is simply an array of names, kinds, and semantic types.  In fact the semantic types will be all be unitary, possibly modified by <code>NOT_NULL</code> or <code>SENSITIVE</code> but none of the other flags apply.  A single <code>sptr</code> directly corresponds to the notion of a &quot;shape&quot; in the analyzer.  Shapes come from anything
that looks like a table, such as a cursor, or the result of a <code>SELECT</code> statement.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for tables and views and the result of a select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_struct {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR struct_name;               // struct name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // field names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *kinds;                    // the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *semtypes;                // typecode for each field</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_struct;</span></div></div></div></div></div><p>If the object is a join type (such as the parts of the <code>FROM</code> clause) then the <code>jptr</code> field will be populated. This is nothing more than a named list of struct types.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for the data type of (parts of) the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// sometimes I refer to as a &quot;joinscope&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_join {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of table/views in the join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // names of the table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct **tables;     // struct type of each table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_join;</span></div></div></div></div></div><p>With these building blocks we can represent the type of anything in the CQL language.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initiating-semantic-analysis"></a>Initiating Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initiating-semantic-analysis" title="Direct link to heading">#</a></h3><p>The semantic analysis pass runs much the same way as the AST emitter.  In <code>sem.c</code> there is the essential function <code>sem_main</code>. It suffices
to call <code>sem_main</code> on the root of the AST. That root node is expected to be a <code>stmt_list</code> node.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This method loads up the global symbol tables in either empty state or</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the appropriate tokens ready to go.  Using our own symbol tables for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// dispatch saves us a lot of if/else string comparison verbosity.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void sem_main(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // restore all globals and statics we own</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_cleanup();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  eval_init();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>As you can see, <code>sem_main</code> begins by resetting all the global state.  You can of course do this yourself after calling <code>sem_main</code> (when you&#x27;re done with the results).</p><p><code>sem_main</code> sets a variety of useful and public global variables that describe the results of the analysis.  The ones in <code>sem.h</code> are part of the contract and
you should feel free to use them in a downstream code-generator.  Other items are internal and should be avoided.
The internal items are typically defined statically in <code>sem.c</code>. The essential outputs will be described in the last section of this part.</p><p>The cleanup has this structure:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This method frees all the global state of the semantic analyzer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void sem_cleanup() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  eval_cleanup();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(deployable_validations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(recreate_annotations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(schema_annotations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(funcs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(globals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(indices);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_ad_hoc_list = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_functions_list = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div></div></div></div></div><p>This basically deallocates everything and resets all the globals to <code>NULL</code>.</p><p><code>sem_main</code> of course has to walk the AST and it does so in much the same way as we saw in <code>gen_sql.c</code>. There is a series of symbol tables
whose key is an AST type and whose value is a function plus arguments to dispatch (effectively a lambda.)  The semantic analyzer doesn&#x27;t
have to think about things like &quot;should I emit parentheses?&quot; so the signature of each type of lambda can be quite a bit simpler.  We&#x27;ll
go over each kind with some examples.</p><p>First we have the non-SQL statements, these are basic flow control or other things that SQLite will never see directly.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *syms = non_sql_stmts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(leave_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><p>Here <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>if_stmt</code> and the function <code>sem_if_stmt</code>.  This lets us dispatch any part of the AST
to its handler directly.</p><p>Next we have the SQL statements.  These get analyzed in the same way as the others, and with functions that have the same signature, however,
if you use one of these it means that procedure that contained this statement must get a database connection in order to run.  Use of the database
will require the procedure&#x27;s signature to change; this is recorded by the setting the <code>SEM_TYPE_DML_PROC</code> flag bit to be set on the procedure&#x27;s AST node.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  syms = sql_stmts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_index_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(delete_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(update_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(insert_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><p>Again <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>delete_stmt</code> and the function <code>sem_delete_stmt</code> so we can dispatch to the handler.</p><p>Next we have expression types. These are set up with <code>EXPR_INIT</code>.  Many of the operators require exactly the same kinds of verification, so in order to be
able to share the code, the expression analysis functions get an extra argument for the operator in question.  Typically the string of the operator
is only needed to make a good quality error message with validation being otherwise identical.  Here are some samples...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, sem_expr_num, &quot;NUM&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, sem_expr_str, &quot;STR&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(blob, sem_expr_blob, &quot;BLB&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, sem_expr_null, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, sem_expr_dot, &quot;DOT&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(const, sem_expr_const, &quot;CONST&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, sem_binary_math, &quot;*&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, sem_binary_integer_math, &quot;%&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, sem_unary_logical, &quot;NOT&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(is_true, sem_unary_is_true_or_false, &quot;IS TRUE&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, sem_unary_integer_math, &quot;~&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, sem_unary_math, &quot;-&quot;);</span></div></div></div></div></div><p>Looking at the very first entry as an example, we see that <code>EXPR_INIT</code> creates a mapping between the AST type <code>num</code>
and the analysis function <code>sem_expr_num</code> and that function will get the text <code>&quot;NUM&quot;</code> as an extra argument.
As it happens <code>sem_expr_num</code> doesn&#x27;t need the extra argument, but <code>sem_binary_math</code> certainly needs the <code>&quot;*&quot;</code>
as that function handles a large number of binary operators.</p><p>Let&#x27;s quickly go over this list as these are the most important analyzers:</p><ul><li><code>sem_expr_num</code> : analyzes any numeric constant</li><li><code>sem_expr_str</code> : analyzes any string literal or identifier</li><li><code>sem_expr_blob</code> : analyzes any blob literal</li><li><code>sem_expr_null</code> : analyzes the NULL literal (and nothing else)</li><li><code>sem_expr_dot</code> : analyzes a compound name like <code>T1.id</code></li><li><code>sem_expr_const</code> : analyzes a <code>const(...)</code> expression, doing the constant evaluation</li><li><code>sem_binary_math</code> : analyzes any normal binary math operator like &#x27;+&#x27;, &#x27;-&#x27;, &#x27;/&#x27; etc.</li><li><code>sem_binary_integer_math</code> : analyzes any binary math operator where the operands must be integers like &#x27;%&#x27; or &#x27;|&#x27;</li><li><code>sem_unary_logical</code> : analyzes any unary logical operator (the result is a bool) -- this is really only <code>NOT</code></li><li><code>sem_unary_is_true_or_false</code> : analyzes any of the <code>IS TRUE</code>, <code>IS FALSE</code> family of postfix unary operators</li><li><code>sem_unary_integer_math</code> : analyzes any unary operator where the operand must be an integer -- this is really only <code>~</code></li><li><code>sem_unary_math</code> : analyzes any any math unary operator, presently only negation (but in the future unary <code>+</code> too)</li></ul><p>The last group of normal associations are for builtin functions, like these:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(changes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(strftime);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(date);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(time);</span></div></div></div></div></div><p>Each of these is dispatched when a function call is found in the tree.  By way of example <code>FUNC_INIT(changes)</code>
causes the <code>changes</code> function to map to <code>sem_func_changes</code> for validation.</p><p>There are a few other similar macros for more exotic cases but the general pattern should be clear now.  With these in place
it&#x27;s very easy to traverse arbitrary statement lists and arbitrary expressions with sub expressions and have the correct function
invoked without having large <code>switch</code> blocks all over.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="semantic-errors"></a>Semantic Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#semantic-errors" title="Direct link to heading">#</a></h3><p>Some of the following examples will show the handling of semantic errors more precisely but the theory is pretty simple.  Each of the analyzers that has
been registered is responsible for putting an appropriate <code>sem_node</code> into the AST it is invoked on.  The caller will look to see if that <code>sem_node</code>
is of type <code>SEM_TYPE_ERROR</code> using <code>is_error(ast)</code>.  If it is, the caller will mark its own AST as errant using <code>record_error(ast)</code> and this continues all
the way up the tree.  The net of this is that wherever you begin semantic analysis, you can know if there were any problems by checking for an error at the
top of the tree you provided.</p><p>At the point of the initial error, the analyzer is expected to also call <code>report_error</code> providing a suitable message.  This will be logged to <code>stderr</code>.
In test mode it is also stored in the AST so that verification steps can confirm that errors were reported at exactly the right place.</p><p>If there are no errors, then a suitable <code>sem_node</code> is created for the resulting type or else, at minimum, <code>record_ok(ast)</code> is used to place the shared &quot;OK&quot; type on the node.
The &quot;OK&quot; type indicates no type information, but no errors either.  &quot;OK&quot; is helpful for statements that don&#x27;t involve expressions like <code>DROP TABLE Foo</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-primitive-types"></a>The Primitive Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-primitive-types" title="Direct link to heading">#</a></h3><p>Perhaps the simplest analysis of all happens at the leaves of the AST.  By way of example, here is the code for expression nodes of type <code>num</code>, the numeric literals.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expression type for numeric primitives</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_expr_num(ast_node *ast, CSTR cstr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_num(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NUM_TYPE(num_type, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (num_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_BOOL:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_INT:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_LONG:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  default:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // this is all that&#x27;s left</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(num_type == NUM_REAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_REAL | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>As you can see the code simply looks at the AST node, confirming first that it is a <code>num</code> node.  Then it extracts the <code>num_type</code>.
Then <code>ast-&gt;sem</code> is set to a semantic node of the matching type adding in <code>SEM_TYPE_NOTNULL</code> because literals are never null.</p><p>The <code>new_sem</code> function is used to make an empty <code>sem_node</code> with the <code>sem_type</code> filled in as specified.  Nothing can go wrong creating a literal so there are no failure modes.</p><p>It doesn&#x27;t get much simpler unless maybe...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expression type for constant NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_expr_null(ast_node *ast, CSTR cstr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It&#x27;s hard to get simpler than doing semantic analysis of the <code>NULL</code> literal.  Its code should be clear with no further explanation needed.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="unary-operators"></a>Unary Operators<a aria-hidden="true" tabindex="-1" class="hash-link" href="#unary-operators" title="Direct link to heading">#</a></h3><p>Let&#x27;s dive in to a simple case that does require some analysis -- the unary operators.  There are comparatively few and there isn&#x27;t much code required to handle them all.</p><p>Here&#x27;s the code for the unary math operators:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The only unary math operators are &#x27;-&#x27; and &#x27;~&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Reference types are not allowed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_unary_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_unary_prep(ast, &amp;core_type, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_validate_numeric(ast, core_type, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The result of unary math promotes to integer.  Basically this converts</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // bool to integer.  Long integer and Real stay as they are.  Text is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // already ruled out.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_result = sem_combine_types(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (core_type | combined_flags));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(sem_type_result);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;kind = ast-&gt;left-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // note ast-&gt;sem-&gt;name is NOT propagated because SQLite doesn&#x27;t let you refer to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the column &#x27;x&#x27; in &#x27;select -x&#x27; -- the column name is actually &#x27;-x&#x27; which is useless</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so we have no name once you apply unary math (unless you use &#x27;as&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // hence ast-&gt;sem-&gt;name = ast-&gt;left-&gt;sem-&gt;name is WRONG here and it is not missing on accident</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><em>Unary Prep</em></p><p>OK already we need to pause because there is a &quot;prep&quot; pattern here common to most of the shared operators that we should discuss.
The prep step takes care of most of the normal error handling which is the same for all the unary operators
and the same pattern happens in binary operators.  Let&#x27;s take a look at <code>sem_unary_prep</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The unary operators all have a similar prep to the binary.  We need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to visit the left side (it&#x27;s always the left node even if the operator goes on the right)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if that&#x27;s ok then we need the combined_flags and core type.  There is only</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the one.  Returns true if everything is ok.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_unary_prep(ast_node *ast, sem_t *core_type, sem_t *combined_flags) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // op left | left op</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(ast-&gt;left)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *combined_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_node *sem = ast-&gt;left-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type = core_type_of(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *combined_flags = not_nullable_flag(sem_type) | sensitive_flag(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Reviewing the steps:</p><ul><li>first we analyze the operand, it will be in <code>ast-&gt;left</code></li><li>if that&#x27;s an error, we just return the error code from the prep steps</li><li>now that it&#x27;s not an error, we pull the core type out of the operand</li><li>then we pull the not nullable and sensitive flag bits out of the operand</li><li>finally return a boolean indicating the presence of an error (or not) for convenience</li></ul><p>This is useful setup for all the unary operators, and as we&#x27;ll see, the binary operators have a similar prep step.</p><p><em>Back to Unary Processing</em></p><p>Looking at the overall steps we see:</p><ul><li><code>sem_unary_prep</code> : verifies that the operand is not an error, and gets its core type and flag bits</li><li><code>sem_validate_numeric</code> : verifies that the operand is a numeric type<ul><li>recall these are the math unary operators, so the operand must be numeric</li></ul></li><li><code>sem_combine_types</code> : creates the smallest type that holds two compatible types<ul><li>by combining with &quot;integer not null&quot; we ensure that the resulting type is at least as big as an integer</li><li>if the argument is of type <code>long</code> or <code>real</code> then it will be the bigger type and the resulting type will be <code>long</code> or <code>real</code> as appropriate</li><li>in short, <code>bool</code> is promoted to <code>int</code>, everything else stays the same</li><li><code>sem_combine_types</code> also combines the nullability and sensitivity appropriately</li></ul></li><li>a new <code>sem_node</code> of the combined type is created<ul><li>the type &quot;kind&quot; of the operand is preserved (e.g. the <code>meters</code> in <code>real&lt;meters&gt;</code>)</li><li>any column alias or variable name is not preserved, the value is now anonymous</li></ul></li></ul><p>These primitives are designed to combine well, for instance, consider <code>sem_unary_integer_math</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_unary_integer_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_unary_math(ast, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_reject_real(ast, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The steps are:</p><ul><li><code>sem_unary_math</code> : do the sequence we just discussed</li><li><code>sem_reject_real</code> : report/record an error if the result type is <code>real</code> otherwise do nothing</li></ul><p>Note that in all cases the <code>op</code> string simply gets pushed down to the place where the errors happen.  Let&#x27;s take a quick look at one of
the sources of errors in the above.  Here&#x27;s the numeric validator:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_validate_numeric(ast_node *ast, sem_t core_type, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_blob(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0045: blob operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0046: object operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_text(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0047: string operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>That function is pretty much dumb as rocks.  The non-numeric types are blob, object, and text.  There is a custom error for each type (it could have been shared
but specific error messages seem to help users.)  This code doesn&#x27;t know its context, but all it needs is <code>op</code> to tell it what the numeric-only
operator was and it can produce a nice error message.  It leaves an error in the AST using <code>record_error</code>. Its caller can then simply <code>return</code>
if anything goes wrong.</p><p>It&#x27;s not hard to guess how <code>sem_reject_real</code> works:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Some math operators like &lt;&lt; &gt;&gt; &amp; | % only make sense on integers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function does the extra checking to ensure they do not get real values</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// as arguments.  It&#x27;s a post-pass after the normal math checks.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_reject_real(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!is_error(ast)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_t core_type = core_type_of(ast-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (core_type == SEM_TYPE_REAL) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      report_error(ast, &quot;CQL0001: operands must be an integer type, not real&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>if the AST node isn&#x27;t already an error, and the node is of type &quot;real&quot;, report an error</li><li>it assumes the type is already known to be numeric</li><li>the pre-check for errors is to avoid double reporting; if something has already gone wrong, the core type will be <code>SEM_TYPE_ERROR</code><ul><li>no new error recording is needed in that case, as obviously an error was already recorded</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="binary-operators"></a>Binary Operators<a aria-hidden="true" tabindex="-1" class="hash-link" href="#binary-operators" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="binary-prep"></a>Binary Prep<a aria-hidden="true" tabindex="-1" class="hash-link" href="#binary-prep" title="Direct link to heading">#</a></h4><p>With the knowledge we have so far, this code pretty much speaks for itself, but we&#x27;ll walk through it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// All the binary ops do the same preparation -- they evaluate the left and the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// right expression, then they check those for errors.  Then they need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the types of those expressions and the combined_flags of the result.  This</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// does exactly that for its various callers.  Returns true if all is well.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_binary_prep(ast_node *ast, sem_t *core_type_left, sem_t *core_type_right, sem_t *combined_flags) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(left, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(right, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // left op right</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(left) || is_error(right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type_left = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type_right = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *combined_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type_left = core_type_of(left-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type_right = core_type_of(right-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *combined_flags = combine_flags(left-&gt;sem-&gt;sem_type, right-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type_left));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type_right));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_expr</code> : used to recursively walk the left and right nodes</li><li><code>is_error</code> : checks if either side had errors, and, if so, simply propagates the error</li><li>extract the left and right core types</li><li>combine nullability and sensitivity flags</li></ul><p>And that&#x27;s it!  These are the standard prep steps for all binary operators. With this done,
the caller has the core types of the left and right operands plus combined flags on a silver platter
and one check is needed to detect if anything went wrong.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-is-or-is-not"></a>Example: Is or Is Not<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-is-or-is-not" title="Direct link to heading">#</a></h4><p>This analyzer is the simplest of all the binaries</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// IS and IS NOT are special in that they return a not null boolean.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_binary_is_or_is_not(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type_left, core_type_right, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_binary_prep(ast, &amp;core_type_left, &amp;core_type_right, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the result of is or is not is always a bool and never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | sensitive_flag(combined_flags));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_binary_prep</code> : checks for errors in the left or right</li><li><code>sem_verify_compat</code> : ensures that left and right operands are type compatible (discussed later)</li><li>the result is always of type <code>bool not null</code></li></ul><p>If either step goes wrong the error will naturally propagate.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-binary-math"></a>Example: Binary Math<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-binary-math" title="Direct link to heading">#</a></h4><p>This is the general worker for binary math operations, the most common operations like &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27; and so forth.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// For all math operations, we combine the types and yield the type that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// holds both using the helper.  If any text, that&#x27;s an error.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_binary_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type_left, core_type_right, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_binary_prep(ast, &amp;core_type_left, &amp;core_type_right, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_object(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_blob_types(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_text_types(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type = sem_combine_types(core_type_left, core_type_right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kind = sem_combine_kinds(ast-&gt;right, ast-&gt;left-&gt;sem-&gt;kind);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(ast-&gt;right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(core_type | combined_flags);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;kind = kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s have a look at those steps:</p><ul><li><code>sem_binary_prep</code> : checks for errors on the left or right</li><li><code>error_any_object</code> : reports an error if the left or right is of type object</li><li><code>error_any_blob_types</code> : reports an error if the left or right is of type blob</li><li><code>error_any_text_types</code> : reports an error if the left or right is of type text</li><li><code>sem_combine_type</code> : computes the combined type, the smallest numeric type that holds both left and right<ul><li>note the operands are now known to be numeric</li><li>the three type error checkers give nice tight errors about the left or right operand</li></ul></li><li><code>sem_combine_kinds</code> : tries to create a single type <code>kind</code> for both operands<ul><li>if their <code>kind</code> is incompatible, records an error on the right</li></ul></li><li><code>new_sem</code> : creates a <code>sem_node</code> with the combined type, flags, and then the <code>kind</code> is set</li></ul><p>At this point it might help to look at a few more of the base validators -- they are rather unremarkable.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator-error_any_object"></a>Example Validator: error_any_object<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator-error_any_object" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If either of the types is an object, then produce an error on the ast.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t error_any_object(ast_node *ast, sem_t core_type_left, sem_t core_type_right, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type_left)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0002: left operand cannot be an object in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type_right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;right, &quot;CQL0003: right operand cannot be an object in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>is_object</code> : checks a <code>sem_type</code> against <code>SEM_TYPE_OBJECT</code><ul><li>if the left or right child is an object, an appropriate error is generated</li></ul></li><li>there is no strong convention for returning <code>true</code> if ok, or <code>true</code> if error; it&#x27;s pretty ad hoc<ul><li>this doesn&#x27;t seem to cause a lot of problems</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator-sem_combine_kinds"></a>Example Validator: sem_combine_kinds<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator-sem_combine_kinds" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we check that type&lt;Foo&gt; only combines with type&lt;Foo&gt; or type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is a current object type, then the next item must match</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is no such type, then an object type that arrives becomes the required type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if they ever don&#x27;t match, record an error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CSTR sem_combine_kinds_general(ast_node *ast, CSTR kleft, CSTR kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (kleft) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (strcmp(kleft, kright)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        CSTR errmsg = dup_printf(&quot;CQL0070: expressions of different kinds can&#x27;t be mixed: &#x27;%s&#x27; vs. &#x27;%s&#x27;&quot;, kright, kleft);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        report_error(ast, errmsg, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return kright;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return kleft;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// helper to crack the ast nodes first and then call the normal comparisons</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CSTR sem_combine_kinds(ast_node *ast, CSTR kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kleft = ast-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_combine_kinds_general(ast, kleft, kright);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_combine_kinds</code> : uses the worker <code>sem_combine_kinds_general</code> after extracting the <code>kind</code> from the left node<ul><li>usually you already have one <code>kind</code> and you want to know if another <code>kind</code> is compatible, hence this helper</li></ul></li><li><code>sem_combine_kinds_general</code> : applies the general rules for &quot;kind&quot; strings:<ul><li>NULL + NULL =&gt; NULL</li><li>NULL + x  =&gt; x</li><li>x + NULL =&gt; x</li><li>x + x =&gt; x</li><li>x + y =&gt; error (if x != y)</li></ul></li><li>this is one of the rare functions that creates a dynamic error message</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--is_numeric_compat"></a>Example Validator : is_numeric_compat<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--is_numeric_compat" title="Direct link to heading">#</a></h4><p>This helper is frequently called several times in the course of other semantic checks.
This one produces no errors, that&#x27;s up to the caller. Often there is a numeric path
and a non-numeric path so this helper can&#x27;t create the errors as it doesn&#x27;t yet know
if anything bad has happened.  Most of the <code>is_something</code> functions are the same way.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport bool_t is_numeric_compat(sem_t sem_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_type = core_type_of(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_type &gt;= SEM_TYPE_NULL &amp;&amp; sem_type &lt;= SEM_TYPE_REAL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>is_numeric_compat</code> operates by checking the core type for the numeric range.
Note that <code>NULL</code> is compatible with numerics because expressions like <code>NULL + 2</code>
have meaning in SQL.  The type of that expression is nullable integer and
the result is <code>NULL</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--sem_combine_types"></a>Example Validator : sem_combine_types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--sem_combine_types" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The second workhorse of semantic analysis, given two types that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// are previously known to be compatible, it returns the smallest type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// that holds both.  If either is nullable, the result is nullable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note: in the few cases where that isn&#x27;t true, the normal algorithm for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// nullability result must be overridden (see coalesce, for instance).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static sem_t sem_combine_types(sem_t sem_type_1, sem_t sem_type_2) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... too much code ... summary below</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This beast is rather lengthy but unremarkable. It follows these rules:</p><ul><li>text is only compatible with text</li><li>object is only compatible with object</li><li>blob is only compatible with blob</li><li>numerics are only compatible with other numerics and NULL<ul><li>NULL promotes the other operand, whatever it is (might still be NULL)</li><li>bool promotes to integer if needed</li><li>integer promotes to long integer if needed</li><li>long integer promotes to real if needed</li><li>the combined type is the smallest numeric type that holds left and right according to the above rules</li></ul></li></ul><p>Some examples might be helpful:</p><ul><li>1 + 2L  -&gt;  long</li><li>false + 3.1 -&gt; real</li><li>2L + 3.1 -&gt; real</li><li>true + 2 -&gt; integer</li><li>&#x27;x&#x27; + 1 -&gt; not compatible</li></ul><p>Note that <code>sem_combine_types</code> assumes the types have already been checked for compatibility and will use <code>Contract</code> to enforce
this.  You should be using other helpers like <code>is_numeric_compat</code> and friends to ensure the types agree before computing
the combined type.  A list of values that must be compatible with each other (e.g. in <code>needle IN (haystack)</code>) can be
checked using <code>sem_verify_compat</code> repeatedly.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--sem_verify_assignment"></a>Example Validator : sem_verify_assignment<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--sem_verify_assignment" title="Direct link to heading">#</a></h4><p>The <code>sem_verify_assignment</code> function is used any time there is something like a logical <code>assignment</code> going on.  There are
two important cases:</p><ul><li><code>SET x := y</code> : an actual assignment</li><li><code>call foo(x)</code> : the expression <code>x</code> must be &quot;assignable&quot; to the formal variable for the argument of <code>foo</code></li></ul><p>This is a lot like normal binary operator compatibility with one extra rule: the source expression must
not be a bigger type than the target.  e.g. you cannot assign a <code>long</code> to an <code>integer</code>, nor pass a long
expression to a function that has an integer parameter.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This verifies that the types are compatible and that it&#x27;s ok to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the expression to the variable.  In practice that means:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable type core type and kind must be compatible with the expression core type and kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable must be nullable if the expression is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable must be sensitive if the assignment is sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable type must be bigger than the expression type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here ast is used only to give a place to put any errors.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_verify_assignment(ast_node *ast, sem_t sem_type_needed, sem_t sem_type_found, CSTR var_name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_compat(ast, sem_type_needed, sem_type_found, var_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_safeassign(ast, sem_type_needed, sem_type_found, var_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type_found) &amp;&amp; is_not_nullable(sem_type_needed)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0013: cannot assign/copy possibly null expression to not null target&quot;, var_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (sensitive_flag(sem_type_found) &amp;&amp; !sensitive_flag(sem_type_needed)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0014: cannot assign/copy sensitive expression to non-sensitive target&quot;, var_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_verify_compat</code> : checks for standard type compatibility between the left and the right</li><li><code>sem_verify_safeassign</code> : checks that if the types are different the right operand is the smaller of the two</li><li>nullability checks ensure you aren&#x27;t trying to assign a nullable value to a not null variable</li><li>sensitivity checks ensure you aren&#x27;t trying to assign a sensitive value to a not sensitive variable</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="simple-statement-validation"></a>Simple Statement Validation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#simple-statement-validation" title="Direct link to heading">#</a></h3><p>With the expression building blocks, most of the usual kind of language statements become quite simple to check
for correctness.  It&#x27;s probably easiest to illustrate this with an example. Let&#x27;s look at validation for
the <code>WHILE</code> statement:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// While semantic analysis is super simple.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the condition must be numeric</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the statement list must be error-free</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * loop_depth is increased allowing the use of interior leave/continue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_numeric_expr(expr, ast, &quot;WHILE&quot;, SEM_EXPR_CONTEXT_NONE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (stmt_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loop_depth++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loop_depth--;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_error(stmt_list)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>EXTRACT*</code> : pulls out the tree parts we need</li><li><code>sem_numeric_expr</code> : verifies the loop expression is numeric</li><li><code>sem_stmt_list</code> : recursively validates the body of the loop</li></ul><p>Note: the while expression is one of the loop constructs which means that <code>LEAVE</code> and <code>CONTINUE</code> are legal inside it.
The <code>loop_depth</code> global tracks the fact that we are in a loop so that analysis for <code>LEAVE</code> and <code>CONTINUE</code> can report errors if we are not.</p><p>It&#x27;s not hard to imagine that <code>sem_stmt_list</code> will basically walk the AST, pulling out statements and dispatching them using the <code>STMT_INIT</code> tables previously discussed.
You might land right back in <code>sem_while_stmt</code> for a nested <code>WHILE</code> -- it&#x27;s turtles all the way down.</p><p>If <code>SEM_EXPR_CONTEXT_NONE</code> is a mystery, don&#x27;t worry, it&#x27;s covered in the next section.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-contexts"></a>Expression Contexts<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-contexts" title="Direct link to heading">#</a></h3><p>It turns out that in the SQL language some expression types are only valid in some parts of a SQL statement (e.g. aggregate functions can&#x27;t appear in a <code>LIMIT</code> clause) and so there is always a context for any numeric expression.  When a new root expression is being evaluated, it sets the expression context per the caller&#x27;s specification.</p><p>The expression contexts are as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_NONE           0x0001</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WHERE          0x0004</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_ON             0x0008</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_HAVING         0x0010</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_LIMIT          0x0080</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_OFFSET         0x0100</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_TABLE_FUNC     0x0200</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WINDOW         0x0400</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000</span></div></div></div></div></div><p>The idea here is simple: when calling a root expression, the analyzer provides the context value that has the bit that corresponds to the current context.
For instance, the expression being validated in is the <code>WHERE</code> clause -- the code will provide <code>SEM_EXPR_CONTEXT_WHERE</code>.
The inner validators check this context, in particular anything that is only available in some contexts has a bit-mask of that is the union
of the context bits where it can be used.  The validator can check those possibilities against the current context with one bitwise &quot;and&quot; operation.
A zero result indicates that the operation is not valid in the current context.</p><p>This bitwise &quot;and&quot; is performed by one of these two helper macros which makes the usage a little clearer:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context &amp; (x)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context &amp; (x)))</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-context-example--concat"></a>Expression Context Example : Concat<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-context-example--concat" title="Direct link to heading">#</a></h4><p>The concatenation operator <code>||</code> is challenging to successfully emulate because it does many different kinds of
numeric to string conversions automatically.  Rather than perennially getting this wrong, we simply do not support
this operator in a context where SQLite isn&#x27;t going to be doing the concatenation.  So typically users
use &quot;printf&quot; instead to get formatting done outside of a SQL context.  The check for invalid use of <code>||</code> is very simple
and it happens, of course, in <code>sem_concat</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0241: CONCAT may only appear in the context of a SQL statement&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-context-example--in"></a>Expression Context Example : IN<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-context-example--in" title="Direct link to heading">#</a></h4><p>A slightly more complex example happens processing the <code>IN</code> operator.  This operator has two forms:
the form with an expression list, which can be used anywhere, and the form with a <code>SELECT</code> statement.
The latter form can only appear in some sections of SQL, and not at all in loose expressions.  For
instance, that form may not appear in the <code>LIMIT</code> or <code>OFFSET</code> sections of a SQLite statement.</p><p>We use this construct to do the validation:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    uint32_t valid = SEM_EXPR_CONTEXT_SELECT_LIST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_WHERE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_ON</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_HAVING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_TABLE_FUNC;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (CURRENT_EXPR_CONTEXT_IS_NOT(valid)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      report_error( ast, &quot;CQL0078: [not] in (select ...) is only allowed inside &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         &quot;of select lists, where, on, and having clauses&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>If the reader is interested in a simple learning exercise, run down the purpose of <code>SEM_EXPR_CONTEXT_TABLE_FUNC</code> -- it&#x27;s simple,
but important, and it only has one use case so it&#x27;s easy to find.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="name-resolution"></a>Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#name-resolution" title="Direct link to heading">#</a></h3><p>We&#x27;ve gotten pretty far without talking about the elephant in the room: name resolution.</p><p>Like SQL, many statements in CQL have names in positions where the type of the name is completely unambiguous.  For instance
nobody could be confused what sort of symbol <code>Foo</code> is in <code>DROP INDEX Foo</code>.</p><p>This type, with a clear name category, is the easiest name resolutions, and there are a lot in this form.  Let&#x27;s do an example.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-index-name-resolution"></a>Example: Index Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-index-name-resolution" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the basic checking for the drop index statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the index must exist (have been declared) in some version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * it could be deleted now, that&#x27;s ok, but the name has to be valid</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_drop_index_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_drop_index_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *index_ast = find_usable_index(name, name_ast,  &quot;CQL0112: index in drop statement was not declared&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!index_ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Well, this is interesting.  But what&#x27;s going on with <code>find_usable_index</code>? What is usable?  Why aren&#x27;t we just looking up the index
name in some name table? Let&#x27;s have a look at the details of <code>find_usable_index</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// returns the node only if it exists and is not restricted by the schema region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static ast_node *find_usable_index(CSTR name, ast_node *err_target, CSTR msg) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *index_ast = find_index(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!index_ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(err_target, msg, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_validate_object_ast_in_current_region(name, index_ast, err_target, msg)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return index_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We haven&#x27;t discussed schema regions yet but what you need to know about them for now is this:</p><ul><li>any object can be in a region.</li><li>a region may depend on other regions</li></ul><p>If an object is in a region, then it may only use schema parts that are in
the same region, or the region&#x27;s dependencies (transitively).</p><p>The point of this is that you might have a rather large schema and you probably don&#x27;t want any piece
of code to use just any piece of schema.  You can use regions to ensure that the code for feature &quot;X&quot; doesn&#x27;t
try to use schema designed exclusively for feature &quot;Y&quot;.  That &quot;X&quot; code probably has no business even
knowing of the existence of &quot;Y&quot; schema.</p><p>So now <code>usable</code> simply means this:</p><ul><li><code>find_index</code> can find the name in the symbol table for indices</li><li>the found index is accessible in the current region</li></ul><p>If we had used an example that was looking up a table name, the same region considerations would apply,
however, additionally tables can be deprecated with <code>@delete</code> so there would be additional checks to make
sure we&#x27;re talking about a live table and not a table&#x27;s tombstone.</p><p>In short, these simple cases just require looking up the entity and verifying that it&#x27;s accessible in the current context.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flexible-name-resolution"></a>Flexible Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flexible-name-resolution" title="Direct link to heading">#</a></h4><p>The &quot;hard case&quot; for name resolution is where the name is occurring in an expression.  Such a name can refer to
all manner of things. It could be a global variable, a local variable, an argument, a table column, a field in a cursor,
and others.  The general name resolver goes through several phases looking for the name.  Each phase can either report
an affirmative success or error (in which case the search stops), or it may simply report that the name was not found
but the search should continue.</p><p>We can demystify this a bit by looking at the most common way to get name resolution done.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Resolves a (potentially qualified) identifier, writing semantic information</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// into `ast` if successful, or reporting and recording an error for `ast` if</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// not.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_resolve_id(ast_node *ast, CSTR name, CSTR scope) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_id(ast) || is_ast_dot(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We have no use for `type` and simply throw it away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *type = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_resolve_id_with_type(ast, name, scope, &amp;type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The name resolver works on either a vanilla name (e.g. <code>x</code>) or a scoped name (e.g. <code>T1.x</code>).  The name and scope are provided.
The <code>ast</code> parameter is used only as a place to report errors; there is no further cracking of the AST needed to resolve
the name.  As you can see <code>sem_resolve_id</code> just calls the more general function <code>sem_resolve_id_with_type</code> and is used
in the most common case where you don&#x27;t need to be able to mutate the semantic type info for the identifier.  That&#x27;s the 99% case.</p><p>So let&#x27;s move on to the &quot;real&quot; resolver.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function is responsible for resolving both unqualified identifiers (ids)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and qualified identifiers (dots). It performs the following two roles:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// - If an optional `ast` is provided, it works the same way most semantic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   analysis functions work: semantic information will be written into the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   ast, errors will be reported to the user, and errors will be recorded in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   the AST.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// - `*type_ptr` will be set to mutable type (`sem_t *`) in the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   environment if the identifier successfully resolves to a type. (There are,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   unfortunately, a few exceptions in which a type will be successfully</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   resolved and yet `*type_ptr` will not be set. These include when a cursor is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   in an expression position, when the expression is `rowid` (or similar), and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   when the id resolves to an enum case. The reason no mutable type is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   returned in these cases is that a new type is allocated as part of semantic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   analysis, and there exists no single, stable type in the environment to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   which a pointer could be returned. This is a limitation of this function,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   albeit one that&#x27;s currently not problematic.)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  Resolution is attempted in the order that the `sem_try_resolve_*` functions</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  appear in the `resolver` array. Each takes the same arguments: An (optional)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  identifier provided to one of these resolvers is resolved successfully, *or*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  if the correct resolver was found but there was an error in the program,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  `SEM_RESOLVE_STOP` is returned and resolution is complete, successful or not.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  If a resolver is tried and it determines that it is not the correct resolver</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned and the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  next resolver is tried.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function should not be called directly. If one is interested in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// performing semantic analysis, call `sem_resolve_id` (or, if within an</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expression, `sem_resolve_id_expr`.) Alternatively, if one wants to get a</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// mutable type from the environment, call `find_mutable_type`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_resolve_id_with_type(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(type_ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *type_ptr = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_resolve (*resolver[])(ast_node *ast, CSTR, CSTR, sem_t **) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_arguments,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_column,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_rowid,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_cursor_as_expression,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_variable,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_enum,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_cursor_field,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_arg_bundle,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (uint32_t i = 0; i &lt; sizeof(resolver) / sizeof(void *); i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (resolver[i](ast, name, scope, type_ptr) == SEM_RESOLVE_STOP) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  report_resolve_error(ast, &quot;CQL0069: name not found&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_resolve_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This function is well described in its own comments.  We can easily see the &quot;mini-resolvers&quot;
which attempt to find the name in order:</p><ul><li><code>sem_try_resolve_arguments</code> : an argument in the argument list</li><li><code>sem_try_resolve_column</code> : a column name (possibly scoped)</li><li><code>sem_try_resolve_rowid</code> : the virtual rowid column (possibly scoped)</li><li><code>sem_try_resolve_cursor_as_expression</code> : use of a cursor as a boolean -- the bool is true if the cursor has data</li><li><code>sem_try_resolve_variable</code> : local or global variables</li><li><code>sem_try_resolve_enum</code> : the constant value of an enum (must be scoped)</li><li><code>sem_try_resolve_cursor_field</code> : a field in a cursor (must be scoped)</li><li><code>sem_try_resolve_arg_bundle</code> : a field in an argument bundle (must be scoped)</li></ul><p>These all use this enum to communicate progress:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indicate that the correct resolver was found. Continuing implies that no</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// failure has (yet) occurred, but stopping implies neither success nor failure.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef enum {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SEM_RESOLVE_CONTINUE = 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SEM_RESOLVE_STOP = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_resolve;</span></div></div></div></div></div><p>Each of these mini-resolvers will have a series of rules, for example <code>sem_try_resolve_cursor_field</code> is going to have to do
something like this:</p><ul><li>if there is no scope, it can&#x27;t be a cursor field, return <code>CONTINUE</code></li><li>if the scope is not the name of a cursor, return <code>CONTINUE</code></li><li>if the name is a field in the cursor, return <code>STOP</code> with success</li><li>else, report that the name is not a valid member of the cursor, and return <code>STOP</code> with an error</li></ul><p>All the mini-resolvers are similarly structured, generically:</p><ul><li>if it&#x27;s not my case, return <code>CONTINUE</code></li><li>if it is my case return <code>STOP</code> (maybe with an error)</li></ul><p>Some of the mini-resolvers have quite a few steps, but any one mini-resolver is only about a screenful of code
and it does one job.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flow-analysis"></a>Flow Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flow-analysis" title="Direct link to heading">#</a></h3><p>CQL implements a basic form of control flow analysis in &quot;flow.c&quot;. The header
&quot;flow.h&quot; exposes a small set of primitives used by &quot;sem.c&quot; during semantic
analysis.</p><p>Flow analysis in CQL involves two important concepts: <strong>flow contexts</strong> and
<strong>improvements</strong>. These are rather entangled concepts â€” one is useless without the
other â€” and so the approach to describing them here will alternate between giving
a bit of background on one and then the other, with a greater level of detail
about the specific types of improvements being supplied later on.</p><p>A flow context is used, in essence, to create a boundary around a portion of a
user&#x27;s program. At the moment, there are four types of contexts.</p><p>The first type of context is called, rather boringly, a <strong>normal</strong> context.
Normal contexts are used for portions of a user&#x27;s code that may be entered
conditionally. A good example of this is in <code>SELECT</code> expressions: When a <code>WHERE</code>
clause is present, the expression list is only evaluated when the <code>WHERE</code> clause
is true. If we look at <code>sem_select_expr_list_con</code>, we can get an idea of how
this works in terms of flow contexts:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_expr_list_con</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Analyze the FROM portion (if it exists).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_from</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_from_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">is_error</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_from_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Push a flow context to contain improvements made via the WHERE clause that</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// will be in effect for the SELECT expression list.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_NORMAL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain">error</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_sensitive </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_where_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_from_etc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">where_expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain">error</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_select_expr_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">select_expr_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_NORMAL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>While very much simplified above, it can be seen that the steps are essentially
as follows:</p><ol><li>Analyze the <code>FROM</code> clause.</li><li>Push a new normal context.</li><li>Analyze the <code>WHERE</code> clause.</li><li>Set improvements given the <code>WHERE</code> clause (ultimately by calling
<code>flow_set_flag_for_type</code>); we&#x27;ll come back to this part shortly.</li><li>Analyze the expression list with the improvements from the <code>WHERE</code> in effect.</li><li>Pop the context, un-setting the improvements from the <code>WHERE</code>.</li></ol><p>This, of course, only begins to make sense once one understands what we mean by
improvements.</p><p>CQL, at the moment, supports two forms of improvements: nullability improvements
and initialization improvements. Both of these will be discussed in more detail
later, but the basic idea is that an improvement upgrades the type of some value
within a particular flow context. For example, in the expression <code>SELECT x + x
FROM t WHERE x IS NOT NULL</code>, we can reason that <code>x + x</code> can safely be given a
nonnull type because of the <code>WHERE</code> clause. This is exactly what we do in
<code>sem_select_expr_list_con</code>: We make a context to hold the improvements that may
come from the <code>WHERE</code>, analyze the <code>WHERE</code>, set the appropriate improvements
given the <code>WHERE</code>, analyze the expression list, and then pop the context to
unset the improvements (as they must not affect any enclosing expressions).</p><p>In addition to normal contexts, there are also <strong>branch contexts</strong> and <strong>branch
group contexts</strong>. These two context types are designed to work together for
handling <code>IF</code>, <code>CASE</code>, <code>IIF</code>, <code>SWITCH</code>, et cetera.</p><p>Like normal contexts, branch contexts assume that they are entered when some
condition is true. The difference is that branch contexts lie within a branch
group context, and branch groups know that <em>at most</em> one branch of a given set
of branches will be entered. A great example of this can be found in
<code>sem_if_stmt</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_if_stmt</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Each branch gets its own flow context in `sem_cond_action` where its</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// condition is known to be true. We also create one more context for the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// entire set of branches. In addition to grouping the branches together, this</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// outer context holds all of the negative improvements that result from the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// knowledge that, if a given branch&#x27;s statements are being evaluated, all</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// previous branches&#x27; conditions must have been false.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_BRANCH_GROUP</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// IF [cond_action]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_cond_action</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">cond_action</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elseif</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_elseif_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elseif</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elsenode</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// ELSE [stmt_list]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">flow_set_context_branch_group_covers_all_cases</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">true</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">EXTRACT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> elsenode</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">sem_stmt_list_in_current_flow_context</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">flow_context_branch_group_add_empty_branch</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">record_ok</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">elsenode</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_BRANCH_GROUP</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>It&#x27;s instructive to look at <code>sem_cond_action</code> as well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_cond_action</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// [expr] THEN stmt_list</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_PUSH_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Add improvements for `stmt_list` where `expr` must be true.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">sem_stmt_list_in_current_flow_context</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">stmt_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">FLOW_POP_CONTEXT_BRANCH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">flow_context_branch_group_add_empty_branch</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// If a later branch will be taken, `expr` must be false. Add its negative</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements to the context created in `sem_if_stmt` so that all later</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// branches will be improved by the OR-linked spine of IS NULL checks in</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `expr`.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_false_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>Putting all of this together, we can see that the basic steps for analyzing an
<code>IF</code> statement are as follows:</p><ol><li>Push a new branch group context to hold all of the branch contexts that are
to come.</li><li>Analyze the condition in the <code>IF condition THEN</code> portion of the statement.</li><li>Push a new branch context to hold the nullability improvements from the
condition (e.g., in <code>IF x IS NOT NULL THEN</code>, we can improve <code>x</code> to have a
nonnull type in the statement list after the <code>THEN</code>).</li><li>Set the improvements.</li><li>Anaylze the statement list after the <code>THEN</code>.</li><li>Pop the branch context.</li><li>Set the <em>negative</em> improvements resulting from the knowledge that <code>condition</code><em>must have been false</em> if the previous branch wasn&#x27;t entered (e.g., in <code>IF y
IS NULL THEN</code>, we know that <code>y</code> must be nonnull from just after the end of
the branch until the end of the current branch group).</li><li>Repeat for the <code>ELSE IF</code> and <code>ELSE</code> branches (if any).</li><li>Pop the branch group context.</li></ol><p>What makes all of this work are the following:</p><ul><li><p>When a branch context is popped, it <em>resets all improvements</em> such that they
become exactly what they were before the branch was analyzed. This is done to
reflect the fact that, because at most one branch will be entered, neither
adding improvements (via <code>flow_set_flag_for_type</code>) nor removing existing
improvements (via <code>flow_unset_flag_for_type</code>) in a branch should affect any of
the other branches in the group.</p></li><li><p>When a branch group context is popped, it <em>merges</em> the effects of all of its
branches. This is a key step that allows CQL to retain an improvement after a
branch group is popped whenever the same improvement is made within every one
of its branches <em>and</em> when the branches given cover all possible cases (which
is indicated by the call to <code>flow_set_context_branch_group_covers_all_cases</code>
in the code above).</p></li></ul><p>The final type of context is called a <strong>jump context</strong>. Jump contexts are a
maximally pessimistic form of context that assume every improvement that might
be unset within them will be unset and that every improvement that might be set
within them will not be set. Jump contexts are used to make semantic analysis
safe in the possible presence of control flow statements like <code>CONTINUE</code>,
<code>LEAVE</code>, and <code>THROW</code>, and so jump contexts are used for the analysis of
statements like <code>LOOP</code>, <code>WHILE</code>, and <code>TRY</code>. Take the following line-numbered
code as an example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token number" style="color:rgb(247, 140, 108)">001</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> x </span><span class="token keyword" style="font-style:italic">TEXT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">002</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;foo&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">003</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">WHILE</span><span class="token plain"> some_condition</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">004</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">005</span><span class="token plain">    </span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> another_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">006</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">007</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> yet_another_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">008</span><span class="token plain">        </span><span class="token keyword" style="font-style:italic">LEAVE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">009</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">010</span><span class="token plain">      </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;bar&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">011</span><span class="token plain">    </span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">012</span><span class="token plain">      </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- do nothing</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">013</span><span class="token plain">    </span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">014</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">END</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">015</span><span class="token plain">  </span><span class="token keyword" style="font-style:italic">CALL</span><span class="token plain"> requires_text_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Here, even though the outer <code>IF</code> makes no change overall to the nullability
improvement to <code>x</code> from line 2 -- it unsets it on line 6 and then re-sets it on
line 10 and the <code>ELSE</code> does nothingâ€”there is no guarantee that line 10 will ever
be evaluated because we may jump straight from line 8 to line 15. As a result,
it is necessary that <code>x</code> be un-improved after the <code>WHILE</code> loop; a normal context
would not accomplish this, but a jump context does. See the comments within
<code>_flow_push_context_branch</code> for additional discussion.</p><p>While jump contexts are necessary for the safety of improvements in the presence
of loops, they are not sufficient: It&#x27;s actually necessary to analyze loops
<em>twice</em>. This is because execution of a loop might repeat, and so a statement
that results in the unsetting of an improvement later in a loop must affect
improvements earlier in that loop. For example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> x </span><span class="token keyword" style="font-style:italic">INT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">WHILE</span><span class="token plain"> some_condition</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- okay on the first analysis pass, but not the second</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">CALL</span><span class="token plain"> requires_int_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- must negatively affect the call on the line above</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Semantic analysis keeps track of whether or not it is currently reanalyzing the
statement list of a loop via the <code>current_loop_analysis_state</code> variable:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// The analysis of loops like LOOP and WHILE is done in two passes. First, we</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// analyze the loop to conservatively figure out every improvement that the loop</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// could possibly unset. After that, we reanalyze it with said improvements</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// unset to ensure that everything is safe. See `sem_stmt_list_within_loop` for</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// more information on why this is necessary.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">typedef</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">enum</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP_ANALYSIS_STATE_NONE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP_ANALYSIS_STATE_ANALYZE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP_ANALYSIS_STATE_REANALYZE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> loop_analysis_state</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Keeps tracks of the current loop analysis state. If this is equal to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `LOOP_ANALYSIS_STATE_ANALYZE`, we are analyzing with a non-final set of</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements. This is useful for two reasons:</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 1. Procedures that perform rewrites based on improvements (e.g.,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    `sem_resolve_id_expr`) can use this to verify whether a rewrite is safe to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    perform (`LOOP_ANALYSIS_STATE_NONE` or `LOOP_ANALYSIS_STATE_REANALYZE`) or</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    whether they should wait because they do not yet have definitive</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    information (`LOOP_ANALYSIS_STATE_ANALYZE`).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 2. Analyses that would otherwise fail if called during reanalysis (e.g.,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    `sem_verify_legal_variable_name`) can use this to check whether the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    current state is `LOOP_ANALYSIS_STATE_REANALYZE` and adjust their</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//    behaviors accordingly.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> loop_analysis_state current_loop_analysis_state </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> LOOP_ANALYSIS_STATE_NONE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>As indicated in the first comment above, the comments within
<code>sem_stmt_list_within_loop</code> go into further detail.</p><p>At this point, we&#x27;ve only scratched the surface of control flow analysis in CQL.
Fortunately, the files &quot;flow.h&quot; and &quot;flow.c&quot; are heavily commented and can be
studied to deepen one&#x27;s understanding.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nullability-improvements"></a>Nullability Improvements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nullability-improvements" title="Direct link to heading">#</a></h3><p>Via a form of occurrence typing (also known as flow typing), CQL has the ability
to determine that, due to a prior conditional check, a nullable variable or
cursor field cannot be null within a particular context, and CQL will improve
its type in that context.</p><p>Unlike most forms of semantic analysis performed by CQL, the analysis for
nullability improvements, as is the case for all types of improvements, makes
heavy use of the <code>find_mutable_type</code> function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Returns the *mutable* type (`sem_t *`) for a given (potentially qualified)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// identifier if one exists in the environment. See the documentation for</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `sem_resolve_id_with_type` for limitations.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">sem_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token function" style="color:rgb(130, 170, 255)">find_mutable_type</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>This function allows us to look up the type of the original binding referred to
by a particular name/scope pair. In essence, it provides access to the current
type environment for whichever part of the program we are analyzing. It also
allows us to mutate that environment by virtue of the fact that it returns a
pointer to the type of the binding, not merely the type itself.</p><p>By using <code>find_mutable_type</code> to get a type pointer and toggling the
<code>SEM_TYPE_INFERRED_NOTNULL</code> flag via <code>flow_set_flag_for_type</code> and
<code>flow_unset_flag_for_type</code>, the procedures <code>sem_set_notnull_improved</code> and
<code>sem_unset_notnull_improved</code> are able to record that a nullable identifier or
cursor field is either temporarily nonnull or no longer nonnull respectively:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Enables a nonnull improvement, if possible.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// This needs to be called for everything that is no longer safe to consider NOT</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL due to a mutation. It is fine to call this for something not currently</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// subject to improvement, but it must only be called with a name/scope pair</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// referring to something that has a mutable type (e.g., it must not be an unbound</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// variable, a cursor used as an expression, an enum case, et cetera).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_unset_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Similarly, <code>sem_is_notnull_improved</code> uses <code>find_mutable_type</code> to check whether
or not something is currently improved:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Returns true if currently improved to be nonnull, else false.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_is_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Why does nullability inference use this approach? The reason is that the
alternative would be maintaining some sort of set of currently improved
identifiers and cursor fields and checking it whenever resolving an identifier
or cursor field. The problem would be that merely knowing that some identifier
&quot;x&quot; is improved would not be sufficient, however: We&#x27;d have to know <em>which</em> &quot;x&quot;.
Is it the local variable &quot;x&quot;? Is it the column &quot;x&quot; of the table from which we&#x27;re
currently selecting?  In essence, correctly maintaining an independent set of
all currently active improvements would involve re-implementing all of the
scoping rules of the language. By using <code>find_mutable_type</code>, we can simply
piggyback on the existing name resolution logic and avoid all of these issues.</p><p>A nullability improvement is always created within a particular flow context.
When an improvement is added via <code>sem_set_notnull_improved</code>, a record of that
improvement is recorded in the current context. When that context ends, that
same record is used to remove the improvement. It is also the case that
<code>sem_unset_notnull_improved</code> may be used to remove an improvement before a
context has ended due to a <code>SET</code>, <code>FETCH</code>, or call to a procedure or function
with an <code>OUT</code> argument resulting in the improvement no longer being safe.</p><p>Improvements can be introduced into the current context via
<code>sem_set_notnull_improved</code> directly (when a variable is <code>SET</code> to a value of a
nonnull type), but more commonly they are introduced via one of the following
two functions:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Given a conditional expression `ast` possibly containing AND-linked</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// subexpressions, set all of the applicable nullability and has-row</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements within the current flow context. Generally speaking, calls to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// this function should be bounded by a new flow context corresponding to the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// portion of the program for which the condition `ast` must be be true.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Improvements for known-false conditions are dual to improvements for</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// known-true conditions.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// For nullability, known-false conditions improve ids and dots verified to be</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL via `IS NULL` along the outermost spine of `OR` expressions, whereas</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// known-true conditions improve ids and dots verified to be nonnull via `IS NOT</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL` along the outermost spine of `AND` expressions. For example, the</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// following two statements introduce the same improvements:</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   IF a IS NOT NULL AND b IS NOT NULL THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//     -- `a` and `b` are improved here because we know the condition is true</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   END IF;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   IF a IS NULL OR b IS NULL RETURN;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   -- `a` and `b` are improved here because we know the condition is false</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   -- since we must not have returned if we got this far</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// ...</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_false_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>These functions introduce improvements by gathering up all of the <code>IS NOT NULL</code>
checks (in the true case) or <code>IS NULL</code> checks (in the false case) and
introducing improvements appropriately. The true version is used when we enter a
context that will only be evaluated at runtime when some particular condition is
true; the false version, conversely, is used when we enter a context that will
only be evaluated at runtime when some particular condition is false:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> some_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- &quot;true&quot; improvements from `some_condition` are in</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- effect here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> another_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- &quot;false&quot; improvements from `some_condition` and true</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- improvements from `another_condition` are in effect</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- &quot;false&quot; improvements from both `some_condition` and</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `another_condition` are in effect here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Global variables in CQL require special treatment when it comes to nullability
improvements. This is because any procedure call could potentially mutate any
number of global variables, and so all currently improved globals must be
un-improved at every such call. The following list keeps track of which global
variables are currently improved:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">typedef</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">global_notnull_improvement_item</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token class-name" style="color:rgb(255, 203, 107)">sem_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">type</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">global_notnull_improvement_item</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">next</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> global_notnull_improvement_item</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Keeps track of all global variables that may currently be improved to be NOT</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// NULL. We need this because we must un-improve all such variables after every</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// procedure call (because we don&#x27;t do interprocedural analysis and cannot know</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// which globals may have been set to NULL).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> global_notnull_improvement_item </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">global_notnull_improvements</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>The fact that we don&#x27;t do interprocedural analysis (as the comment above
indicates) is not a deficiency. Programmers should be able to reason locally
about nullability improvements, and an analysis that depended upon the details
of how other procedures were implemented would make that impossible.</p><p>So far, we have talked a lot about how improvements are set and unset, but we
haven&#x27;t talked about how the improvement actually happens in terms of code
generation. Since CQL represents values of nullable and nonnull types
differently (at least in the case of non-reference types), we cannot simply
treat a value of a nullable type as though it were of a nonnull type: We need to
actually change its representation.</p><p>The way this works is that, whenever we resolve a name/scope pair via
<code>sem_resolve_id_expr</code>, we check whether the pair is currently improved via
<code>sem_is_notnull_improved</code>. If it is, we call <code>rewrite_nullable_to_notnull</code> to
wrap the id or dot we&#x27;re resolving with a call to the function
<code>cql_inferred_notnull</code> (for which we generate code in
<code>cg_func_cql_inferred_notnull</code>):</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Wraps an id or dot in a call to cql_inferred_notnull.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">rewrite_nullable_to_unsafe_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">_Nonnull ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// The `cql_inferred_notnull` function is not used by the programmer directly,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// but rather inserted via a rewrite during semantic analysis to coerce a value</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// of a nullable type to be nonnull. The reason for this approach, as opposed to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// just changing the type directly, is that there are also representational</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// differences between values of nullable and nonnull types; some conversion is</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// required.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">cg_func_cql_inferred_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">call_ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> charbuf </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">is_null</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> charbuf </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">value</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>As the comment for <code>cg_func_cql_inferred_notnull</code> indicates, programmers do not
use <code>cql_inferred_notnull</code> directly: It is only inserted as a product of the
above-mentioned rewrite. In fact, we explicitly disallow its use by programmers
in the parser:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// We insert calls to `cql_inferred_notnull` as part of a rewrite so we expect</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// to see it during semantic analysis, but it cannot be allowed to appear in a</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// program. It would be unsafe if it could: It coerces a value from a nullable</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// type to a nonnull type without any runtime check.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">define</span><span class="token macro property"> </span><span class="token macro property macro-name function" style="color:rgb(130, 170, 255)">YY_ERROR_ON_CQL_INFERRED_NOTNULL</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression">x</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">  </span><span class="token macro property expression function" style="color:rgb(130, 170, 255)">EXTRACT_STRING</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression">proc_name</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token macro property expression"> x</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">  </span><span class="token macro property expression keyword" style="font-style:italic">if</span><span class="token macro property expression"> </span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression operator" style="color:rgb(137, 221, 255)">!</span><span class="token macro property expression function" style="color:rgb(130, 170, 255)">strcmp</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property expression">proc_name</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token macro property expression"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&quot;cql_inferred_notnull&quot;</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression"> </span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">    </span><span class="token macro property expression function" style="color:rgb(130, 170, 255)">yyerror</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token macro property string" style="color:rgb(195, 232, 141)">&quot;Call to internal function is not allowed &#x27;cql_inferred_notnull&#x27;&quot;</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token macro property expression"> </span><span class="token macro property punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token macro property"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token macro property">  </span><span class="token macro property expression punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>One subtle aspect of the rewrite is that the rewrite itself performs analysis to
validate the product of the rewrite (as do other many other rewrites). To avoid
going into a loop of rewriting, analyzing the result (which ultimately happens
in <code>sem_special_func_cql_inferred_notnull</code>), rewriting again because the result
contains a name that is improved, et cetera, we keep track of whether or not
we&#x27;re currently analyzing a subexpression under a call to <code>cql_inferred_notnull</code>
and avoid re-rewriting appropriately:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// This is true if we are analyzing a call to `cql_inferred_notnull`. This can</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// happen for three reasons:</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// * We just did a rewrite that produced a `cql_inferred_notnull` call and now</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   we&#x27;re computing its type.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// * We&#x27;re analyzing an expression that was already analyzed (e.g., in a CTE).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// * We&#x27;re analyzing the output of a previous CQL run within which calls to</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//   `cql_inferrred_notnull` may occur.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Regardless of the cause, if `is_analyzing_notnull_rewrite` is true, we do not</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// want to rewrite again.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> is_analyzing_notnull_rewrite</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_special_func_cql_inferred_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">uint32_t</span><span class="token plain"> arg_count</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">is_aggregate</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Since we&#x27;re checking a call to `cql_inferred_notnull`, its arguments have</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// already been rewritten and we don&#x27;t want to do it again. Setting</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// `is_analyzing_notnull_rewrite` prevents that.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  is_analyzing_notnull_rewrite </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> true</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">sem_arg_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">arg_list</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> IS_NOT_COUNT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  is_analyzing_notnull_rewrite </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> false</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Like `sem_resolve_id`, but specific to expression contexts (where nullability</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// improvements are applicable).</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_resolve_id_expr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">is_analyzing_notnull_rewrite</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// If we&#x27;re analyzing the product of a rewrite and we&#x27;re already inside of a</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// call to `cql_inferred_notnull`, do not expand again.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// forever.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>At this point, you should have a decent understanding of how nullability
improvements function, both in terms of semantic analysis and in terms of code
generation. The implementation is heavily commented, so reading the code and
searching for calls to the core functions listed below should be sufficient to
fill in any gaps:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-c codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_is_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_unset_notnull_improved</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">CSTR name</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> CSTR scope</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_unset_global_notnull_improvements</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_true_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_set_improvements_for_false_condition</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">sem_special_func_cql_inferred_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">uint32_t</span><span class="token plain"> arg_count</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">bool_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">is_aggregate</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">rewrite_nullable_to_unsafe_notnull</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ast_node </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">_Nonnull ast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initialization-improvements"></a>Initialization Improvements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initialization-improvements" title="Direct link to heading">#</a></h3><p>Compared to nullability improvements, initialization improvements are relatively
simple.</p><p>The idea behind initialization improvements is that, if one declares a variable
of a reference type (<code>BLOB</code>, <code>OBJECT</code>, or <code>TEXT</code>) that is also <code>NOT NULL</code>, it is
not safe to use the variable until it has been given a value. For example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> x </span><span class="token keyword" style="font-style:italic">TEXT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">NOT</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> some_condition </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> some_text_notnull_value</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `x` is safe to use here</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `x` is NOT safe to use here (it might be uninitialized)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- `x` is NOT safe to use here either (it might be uninitialized)</span></div></div></div></div></div><p>As with nullability improvements, initialization improvements rely heavily on
flow contexts. The function <code>sem_set_initialization_improved</code>, similarly to
<code>sem_set_notnull_improved</code> for nullability, is used to enable an initialization
improvement. (There is nothing analogous to <code>sem_unset_notnull_improved</code> for
initialization because nothing can ever be uninitialized once it has been given
a value.)</p><p>Unlike nullability improvements, initialization improvements use <em>two</em> flags:
<code>SEM_TYPE_INIT_REQUIRED</code> and <code>SEM_TYPE_INIT_COMPLETE</code>. Rather than assuming
everything is uninitalized by default and requiring the presence of some
<code>SEM_TYPE_INITIALIZED</code> flag before anything can be used, we explicitly tag
things that are not initialized but need to be with <code>SEM_TYPE_INIT_REQUIRED</code> and
later tag them with <code>SEM_TYPE_INIT_COMPLETE</code> once they&#x27;ve been initialized.
Doing it in this way has two benefits:</p><ol><li><p>It reduces the amount of noise in the AST output significantly: Code like
<code>LET x := 10;</code> can remain <code>{let_stmt}: x: integer notnull variable</code> in the
AST without the need of the extra noise of some <code>initialized</code> flag.</p></li><li><p>More importantly, it means we only have to deal with initialization in a tiny
portion of &quot;sem.c&quot;. For example, we must handle it in <code>sem_declare_vars_type</code>
to add the <code>SEM_TYPE_INIT_REQUIRED</code> flag and in <code>sem_assign</code> to add
<code>SEM_TYPE_INIT_COMPLETE</code>, but <code>sem_let_stmt</code> can remain blissfully ignorant
of initialization altogether.</p></li></ol><p>There are only three places in which a variable may be initialized: <code>sem_assign</code>
(as mentioned), <code>sem_fetch_stmt</code> (for the <code>FETCH...INTO</code> form), and
<code>sem_arg_for_out_param</code> (as passing a variable to a procedure requiring an <code>OUT</code>
argument of a <code>NOT NULL</code> type can initialize it).</p><p>Regarding <code>sem_arg_for_out_param</code>, we can only set initialization improvements
when a variable is passed as an <code>OUT</code> argument because we require that all
procedures initialize all of their <code>OUT</code> parameters of a nonnull reference type.
This is handled in two places:</p><ol><li><p>In <code>sem_param</code>, we set the <code>SEM_TYPE_INIT_REQUIRED</code> flag when
<code>param_should_require_initialization</code> is true.</p></li><li><p>In <code>sem_validate_current_proc_params_are_initialized</code>, which is called both
after analyzing the statement list of a procedure and for each return
statement within the procedure, we ensure that <code>SEM_TYPE_INIT_COMPLETE</code> is
present on all parameters that have <code>SEM_TYPE_INIT_REQUIRED</code>.</p></li></ol><p>There is only one wrinkle in all of this: the <code>cql:try_is_proc_body</code> attribute.
If <code>cql:try_is_proc_body</code> is present on a <code>TRY</code> statement, we call
<code>sem_validate_current_proc_params_are_initialized</code> at the end of the <code>TRY</code> and
<em>not</em> at the end of the procedure. The rationale for this is explained
thoroughly in the comments for
<code>sem_find_ast_misc_attr_trycatch_is_proc_body_callback</code>.</p><p>That&#x27;s all there is to it: &quot;flow.c&quot; does most of the hard work for us.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="structure-types-and-the-notion-of-shapes"></a>Structure types and the notion of Shapes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#structure-types-and-the-notion-of-shapes" title="Direct link to heading">#</a></h3><p>Earlier we discussed <code>SEM_TYPE_STRUCT</code> briefly. Recall the basic notion of the <code>structure</code> type:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for tables and views and the result of a select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_struct {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR struct_name;               // struct name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // field names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *kinds;                    // the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *semtypes;                // typecode for each field</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_struct;</span></div></div></div></div></div><p>The structure is nothing more than an array of names, types and kinds with a count.  But it creates the notion of
what&#x27;s usually called a &quot;shape&quot; in the codebase. Shapes can be used in a variety of ways as is described in
<a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the CQL Guide. But before we get
into shapes, let&#x27;s look at an example of how a structure type is created.</p><p>The code that follows is the back end of <code>sem_create_table_stmt</code>.  At this point the bulk of the analysis is
done and the columns all have their types.  We&#x27;re about to build the struct type for the table.  Let&#x27;s see how
that goes.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // now create a struct type with the correct number of columns</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the types have already been computed so all we have to do is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // check for duplicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_struct *sptr = new_sem_struct(name, cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *columns = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t col = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *item = col_key_list; item; item = item-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(is_ast_col_key_list(item));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(def, item-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_col_def(def)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(def-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(col &lt;= cols);  // it&#x27;s possible that the rest are deleted and we&#x27;re at the end.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // columns must be unique, including deleted columns</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (!symtab_add(columns, def-&gt;sem-&gt;name, NULL)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_NOTNULL(col_def_type_attrs, def-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_ANY_NOTNULL(col_def_ast, col_def_name_type-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        report_error(col_def_ast, &quot;CQL0142: duplicate column name&quot;, def-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        symtab_delete(columns);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        goto cleanup;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (is_deleted(def-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(col &lt; cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;names[col] = def-&gt;sem-&gt;name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;semtypes[col] = def-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;kinds[col] = def-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      col++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(columns);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(col == cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_STRUCT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;sptr = sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;jptr = sem_join_from_sem_struct(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;region = current_region;</span></div></div></div></div></div><ul><li><code>new_sem_struct</code> : makes a struct to hold the result, we already have the count of columns and the table name</li><li><code>symtab_new</code> : is going to give us a scratch symbol table so we can check for duplicate column names</li><li>we walk all the items in the table and use <code>is_ast_col_def(def)</code> to find the column definitions</li><li><code>Invariant(def-&gt;sem-&gt;name)</code> : claims that we must have already computed the semantic info for the column and it has its name populated<ul><li>this was done earlier</li></ul></li><li><code>symtab_add(columns, def-&gt;sem-&gt;name, NULL)</code> : adds a nil entry under the column name -- if this fails we have a duplicate column,<ul><li>in which case we report errors and stop</li></ul></li><li><code>is_deleted</code> : tells us if the column was marked with <code>@delete</code> in which case it no longer counts as part of the table</li><li>if all this is good we set the <code>names</code>, <code>kinds</code>, and <code>semtypes</code> from the column definition&#x27;s semantic info</li><li><code>symtab_delete</code> : cleans up the temporary symbol table</li><li><code>new_sem</code> : creates a <code>sem_node</code> of type <code>SEM_TYPE_STRUCT</code> which is filled in<ul><li><code>sem_join_from_sem_struct</code> will be discussed shortly, but it creates a <code>jptr</code> with one table in it</li></ul></li></ul><p>Structure types often come from the shape of a table, but other things can create a structure type.  For instance, the
columns of a view, or any select statement, are also described by a structure type and are therefore valid &quot;shapes&quot;.  The
return type of a procedure usually comes from a <code>SELECT</code> statement, so the procedure too can be the source of a shape.
The arguments of a procedure form a shape.  The fields of a cursor form a shape.  You can even have a named subset
of the arguments of a procedure and use them like a shape. All of these things are described by structure types.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="shapes-and-the-like-construct"></a>Shapes and the LIKE construct<a aria-hidden="true" tabindex="-1" class="hash-link" href="#shapes-and-the-like-construct" title="Direct link to heading">#</a></h4><p>There are many cases where you want to be able to capture or re-use something with a known shape and you don&#x27;t
want to have to fully re-declare the thing.  CQL uses the <code>LIKE</code> construct to do these sorts of things.  This is
more fully explained in <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the Guide,
but for now let&#x27;s look at two different cases that are of interest.</p><p>First, a cursor:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE C CURSOR LIKE Foo;  -- Foo something with a shape</span></div></div></div></div></div><p>So, in the above, Foo could be a table, a view, a procedure with a result, another cursor, and so forth.</p><p>How might we do this?  This is the business of <code>sem_declare_cursor_like_name</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we&#x27;re going to make a new value cursor using the indicated name for the shape.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The name has to be &quot;likeable&quot; meaning it refers to some named thing with a shape</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// such as a table, a view, another cursor, or a procedure that returns a result set.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These are the so called &quot;value cursors&quot; in that they have no underlying statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// that they move through.  You can just load them up with a row and pass them around.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_declare_cursor_like_name(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_declare_cursor_like_name(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(new_cursor_ast, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(new_cursor_name, new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(like_ast, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(name_ast, like_ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(like_name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // no duplicates allowed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_legal_variable_name(ast, new_cursor_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be a valid shape</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *found_shape = sem_find_likeable_ast(like_ast, LIKEABLE_FOR_VALUES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!found_shape) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // good to go, make our cursor, with storage.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name_ast-&gt;sem = like_ast-&gt;sem = found_shape-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem-&gt;sptr = found_shape-&gt;sem-&gt;sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem-&gt;name = new_cursor_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_cursor_ast-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_add(current_variables, new_cursor_name, new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>EXTRACT</code> : gets the pieces we need from the AST</li><li><code>sem_verify_legal_variable_name</code> : makes sure the cursor name is unique and doesn&#x27;t hide a table name</li><li><code>sem_find_likeable_ast</code> : searches for something with a suitable name that has a shape</li><li>we populate the name node with the  semantic type that we found</li><li><code>new_sem</code> : makes a new <code>sem_node</code> for the cursor variable with <code>SEM_TYPE_STRUCT</code><ul><li>set the <code>sptr</code> field using the discovered shape</li></ul></li></ul><p>Note: <code>name_ast-&gt;sem</code> isn&#x27;t actually used for anything but it is helpful for debugging. If the AST is printed it
shows the original unmodified semantic type which can be helpful.</p><p>Briefly <code>sem_find_likeable_ast</code> does these steps:</p><ul><li>if the right of the <code>LIKE</code> refers to procedure arguments (e.g. C LIKE Foo ARGUMENTS), get the args of the named procedure and use them as a shape</li><li>if the right is a local or global, and its a cursor, use the shape of that cursor for the new cursor</li><li>if the right is the name of an argument bundle, use the shape of the bundle<ul><li>e.g. in <code>CREATE PROC Foo(p1 like Person, p2 like Person)</code> <code>p1</code> and <code>p2</code> are the names of argument bundles shaped like <code>Person</code></li></ul></li><li>if the right is the name of a table or view, use that shape</li><li>if the right is the name of a procedure with a structure result, use that shape</li><li>if it&#x27;s none of these, produce an error</li></ul><p>This is the primary source of shape reuse.  Let&#x27;s look at how we might use that.</p><p>Suppose we want to write a procedure that inserts a row into the table <code>Foo</code>, we could certainly list the columns of <code>Foo</code> as arguments like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC InsertIntoFoo(id integer, t text, r real, b blob)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSERT INTO Foo(id, t, r, b) VALUES(id, t, r, b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>But that approach is going to get a lot less exciting when there are lots of columns and it will be increasingly a maintenance headache.</p><p>Compare that with the following:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC InsertIntoFoo(row LIKE Foo)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSERT INTO Foo FROM row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Those two versions of <code>InsertIntoFoo</code> compile into the same code.  The semantic analyzer expands the <code>(row LIKE Foo)</code> into
<code>(row_id integer, row_t text, row_r real, row_b blob)</code> and then replaces <code>FROM row</code> with
<code>(row_id, row_t, row_r, row_b)</code>.  In both case it simply looked up the shape using <code>sem_find_likeable_ast</code>
and then altered the AST to the canonical pattern.  This kind of &quot;shape sugar&quot; is all over CQL and
greatly increases maintainability while eliminating common errors.  The most common operation is simply
to expland a &quot;shape&quot; into a list of arguments or columns (maybe with or without type names).  SQLite doesn&#x27;t
know any of this shape magic so by the time SQLite sees the code it has to look &quot;normal&quot; -- the shapes
are all resolved.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="join-types"></a>Join Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#join-types" title="Direct link to heading">#</a></h3><p>The last of the type building data structure is the join type.  Recall that we have this shape:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for the data type of (parts of) the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// sometimes I refer to as a &quot;joinscope&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_join {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of table/views in the join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // names of the table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct **tables;     // struct type of each table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_join;</span></div></div></div></div></div><p>This is an array of named structure types, which is exactly what you get when you do something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select * from T1 INNER JOIN T2;</span></div></div></div></div></div><p>The result has all of the columns of <code>T1</code> and all of the columns of <code>T2</code>.  They can be referred to with scoped
names like <code>T1.x</code> which means &quot;find the <code>sptr</code> corresponding to the name <code>T1</code> then within that structure
find the column named <code>x</code>&quot;.  In general, when we join, we take a <code>jptr</code> on the left and concatenate it
with a <code>jptr</code> on the right.  For all this to work we have to start somewhere, usually single tables.</p><p>As we saw when we make a table we use <code>sem_join_from_sem_struct</code> to make its initial <code>jptr</code>.  Let&#x27;s
have a look at that now:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create a base join type from a single struct.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static sem_join *sem_join_from_sem_struct(sem_struct *sptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_join *jptr = new_sem_join(1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  jptr-&gt;names[0] = sptr-&gt;struct_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  jptr-&gt;tables[0] = new_sem_struct_strip_table_flags(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return jptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It doesn&#x27;t get much simpler than the above, here are the steps briefly:</p><ul><li><code>new_sem_join</code> : gives us an empty <code>sem_join</code> with room for 1 table</li><li>we use the struct name for the name and the table&#x27;s <code>sptr</code> for the shape</li><li><code>new_sem_struct_strip_table_flags</code> : copies the table&#x27;s <code>sptr</code> keeping only the essential flags<ul><li><code>SEM_TYPE_HIDDEN_COL</code></li><li><code>SEM_FLAG_NOTNULL</code></li><li><code>SEM_FLAG_SENSITIVE</code></li></ul></li></ul><p>The other flags (e.g. <code>SEM_TYPE_PK</code>) have no value in doing type checking and were only needed to help validate the table itself.
Those extra flags would be harmless but they would also contaminate all of the debug output, so they are stripped.  As a result
the type of columns as they appear in say <code>SELECT</code> statements is simpler than how they appear in a <code>CREATE TABLE</code> statement.</p><p>When we need to create a new join type we simply (*) make a new <code>sem_join</code> that is the concatenation of the left and right sides of the join
operation.</p><ul><li>some join types change the nullability of columns like <code>LEFT JOIN</code>, so we have to handle that too</li><li>the names of the tables in the new concatenated joinscope have to be unambiguous so there is also error checking to do</li><li>but basically it&#x27;s just a concatenation</li></ul><p>Importantly, we call the thing a &quot;joinscope&quot; because it creates a namespace.  When we are evaluating names inside of the <code>FROM</code> clause or
even later in, say, a <code>WHERE</code> clause, the joinscope that we have created so far controls the <code>table.column</code> combinations that you can
use in expressions.  This changes again when there is a subquery, so the joinscopes can be pushed and popped as needed.</p><p>By way of example, you&#x27;ll see these two patterns in the code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PUSH_JOIN(from_scope, select_from_etc-&gt;sem-&gt;jptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error = sem_select_orderby(select_orderby);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  POP_JOIN();</span></div></div></div></div></div><ul><li><code>PUSH_JOIN</code> : use the <code>jptr</code> from the <code>FROM</code> clause to put things back in scope for the <code>ORDER BY</code> clause</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PUSH_JOIN_BLOCK();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_numeric_expr(ast-&gt;left, ast, &quot;LIMIT&quot;, SEM_EXPR_CONTEXT_LIMIT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  POP_JOIN();</span></div></div></div></div></div><ul><li><code>PUSH_JOIN_BLOCK</code> : causes the name search to stop -- nothing deeper in the stack is searched</li><li>in this case we do not allow <code>LIMIT</code> expressions to see any joinscopes, as they may not use any columns<ul><li>even if the <code>LIMIT</code> clause is appearing in a subquery it can&#x27;t refer to columns in the parent query</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-regions"></a>Schema Regions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-regions" title="Direct link to heading">#</a></h3><p>We touched briefly on schema regions earlier in this section.  The purpose and language for regions
is described more fully in <a href="https://cgsql.dev/cql-guide/ch10#schema-regions" target="_blank" rel="noopener noreferrer">Chapter 10</a> of the Guide.
In this section we&#x27;ll deal with how they are implemented and what you should expect to see in the code.</p><p>When a region declaration is found this method is used:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// A schema region is an partitioning of the schema such that it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// only uses objects in the same partition or one of its declared</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// dependencies.  One schema region may be upgraded independently</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// from any others (assuming they happen such that dependents are done first).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we validate:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the region name is unique</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the dependencies (if any) are unique and exist</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_declare_schema_region_stmt(ast_node *ast)  { ... }</span></div></div></div></div></div><p>The general rules are described in the comment, but effectively it accumulates the list of
the declared region&#x27;s dependencies.  Sometimes these are called the antecedent regions.  Since
a region can only depend on regions that have already been declared, it&#x27;s not possible
to make any cycles. Regions are declared before you put anything into them.</p><p>Pieces of schema or procedures (or anything really) can go into a region by putting that code
inside a begin/end pair for the named region.  Like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token variable" style="color:rgb(191, 199, 213)">@begin_schema_region</span><span class="token plain"> your_region</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- your stuff</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token variable" style="color:rgb(191, 199, 213)">@end_schema_region</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Now whatever happens to be in &quot;your stuff&quot; is:</p><ul><li>limited to seeing only the things that <code>your_region</code> is allowed to see, and</li><li>contributes its contents to <code>your_region</code> thereby limiting how others will be able to use &quot;your stuff&quot;</li></ul><p>To see how this happens, let&#x27;s have a look at <code>sem_begin_schema_region_stmt</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Entering a schema region makes all the objects that follow part of that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// region.  It also means that all the contained objects must refer to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// only pieces of schema that are in the same region or a dependent region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we validate that region we are entering is in fact a valid region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and that there isn&#x27;t already a schema region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_begin_schema_region_stmt(ast_node * ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_begin_schema_region_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(name, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // @BEGIN_SCHEMA_REGION name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!verify_schema_region_out_of_proc(ast)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (current_region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0246: schema regions do not nest; end the current region before starting a new one&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *region = find_region(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0244: unknown schema region&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Get the canonical name of the region (case adjusted)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_region(region));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(region_name, region-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // we already know we are not in a region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(!current_region_image);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  current_region_image = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_accumulate_public_region_image(current_region_image, region_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this is the one and only text pointer value for this region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  current_region = region_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We see these basic steps:</p><ul><li><code>EXTRACT</code> : gets the region name</li><li><code>verify_schema_region_out_of_proc</code> : makes sure we are out of any procedure (we have to be at the top level)<ul><li>errors if in a procedure</li></ul></li><li><code>current_region</code> : is tested to make sure we are not already in a region (no nesting)<ul><li>errors if already in a region</li></ul></li><li><code>find_region</code> : is used to find the region AST by name<ul><li>errors if the region name isn&#x27;t valid</li></ul></li><li><code>EXTRACT</code> : is used again to get the canonical name of the region<ul><li>you could write <code>@begin_schema_region YoUr_ReGION;</code> but we want the canonical name <code>your_region</code>, as it was declared</li></ul></li><li><code>symtab_new</code> : creates a new symbol table <code>current_region_image</code></li><li><code>sem_accumulate_public_region_image</code> : populates <code>current_region_image</code> by recursively walking this region adding the names of all the regions we find along the way<ul><li>note the regions form a DAG so we might find the same name twice; we can stop if we find a region that is already in the image symbol table</li></ul></li><li><code>current_region</code> : set it to the now new current region</li></ul><p>Now we&#x27;re all set up.</p><ul><li>We can use <code>current_region</code> to set the <code>region</code> in the <code>sem_node</code> of anything we encounter</li><li>We can use <code>current_region_image</code> to quickly see if we are allowed to use any given region<ul><li>if it&#x27;s in the symbol table we can use it</li></ul></li></ul><p>Recall that at the end of <code>sem_create_table_stmt</code> we do this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_STRUCT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;sptr = sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;jptr = sem_join_from_sem_struct(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;region = current_region;</span></div></div></div></div></div><p>That should make a lot more sense now.</p><p>When doing the symmetric check in <code>sem_validate_object_ast_in_current_region</code> we see this pattern:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Validate whether or not an object is usable with a schema region. The object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can only be a table, view, trigger or index.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_validate_object_ast_in_current_region(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_ast,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *err_target,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR msg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We&#x27;re in a non-region therefore no validation needed because non-region stmt</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // can reference schema in any region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!current_region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (table_ast-&gt;sem &amp;&amp; table_ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // if we have a current region then the image is always computed!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(current_region_image);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!symtab_find(current_region_image, table_ast-&gt;sem-&gt;region)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // The target region is not accessible from this region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // while in schema region &#x27;%s&#x27;, accessing an object that isn&#x27;t in a region is invalid</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>I&#x27;ve elided some of the code here, but only the part that generates error messages.  The essential logic is:</p><ul><li>if we are not in a region we can access anything</li><li>if we&#x27;re in a region then...<ul><li>the thing we&#x27;re trying to access must also be in a region, and</li><li>that region must be in <code>current_region_image</code></li><li>otherwise, we can&#x27;t access it</li></ul></li></ul><p>This is enough to do all the region validation we need.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="results-of-semantic-analysis"></a>Results of Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#results-of-semantic-analysis" title="Direct link to heading">#</a></h3><p>Semantic Analysis leaves a lot of global state ready for the remaining stages to harvest.  If the state
is defined in <code>sem.h</code> then it&#x27;s ok to harvest.  Here we&#x27;ll highlight some of the most important things you
can use in later passes.  These are heavily used in the code generators.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_tables_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_functions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_views_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_indices_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_triggers_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_regions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_ad_hoc_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_select_functions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_enums_list );</span></div></div></div></div></div><p>These linked lists are authoritiative; they let you easily enumerate all the objects of the specified type.  For
instance, if you wanted to do some validation of all indices, you could simply walk <code>all_indices_list</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_proc(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_region(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_func(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_table_or_view_even_deleted(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_enum(CSTR name);</span></div></div></div></div></div><p>These functions give you access to the core name tables (which are still valid!) so that you can look up procedures, functions,
tables, etc. by name.</p><p>Finally, information about all the schema annotations is invaluable for building schema upgraders.  These
two buffers hold dense arrays of annotation records as shown below.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( bytebuf *schema_annotations );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( bytebuf *recreate_annotations );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct recreate_annotation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR target_name;               // the name of the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR group_name;                // group name or &quot;&quot; if no group (not null, safe to sort)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *target_ast;           // top level target (table, view, or index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *annotation_ast;       // the actual annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t ordinal;                // when sorting we want to use the original order (reversed actually) within a group</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} recreate_annotation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct schema_annotation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t version;                // the version number (always &gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *target_ast;           // top level target (table, view, or index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR target_name;               // the name of the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t annotation_type;       // one of the codes below for the type of annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *annotation_ast;       // the actual annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t column_ordinal;         // -1 if not a column</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *column_ast;           // a particular column if column annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} schema_annotation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note: schema annotations are processed in the indicated order: the numbers matter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_INVALID 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_FIRST 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_CREATE_TABLE 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_CREATE_COLUMN 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_TRIGGER 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_VIEW 4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_INDEX 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_COLUMN 6</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_TABLE 7</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_AD_HOC 8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_LAST 8</span></div></div></div></div></div><p>And of course, each &quot;back end&quot; is provided with the root of the AST so that it can also search
and/or walk the AST in its own manner.  We will see examples of this in later sections.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>At present, there are nearly 20000 lines in <code>sem.c</code> and it would no doubt take more than 20000 lines of text
to explain what they all do, and that would be more imprecise than the source code, and probably less
readable.  <code>sem.c</code> includes over 4000 lines of comments, and probably should have more.  While there
is a lot of code there, it&#x27;s very readable and I encourage you to do just that -- read it -- to get your answers.</p><p>The point of this part of the Internals Guide isn&#x27;t to fully explain all 400+ error checks in about
as many semantic error checking functions, it is to showcase the key concepts shared by all of them. Things like:</p><ul><li>errors are reported largely in the AST and percolate up</li><li>expressions and statements have general purpose dispatch logic for continuing a statement walk</li><li><code>EXTRACT</code> macros are used to keep the tree walk on track and correct in the face of changes</li><li>regions are used for visibility</li><li>versioning contributes to visibility</li><li>nullability and sensitivity are tracked throughout using type bits</li><li>type &quot;kind&quot; is managed by a simple string in the <code>sem_node</code> payload</li><li>the three main payloads are<ul><li><code>sem_node</code> for basic info, and</li><li><code>sem_struct</code> or <code>sem_join</code> for the non-unitary types</li></ul></li></ul><p>This isn&#x27;t everything but it should leave you well armed to begin your own exploration of <code>sem.c</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-3-c-code-generation"></a>Part 3: C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-3-c-code-generation" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-2"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-2" title="Direct link to heading">#</a></h3><p>Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every detail of code generation but rather to give
a sense of how codegen happens in general -- the core strategies and implementation choices --
so that when reading the code you will have an idea how smaller pieces would fit into the whole. To accomplish
this, various key data structures will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="c-code-generation"></a>C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#c-code-generation" title="Direct link to heading">#</a></h2><p>There are several key pieces of C code that we have to generate to make working CQL procedures using C
functions.  This all happens in <code>cg_c.c</code>.  From a big picture perspective, these are the essential problems:</p><ul><li>we have to compile SQL expressions into C<ul><li>including expressions with variables that are nullable</li><li>including SQL expressions that are highly complex like <code>CASE..WHEN..THEN..END</code> and <code>IN (..)</code></li></ul></li><li>we have to generate control flow for things like <code>IF</code>, <code>WHILE</code> and, <code>SWITCH</code></li><li>we have to make result sets<ul><li>including the code to slurp up all the rows from a SQL statement into an array of values</li><li>we want to do this very economically</li></ul></li><li>we have to be able to create the text for every SQLite statement and bind any variables to it</li><li>we have to check every SQLite API for errors and throw exceptions consistently and deal with them<ul><li>including constructs that allow users to handle exceptions, such as <code>TRY/CATCH</code></li></ul></li><li>we have to track any reference types carefully so that retain/release pairs are done consistently<ul><li>even in the presence of SQLite errors or other exceptions</li></ul></li><li>we have to produce a <code>.h</code> and a <code>.c</code> file for the C compiler<ul><li>contributions to these files could come from various places, not necessarily in order</li><li>the <code>.c</code> file will itself have various sections and we might need to contribute to them at various points in the compilation</li></ul></li><li>we want to do this all in one pass over the AST</li><li>we get to assume that the program is error-free -- codegen never runs unless semantic analysis reports zero errors<ul><li>so nothing can be wrong by the time the codegen pass runs, we never detect errors here</li><li>sometimes we add <code>Contract</code> and <code>Invariant</code> statements to <code>cg.c</code> to make our assumptions clear and to prevent regressions</li></ul></li></ul><p>There are some very important building blocks used to solve these problems: we will start with those, then move to
a discussion of each of the essential kinds of code generation that we have to do to get working programs.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="launching-the-code-generator"></a>Launching the Code Generator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#launching-the-code-generator" title="Direct link to heading">#</a></h3><p>Once semantic analysis is done, all of the code generators have the same contract: they
have a main function like <code>cg_c_main</code> for the C code generator.  It gets the root of
the AST and it can use the public interface of the semantic analyzer to get additional
information.  See <a href="https://cgsql.dev/cql-guide/int02" target="_blank" rel="noopener noreferrer">Part 2</a> for those details.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for code-gen.  This will set up the buffers for the global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variables and any loose calls or DML.  Any code that needs to run in the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// global scope will be added to the global_proc.  This is the only codegen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// error that is possible.  If you need global code and you don&#x27;t have a global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// proc then you can&#x27;t proceed.  Semantic analysis doesn&#x27;t want to know that stuff.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Otherwise all we do is set up the most general buffers for the global case and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// spit out a function with the correct name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_c_main(ast_node *head) { ... }</span></div></div></div></div></div><p>In addition to initializing its scratch storage, the main entry point also sets up a
symbol table for AST dispatch just like the <code>gen_</code> and <code>sem_</code> functions do.  Here
are some samples from that table with the most common options:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_view_stmt);</span></div></div></div></div></div><p>The DDL (Data Definition Language) statements all get the same handling:  The text of the statement
is generated from the AST. Any variables are bound and then the statement is executed.  The work
is done with <code>cg_bound_sql_statement</code> which will be discussed later.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DDL invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We don&#x27;t minify the aliases because DDL can have views and the view column names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can be referred to in users of the view.  Loose select statements can have</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// no external references to column aliases.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_any_ddl_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>DML (Data Manipulation Language) statements are declared similarly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(begin_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(commit_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(rollback_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(savepoint_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(delete_stmt);</span></div></div></div></div></div><p>The DML statements are handled by <code>cg_std_dml_exec_stmt</code>; the processing is identical to
DDL except <code>CG_MINIFY_ALIASES</code> is specified.  This allows the code generator
to remove unused column aliases in <code>SELECT</code> statements to save space.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DML invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_std_dml_exec_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Note that this flag difference only matters for the <code>CREATE VIEW</code> statement
but for symmetry all the DDL is handled with one macro and all the DML
with the second macro.</p><p>Next, the easiest case... there are a bunch of statements that create
no code-gen at all.  These statements are type definitions that are interesting
only to the semantic analyzer, or other control statements.  Some examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_enum_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_named_type);</span></div></div></div></div></div><p>Next, the general purpose statement handler.  <code>STMT_INIT</code> creates mappings
such as the <code>if_stmt</code> AST node mapping to <code>cg_if_stmt</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(assign);</span></div></div></div></div></div><p>The next group of declarations are the expressions, with precedence and operator specified.
There is a lot of code sharing between AST types as you can see from this sample:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, cg_expr_num, &quot;num&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, cg_expr_str, &quot;STR&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, cg_expr_null, &quot;NULL&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, cg_expr_dot, &quot;DOT&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, cg_binary, &quot;*&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(div, cg_binary, &quot;/&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, cg_binary, &quot;%&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(add, cg_binary, &quot;+&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(sub, cg_binary, &quot;-&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, cg_unary, &quot;!&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, cg_unary, &quot;~&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, cg_unary, &quot;-&quot;, C_EXPR_PRI_UNARY);</span></div></div></div></div></div><p>Most (not all) of the binary operators are handled with one function <code>cg_binary</code> and likewise
most unary operators are handled with <code>cg_unary</code>.</p><p>Note: the precedence constants are the <code>C_EXPR_PRI_*</code> flavor because, naturally, parentheses
will be generated based on the C rules during C codegen.  Importantly, the AST still, and always,
authoritatively encodes the user-specified order of operations -- there&#x27;s no change there.  The
only thing that changes is where parentheses are needed to get the desired result.  Some parens
may need to be added, and some that were present in the original text might no longer be needed.</p><p>Here are some helpful examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* NOT is weaker than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET x := (NOT 1) + (NOT 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := NOT 1 + 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* ! is stronger than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! 1 + ! 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! (1 + 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Finally, many built-in functions need special codegen, such as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(coalesce);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div></div></div></div></div><p><code>FUNC_INIT(coalesce)</code> creates a mapping between the function name <code>coalesce</code> and the generator <code>cg_func_coalesce</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="character-buffers-and-byte-buffers"></a>Character Buffers and Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#character-buffers-and-byte-buffers" title="Direct link to heading">#</a></h3><p>The first kind of text output that CQL could produce was the AST echoing.  This was originally done directly with <code>fprintf</code> but
that was never going to be flexible enough -- we have to be able to emit that output into other places like comments, or the text of
SQL statements.  This need forces that pass to use character buffers, which we touched on in Part 1.  C Code generation
has a more profound dependency on character buffers -- they are literally all over <code>cg_c.c</code> and we need to go over how they are used
if we&#x27;re going to understand the codegen passes.</p><p>The public  interface for <code>charbuf</code> is in <code>charbuf.h</code> and it&#x27;s really quite simple.  You allocate a <code>charbuf</code> and then you can
<code>bprintf</code> into it. Let&#x27;s be a bit more specific:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_INTERNAL_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_GROWTH_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct charbuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char *ptr;      // pointer to stored data, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t used;  // bytes used in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t max;   // max bytes in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // builtin buffer storage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char internal[CHARBUF_INTERNAL_SIZE];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} charbuf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( int32_t charbuf_open_count );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bopen(charbuf* b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bclose(charbuf *b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bprintf(charbuf *b, const char *format, ...);</span></div></div></div></div></div><p>The typical pattern goes something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf foo;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;foo);</span></div></div></div></div></div><p>Note that <code>charbuf</code> includes <code>CHARBUF_INTERNAL_SIZE</code> of storage that does not
have to be allocated with <code>malloc</code> and it doesn&#x27;t grow very aggressively.
This economy reflects that fact that most <code>charbuf</code> instances are very small.
Of course a <code>charbuf</code> could go on the heap if it needs to outlive
the function it appears in, but this is exceedingly rare.</p><p>To make sure buffers are consistently closed -- and this is a problem because
there are often a lot of them -- they are allocated with these simple helper
macros:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_OPEN(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t __saved_charbuf_count##x = charbuf_open_count; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf x; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_CLOSE(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;x); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(__saved_charbuf_count##x == charbuf_open_count)</span></div></div></div></div></div><p>The earlier example would be written more properly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(foo);</span></div></div></div></div></div><p>If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure.</p><p>It&#x27;s normal to create several buffers in the course of doing code generation.  In fact some of these buffers
become &quot;globally&quot; visible and get swapped out as needed.  For instance, the kind of chaining we see
inside of <code>cg_create_proc_stmt</code> is normal, here is the sequence:</p><p>Make new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_fwd_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_body);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_cleanup);</span></div></div></div></div></div><p>Save the current buffer pointers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_main = cg_main_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_decls = cg_declarations_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_scratch = cg_scratch_vars_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_cleanup = cg_cleanup_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_fwd_ref = cg_fwd_ref_output;</span></div></div></div></div></div><p>Switch to the new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fwd_ref_output = &amp;proc_fwd_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_main_output = &amp;proc_body;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_declarations_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_vars_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_cleanup_output = &amp;proc_cleanup;</span></div></div></div></div></div><p>And of course the code puts the original values back when it&#x27;s done and then closes what it opened.</p><p>This means that while processing a procedure the codegen that declares say scratch variables,
which would go to <code>cg_scratch_vars_output</code>, is going to target the <code>proc_locals</code> buffer
which will be emitted before the <code>proc_body</code>.  By the time <code>cg_stmt_list</code> is invoked the
<code>cg_main_output</code> variable will be pointing to the procedure body, thus any statements
will go into there rather than being accumulated at the global level.</p><p>Note: it&#x27;s possible to have code that is not in a procedure (see <a href="https://cgsql.dev/cql-guide/x1#--global_proc-name" target="_blank" rel="noopener noreferrer"><code>--global_proc</code></a>).</p><p>In general, it&#x27;s very useful to have different buffers open at the same time.  New local variables
or scratch variables can be added to their own buffer. New cleanup steps that are necessary can be added to
<code>cg_cleanup_output</code> which will appear at the end of a procedure. The final steps of procedure codegen
combines all of these pieces plus a little glue to make a working procedure.</p><p>All codegen works like this -- statements, expressions, all of it.</p><p>One interesting but unexpected feature of <code>charbuf</code> is that it provides helper methods for indenting
a buffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C
code because of course we want (e.g.) the body of an <code>if</code> statement to be indented.  CQL tries to create
well formatted code that is readable by humans as much as possible.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="byte-buffers"></a>Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#byte-buffers" title="Direct link to heading">#</a></h4><p>The byte buffers type, creatively called <code>bytebuf</code> is less commonly used.  It is a peer to <code>charbuf</code>
and provides a growable binary buffer.  <code>bytebuf</code> is often used to hold arrays of structures.
Interestingly, <code>cg_c.c</code> doesn&#x27;t currently consume byte buffers, the presence of <code>bytebuf.c</code> actually
came late to the CQL compiler. However the CQL runtime <code>cqlrt.c</code> (and <code>cqlrt_common.c</code>) provide
<code>cql_bytebuf_open</code>, <code>cql_bytebuf_alloc</code> and, <code>cql_bytebuf_close</code> which are akin to the <code>charbuf</code> methods.
These functions <em>are</em> used in the generated code to create result sets at runtime.</p><p><code>bytebuf</code> was so useful that it found its way back from the runtime into the compiler itself, and is used by
other code-generators like the schema upgraded.   The semantic analyzer also uses it to help with query
fragments and to track the various upgrade annotations.</p><p>Both <code>charbuf</code> and <code>bytebuf</code> are simple enough that they don&#x27;t need special discussion. Surveying
their code and comments is an excellent exercise for the reader.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expressions"></a>Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expressions" title="Direct link to heading">#</a></h3><p>Many of the output needs of CQL stemmed from the base case of creating the code for CQL expressions.
A simple CQL expression like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>seems innocuous enough, and we&#x27;d like that expression to compile to this code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div></div></div></div></div><p>And indeed, it does.  Here&#x27;s some actual output from the compiler:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>(*) the output above was created by using <code>out/cql --in x --cg x.h x.c --nolines</code> to avoid all the <code>#</code> directives</p><p>That expression looks easy enough. And indeed if all expressions were like this, we could do expression compilation
pretty simply -- every binary operator would look something like this:</p><ul><li>recurse left</li><li>emit infix operator</li><li>recurse right</li></ul><p>This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have
the whole expression.</p><p>This doesn&#x27;t work at all.</p><p>To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result is telling:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>In this new example above, <code>x</code> and <code>y</code> became nullable variables i.e. the <code>NOT NULL</code> was
removed from their declarations -- this makes all the difference in the world.</p><p>Let&#x27;s take a quick look at <code>cql_nullable_int32</code> and we&#x27;ll see the crux of the problem immediately:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_nullable_int32 {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> cql_bool is_null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> cql_int32 value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_nullable_int32;</span></div></div></div></div></div><p>The problem is that nullable value types like <code>cql_nullable_int32</code> have both their <code>value</code> field
and a boolean <code>is_null</code> and these don&#x27;t flow into expressions that use operators like <code>+</code>, <code>-</code>, <code>/</code> and so forth.
This means that even simple expressions involving nullable types actually expand into several statements.  And, in general,
these statements need a place to put their temporary results to accumulate the correct answer, so scratch variables
are required to make all this work.</p><p>Here&#x27;s a more realistic example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET result := 5 * x + 3 * y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;combine&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)result, 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(*result); // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div></div></div></div></div><ul><li><code>_tmp_n_int_1</code> : holds the product of x and 5, it&#x27;s null if <code>x.is_null</code> is true</li><li><code>_tmp_n_int_2</code> : holds the product of y and 3, it&#x27;s null if <code>y.is_null</code> is true</li><li><code>*result</code> : holds the answer, it&#x27;s null if either of <code>_tmp_n_int_1.is_null</code>, <code>_tmp_n_int_2.is_null</code> is true<ul><li>otherwise it&#x27;s <code>_tmp_n_int_1.value + _tmp_n_int_2.value</code></li></ul></li></ul><p>So, in general, we need to emit arbitrarily many statements in the course of evaluating even simple looking expressions
and we need good mechanisms to manage that.  This is what we&#x27;ll talk about in the coming sections.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="managing-scratch-variables"></a>Managing Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#managing-scratch-variables" title="Direct link to heading">#</a></h4><p>The function that actually assigns scratch variables is <code>cg_scratch_var</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch variable helper uses the given sem_type and the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stack level to create a temporary variable name for that type at that level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the variable does not already have a declaration (as determined by the masks)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// then a declaration is added to the scratch_vars section.  This is one of the root</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ways of getting an .is_null and .value back.  Note that not null variables always</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// have a .is_null of &quot;0&quot; which becomes important when deciding how to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// one result to another.  Everything stays uniform.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)</span></div></div></div></div></div><p>The signature is a bit unexpected so we&#x27;ll go over it, some of below will make more
sense as we learn about expressions generally, but this is as good an introduction as any.</p><ul><li><code>ast</code> : holds a reference to a variable we want to assign to<ul><li>this argument is normally <code>NULL</code> for scratch variables</li><li><code>ast</code> is not null for the <code>RESULT</code> macros which we&#x27;ll study later</li><li>for now, we can basically ignore this argument</li></ul></li><li><code>sem_type</code> : holds the type of the variable we need<ul><li>it must be a unitary type, optionally with <code>SEM_TYPE_NOTNULL</code> set</li></ul></li><li><code>var</code> : a character buffer that will get the name of the variable</li><li><code>is_null</code> : a character buffer that will get the <code>is_null</code> expression for this variable (more below)</li><li><code>value</code> : a character buffer that will get the <code>value</code> expression for this variable (more below)</li></ul><p>And this is a good time to talk about <code>is_null</code> and <code>value</code> because they will be everywhere.</p><p>The codegen for expressions in the C code generator produces two results:</p><ul><li>the text that corresponds to the current value so far (e.g. &quot;(1+2)*3&quot;), and,</li><li>the text that will tell you if the current value is null<ul><li>this could be as simple as &quot;0&quot; for an expression that is known to be not null</li></ul></li></ul><p>Let&#x27;s make this a little more concrete:</p><p>Suppose we ask for a scratch &quot;not null integer&quot;, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_n_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;0&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_n_int_1&quot;</code></li></ul><p>Meaning: if we want the value, use the text <code>&quot;_tmp_n_int_1&quot;</code> if we want to know if the variable is null, we use the text <code>&quot;0&quot;</code></p><p>Note: many parts of <code>cg_c.c</code> special case an <code>is_null</code> value of <code>&quot;0&quot;</code> to make better code because such a thing is known to
be not null at compile time.</p><p>Now let&#x27;s suppose we ask for a scratch nullable integer, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;_tmp_int_1.is_null&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_int_1.value&quot;</code></li></ul><p>So again, we have exactly the text we need to test for null, and the test we need to get the value.</p><p>Additional notes:</p><ul><li>scratch variables can be re-used, they are on a &quot;stack&quot;</li><li>a bitmask is used to track which scratch variables have already had a declaration emitted, so they are only declared once</li><li>the variable name is based on the current value of the <code>stack_level</code> variable which is increased in a push/pop fashion as temporaries come in and out of scope<ul><li>this strategy isn&#x27;t perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad</li><li>importantly, there is one <code>stack_level</code> variable for all temporaries not one <code>stack_level</code> for every type of temporary, this seemed like a reasonable simplification</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocating-scratch-variables"></a>Allocating Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocating-scratch-variables" title="Direct link to heading">#</a></h4><p>The most common reason to create a &quot;scratch&quot; variable is that a temporary variable is needed for some part of the computation.
The most common reason for a temporary variable is to hold an intermediate result of a computation involving nullable arithmetic.</p><p>These temporaries are created with <code>CG_PUSH_TEMP</code> which simply creates the three <code>charbuf</code> variables needed and then asks for a
scratch variable of the required type.  The variables follow a simple naming convention.  The stack level is increased after
each temporary is allocated.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the text needed to refer to the variable.  cg_scratch_var picks the name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// based on stack level-and type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_TEMP(name, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_var(NULL, sem_type, &amp;name, &amp;name##_is_null, &amp;name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  stack_level++;</span></div></div></div></div></div><p>Symmetrically, <code>CG_POP_TEMP</code> closes the <code>charbuf</code> variables and restores the stack level.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffers for the temporary, restore the stack level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_TEMP(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  stack_level--;</span></div></div></div></div></div><p>As with the other <code>PUSH/POP</code> <code>OPEN/CLOSE</code> macro types, these macros are designed to make it impossible
to forget to free the buffers, or to get the stack level wrong.  The stack level can be (and is) checked
at strategic places to ensure it&#x27;s back to baseline -- this is easy because the code can always just
snapshot <code>stack_level</code>, do some work that should be clean, and then check that <code>stack_level</code> is back to
where it&#x27;s supposed to be with an <code>Invariant</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursing-sub-expressions"></a>Recursing Sub-expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursing-sub-expressions" title="Direct link to heading">#</a></h4><p>Now that we understand that we can create scratch variables as needed, it&#x27;s time to take a look at the typical evaluation patterns
and how the evaluation works within that pattern.  This is everywhere in <code>cg_c.c</code>.</p><p>So let&#x27;s look at an actual evaluator, the simplest of them all, this one does code generation for the <code>NULL</code> literal.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_null(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *expr,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR op,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *is_null,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *value,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t pri,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t pri_new)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(expr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(value, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Now this may be looking familiar: the signature of the code generator is something very much like the
signature of the the <code>gen_</code> functions in the echoing code.  That&#x27;s really because in some sense
the echoing code is a very simple code generator itself.</p><ul><li><code>expr</code> : the AST we are generating code for</li><li><code>op</code> : the relevant operator if any (operators share code)</li><li><code>is_null</code> : a <code>charbuf</code> into which we can write the <code>is_null</code> expression text</li><li><code>value</code> : a <code>charbuf</code> into which we can write the <code>value</code> expression text</li><li><code>pri</code> : the binding strength of the node above this one</li><li><code>pri_new</code> : the binding strength of this node</li></ul><p>This particular generator is going to produce <code>&quot;NULL&quot;</code> for the <code>value</code> and <code>&quot;1&quot;</code> for the <code>is_null</code> expression.</p><p><code>is_null</code> and <code>value</code> are the chief outputs, and the caller will use these to create its own expression results
with recursive logic.  But the expression logic can also write into the statement stream, the cleanup stream,
even into the header file stream, and as we&#x27;ll see, it does.</p><p><code>pri</code> and <code>pri_new</code> work exactly like they did in the echoing code (see <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>),
they are used to allow the code generator to decide if it needs to emit parentheses.  But recall that the binding strengths
now will be the C binding strengths NOT the SQL binding strengths (discussed above).</p><p>Let&#x27;s look at one of the simplest operators: the <code>IS NULL</code> operator handled by <code>cg_expr_is_null</code></p><p>Note: this code has a simpler signature because it&#x27;s actually part of codegen for <code>cg_expr_is</code> which
has the general contract.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The code-gen for is_null is one of the easiest.  The recursive call</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// produces is_null as one of the outputs.  Use that.  Our is_null result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is always zero because IS NULL is never, itself, null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_expr = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // expr IS NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;0&quot;); // the result of is null is never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The fact that this is not constant not null for not null reference types reflects</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the weird state of affairs with uninitialized reference variables which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be null even if they are typed not null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_not_nullable(sem_type_expr) &amp;&amp; !is_ref_type(sem_type_expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Note, sql has no side-effects so we can fold this away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;0&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;%s&quot;, expr_is_null.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>So walking through the above:</p><ul><li>the result of <code>IS NULL</code> is never null, so we can immediately put &quot;0&quot; into the <code>is_null</code> buffer</li><li>if the operand is a not-null numeric type then the result of <code>IS NULL</code> is <code>0</code></li><li>if the operand might actually be null then<ul><li>use <code>CG_PUSH_EVAL</code> to recursively do codegen for it</li><li>copy its <code>expr_is_null</code> text into our <code>value</code> text</li></ul></li></ul><p>Note: the code reveals one of the big CQL secrets -- that not null reference variables can be null...  C has the same issue with <code>_Nonnull</code> globals.</p><p>Now let&#x27;s look at those helper macros, they are pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// naming convention.  This might exit having burned some stack slots</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for its result variables, that&#x27;s normal.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri);</span></div></div></div></div></div><p>The push macro simply creates buffers to hold the <code>is_null</code> and <code>value</code> results, then it calls <code>cg_expr</code> to dispatch the indicated expression.
The <code>pri</code> value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is the <code>pri_new</code> of the caller.
but often <code>C_EXPR_PRI_ROOT</code> can be used if the current context implies that the callee will never need parentheses.</p><p>How do we know that parens are not needed here? It seems like the operand of <code>IS NULL</code> could be anything, surely it might need parentheses?  Let&#x27;s consider:</p><ul><li>if the operand is of not null numeric type then we aren&#x27;t even going to evaluate it, we&#x27;re on the easy &quot;no it&#x27;s not null&quot; path<ul><li>no parens there</li></ul></li><li>if the operand is nullable then the only place the answer can be stored is in a scratch variable and its <code>is_null</code> expression will be exactly like <code>var.is_null</code><ul><li>no parens there</li></ul></li><li>if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is <code>is_null</code> expression will be like <code>!var</code><ul><li>no parens there</li></ul></li></ul><p>So, none of these require further wrapping regardless of what is above the <code>IS NULL</code> node in the tree because of the high strength of the <code>.</code> and <code>!</code> operators.</p><p>Other cases are usually simpler, such as &quot;no parentheses need to be added by the child node because it will be used as the argument to a helper
function so there will always be parens hard-coded anyway&quot;.  However these things need to be carefully tested hence the huge variety of codegen tests.</p><p>Note that after calling <code>cg_expr</code> the temporary stack level might be increased.  We&#x27;ll get to that in the next section.  For now, looking at <code>POP_EVAL</code> we
can see it&#x27;s very straightforward:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Close the buffers used for the above.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch stack is not restored so that any temporaries used in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the evaluation of expr will not be re-used prematurely.  They</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can&#x27;t be used again until either the expression is finished,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// or they have been captured in a less-nested result variable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_EVAL(expr) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_is_null);</span></div></div></div></div></div><p><code>CG_POP_EVAL</code> simply closes the buffers, leaving the stack level unchanged.  More on this in the coming section.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-variables"></a>Result Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-variables" title="Direct link to heading">#</a></h4><p>When recursion happens in the codegen, a common place that the result will be found is
in a temporary variable i.e. the generated code will use one or more statements to arrange for the correct
answer to be in a variable.  To do this, the codegen needs to first get the name of a
result variable of a suitable type.  This is the &quot;other&quot; reason for making scratch variables.</p><p>There are three macros that make this pretty simple.  The first is <code>CG_RESERVE_RESULT_VAR</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a scratch variable to hold the final result of an evaluation.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// It may or may not be used.  It should be the first thing you put</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// so that it is on the top of your stack.  This only saves the slot.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If you use this variable you can reclaim other temporaries that come</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// from deeper in the tree since they will no longer be needed.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_RESERVE_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_reserved = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">sem_t sem_type_reserved = sem_type; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *ast_reserved = ast; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>If this looks a lot like <code>PUSH_TEMP</code> that shouldn&#x27;t be surprising.  The name of the variable
and the expression parts always go into <code>charbuf</code> variables named <code>result_var</code>, <code>result_var_is_null</code>, and <code>result_var_value</code>
but the scratch variable isn&#x27;t actually allocated!  However -- we burn the stack_level as though it had been
allocated.</p><p>The name of the macro provides a clue: this macro reserves a slot for the result variable, it&#x27;s used if the codegen might
need a result variable, but it might not.  If/when the result variable is needed, it we can artificially move the stack level
back to the reserved spot, allocate the scratch variable, and then put the stack level back.  When the name is set we know
that the scratch variable was actually used.</p><p>The <code>CG_USE_RESULT_VAR</code> macro does exactly this operation.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable is going to be used, this writes its name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and .value and .is_null into the is_null and value fields.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_USE_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_now = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_reserved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_now; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Invariant(result_var.used &gt; 1); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(is_null, &quot;%s&quot;, result_var_is_null.ptr); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(value, &quot;%s&quot;, result_var_value.ptr)</span></div></div></div></div></div><p>Once the code generator decides that it will in fact be using a result variable to represent the answer, then
the <code>is_null</code> and <code>value</code> buffers can be immediately populated to whatever the values were
for the result variable.  That text will be correct regardless of what codegen is used
to populate the variable.  The variable is the result.</p><p>There is a simpler macro that reserves and uses the result variable in one step, it&#x27;s used frequently.
The &quot;reserve&quot; pattern is only necessary when there are some paths that need a result variable and some
that don&#x27;t.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This does reserve and use in one step</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_SETUP_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_RESERVE_RESULT_VAR(ast, sem_type); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_USE_RESULT_VAR();</span></div></div></div></div></div><p>And now armed with this knowledge we can look at the rest of the scratch stack management.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffer holding the name of the variable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable was used, we can re-use any temporaries</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with a bigger number.  They&#x27;re no longer needed since they</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// are captured in this result.  We know it was used if it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// has .used &gt; 1 (there is always a trailing null so empty is 1).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_CLEANUP_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (result_var.used &gt; 1) stack_level = stack_level_reserved + 1; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(result_var);</span></div></div></div></div></div><p>As it happens when you use <code>CG_PUSH_EVAL</code> it is entirely possible, even likely,
that the result of <code>cg_expr</code> is in a result variable.  The convention is that if the codegen
requires a result variable it is allocated <em>first</em>, before any other temporaries.  This is why
there is a way to reserve a variable that you <em>might</em> need.</p><p>Now if it turns out that you used the result variable at your level it means that any
temporary result variables from deeper levels have been used and their values plus
whatever math was needed is now in your result variable.  This means that the <code>stack_level</code>
variable can be decreased to one more than the level of the present result.  This is
in the fact the only time it is safe to start re-using result variables because
you otherwise never know how many references to result variables that were &quot;deep in the tree&quot;
are left in the contents of <code>expr_value</code> or <code>expr_is_null</code>.</p><p>Now, armed with the knowledge that there are result variables and temporary variables and both
come from the scratch variables we can resolve the last mystery we left hanging.  Why does
the scratch variable API accept an AST pointer?</p><p>The only place that AST pointer can be not null is in the <code>CG_USE_RESULT_VAR</code> macro, it was
this line:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value);</span></div></div></div></div></div><p>And <code>ast_reserved</code> refers to the AST that we are trying to evaluate.  There&#x27;s an important
special case that we want to optimize that saves a lot of scratch variables.  That case is handled
by this code in <code>cg_scratch_var</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_assignment_target_reusable(ast, sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(ast &amp;&amp; ast-&gt;parent &amp;&amp; ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_out_parameter(name_ast-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;*%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The idea is that if the generator is doing an assignment like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := a + b;</span></div></div></div></div></div><p>Then the code generator doesn&#x27;t need a scratch variable to hold the result of the expression <code>a + b</code> like it would
in many other contexts.  It can use <code>x</code> as the result variable!  The <code>SET</code> codegen will discover
that the value it&#x27;s supposed to set is already in <code>x</code> so it does nothing and everything just
works out.  The price of this is a call to <code>is_assignment_target_reusable</code> and then some
logic to handle the case where <code>x</code> is an out argument (hence call by reference, hence needs to be used as <code>*x</code>).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="basic-control-flow-patterns"></a>Basic Control Flow Patterns<a aria-hidden="true" tabindex="-1" class="hash-link" href="#basic-control-flow-patterns" title="Direct link to heading">#</a></h3><p>To get a sense of how the compiler generates code for statements, we can look at some of the easiest cases.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;While&quot; suffers from the same problem as IF and as a consequence</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// generating while (expression) would not generalize.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The overall pattern for while has to look like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    prep statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    condition = final expression;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    if (!condition) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note that while can have leave and continue substatements which have to map</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to break and continue.   That means other top level statements that aren&#x27;t loops</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// must not create a C loop construct or break/continue would have the wrong target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;for (;;) {\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!cql_is_nullable_true(%s, %s)) break;\n&quot;, expr_is_null.ptr, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!(%s)) break;\n&quot;, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t loop_saved = cg_in_loop;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = loop_saved;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The comment before the <code>cg_while_stmt</code> actually describes the situation pretty clearly;
the issue with this codegen is that the expression in the while statement might actually
require many C statements to evaluate.  There are many cases of this sort of thing, but the
simplest is probably when any nullable types are in that expression.  A particular example
illustrates this pretty clearly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>which generates:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* in trickier cases there would be code right here */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(x &lt; 5)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    x = x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>In this case, a <code>while</code> statement could have been used because the condition is simply <code>x &lt; 5</code>
so this more general pattern is overkill.  But consider this program, just a tiny bit different:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER;  -- x is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>which produces:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_bool _tmp_n_bool_0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_bool_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_notnull(x, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_bool_0, x.is_null, x.value &lt; 5);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_nullable(x, x.is_null, x.value + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Even for this small little case, the nullable arithmetic macros have to be used to keep <code>x</code> up to date.
The result of <code>x &lt; 5</code> is of type <code>BOOL</code> rather than <code>BOOL NOT NULL</code> so a temporary variable captures
the result of the expression.  This is an easy case, but similar things happen if the expression
includes e.g. <code>CASE...WHEN...</code> or <code>IN</code> constructs.  There are many other cases.</p><p>So with this in mind, let&#x27;s reconsider what <code>cg_while_stmt</code> is doing:</p><ul><li>we start the <code>for</code> statement in the output<ul><li>there&#x27;s a bprintf for that</li></ul></li><li>we evaluate the while expression, the details will be in <code>is_null</code> and <code>value</code><ul><li>we use CG_PUSH_EVAL for that</li></ul></li><li>if the result is nullable there is a helper macro <code>cql_is_nullable_true</code> that tells us if the value is not null and true</li><li>if the result is not nullable we can use <code>expr_value.ptr</code> directly</li><li>we make a note that we&#x27;re in a loop (this matters for statement cleanup, more on that later)</li><li>we recurse to do more statements with <code>cg_stmt_list</code></li><li>finally we end the <code>for</code> that we began</li></ul><p>This kind of structure is common to all the control flow cases.  Generally, we have to deal with the
fact that CQL expressions often become C statements so we use a more general flow control strategy.
But with this in mind, it&#x27;s easy to imagine how the <code>IF</code>, <code>LOOP</code>, and <code>SWITCH</code> switch statements are
handled.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cleanup-and-errors"></a>Cleanup and Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cleanup-and-errors" title="Direct link to heading">#</a></h3><p>There are a number of places where things can go wrong when running a CQL procedure.  The most
common sources are: (1) SQLite APIs, almost all of which can fail, and, (2) calling other procedures
which also might fail.  Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC something_that_might_fail (arg TEXT) USING TRANSACTION;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Which generates:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look at those fragments carefully:</p><ul><li>first, we had to declare <code>something_that_might_fail</code><ul><li>the declaration included <code>USING TRANSACTION</code> indicating the procedure uses the database</li><li>we didn&#x27;t provide the procedure definition, this is like an <code>extern ... foo(...);</code> declaration</li></ul></li><li>there is a string literal named <code>_literal_1_test_p</code> that is auto-created<ul><li><code>cql_string_literal</code> can expand into a variety of things, whatever you want &quot;make a string literal&quot; to mean</li><li>it&#x27;s defined in <code>cqlrt.h</code> and it&#x27;s designed to be replaced</li></ul></li><li><code>cql_set_string_ref(&amp;arg, _literal_1_test_p);</code> is expected to &quot;retain&quot; the string (+1 ref count)</li><li><code>cql_cleanup</code> is the exit label, this cleanup code will run on all exit paths<ul><li>cleanup statements are accumulated by writing to <code>cg_cleanup_output</code> which usually writes to the <code>proc_cleanup</code> buffer</li><li>because cleanup is in its own buffer you can add to it freely whenever a new declaration that requires cleanup arises</li><li>in this case the declaration of the string variable caused the <code>C</code> variable <code>arg</code> to be created and also the cleanup code</li></ul></li><li>now we call <code>something_that_might_fail</code> passing it our database pointer and the argument</li><li>the hidden <code>_db_</code> pointer is passed to all procedures that use the database</li><li>these procedures are also the ones that can fail</li><li>any failed return code (not <code>SQLITE_OK</code>) causes two things:<ul><li>the <code>cql_error_trace()</code> macro is invoked (this macro typically expands to nothing)</li><li>the code is redirected to the cleanup block via <code>goto cql_cleanup;</code></li></ul></li></ul><p>The essential sequence is this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div></div></div></div></div><p>The C code generator consistently uses this pattern to check if anything went wrong and to exit with an error code.
Extensive logging can be very expensive, but in debug builds it&#x27;s quite normal for <code>cql_error_trace</code> to expand
into something like <code>fprintf(stderr, &quot;error %d in %s %s:%d\n&quot;, _rc_, _PROC_, __FILE__, __LINE_)</code> which is probably
a lot more logging than you want in a production build but great if you&#x27;re debugging.  Recall that CQL generates
something like <code>#define _PROC_ &quot;p&quot;</code> before every procedure.</p><p>This error pattern generalizes well and indeed if we use the exception handling pattern, we get a lot of control.
Let&#x27;s generalize this example a tiny bit:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (OUT success BOOL NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN TRY</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END TRY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN CATCH</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END CATCH;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>CQL doesn&#x27;t have complicated exception objects or anything like that, exceptions are just simple
control flow.  Here&#x27;s the code for the above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_bool *_Nonnull success) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)success, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *success = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    goto catch_end_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_start_1: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_end_1:;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The code in this case is nearly the same as the previous example.  Let&#x27;s look at the essential differences:</p><ul><li>If there is an error, <code>goto catch_start_1</code> will run</li><li>If the try block succeeds, <code>goto catch_end_1</code> will run</li><li>both the <code>TRY</code> and <code>CATCH</code> branches set the <code>success</code> out parameter</li><li>since an out argument was added, CQL generated an error check to ensure that <code>success</code> is not null<ul><li><code>cql_contract_argument_notnull((void *)success, 1)</code>, the 1 means &quot;argument 1&quot; and will appear in the error message if this test fails</li><li>the hidden <code>_db_</code> argument doesn&#x27;t count for error message purposes, so <code>success</code> is still the first argument</li></ul></li></ul><p>How does this happen?  Let&#x27;s look at <code>cg_trycatch_helper</code> which does this work:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Very little magic is needed to do try/catch in our context.  The error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// handlers for all the sqlite calls check _rc_ and if it&#x27;s an error they</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;goto&quot; the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Inside the try block, the cleanup handler is changed to the catch block.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The catch block puts it back.  Otherwise, generate nested statements as usual.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_start);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We need unique labels for this block</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ++catch_block_count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_start, &quot;catch_start_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_end, &quot;catch_end_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Divert the error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR saved_error_target = error_target;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t saved_error_target_used = error_target_used;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target = catch_start.ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> ...</span></div></div></div></div></div><p>The secret is the <code>error_target</code> global variable.
All of the error handling will emit a goto <code>error_target</code> statement. The
try/catch pattern simply changes the current error target.  The rest of
the code in the helper is just to save the current error target and to
create unique labels for the try/catch block.</p><p>The important notion is that, if anything goes wrong, whatever it is,
the generator simply does a <code>goto error_target</code> and that will either
hit the catch block or else go to cleanup.</p><p>The <code>THROW</code> operation illustrates this well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Convert _rc_ into an error code.  If it already is one keep it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Then go to the current error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_throw_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_throw_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_best_error(%s);\n&quot;, rcthrown_current);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;goto %s;\n&quot;, error_target);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  rcthrown_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>first we make sure <code>_rc_</code> has some kind of error in it, either <code>rcthrown_current</code> or else <code>SQLITE_ERROR</code></li><li>then we go to the current error target</li><li><code>error_target_used</code> tracks whether if the error label was used, this is just to avoid C compiler errors about unused labels.<ul><li>if the label is not used it won&#x27;t be emitted</li><li>the code never jumps back to an error label, so we&#x27;ll always know if the label was used before we need to emit it</li></ul></li></ul><p>Note: every catch block captures the value of <code>_rc_</code> in a local variable whose name is in <code>rcthrown_current</code>.
This captured value is the current failing result code accessible by <code>@RC</code> in CQL.</p><p>A catch block can therefore do stuff like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">@RC</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  THROW</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">call</span><span class="token plain"> attempt_retry</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>This entire mechanism is built with basically just a few state variables that nest.  There is no complicated stack walking
or anything like that.  All the code has to do is chain the error labels together and let users create new catch blocks
with new error labels.  All that together gives you very flexible try/catch behaviour with very little overhead.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="string-literals"></a>String Literals<a aria-hidden="true" tabindex="-1" class="hash-link" href="#string-literals" title="Direct link to heading">#</a></h3><p>Before we move on to more complex statements we have to discuss string literals a little bit.  We&#x27;ve mentioned before
that the compiler is going to generate something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div></div></div></div></div><p>To create a reference counted object <code>_literal_1_test_p</code> that it can use.  Now we&#x27;re going to talk about how
the text <code>&quot;test&quot;</code> was created and how that gets more complicated.</p><p>The first thing to remember is that the generator creates C programs.  That means
no matter what kind of literal we might be processing it&#x27;s ending up encoded as a C string for the C
compiler.  The C compiler will be the first thing the decodes the text the generator produces and
puts the byte we need into the final programs data segment or wherever.  That means if we have
SQL format strings that need to go to SQLite they will be twice-encoded, the SQL string is escaped
as needed for SQLite and <em>that</em> is escaped again for the C compiler.</p><p>An example might make this clearer consider the following SQL:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &#x27;&quot;x&#x27;&#x27;y&quot;&#x27; AS a, &quot;&#x27;y&#x27;\n&quot; AS b;</span></div></div></div></div></div><p>The generated text for this statement will be:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;SELECT &#x27;\&quot;x&#x27;&#x27;y\&quot;&#x27;, &#x27;&#x27;&#x27;y&#x27;&#x27;\n&#x27;&quot;</span></div></div></div></div></div><p>Let&#x27;s review that in some detail:</p><ul><li><p>the first string &quot;a&quot; is a standard SQL string</p><ul><li>it is represented unchanged in the AST, it is <em>not</em> unescaped</li><li>even the outer single quotes are preserved, CQL has no need to change it at all</li><li>when we emit it into our output it will be read by the C compiler, so</li><li>at that time it is escaped <em>again</em> into C format<ul><li>the double quotes which required no escaping in SQL become <code>\&quot;</code></li></ul></li><li>the single quote character requires no escape but there are still two of them because SQLite will also process this string</li></ul></li><li><p>the second string &quot;b&quot; is a C formatted string literal</p><ul><li>SQLite doesn&#x27;t support this format or its escapes, therefore</li><li>as discussed in <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>, it is decoded to plain text, then re-encoded as a SQL escaped string</li><li>internal newlines do not require escaping in SQL, they are in the string as the newline character not &#x27;\n&#x27; or anything like that<ul><li>to be completely precise the byte value 0x0a is in the string unescaped</li></ul></li><li>internal single quotes don&#x27;t require escaping in C, these have to be doubled in a SQL string</li><li>the outer double quotes are removed and replaced by single quotes during this process</li><li>the AST now has a valid SQL formatted string possibly with weird characters in it</li><li>as before, this string has to be formatted for the C compiler so now it has to be escaped again</li><li>the single quotes require no further processing, though now there are quite a few of them</li><li>the embedded newline is converted to the escape sequence &quot;\n&quot; so we&#x27;re back to sort of where we started<ul><li>the C compiler will convert this back to the byte 0x0a which is what ends up in the data segment</li></ul></li></ul></li></ul><p>In the above example we were making one overall string for the <code>SELECT</code> statement so the outer double quotes
are around the whole statement.  That was just for the convenience of this example.  If the literals had
been in some other loose context then individual strings would be produced the same way.  Except, not so fast,
not every string literal is heading for SQLite.  Some are just making regular strings.  In that case even
if they are destined for SQLite they will go as bound arguments to a statement not in the text of the SQL.
That means <em>those</em> strings do not need SQL escaping.</p><p>Consider:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET a := &#x27;&quot;x&#x27;&#x27;y&quot;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET b := &quot;&#x27;y&#x27;\n&quot;;</span></div></div></div></div></div><p>To do those assignments we need:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_x_y_p, &quot;\&quot;x&#x27;y\&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_2_y_p, &quot;&#x27;y&#x27;\n&quot;);</span></div></div></div></div></div><p>In both of these cases the steps are:</p><ul><li>unescape the escaped SQL string in the AST to plain text<ul><li>removing the outer single quotes of course</li></ul></li><li>re-escape the plain text (which might include newlines and such) as a C string<ul><li>emit that text, including its outer double quotes</li></ul></li></ul><p>Trivia: the name of the string literal variables include a fragment of the string to make them a little easier to spot.</p><p><code>encoders.h</code> has the encoding functions</p><ul><li><code>cg_decode_string_literal</code></li><li><code>cg_encode_string_literal</code></li><li><code>cg_encode_c_string_literal</code></li><li><code>cg_decode_c_string_literal</code></li></ul><p>As well as similar functions for single characters to make all this possible.  Pretty much every combination
of encoding and re-encoding happens in some path through the code generator.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="executing-sqlite-statements"></a>Executing SQLite Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#executing-sqlite-statements" title="Direct link to heading">#</a></h3><p>By way of example let&#x27;s consider a pretty simple piece of SQL we might want to run.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE TABLE foo(id INTEGER, t TEXT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER, t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  UPDATE foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t = t_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>To make this happen we&#x27;re going to have to do the following things:</p><ul><li>create a string literal with the statement we need</li><li>the references to <code>id_</code> and <code>t_</code> have to be replaced with <code>?</code></li><li>we prepare that statement</li><li>we bind the values of <code>id_</code> and <code>t_</code></li><li>we <code>step</code> the statement</li><li>we <code>finalize</code> the statement</li><li>suitable error checks have to be done at each stage</li></ul><p>That&#x27;s quite a bit of code and it&#x27;s easy to forget a step, this is an area where CQL shines.  The
code we had to write in CQL was very clear and all the error checking is implicit.</p><p>This is the generated code.  We&#x27;ll walk through it and discuss how it is created.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 id_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nullable t_)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_temp_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;_temp_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;UPDATE foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SET t = ? &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multibind(&amp;_rc_, _db_, &amp;_temp_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_INT32, &amp;id_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_STRING, t_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>the functions signature includes the hidden <code>_db_</code> parameter plus the two arguments</li><li>we need a hidden <code>_rc_</code> variable to hold the result codes from SQLite</li><li>we need a scratch <code>sqlite3_stmt *</code> named <code>_temp_stmt</code> to talk to SQLite<ul><li>when this is created, the cleanup section gets <code>cql_finalize_stmt(&amp;_temp_stmt);</code></li><li><code>cql_finalize_stmt</code> sets the statement to null and does nothing if it&#x27;s already null</li></ul></li><li>the string <code>&quot;INSERT INTO foo(id, t) VALUES(?, ?)&quot;</code> is created from the AST<ul><li>recall that we have <code>variables_callback</code> as an option, it&#x27;s used here to track the variables and replace them with <code>?</code></li><li>more on this shortly</li></ul></li><li><code>cql_multibind</code> is used to bind the values of <code>id_</code> and <code>t_</code><ul><li>this is just a varargs version of the normal SQLite binding functions, it&#x27;s only done this way to save space</li><li>only one error check is needed for any binding failure</li><li>the type of binding is encoded very economically</li><li>the &quot;2&quot; here refers to two arguments</li></ul></li><li>the usual error processing happens with <code>cql_error_trace</code> and <code>goto cql_cleanup</code></li><li>the statement is executed with <code>sqlite3_step</code></li><li>temporary statements are finalized immediately with <code>cql_finalize_stmt</code><ul><li>in this case its redundant because the code is going to fall through to cleanup anyway</li><li>in general there could be many statements and we want to finalize immediately</li><li>this is an optimization opportunity, procedures with just one statement are very common</li></ul></li></ul><p>Most of these steps are actually hard coded.  There is no variability in the sequence
after the <code>multibind</code> call, so that&#x27;s just boiler-plate the compiler can inject.</p><p>We don&#x27;t want to declare <code>_temp_stmt</code> over and over so there&#x27;s a flag that records
whether it has already been declared in the current procedure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a declaration for the temporary statement _temp_stmt_ if we haven&#x27;t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// already done so.  Also emit the cleanup once.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void ensure_temp_statement() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!temp_statement_emitted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_declarations_output, &quot;sqlite3_stmt *_temp_stmt = NULL;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_cleanup_output, &quot;  cql_finalize_stmt(&amp;_temp_stmt);\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    temp_statement_emitted = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This is a great example of how, no matter where the processing happens to be,
the generator can emit things into the various sections.  Here it adds
a declaration and an cleanup with no concern about what else might be going on.</p><p>So most of the above is just boiler-plate, the tricky part is:</p><ul><li>getting the text of the SQL</li><li>binding the variables</li></ul><p>All of this is the business of this function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the most important function for sqlite access;  it does the heavy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// lifting of generating the C code to prepare and bind a SQL statement.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If cg_exec is true (CG_EXEC) then the statement is executed immediately</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and finalized.  No results are expected.  To accomplish this we do the following:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * figure out the name of the statement, either it&#x27;s given to us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     or we&#x27;re using the temp statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * call get_statement_with_callback to get the text of the SQL from the AST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     * the callback will give us all the variables to bind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     * count the variables so we know what column numbers to use (the list is backwards!)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * bind any variables</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   * if there are variables CG_EXEC will step and finalize</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_flags)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The core of this function looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callbacks callbacks;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_gen_sql_callbacks(&amp;callbacks);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  callbacks.variables_callback = cg_capture_variables;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  callbacks.variables_context = &amp;vars;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ... more flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(temp);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_set_output_buffer(&amp;temp);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_statement_with_callbacks(stmt, &amp;callbacks);</span></div></div></div></div></div><p>It&#x27;s set up the callbacks for variables and it calls the echoing function on the buffer.  We&#x27;ve
talked about <code>gen_statement_with_callbacks</code> in  <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>.</p><p>Let&#x27;s take a look at that callback function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the callback method handed to the gen_ method that creates SQL for us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// it will call us every time it finds a variable that needs to be bound.  That</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variable is replaced by ? in the SQL output.  We end up with a list of variables</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to bind on a silver platter (but in reverse order).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  list_item **head = (list_item**)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_item_to_list(head, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(buffer, &quot;?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The <code>context</code> variable was set to be <code>vars</code>, we convert it back to the correct type
and add the current ast to that list.  <code>add_item_to_list</code> always puts things at the
head so the list will be in reverse order.</p><p>With this done, we&#x27;re pretty much set.  We&#x27;ll produce the statement with a sequence
like this one (there are a couple of variations, but this is the most general)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_prepare(_db_, %s%s_stmt,\n  &quot;, amp, stmt_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_pretty_quote_plaintext(temp.ptr, cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;);\n&quot;);</span></div></div></div></div></div><p><code>cg_pretty_quote_plaintext</code> is one of the C string encoding formats, it could have been just the regular C string encoding
but that would have been a bit wasteful and it wouldn&#x27;t have looked as nice.  This function does a little transform.</p><p>The normal echo of the update statement in question looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  UPDATE foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t = ?</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = ?;</span></div></div></div></div></div><p>Note that it has indenting and newlines embedded in it.  The standard encoding of that would look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;  UPDATE foo\n  SET t = ?\n    WHERE id = ?;&quot;</span></div></div></div></div></div><p>That surely works, but it&#x27;s wasteful and ugly. The pretty format instead produces:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;UPDATE foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SET t = ? &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;</span></div></div></div></div></div><p>So, the newlines are gone from the string (they aren&#x27;t needed), instead the string literal was broken into lines for readability.
The indenting is gone from the string, instead the string fragments are indented.  So what you get is a string literal that
reads nicely but doesn&#x27;t have unnecessary whitespace for SQLite.  Obviously you can&#x27;t use pretty-quoted literals in all cases,
it&#x27;s exclusively for SQLite formatting.</p><p>All that&#x27;s left to do is bind the arguments.  Remember that arg list is in reverse order:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = vars; item; item = item-&gt;next, count++) ;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  reverse_list(&amp;vars);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;cql_multibind(&amp;_rc_, _db_, %s%s_stmt, %d&quot;, amp, stmt_name, count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Now emit the binding args for each variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (list_item *item = vars; item; item = item-&gt;next)  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Contract(item-&gt;ast-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(cg_main_output, &quot;,\n              &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_bind_column(item-&gt;ast-&gt;sem-&gt;sem_type, item-&gt;ast-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;);\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><ul><li>first compute the count, we don&#x27;t need to bind if there are no variables</li><li><code>reverse_list</code> does exactly what is sounds like (finally a real-world use-case for reverse-list-in-place)</li><li><code>cg_bind_column</code> creates one line of the var-args output: column type and variable name<ul><li>the type and name information is right there on the <code>AST</code> in the <code>sem_node</code></li></ul></li></ul><p>And that&#x27;s it.  With those few helpers we can bind any SQLite statement the same way.  All of the
<code>DDL_STMT_INIT</code> and <code>DML_STMT_INIT</code> statements are completely implemented by this path.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reading-single-values"></a>Reading Single Values<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reading-single-values" title="Direct link to heading">#</a></h3><p>In many cases you need just one value</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER NOT NULL, OUT t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t_ := ( SELECT t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FROM foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_ );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This is going to be very similar to the examples we&#x27;ve seen so far:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_int32 id_, cql_string_ref _Nullable *_Nonnull t_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)t_, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _tmp_text_0 = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_temp_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *(void **)t_ = NULL; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;_temp_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT t &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;FROM foo &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;WHERE id = ?&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multibind(&amp;_rc_, _db_, &amp;_temp_stmt, 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_column_string_ref(_temp_stmt, 0, &amp;_tmp_text_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;*t_, _tmp_text_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(_tmp_text_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;_temp_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>_db_</code> : incoming arg for a procedure that uses the database same as always, check</li><li><code>*(void **)t_ = NULL;</code> : out args are always set to NULL on entry, note, there is no <code>release</code> here<ul><li>argument is assumed to be garbage, that&#x27;s the ABI</li><li>if argument is non-garbage caller must release it first, that&#x27;s the ABI</li></ul></li><li><code>_rc_</code> : same as always, check</li><li><code>_tmp_text_0</code> : new temporary text, including cleanup (this could have been avoided)</li><li><code>_temp_stmt</code> : as before, including cleanup</li><li><code>cql_prepare</code> : same as always, check</li><li><code>cql_multibind</code> : just one integer bound this time</li><li><code>sqlite3_step</code> : as before, we&#x27;re stepping once, this time we want the data</li><li><code>if (_rc_ != SQLITE_ROW)</code> new error check and goto cleanup if no row<ul><li>this is the same as the <code>IF NOTHING THROW</code> variant of construct, that&#x27;s the default</li></ul></li><li><code>cql_column_string_ref</code> : reads one string from <code>_temp_stmt</code></li><li><code>cql_finalize_stmt</code> : as before</li><li><code>cql_set_string_ref(&amp;*t_, _tmp_text_0)</code> : copy the temporary string to the out arg<ul><li>includes retain, out arg is NULL so <code>cql_set_string_ref</code> will do no release</li><li>if this were (e.g.) running in a loop, the out arg would not be null and there would be a release, as expected</li><li>if something else had previously set the out arg, again, there would be a release as expected</li></ul></li></ul><p>There are variations of this form such as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (id_ INTEGER NOT NULL, OUT t_ TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET t_ := ( SELECT t</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FROM foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    WHERE id = id_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    IF NOTHING &#x27;&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This simply changes the handling of the case where there is no row.  The that part of the code
ends up looking like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ == SQLITE_ROW) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_column_string_ref(_temp_stmt, 0, &amp;_tmp_text_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_string_ref(&amp;_tmp_text_0, _tmp_text_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_string_ref(&amp;_tmp_text_0, _literal_1_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><ul><li>any error code leads to cleanup</li><li><code>SQLITE_ROW</code> : leads to the same fetch as before</li><li><code>SQLITE_DONE</code> : leads to the no row case which sets <code>_tmp_text_0</code> to the empty string<ul><li><code>cql_string_literal(_literal_1_p, &quot;&quot;);</code> is included as a data declaration</li></ul></li></ul><p>There is also the <code>IF NOTHING OR NULL</code> variant which is left as an exercise to the reader.
You can find all the flavors in <code>cg_c.c</code> in the this function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is a nested select expression.  To evaluate we will</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * prepare a temporary to hold the result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * generate the bound SQL statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * extract the exactly one argument into the result variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    which is of exactly the right type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * use that variable as the result.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The helper methods take care of sqlite error management.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_select(...</span></div></div></div></div></div><p>This handles all of the <code>(select ...)</code> expressions and it has the usual expression handler
syntax. Another great example of a CQL expressions that might require many C statements
to implement.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reading-rows-with-cursors"></a>Reading Rows With Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reading-rows-with-cursors" title="Direct link to heading">#</a></h3><p>This section is about the cases where we are expecting results back from SQLite.  By results here
I mean the results of some kind of query, not like a return code.  SQLite does this by giving
you a <code>sqlite3_stmt *</code> which you can then use like a cursor to read out a bunch of rows.  So
it should be no surprise that CQL cursors map directly to SQLite statements.</p><p>Most of the code to get a statement we&#x27;ve already seen before, we only saw the <code>_temp_stmt</code>
case and we did very little with it.  Let&#x27;s look at the code for something a little bit more
general and we&#x27;ll see how little it takes to generalize.</p><p>First, let&#x27;s look at how a CQL cursor is initialized:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Now in this case there can only be one row in the result, but it would be no different if there were more.</p><p>Here&#x27;s the C code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _C_has_row_ = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;C_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT 1, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look over that code very carefully and see what is necessary to make it happen.</p><ul><li><code>_db_</code> : incoming arg for a procedure that uses the database same as always, check</li><li><code>_rc_</code> : same as always, check</li><li><code>C_stmt</code> : we need to generate this instead of using <code>_temp_stmt</code><ul><li><code>cql_finalize_stmt(&amp;C_stmt)</code> in cleanup, just like <code>_temp_stmt</code></li></ul></li><li><code>cql_prepare</code> : same as always, check</li><li><code>cql_multibind</code> : could have been binding, not none needed here, but same as always anyway, check</li><li>no step, no finalize (until cleanup) : that boiler-plate is removed</li></ul><p>And that&#x27;s it, we now have a statement in <code>C_stmt</code> ready to go.  We&#x27;ll see later that <code>_C_has_row_</code>
will track whether or not the cursor has any data in it.</p><p>How do we make this happen?  Well you could look at <code>cg_declare_cursor</code> and your eye might hurt at
first.  The truth is there are many kinds of cursors in CQL and this method handles all of them.
We&#x27;re going to go over the various flavors but for now we&#x27;re only discussing the so-called
&quot;statement cursor&quot;, so named because it simply holds a SQLite statement.  This was the
first, and for a while only, type of cursor added to the CQL language.</p><p>OK so how do we make a statement cursor.  It&#x27;s once again <code>cg_bound_sql_statement</code> just like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_bound_sql_statement(cursor_name, select_stmt, CG_PREPARE|CG_MINIFY_ALIASES);</span></div></div></div></div></div><p>The entire difference is that the first argument is the cursor name rather than NULL.  If you
pass NULL it means use the temporary statement.</p><p>And you&#x27;ll notice that even in this simple example the SQLite text was altered a bit:
the text that went to SQLite was <code>&quot;SELECT 1, 2&quot;</code> -- that&#x27;s CG_MINIFY_ALIASES at work.
SQLite didn&#x27;t need to see those column aliases, it makes no difference in the result.
Column aliases are often long and numerous.  Even in this simple example we saved 4 bytes.
But the entire query was only 12 bytes long (including trailing null) so that&#x27;s 25%.
It&#x27;s not a huge savings in general but it&#x27;s something.</p><p>The other flag <code>CG_PREPARE</code> tells the binder that it should not step or finalize the query.
The alternative is <code>CG_EXEC</code> (which was used in the previous section for the <code>UPDATE</code> example).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="fetching-data-from-cursors"></a>Fetching Data From Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#fetching-data-from-cursors" title="Direct link to heading">#</a></h3><p>The first cursor reading primitive that was implemented as <code>FETCH [cursor] INTO [variables]</code> and
it&#x27;s the simplest to understand so let&#x27;s start there.</p><p>We change the example just a bit:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C INTO x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>For simplicity I will only include the code that is added.  The rest is the same.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // same as before</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _C_has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div></div></div></div></div><p>Do to the <code>FETCH</code> we do the following:</p><ul><li>step the cursor</li><li>set the <code>_C_has_row_</code> variable so to indicate if we got a row or not</li><li>use the varargs <code>cql_multifetch</code> to read 2 columns from the cursor<ul><li>this helper simply uses the usual <code>sqlite3_*_column</code> functions to read the data out</li><li>again, we do it this way so that there is less error checking needed in the generated code</li><li>also, there are fewer function calls so the code is overall smaller</li><li>trivia: <code>multibind</code> and <code>multifetch</code> are totally references to <em>The Fifth Element</em><ul><li>hence, they should be pronounced like Leeloo saying &quot;multipass&quot;</li></ul></li></ul></li><li><code>multifetch</code> uses the varargs to clobber the contents of the target variables if there is no row according to <code>_rc_</code></li><li><code>multifetch</code> uses the <code>CQL_DATA_TYPE_NOT_NULL</code> to decide if it should ask SQLite first if the column is null</li></ul><p>So now this begs the question, in the CQL, how do you know if a row was fetched or not?</p><p>The answer is, you can use the cursor name like a boolean.  Let&#x27;s complicate this up a little more.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROCEDURE printf NO CHECK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C INTO x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH C INTO x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Again here is what is now added, we&#x27;ve seen the <code>WHILE</code> pattern before:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(_C_has_row_)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _C_has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>So, if you use the cursors name in an ordinary expression that is converted to a reference to
the boolean <code>_C_has_row_</code>.  Within the loop we&#x27;re going to print some data and then fetch the next row.
The internal fetch is of course the same as the first.</p><p>The next improvement that was added to the language was the <code>LOOP</code> statement.  Let&#x27;s take a look:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C INTO x, y</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The generated code is very similar:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _C_has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!_C_has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%d, %d\n&quot;, x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>This is done by:</p><ul><li>emit the <code>for (;;) {</code> to start the loop</li><li>generate the <code>FETCH</code> just as if it was standalone</li><li>emit <code>if (!_C_has_row_) break;</code> (with the correct cursor name)</li><li>use <code>cg_stmt_list</code> to emit the internal statement list (<code>CALL printf</code> in this case)</li><li>close the loop with <code>}</code> and we&#x27;re done</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cursors-with-storage"></a>Cursors With Storage<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cursors-with-storage" title="Direct link to heading">#</a></h3><p>We now come to the big motivating reasons for having the notion of shapes in the CQL language.
This particular case was the first such example in the language and it&#x27;s very commonly
used and saves you a lot of typing.  Like the other examples it&#x27;s only sugar in that
it doesn&#x27;t give you any new language powers you didn&#x27;t have, but it does give clarity
and maintenance advantages.  And it&#x27;s just a lot less to type.</p><p>Let&#x27;s go back to one of the earlier examples, but write it the modern way:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>And the generated C code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { 0 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;C_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT 1, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look at what&#x27;s different here:</p><ul><li><code>struct p_C_row</code> has been created, it contains:<ul><li><code>_has_row_</code> for the cursor</li><li><code>x</code> and <code>y</code> the data fields</li><li><code>_refs_count</code> the number of reference fields in the cursor (0 in this case)</li><li><code>_refs_offset</code> the offset of the references fields (they always go at the end)</li><li>because the references are together a cursor with lots of reference fields can be cleaned up easily</li></ul></li><li>in the generated code the variable <code>C</code> refers to the current data that has been fetched<ul><li>convenient for debugging <code>p C</code> in lldb shows you the row</li></ul></li><li>references to <code>x</code> and <code>y</code> became <code>C.x</code> and <code>C.y</code></li><li>references to <code>_C_has_row_</code> became <code>C._has_row_</code></li></ul><p>That&#x27;s pretty much it.  The beauty of this is that you can&#x27;t get the declarations of your locals wrong
and you don&#x27;t have to list them all no matter how big the data is.  If the data shape changes the
cursor change automatically changes to accommodate it.  Everything is still statically typed.</p><p>Now lets look at the loop pattern:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %d\n&quot;, C.x, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Note that the columns of the cursor were defined by the column aliases of the <code>SELECT</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!C._has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%d, %d\n&quot;, C.x, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The loop is basically the same except <code>x</code> and <code>y</code> have been replaced with <code>C.x</code> and <code>C.y</code>
and again <code>_C_has_row_</code> is now <code>C._has_row_</code>.</p><p>The code generator knows that it should allocate storage for the <code>C</code> cursor if it has
the flag <code>SEM_TYPE_HAS_SHAPE_STORAGE</code> on it. The semantic analyzer adds that flag
if it ever finds <code>FETCH C</code> with no <code>INTO</code> part.</p><p>Finally let&#x27;s look at an example with cleanup required.  We&#x27;ll just change the test case a tiny bit.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT 1 AS x, &quot;2&quot; AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL printf(&quot;%d, %s\n&quot;, C.x, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The <code>x</code> column is now text.  We&#x27;ll get this code which will be studied below:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, &amp;C_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT &#x27;1&#x27;, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!C._has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_alloc_cstr(_cstr_1, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%s, %d\n&quot;, _cstr_1, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_free_cstr(_cstr_1, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It&#x27;s very similar to what we had before, let&#x27;s quickly review the differences.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1</span></div></div></div></div></div><ul><li><code>x</code> is now <code>cql_string_ref _Nonnull x;</code> rather than <code>cql_int32</code></li><li><code>x</code> has moved to the end (because it&#x27;s a reference type)</li><li>the offset of the first ref is computed in a constant</li></ul><p>Recall the reference types are always at the end and together.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div></div></div></div></div><ul><li><code>p_C_row</code> is now initialized to to ref count 1 and refs offset <code>p_C_refs_offset</code> defined above</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div></div></div></div></div><ul><li>C.x is now of type string</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_alloc_cstr(_cstr_1, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;%s, %d\n&quot;, _cstr_1, C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_free_cstr(_cstr_1, C.x);</span></div></div></div></div></div><ul><li>C.x has to be converted to a C style string before it can be used with <code>printf</code> as a <code>%s</code> argument</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div></div></div></div></div><ul><li>the cleanup section has to include code to teardown the cursor, this will release all of its reference variables in bulk<ul><li>remember we know the count, and the offset of the first one -- that&#x27;s all we need to do them all</li></ul></li></ul><p>With these primitives we can easily create cursors of any shape and load them up with data.  We don&#x27;t have to
redundantly declare locals that match the shape of our select statements which is both error prone and
a hassle.</p><p>All of this is actually very easy for the code-generator.  The semantic analysis phase knows if the cursor needs
shape storage.  And it also recognizes when a variable reference like <code>C.x</code> happens, the variable references are
re-written in the AST so that the code-generator doesn&#x27;t even have to know there was a cursor reference, from
its perspective the variable IS <code>C.x</code> (which it sort of is).  The code generator does have to create the
storage for the cursor but it knows it should do so because the cursor variable is marked with <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>.
A cursor without this marking only gets its statement (but not always as we&#x27;ll see later) and its <code>_cursor_has_row_</code>
hidden variable.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flowing-sqlite-statements-between-procedures"></a>Flowing SQLite Statements Between Procedures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flowing-sqlite-statements-between-procedures" title="Direct link to heading">#</a></h3><p>Earlier we saw that we can get a cursor from a SQLite <code>SELECT</code> statement.  The cursor is used to iterate
over the <code>sqlite3_stmt *</code> that SQLite provides to us.  This process can be done between procedures.  Here&#x27;s a
simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@ATTRIBUTE(cql:private)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This is the first example of a procedure that return a result set that we&#x27;ve seen.  The wiring for this is
very simple.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CQL_WARN_UNUSED cql_code q(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_Nullable *_Nonnull _result_stmt)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *_result_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, _result_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT &#x27;1&#x27;, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ == SQLITE_OK &amp;&amp; !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>First note that there are now <em>two</em> hidden parameters to <code>q</code>:</p><ul><li><code>_db_</code> : the database pointer as usual,</li><li><code>_result_stmt</code> : the statement produced by this procedure</li></ul><p>The rest of the code is just like any other bound SQL statement.  Note that if
<code>_result_stmt</code> isn&#x27;t otherwise set by the code it will be initialized to a statement
that will return zero rows.</p><p>All of this is pretty much old news except for the new hidden variable.  Note let&#x27;s look how we might use
this.  We can write a procedure that calls <code>q</code>, like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR CALL q();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>This generates:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *C_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = q(_db_, &amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = sqlite3_step(C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C._has_row_ = _rc_ == SQLITE_ROW;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_multifetch(_rc_, C_stmt, 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_finalize_stmt(&amp;C_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>All of the above is <em>exactly</em> the same as the previous cases where we got
data from the database except that instead of using <code>cql_prepare</code> the
compiler produced <code>_rc_ = q(_db_, &amp;C_stmt);</code>  That function call gives us,
of course, a ready-to-use <code>sqlite3_stmt *</code> which we can then step, and
use to fetch values.  The shape of the cursor <code>C</code> is determined by the
result type of procedure <code>q</code> -- hence they always match.</p><p>If q was in some other module, it could be declared with:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC q () (x TEXT NOT NULL, y INTEGER NOT NULL);</span></div></div></div></div></div><p>This is a procedure that takes no arguments and returns a result with the indicated shape.</p><p>CQL can generate this declaration for you if you add <code>--generate_exports</code> to the command line.  Note
that in this case <code>q</code> was marked with <code>@attribute(cql:private)</code> which caused <code>q</code> to be <code>static</code>
in the output. Hence it can&#x27;t be called outside this translation unit and <code>--generate_exports</code>
won&#x27;t provide the declaration.</p><p>If the private annotation were removed, the full exports for this file would be:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC q () (x TEXT NOT NULL, y INTEGER NOT NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC p () USING TRANSACTION;</span></div></div></div></div></div><p>And these would allow calling both procedures from elsewhere.  Simply <code>#include</code> the exports file.</p><p>There is a special function in the echoing code that can emit a procedure that was created in the
form that is needed to declare it, this is <code>gen_declare_proc_from_create_proc</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="value-cursors"></a>Value Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#value-cursors" title="Direct link to heading">#</a></h3><p>Once CQL had the ability to fetch rows into a cursor with no need to declare all the locals
it was clear that it could benefit from the ability to save a copy of any given row. That is
basic cursor operations seemed like they should be part of the calculus of CQL.  Here&#x27;s a
simple sample program that illustrates this.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE D CURSOR LIKE C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH D from C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>We already have a good idea what is going to happen with <code>C</code> in this program.  Let&#x27;s look at the
generated code focusing just on the parts that involve <code>D</code>.</p><p>First there is a row defintion for <code>D</code>. Unsurprisingly it is exactly the samea as the one for <code>C</code>.
This must be the case since we specified <code>D CURSOR LIKE C</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_D_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_D_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_D_refs_offset cql_offsetof(p_D_row, x) // count = 1</span></div></div></div></div></div><p>Then the <code>D</code> cursor variables will be needed:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">p_D_row D = { ._refs_count_ = 1, ._refs_offset_ = p_D_refs_offset };</span></div></div></div></div></div><p>The above also implies the cleanup code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(D);</span></div></div></div></div></div><p>finally, we fetch <code>D</code> from <code>C</code>.  That&#x27;s just some assignments:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  D._has_row_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;D.x, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  D.y = C.y;</span></div></div></div></div></div><p>Importantly, there is no <code>D_stmt</code> variable.  <code>D</code> is <em>not</em> a statement cursor like <code>C</code>, it&#x27;s
a so-called &quot;value&quot; cursor.  In that it can only hold values.</p><p>A value cursor can actually be loaded from anywhere, it just holds data.  You don&#x27;t
loop over it (attempts to do so will result in errors).</p><p>The general syntax for loading such a cursor is something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> FETCH D(x, y) FROM VALUES(C.x, C.y);</span></div></div></div></div></div><p>And indeed the form <code>FETCH D FROM C</code> was rewritten automatically into the general form.
The short form is just sugar.</p><p>Once loaded, <code>D.x</code> and <code>D.y</code> can be used as always.  The data type of <code>D</code> is similar to <code>C</code>.</p><p>The AST would report:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{declare_cursor_like_name}: D: select: { x: text notnull, y: integer notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   variable shape_storage value_cursor</span></div></div></div></div></div><p>meaning <code>D</code> has the flags <code>SEM_TYPE_STRUCT</code>, <code>SEM_TYPE_VARIABLE</code>, <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>, and <code>SEM_TYPE_VALUE_CURSOR</code>.
That last flag indicates that there is no statement for this cursor, it&#x27;s just values. And all such cursors must have
<code>SEM_TYPE_HAS_SHAPE_STORAGE</code> -- if they had no statement and no storage they would be -- nothing.</p><p>Value cursors are enormously helpful and there is sugar for loading them from all kinds of sources with a shape.
These forms are described more properly in <a href="https://cgsql.dev/cql-guide/ch05" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the Guide but they
all end up going through the general form, making the codegen considerably simpler. There are many examples where the semantic
analyzer rewrites a sugar form to a canonical form to keep the codegen from forking into dozens of special cases
and most of them have to do with shapes and cursors.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="returning-value-cursors"></a>Returning Value Cursors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#returning-value-cursors" title="Direct link to heading">#</a></h3><p>Let&#x27;s look at an example that is similar to the previous one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@ATTRIBUTE(cql:private)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR LIKE SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C USING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   &quot;foo&quot; x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   3 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  OUT C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FETCH FROM CALL q();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  -- do something with C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Let&#x27;s discuss some of what is above, first looking at <code>q</code>:</p><ul><li><code>DECLARE C CURSOR LIKE SELECT &quot;1&quot; AS x, 2 AS y;</code> : this makes an empty value cursor<ul><li>note the shape is <code>LIKE</code> the indicated <code>SELECT</code>, the <code>SELECT</code> does not actually run</li></ul></li><li><code>FETCH ... USING</code> : this form is sugar, it lets you put the column names <code>x</code> and <code>y</code> adjacent to the values but is otherwise equivalent to the canonical form<ul><li><code>FETCH C(x, y) FROM VALUES(&quot;foo&quot;, 3);</code> is the canonical form</li><li>codegen only ever sees the canonical form</li></ul></li><li><code>OUT C</code> is new, we&#x27;ll cover this shortly</li></ul><p>Now let&#x27;s look at the C for <code>q</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct q_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} q_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define q_refs_offset cql_offsetof(q_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_foo_q, &quot;foo&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct q_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} q_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define q_C_refs_offset cql_offsetof(q_C_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void q(q_row *_Nonnull _result_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  memset(_result_, 0, sizeof(*_result_));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_C_row C = { ._refs_count_ = 1, ._refs_offset_ = q_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C._has_row_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;C.x, _literal_1_foo_q);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C.y = 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;_has_row_ = C._has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;_refs_count_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;_refs_offset_ = q_refs_offset;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;_result_-&gt;x, C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _result_-&gt;y = C.y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>the <code>_result_</code> variable is clobbed with zeros, it is assumed to be junk coming in<ul><li>if it had valid data, the caller is expected to use <code>cql_teardown_row</code> to clean it up <em>before</em> calling</li></ul></li><li><code>q_row</code> : this is new, this is the structure type for the result of <code>q</code><ul><li>it&#x27;s exactly the same shape as C</li><li>it has its own <code>q_refs_offset</code> like other shapes</li></ul></li><li><code>q_C_row</code> : this is the same old same old row structure for cursor C</li><li><code>static void q(q_row *_Nonnull _result_)</code> : q now accepts a q_row to fill in!<ul><li>note that <code>q</code> does not have the <code>_db_</code> parameter, it doesn&#x27;t use the database!</li><li>it is entirely possible to fill value cursors from non-database sources, e.g. constants, math, whatever</li></ul></li><li><code>C</code> : the value cursor is declared as usual</li><li><code>C.x</code> and <code>C.y</code> are loaded, this resolves the <code>FETCH</code> statement</li><li>the <code>_result_</code> fields are copied from <code>C</code>, this resolves the <code>OUT</code> statement</li><li><code>C</code> can be torn down</li><li>there is no cleanup label, there are no error cases, nothing can go wrong!</li></ul><p>The net of all this is that we have loaded a value cursor that was passed in to the procedure via
a hidden argument and it has retained references as appropriate.</p><p>Now let&#x27;s look at <code>p</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q((q_row *)&amp;C); // q_row identical to cursor type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // usually you do something with C at this point</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_teardown_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>p_C_row</code> : the cursor type for <code>C</code> in the procedure <code>p</code> is defined</li><li><code>p_C_refs_offset</code> : the refs offset for <code>C</code> in <code>p</code> as usual</li><li><code>C = {...}</code> : the usual initialization for a cursor with shape<ul><li>note that <code>C</code> is a value cursor, so it has no <code>C_stmt</code></li></ul></li><li><code>cql_teardown_row(C)</code> : releases any references in C, there are none<ul><li>this pattern is general purpose, the call to <code>q</code> might be in a loop or something</li><li>in this instance the teardown here is totally redundant, but harmless</li></ul></li><li><code>q((q_row *)&amp;C)</code> : fetch <code>C</code> by calling <code>q</code><ul><li><code>p_C_row</code> has been constructed to be exactly the same as <code>q_row</code> so this cast is safe</li><li>there are no error checks because <code>q</code> can&#x27;t fail!</li></ul></li><li>some code that would use <code>C</code> is absent for this sample, it would go where the comment is</li><li>the cleanup label is missing because there are no error cases, emitting the label would just cause warnings<ul><li>such warnings are often escalated to errors in production builds...</li></ul></li><li><code>cql_teardown_row(C)</code> is needed as always,<ul><li>even though there is no cleanup label the <code>teardown</code> is in the cleanup section</li><li>the <code>teardown</code> was added as usual when <code>C</code> was declared</li></ul></li></ul><p>So with just normal value cursor codegen we can pretty easily create a situation where
procedures can move structures from one to another.  As we saw, the source of value cursors
may or may not be the database.  Value cursors are frequently invaluable in test code
as they can easily hold mock rows based on any kind of computation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-sets"></a>Result Sets<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-sets" title="Direct link to heading">#</a></h3><p>In addition to returning a single row into a value cursor, or returning a statement to consume with a statement cursor,
it&#x27;s possible to generate a result set.  So far the samples have included <code>@attribute(cql:private)</code> to suppress that
code.  This pattern is intended to let regular C code access the data so <code>private</code> suppresses it.</p><p>Let&#x27;s consider a simple example, this example returns only one row but the mechanism works for any number of rows,
we&#x27;re just using this form because it&#x27;s what we&#x27;ve used so far and its simple.  Let&#x27;s begin:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The core generated function is this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *_result_stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = cql_prepare(_db_, _result_stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;SELECT &#x27;1&#x27;, 2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ == SQLITE_OK &amp;&amp; !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We&#x27;ve seen this before, it creates the SQLite statement.  But that isn&#x27;t all the code that was generated,
let&#x27;s have a look at what else we got in our outputs:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p_fetch_results(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3 *_Nonnull _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_result_set_ref _Nullable *_Nonnull result_set)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *stmt = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_profile_start(CRC_p, &amp;p_perf_index);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code rc = p(_db_, &amp;stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_fetch_info info = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .rc = rc,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .db = _db_,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .stmt = stmt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .data_types = p_data_types,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .col_offsets = p_col_offsets,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .refs_count = 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .refs_offset = p_refs_offset,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .encode_context_index = -1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .rowsize = sizeof(p_row),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .crc = CRC_p,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .perf_index = &amp;p_perf_index,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cql_fetch_all_results(&amp;info, (cql_result_set_ref *)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>p_fetch_results</code> does two main things:</p><ul><li><code>cql_code rc = p(_db_, &amp;stmt)</code> : it calls the underlying function to get the statement</li><li><code>cql_fetch_all_results</code> : it calls a standard helper to read all the results from the statement and put them into <code>result_set</code><ul><li>to do the fetch, it sets up a <code>cql_fetch_info</code> for this result set, this has all the information needed to do the fetch</li><li>the intent here is that even a complex fetch with lots of columns can be done economically, and</li><li>the code that does the fetching is shared</li></ul></li></ul><p>Let&#x27;s look at the things that are needed to load up that <code>info</code> structure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref _Nonnull x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">uint8_t p_data_types[p_data_types_count] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // x</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // y</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_refs_offset cql_offsetof(p_row, x) // count = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static cql_uint16 p_col_offsets[] = { 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_offsetof(p_row, x),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_offsetof(p_row, y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div></div></div><ul><li><code>p_row</code> : the row structure for this result set, same as always, reference types last</li><li><code>p_data_types</code> : an array with the data types encoded as bytes</li><li><code>p_refs_offset</code> : the offset of the first reference type</li><li><code>p_col_offsets</code> : this is the offset of each column within the row structure<ul><li>these are in column order, not offset order</li></ul></li></ul><p>Code generation creates a <code>.c</code> file and a <code>.h</code> file, we haven&#x27;t talked much about the <code>.h</code>
because it&#x27;s mostly prototypes for the functions in the <code>.c</code> file.  But in this case we have
a few more interesting things.  We need just two of them:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CRC_p -6643602732498616851L</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_data_types_count 2</span></div></div></div></div></div><p>Now we&#x27;re armed to discuss loading the <code>info</code> structure:</p><ul><li><code>.rc</code> : the fetcher needs to know if <code>p</code> was successful, it won&#x27;t read from the statement if it wasn&#x27;t</li><li><code>.db</code> : the database handle, the fetcher needs this to call SQLite APIs</li><li><code>.stmt</code> : the statement that came from <code>p</code> that is to be enumerated</li><li><code>.data_types</code> : types of the columns, this tells the fetcher what columns to read to the statement in what order</li><li><code>.col_offsets</code> : the column offsets, this tells the fetcher were to store the column data within each row</li><li><code>.refs_count</code> : the number of references in the row, this is needed to tear down the rows in the result set when it is released</li><li><code>.refs_offset</code> : the first reference offset, as usual this tells the fetcher where the references that need to be released are</li><li><code>.encode_context_index</code> : it&#x27;s possible to have sensitive fields encoded, this identifies an optional column that will be combined with the sensitive data
. <code>.rowsize</code> : the size of <code>p_row</code>, this is needed to allocate rows in a growable buffer</li><li><code>.crc</code> : this is a CRC of the code of <code>p</code>, it&#x27;s used to uniquely identify <code>p</code> economically, performance logging APIs typically use this CRC in a begin/end logging pair</li><li><code>.perf_index</code> : performance data for stored procedures is typically stored in an array of stats, CQL provides storage for the index for each procedure</li></ul><p>With this data (which is in the end pretty small) the <code>cql_fetch_all_results</code> can do all the things it needs to do:</p><ul><li><code>cql_profile_start</code> has already been called, it can call <code>cql_profile_end</code> once the data is fetched<ul><li><code>cql_profile_start</code> and <code>_end</code> do nothing by default, but those macros can be defined to log performance data however you like</li></ul></li><li>it can allocate a <code>bytebuf</code> with <code>cql_bytebuf_open</code> and then grow it with <code>cql_bytebuf_alloc</code><ul><li>in the end all the rows are in one contiguous block of storage</li></ul></li><li><code>cql_multifetch_meta</code> is used to read each row from the result set, it&#x27;s similar to <code>cql_multifetch</code><ul><li>the <code>meta</code> version uses <code>data_types</code> and <code>column_offsets</code> instead of varargs but is otherwise the same</li><li>the first member of the <code>col_offsets</code> array is the count of columns</li></ul></li></ul><p>With this background, <code>cql_fetch_all_results</code> should be very approachable.  There&#x27;s a good bit of work but it&#x27;s all very simple.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// By the time we get here, a CQL stored proc has completed execution and there is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// now a statement (or an error result).  This function iterates the rows that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// come out of the statement using the fetch info to describe the shape of the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected results.  All of this code is shared so that the cost of any given</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stored procedure is minimized.  Even the error handling is consolidated.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_code cql_fetch_all_results(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_fetch_info *_Nonnull info,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_result_set_ref _Nullable *_Nonnull result_set) {...}</span></div></div></div></div></div><p>The core of that function looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bytebuf_open(&amp;b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    rc = sqlite3_step(stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (rc == SQLITE_DONE) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (rc != SQLITE_ROW) goto cql_error;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    count++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    row = cql_bytebuf_alloc(&amp;b, rowsize);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    memset(row, 0, rowsize);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_multifetch_meta((char *)row, info);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_profile_stop(info-&gt;crc, info-&gt;perf_index);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><ul><li><code>cql_bytebuf_open</code> : open the buffer, get ready to start appending rows</li><li><code>sqlite3_step</code> : keep reading while we get <code>SQLITE_ROW</code>, stop on <code>SQLITE_DONE</code></li><li><code>cql_bytebuf_alloc</code> : allocate a new row in the buffer</li><li><code>memset</code> : zero the row</li><li><code>cql_multifetch_meta</code> : read the data from the the statement into the row</li><li><code>cql_profile_stop</code> : signals that processing is done and profiling can stop</li><li>if all goes well, <code>SQLITE_OK</code> is returned as usual</li></ul><p>The remaining logic is largely about checking for errors and tearing down the result set
if anything goes wrong.  There is not very much to it, and it&#x27;s worth a read.</p><p>Now recall that the way <code>cql_fetch_all_results</code> was used, was as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cql_fetch_all_results(&amp;info, (cql_result_set_ref *)result_set)</span></div></div></div></div></div><p>And <code>result_set</code> was the out-argument for the the <code>p_fetch_results</code> method.</p><p>So <code>p_fetch_results</code> is used to get that result set.  But what can you do with it?
Well, the result set contains copy of all the selected data, ready to use in with a C-friendly API.
The interface is in the generated <code>.h</code> file.  Let&#x27;s look at that now, it&#x27;s the final piece of the puzzle.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#ifndef result_set_type_decl_p_result_set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define result_set_type_decl_p_result_set 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_result_set_type_decl(p_result_set, p_result_set_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_string_ref _Nonnull p_get_x(p_result_set_ref _Nonnull result_set, cql_int32 row);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_int32 p_get_y(p_result_set_ref _Nonnull result_set, cql_int32 row);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_int32 p_result_count(p_result_set_ref _Nonnull result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern CQL_WARN_UNUSED cql_code p_fetch_results(sqlite3 *_Nonnull _db_, p_result_set_ref _Nullable *_Nonnull result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_row_hash(result_set, row) cql_result_set_get_meta( \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (cql_result_set_ref)(result_set))-&gt;rowHash((cql_result_set_ref)(result_set), row)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define p_row_equal(rs1, row1, rs2, row2) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_result_set_get_meta((cql_result_set_ref)(rs1))-&gt;rowsEqual( \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (cql_result_set_ref)(rs1), \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    row1, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (cql_result_set_ref)(rs2), \</span></div></div></div></div></div><ul><li><code>cql_result_set_type_decl</code> : declares <code>p_result_set_ref</code><ul><li>to avoid being defined more than once, the declaration is protected by <code>#ifndef result_set_type_decl_p_result_set</code></li></ul></li><li><code>p_get_x</code>, <code>p_get_y</code> : allow access to the named fields of the result set at any given row</li><li><code>p_result_count</code> :  provides the count of rows in the result set</li><li><code>p_fetch_results</code> : the declaration of the fetcher (previously discussed)</li><li><code>p_row_hash</code> : provides a hash of any given row, useful for detecting changes between result sets</li><li><code>p_row_equal</code> : tests two rows in two results sets of the same shape for equality</li></ul><p>The getters are defined very simply:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull p_get_x(p_result_set_ref _Nonnull result_set, cql_int32 row) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_row *data = (p_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data[row].x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int32 p_get_y(p_result_set_ref _Nonnull result_set, cql_int32 row) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_row *data = (p_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data[row].y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The <code>p_row</code> is exactly the right size, and of course the right shape, the final access looks something like <code>data[row].x</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-sets-from-the-out-statement"></a>Result Sets from the OUT statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-sets-from-the-out-statement" title="Direct link to heading">#</a></h4><p>Recalling this earlier example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR LIKE SELECT &quot;1&quot; AS x, 2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FETCH C USING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   &quot;foo&quot; x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   3 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  OUT C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>The original example had <code>@attribute(cql:private)</code> to suppress the result set, but normally a one-row result is
is generated from such a method.  The C API is almost identical.  However, there count is always 0 or 1.</p><p>The getters do not have the row number:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_string_ref _Nonnull q_get_x(q_result_set_ref _Nonnull result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extern cql_int32 q_get_y(q_result_set_ref _Nonnull result_set);</span></div></div></div></div></div><p>The actual getters are nearly the same as well</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull q_get_x(q_result_set_ref _Nonnull result_set) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_row *data = (q_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data-&gt;x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int32 q_get_y(q_result_set_ref _Nonnull result_set) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_row *data = (q_row *)cql_result_set_get_data((cql_result_set_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return data-&gt;y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Basically <code>data[row].x</code> just became <code>data-&gt;x</code> and the rest is nearly the same.
Virtually all the code for this is shared.</p><p>You can find all this and more in <code>cg_c.c</code> by looking here:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If a stored procedure generates a result set then we need to do some extra work</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to create the C friendly rowset creating and accessing helpers.  If stored</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// proc &quot;foo&quot; creates a row set then we need to:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * emit a struct &quot;foo_row&quot; that has the shape of each row</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    * this isn&#x27;t used by the client code but we use it in our code-gen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * emit a function &quot;foo_fetch_results&quot; that will call &quot;foo&quot; and read the rows</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    from the statement created by &quot;foo&quot;.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    * this method will construct a result set object via cql_result_create and store the data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    * the remaining functions use cql_result_set_get_data and _get_count to get the data back out</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * for each named column emit a function &quot;foo_get_[column-name]&quot; which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    gets that column out of the rowset for the indicated row number.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * prototypes for the above go into the main output header file</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_proc_result_set(ast_node *ast)</span></div></div></div></div></div><p>There are many variations in that function to handle the cases mentioned so far, but they are
substantially similar to each other with a lot of shared code.  There is one last variation
we should talk about and that is the <code>OUT UNION</code> form.  It is the most flexible of them all.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-sets-from-the-out-union-statement"></a>Result Sets from the OUT UNION statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-sets-from-the-out-union-statement" title="Direct link to heading">#</a></h4><p>The <code>OUT</code> statement, allows the programmer to produce a result set that has exactly one row,
<code>OUT UNION</code> instead accumulates rows.  This is very much like writing your own <code>fetcher</code> procedure
with your own logic.  The data could come from the database, by, for instance, enumerating
a cursor.  Or it can come from some computation or a mix of both.  Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC q ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR LIKE SELECT 1 AS x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET i := 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE i &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH C(x) FROM VALUES(i);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    OUT UNION C;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET i := i + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>Let&#x27;s look at the code for the above, it will be very similar to other examples we&#x27;ve seen so far:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct q_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} q_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void q_fetch_results(q_result_set_ref _Nullable *_Nonnull _result_set_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bytebuf _rows_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bytebuf_open(&amp;_rows_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *_result_set_ = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_C_row C = { 0 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 i = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_profile_start(CRC_q, &amp;q_perf_index);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  i = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(i &lt; 5)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C.x = i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_retain_row(C);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (C._has_row_) cql_bytebuf_append(&amp;_rows_, (const void *)&amp;C, sizeof(C));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    i = i + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_results_from_data(SQLITE_OK, &amp;_rows_, &amp;q_info, (cql_result_set_ref *)_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>q_C_row</code> : the shape of the cursor, as always</li><li><code>_rows_</code> : the <code>bytebuf</code> that will hold our data</li><li><code>cql_bytebuf_open(&amp;_rows_);</code> : initializes the buffer</li><li><code>cql_profile_start(CRC_q, &amp;q_perf_index);</code> : start profiling as before</li><li><code>for (;;)</code> : the while pattern as before</li><li><code>C.x = i;</code> : loads the cursor</li><li><code>cql_retain_row(C);</code> : retains any references in the cursor (there are none)<ul><li>we&#x27;re about to copy the cursor into the buffer so all refs need to be +1</li></ul></li><li><code>cql_bytebuf_append</code> : append the the cursor&#x27;s bytes into the buffer</li><li>the loop does its repetitions until finally</li><li><code>cql_results_from_data</code> : used instead of <code>cql_fetch_all_results</code> because all the data is already prepared<ul><li>in this particular example there is nothing to go wrong so it always gets <code>SQLITE_OK</code></li><li>in a more complicated example, <code>cql_results_from_data</code> frees any partly created result set in case of error</li><li><code>cql_results_from_data</code> also performs any encoding of sensitive data that might be needed</li></ul></li><li><code>q_info</code> : created as before, but it can be static as it&#x27;s always the same now</li></ul><p>Importantly, when using <code>OUT UNION</code> the codegen only produces <code>q_fetch_results</code>, there is no <code>q</code>.
If you try to call <code>q</code> from CQL you will instead call <code>q_fetch_results</code>. But since
many results as possible, a cursor is needed to make the call.</p><p>Here&#x27;s an example, here <code>p</code> calls the <code>q</code> method above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (OUT s INTEGER NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE C CURSOR FOR CALL q();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET s := s + C.x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>And the relevant code for this is as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct p_C_row {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool _has_row_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint16 _refs_offset_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} p_C_row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull s) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)s, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_result_set_ref C_result_set_ = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 C_row_num_ = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 C_row_count_ = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p_C_row C = { 0 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *s = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  q_fetch_results(&amp;C_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C_row_num_ = C_row_count_ = -1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C_row_num_++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    C._has_row_ = C_row_num_ &lt; C_row_count_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!C._has_row_) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *s = (*s) + C.x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_object_release(C_result_set_);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>p_C_row</code> : the cursor row as always</li><li><code>cql_contract_argument_notnull((void *)s, 1)</code> : verify that the out arg pointer is not null</li><li><code>C_result_set_</code> : this will hold the result set from <code>q_fetch_results</code></li><li><code>C_row_num_</code> : the current row number being processed in the result set</li><li><code>C_row_count_</code> : the total number of rows in the result set</li><li>other locals are intialized as usual</li><li><code>*s = 0;</code> : set the out arg to non-garbage as usual</li><li><code>q_fetch_results</code> : get the result set from <code>q_fetch_results</code><ul><li>in this case no database access was required so this API can&#x27;t fail</li><li><code>C_row_num</code> : set to -1</li><li><code>C_row_count</code> : set to the row count</li></ul></li><li><code>cql_copyoutrow</code> : copies one row from the result set into the cursor</li><li><code>*s = (*s) + C.x;</code> : computes the sum</li><li><code>cql_object_release</code> : the result set is torn down</li><li>if there are any reference fields in the cursor there would have been a <code>cql_teardown_row(C)</code></li></ul><p>In short, this is another form of cursor, it&#x27;s a value cursor, so it has no statement but
it also needs a result set, a count and an index to go with it so that it can enumerate the result set.</p><p>In the AST it looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{name C}: C: select: { x: integer notnull } variable shape_storage uses_out_union</span></div></div></div></div></div><p>This implies we have the semantic flags: <code>SEM_TYPE_STRUCT</code>, <code>SEM_TYPE_VARIABLE</code>, <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>, and <code>SEM_TYPE_USES_OUT_UNION</code>.</p><p>The difference is of course the presence of <code>SEM_TYPE_USES_OUT_UNION</code>.</p><p>This is the last of the cursor forms and the final complication of <code>cg_proc_result_set</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap-1"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap-1" title="Direct link to heading">#</a></h3><p>At present <code>cg_c.c</code> is a little over 7400 lines of code, maybe 1500 of those lines are comments.   So <code>cg_c.c</code> is actually quite a
bit smaller and simpler than <code>sem.c</code> (roughly 1/3 the size).  It is, however, the most complex of the code generators by far.
Part 3 of the internals guide has come out a lot larger than Part 2 but that&#x27;s mainly because there are a few more cases worth
discussing in detail and the code examples of Part 3 are bigger than the AST examples of Part 2.</p><p>Topics covered included:</p><ul><li>compiling expressions into C, including nullable types</li><li>techniques used to generate control flow</li><li>creation of result sets, including:<ul><li>various helpers to do the reading economically</li><li>the use of <code>cql_bytebuf</code> to manage the memory</li></ul></li><li>create the text for SQLite statements and binding variables to that text</li><li>error management, and how it relates to <code>TRY</code> and <code>CATCH</code> blocks</li><li>use of cleanup sections to ensure that references and SQLite statement lifetime is always correct</li><li>the contents of the <code>.c</code> and <code>.h</code> files and the key sections in them</li><li>the use of <code>charbuf</code> to create and assemble fragments</li></ul><p>As with the other parts, this is not a complete discussion of the code but a useful survey that
should give readers enough context to understand <code>cg_c.c</code> and the runtime helpers in <code>cqlrt.c</code>
and <code>cqlrt_common.c</code>.  Good luck in your personal exploration!</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-4-testing"></a>Part 4: Testing<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-4-testing" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-3"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-3" title="Direct link to heading">#</a></h3><p>Part 4 continues with a discussion of the essentials testing frameworks for the CQL compiler.
As in the previous sections, the goal here is not to go over every detail but rather to give
a sense of how testing happens in general -- the core strategies and implementation choices --
so that when reading the tests you will have an idea how it all hangs together. To accomplish
this, various key tools will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="testing"></a>Testing<a aria-hidden="true" tabindex="-1" class="hash-link" href="#testing" title="Direct link to heading">#</a></h2><p>There are several types of tests in the system, all of which are launched by the <code>test.sh</code>
script which builds the compiler and does a full test pass, there are well over 3000 tests
as of this writing.  Broadly these are in these few categories:</p><ul><li><p><strong>parse tests</strong> : these are in <code>test.sql</code></p><ul><li>the test script verifies that the compiler can parse this file with no errors</li><li>the parse pass echoes what it read in normalized form, this is compared against a reference copy and any differences are noted</li><li>each difference can be accepted or rejected; rejecting a difference stops the script</li><li>verification here is very light and in fact much of parsing is actually tested in the next pass</li></ul></li><li><p><strong>semantic tests</strong> : these are in <code>sem_test.sql</code></p><ul><li>the file has no parse errors but it has MANY semantic errors, nearly every such error in fact</li><li>semantic analysis is run with the <code>--test</code> flag which produces AST fragments and echoed CQL</li><li>the test file includes patterns which either must appear, or must not appear, in the output to pass the test</li><li>the AST includes full type information, so virtually anything about the semantic results can be, and is, verified</li><li>many tests are designed to exercise the parser as well, ensuring that the correct AST was built and then analyzed<ul><li>e.g. operator precedence can be verified here</li><li>the AST echoing logic can also be verified here, e.g. placement of parenthesis in the echoed output</li></ul></li><li>any semantic rewrites can be verified here because the rewritten form is emitted in the test output, not the original input</li><li>all other operations that happen during the semantic pass (e.g. constant evaluation) are also tested here</li><li>the full semantic output is also normalized (e.g. removing line numbers) and is compared against a reference copy, any differences are noted</li><li>each difference can be accepted or rejected; rejecting a difference stops the script</li><li>there are additional files to test different modes like &quot;previous schema&quot; validation (q.v.) as well as dev mode and the schema migrator, the files in this family are: <code>sem_test.sql</code>, <code>sem_test_dev.sql</code>, <code>sem_test_migrate.sql</code>, <code>sem_test_prev.sql</code></li></ul></li><li><p><strong>code gen tests</strong> : the basic test in this family is <code>cg_test.sql</code> which has the C codegen tests</p><ul><li>these test files do pattern matching just like the semantic case except the codegen output is checked rather than the AST</li><li>the test output is normalized and checked against a reference, just like the semantic tests</li><li>there is generally no need to check for errors in test output because all errors are detected during semantic analysis</li><li>there are MANY tests in this family, at least one for each of the various generators:<ul><li><code>cg_test.sql</code>, <code>cg_test_assembly_query.sql</code>, <code>cg_test_base_fragment.sql</code>, <code>cg_test_base_java_fragment.sql</code>, <code>cg_test_c_type_getters.sql</code>, <code>cg_test_extension_fragment.sql</code>, <code>cg_test_extension_java_fragment.sql</code>, <code>cg_test_generate_copy.sql</code>, <code>cg_test_generated_from.sql</code>, <code>cg_test_json_schema.sql</code>, <code>cg_test_no_result_set.sql</code>, <code>cg_test_out_object.sql</code>, <code>cg_test_out_union.sql</code>, <code>cg_test_prev_invalid.sql</code>, <code>cg_test_query_plan.sql</code>, <code>cg_test_schema_upgrade.sql</code>, <code>cg_test_single_proc_not_nullable.sql</code>, <code>cg_test_single_proc_nullable.sql</code>, <code>cg_test_suppressed.sql</code>, <code>cg_test_test_helpers.sql</code>, <code>cg_test_with_object.sql</code>,</li></ul></li></ul></li><li><p><strong>run tests</strong> : the main run test creatively named <code>run_test.sql</code></p><ul><li>this test code is compiled and excuted</li><li>the test contains expectations like any other unit test</li><li>it has CQL parts and C parts, the C parts test the C API to the procedures, plus do initial setup</li><li>these test include uses of all CQL features and all of the CQL runtime features</li><li>the schema upgrader tests are arguably &quot;run tests&quot; as well in that they run the code but they have a much different verification strategy</li></ul></li><li><p><strong>unit test</strong> : the compiler supports the <code>--run_unit_tests</code> flag</p><ul><li>this causes the compile to self-test certain of its helper functions that are otherwise difficult to test</li><li>mostly this is buffers that need to be growable to but in practice only grow with huge input files</li><li>other exotic cases that would be hard to reliability hit in some other fashion are covered by this code</li></ul></li></ul><p>Test coverage is maintained at 100% line coverage (sometimes there are a few
hours when it drops to 99.9% or something like that but this never lasts).
Branch coverage is not especially targetted but is nonethless quite high. To
see the true branch coverage you have to build the compiler with the asserts
(Contract and Invariant) off.  Last time it was measured, it was well over 80%.</p><p>To start the tests you should run <code>test.sh</code>, this launches <code>common/test_common.sh</code> to do the work.
This structure allows anyone to make their own harness that launches the common test passes and adds
their own extra tests, or passes in additional flags.  <code>test.sh</code> itself uses <code>make</code> to
build the compiler.</p><p>As mentioned above, <code>test.sh</code> normally allows the user to accept or reject differences in output, but
this is automatically disabled in non-terminal environments, and manually disabled if the script is
run with <code>--non_interactive</code>. <code>ok.sh</code> can be run to copy all of the outputs from the most recent test
run over the previous references.</p><p>To get the coverage report, use <code>cov.sh</code> which in turn launches <code>test.sh</code> with suitable flags
and then assembles the coverage report using <code>gcovr</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="parse-tests"></a>Parse Tests<a aria-hidden="true" tabindex="-1" class="hash-link" href="#parse-tests" title="Direct link to heading">#</a></h3><p>Looking at <code>test/test_common.sh</code> we find the source for the most basic test.  This is entirely
unremarkable stuff.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function-name function" style="color:rgb(130, 170, 255)">basic_test</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;--------------------------------- STAGE 2 -- BASIC PARSING TEST&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> running </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/test.sql&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">${CQL}</span><span class="token plain"> --dev --in </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/test.sql&quot;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/test.out&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> basic parsing </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">test</span><span class="token plain"> failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;  computing diffs (empty if none)&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  on_diff_exit test.out</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><ul><li>it&#x27;s &quot;STAGE 2&quot; because &quot;STAGE 1&quot; was the build</li><li>all it tries to do is run the compiler over <code>test/test.sql</code></li><li>if there are errors the test fails</li><li>if there are any differences between <code>test.out</code> and <code>test.out.ref</code> the test fails</li></ul><p>That&#x27;s it.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="sematic-tests"></a>Sematic Tests<a aria-hidden="true" tabindex="-1" class="hash-link" href="#sematic-tests" title="Direct link to heading">#</a></h3><p>The semantic tests are not much different but this is where the pattern matching comes in.</p><p>First let&#x27;s look at the shell script:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function-name function" style="color:rgb(130, 170, 255)">semantic_test</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;--------------------------------- STAGE 4 -- SEMANTIC ANALYSIS TEST&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> running semantic analysis </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">test</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> sem_check --sem --ast --dev --in </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/sem_test.sql&quot;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/sem_test.out&quot;</span><span class="token plain"> </span><span class="token operator file-descriptor important" style="color:rgb(137, 221, 255)">2</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/sem_test.err&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;CQL semantic analysis returned unexpected error code&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token function" style="color:rgb(130, 170, 255)">cat</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/sem_test.err&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> validating output trees</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cql-verify&quot;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/sem_test.sql&quot;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/sem_test.out&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> failed verification</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> running dev semantic analysis </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">test</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">..</span><span class="token plain">. same thing again </span><span class="token keyword" style="font-style:italic">for</span><span class="token plain"> sem_test_dev.sql</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;  computing diffs (empty if none)&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  on_diff_exit sem_test.out</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  on_diff_exit sem_test.err</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">..</span><span class="token plain">. same thing again </span><span class="token keyword" style="font-style:italic">for</span><span class="token plain"> sem_test_dev.out and .err</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>There are basically 3 steps:</p><ul><li>run the compiler over <code>test/sem_test.sql</code><ul><li>fail if this generates no errors (yes you read that right, see below)</li></ul></li><li>do the pattern matching on the output using <code>cql-verify</code> to ensure the patterns match (discussed below)<ul><li>fail if the output is not consistent with the patterns</li></ul></li><li>compare the reference output for the AST and the errors<ul><li>fail if there are any differences</li></ul></li></ul><p>In the first step the compiler MUST produce an error code, let&#x27;s look at <code>sem_check</code> to see why:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function-name function" style="color:rgb(130, 170, 255)">sem_check</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token variable" style="color:rgb(191, 199, 213)">${CQL}</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">$@</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">$?</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token plain"> -ne </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;1&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;All semantic analysis checks have errors in the test&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;the normal return code is &quot;1&quot; -- any other return code is bad news&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;A return code of zero indicates we reported success in the face of errors&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;A return code other than 1 indicates an unexpected fatal error of some type&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">return</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>In short <code>sem_test.sql</code> is FULL of semantic errors, that&#x27;s part of the test.  If the compiler
reports success something is <em>seriously</em> wrong.</p><p>In the next phase we&#x27;re going to do some pattern matching, let&#x27;s look at a couple of examples
to illustrate how this works.  The program <code>cql-verify</code> actually does all this matching and
that program is itself written in (mostly) CQL which is cute.
It can be found in the <code>tester</code> directory.</p><p>Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- TEST: we&#x27;ll be using printf in lots of places in the tests as an external proc</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + {declare_proc_no_check_stmt}: ok</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- - Error</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">DECLARE</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">PROCEDURE</span><span class="token plain"> printf </span><span class="token keyword" style="font-style:italic">NO</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">CHECK</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>The code under test is of course <code>DECLARE PROCEDURE printf NO CHECK</code>.  The patterns happen
immediately before this code.  Let&#x27;s look at each line:</p><ul><li><code>-- TEST: etc.</code> : this is just a comment, it means nothing and serves no purpose other than documentation</li><li><code>-- + {declare_proc_no_check_stmt}: ok</code> : the comment stats with <code>&quot; + &quot;</code>, this is a trigger<ul><li>the test output from the statement under test must include indicated text</li><li>this happens to be the text for the AST of <code>declare_proc_no_check_stmt</code> after semantic success</li><li>there is no type info hence the <code>ok</code> designation (recall <code>SEM_TYPE_OK</code>)</li></ul></li><li><code>-- Error</code> : the comment starts with <code>&quot; - &quot;</code>, this is a trigger<ul><li>the test output from the statement under test must NOT include indicated text</li><li>in this case that means no reported erros</li></ul></li></ul><p>Easy enough.  Now does this happen?</p><p>The test output includes:</p><ul><li>text like &quot;The statement ending at line XXXX&quot; where XXXX is appropriate line number</li><li>an echo of the statement that was analyzed (after any rewrites)</li><li>the AST of that statement including semantic type info that was computed</li></ul><p>Using the value of XXXX the tester searches the test file in this case <code>sem_test.sql</code>, it
extracts the test patterns that happen AFTER the previous XXXX value for the previous statement
and up to the indicated line number.  This is The Price Is Right algorithm where you
read up to the designated lines without going over.</p><p>Each pattern is matched, or not matched, using the SQL <code>LIKE</code> or <code>NOT LIKE</code> operator.  In case
of errors the tester writes out the actual output and the expected patterns having all this information
handy.</p><p>The line numbers are all changed to literally &quot;XXXX&quot; after this pass so that the difference in
later passes is not a cascade of of trivial line number changes in otherwise identical output.</p><p>Let&#x27;s look at another example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- TEST: create a table using type discrimation: kinds</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + {create_table_stmt}: with_kind: { id: integer&lt;some_key&gt;, cost: real&lt;dollars&gt;, value: real&lt;dollars&gt; }</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + {col_def}: id: integer&lt;some_key&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + {col_def}: cost: real&lt;dollars&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + {col_def}: value: real&lt;dollars&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- - Error</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">create</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">table</span><span class="token plain"> with_kind</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  id </span><span class="token keyword" style="font-style:italic">integer</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain">some_key</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cost </span><span class="token keyword" style="font-style:italic">real</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain">dollars</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">value</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">real</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain">dollars</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>This reads pretty easily now:</p><ul><li><code>{create_table_stmt}</code> : the struct type of the table must be an exact match for what is expected</li><li><code>{col_def}</code> : there are 3 different <code>{col_def}</code> nodes, one for each column</li><li><code>- Error</code> : there are no reported errors</li></ul><p>So there are no errors reported nor are there any in the AST.  At least the part of the AST that was
checked.  The AST actually had other stuff too but it&#x27;s normal to just test the &quot;essential&quot; stuff.
There are many tests that try many variations and we don&#x27;t want to check every fact in every case
of every test.</p><p>If you want to see the whole AST output for this, it&#x27;s easy enough.  It&#x27;s sitting in <code>sem_test.out.ref</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">The statement ending at line XXXX</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE TABLE with_kind(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  id INTEGER&lt;some_key&gt;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cost REAL&lt;dollars&gt;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  value REAL&lt;dollars&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {create_table_stmt}: with_kind: { id: integer&lt;some_key&gt;, cost: real&lt;dollars&gt;, value: real&lt;dollars&gt; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {create_table_name_flags}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {table_flags_attrs}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | | {int 0}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {name with_kind}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {col_key_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {col_def}: id: integer&lt;some_key&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | | {col_def_type_attrs}: ok</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |   | {col_def_name_type}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |     | {name id}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |     | {type_int}: integer&lt;some_key&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |       | {name some_key}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {col_key_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {col_def}: cost: real&lt;dollars&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | | {col_def_type_attrs}: ok</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      |   | {col_def_name_type}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      |     | {name cost}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      |     | {type_real}: real&lt;dollars&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      |       | {name dollars}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {col_key_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        | {col_def}: value: real&lt;dollars&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          | {col_def_type_attrs}: ok</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            | {col_def_name_type}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">              | {name value}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">              | {type_real}: real&lt;dollars&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                | {name dollars}</span></div></div></div></div></div><p>As you can see there was potentially a lot more than could have been verified but those view key lines were
selected because their correctness really implies the rest.  In fact just the <code>{create_table_stmt}</code> line
really was enough to know that everthing was fine.</p><p>Let&#x27;s look at one more example, this time on that is checking for errors.  Many tests check for
errors because correctly reporting errors is the primary job of <code>sem.c</code>.  It&#x27;s fair to say that
there are more tests for error cases than there are for correct cases because there are a lot
more ways to write code incorrectly than correctly.  Here&#x27;s the test:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- TEST: join with bogus ON expression type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- + Error % expected numeric expression &#x27;ON&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- +1 Error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- + {select_stmt}: err</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- + {on}: err</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">select * from foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">inner join bar as T2 on &#x27;v&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">where &#x27;w&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">having &#x27;x&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">limit &#x27;y&#x27;;</span></div></div></div></div></div><ul><li><code>+ Error % expected numeric expression &#x27;ON&#x27;</code> : there must be a reported Error message with the indicated error text</li><li><code>+1 Error</code> : this indicates that there must be <em>exactly</em> 1 match for the pattern &quot;Error&quot; (i.e. exactly one error)<ul><li>note that there are several problems with the test statement but error processing is supposed to stop after the first</li></ul></li><li><code>-- + {on}: err</code> : verifies that the ON clause was marked as being in error</li><li><code>-- + {select_stmt}: err</code> : verifies that the error correctly propogated up to the top level statement</li></ul><p>Note that the patterns can be in any order and every pattern is matched against the whole input so for instance:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- + {on}: err</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- + {on}: err</span></div></div></div></div></div><p>The above does not imply that there are two such <code>{on}</code> nodes.  The second line will match the same text as the first.
To to enforce that there were exactly two matches you use:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- +2 {on}: err</span></div></div></div></div></div><p>There is no syntax for &quot;at least two matches&quot; though one could easily be added.  So far it hasn&#x27;t been especially
necessary.</p><p>As we&#x27;ll see this simple pattern is used in many other tests.  All that is required for it work is output with
lines of the form &quot;The statement ending at line XXXX&quot;</p><p>The <code>sem_test_dev.sql</code> test file is a set of tests that are run with the <code>--dev</code> flag passed to CQL.  This
is the mode where certain statements that are prohibited in production code are verified.  This file is
very small indeed and the exact prohibitions are left as an exercise to the reader.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="code-generation-tests"></a>Code Generation Tests<a aria-hidden="true" tabindex="-1" class="hash-link" href="#code-generation-tests" title="Direct link to heading">#</a></h3><p>The test logic for the &quot;codegen&quot; family of tests (<code>cg_test*.sql</code>) is virtually identical to the semantic
test family. The same testing utililty is used, and it works the same way, looking for the same marker.
The only difference in this stage is that the test output is generated code, not an AST. The codegen tests
are a great way to lock down important code fragments in the output.  Note that the codegen tests do not actually
execute any generated code.  That&#x27;s the next category.</p><p>Here&#x27;s an sample test:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- TEST: unused temp in unary not emitted</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- - cql_int32 _tmp_int_0 = 0;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- - cql_int32 _tmp_int_1 = 0;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + o = i.value;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- + o = - 1;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">create</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">proc</span><span class="token plain"> unused_temp</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">i </span><span class="token keyword" style="font-style:italic">integer</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">out</span><span class="token plain"> o </span><span class="token keyword" style="font-style:italic">integer</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">not</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">null</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">begin</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">set</span><span class="token plain"> o :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">coalesce</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">-</span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">end</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>This test is verifying one of the optimizations that we talked about in
<a href="https://cgsql.dev/cql-guide/int03#result-variables" target="_blank" rel="noopener noreferrer">Part 3</a>.
In many cases temporary variables for results (such as function calls) can be elided.</p><ul><li><code>- cql_int32 _tmp_int_0 = 0;</code> : verifies that this temporary is NOT created</li><li><code>- cql_int32 _tmp_int_1 = 0;</code> : likewise</li><li><code>+ o = i.value;</code> : the first alternative in coalesce directly assigns to <code>o</code></li><li><code>+ o = - 1;</code> : as does the second</li></ul><p>It might be helpful to look at the full output, which as always is in a <code>.ref</code> file.
In this case <code>cg_test.c.ref</code>.  Here is the full output with the line number
normalized:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The statement ending at line XXXX</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET o := coalesce(i, -1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;unused_temp&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// export: DECLARE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void unused_temp(cql_nullable_int32 i, cql_int32 *_Nonnull o) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)o, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *o = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  do {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!i.is_null) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      *o = i.value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *o = - 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } while (0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>As we can see, the test has picked out the bits that it wanted to verify. The <code>coalesce</code>
function is verified elsewhere -- in this test we&#x27;re making sure that this pattern doesn&#x27;t cause
extra temporaries.</p><p>Let&#x27;s take a quick look at the part of <code>test_common.sh</code> that runs this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function-name function" style="color:rgb(130, 170, 255)">code_gen_c_test</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;--------------------------------- STAGE 5 -- C CODE GEN TEST&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> running codegen </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">test</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">${CQL}</span><span class="token plain"> --test --cg </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test_c.h&quot;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test_c.c&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test_exports.out&quot;</span><span class="token plain"> --in </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test.sql&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    --global_proc cql_startup --generate_exports </span><span class="token operator file-descriptor important" style="color:rgb(137, 221, 255)">2</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test_c.err&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;ERROR:&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">cat</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test_c.err&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> validating codegen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cql-verify&quot;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test.sql&quot;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/cg_test_c.c&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;ERROR: failed verification&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> testing </span><span class="token keyword" style="font-style:italic">for</span><span class="token plain"> successful compilation of generated C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token function" style="color:rgb(130, 170, 255)">rm</span><span class="token plain"> -f out/cg_test_c.o</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> do_make out/cg_test_c.o</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;ERROR: failed to compile the C code from the code gen test&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">..</span><span class="token plain">.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;  computing diffs (empty if none)&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  on_diff_exit cg_test_c.c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  on_diff_exit cg_test_c.h</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">..</span><span class="token plain">. other tests</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div></div></div><p>Briefly reviewing this, we see the following important steps:</p><ul><li><code>{CQL} --test --cg etc.</code> : run the compiler on the test input<ul><li>the test fails if there are any errors</li></ul></li><li><code>cql-verify</code> : performs the pattern matching<ul><li>the output has the same statement markers as in the semantic case</li></ul></li><li><code>do_make</code> : use <code>make</code> to build the generated code ensuring it compiles cleanly<ul><li>if the C compiler returns any failure, the test fails</li></ul></li><li><code>on_diff_exit</code> : compares the test output to the reference output<ul><li>any difference fails the test</li></ul></li></ul><p>This is all remarkably similar to the semantic tests. All the code generators
are tested in the same way.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="run-tests"></a>Run Tests<a aria-hidden="true" tabindex="-1" class="hash-link" href="#run-tests" title="Direct link to heading">#</a></h3><p>The last category of tests actually does execution.  The main &quot;run test&quot; happens
at &quot;stage 13&quot;, because there are <em>many</em> codegen tests for the various
output formats and these all pass before before we try to execute anything.
This is not so bad because the tests are quite quick with a full test pass taking
less than 90s on my laptop.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function-name function" style="color:rgb(130, 170, 255)">run_test</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;--------------------------------- STAGE 13 -- RUN CODE TEST&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> running codegen </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">test</span><span class="token plain"> with execution</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> cc -E -x c -w </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${TEST_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/run_test.sql&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/run_test_cpp.out&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> preprocessing failed.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">elif</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">${CQL}</span><span class="token plain"> --nolines </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    --cg </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/run_test.h&quot;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/run_test.c&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    --in </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/run_test_cpp.out&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    --global_proc cql_startup --rt c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> codegen failed.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">elif</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">echo </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;  compiling code&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> do_make run_test </span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> build failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">elif</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">echo </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;  executing tests&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;./</span><span class="token string variable" style="color:rgb(191, 199, 213)">${OUT_DIR}</span><span class="token string" style="color:rgb(195, 232, 141)">/a.out&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin class-name" style="color:rgb(255, 203, 107)">echo</span><span class="token plain"> tests failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    failed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">fi</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">..</span><span class="token plain">.</span></div></div></div></div></div><p>The main structure is mostly what one would expect:</p><ul><li><code>cc -E -x c</code> : this is used to pre-process the run test file so that we can use C pre-processor features to define tests<ul><li>there are quite a few helpful macros as we&#x27;ll see</li><li>if pre-processing fails, the test fails</li></ul></li><li><code>{CQL} --nolines --cg ...</code> : this is used to create the <code>.h</code> and <code>.c</code> file for the compiland<ul><li><code>--nolines</code> is used to suppress the <code>#</code> directives that would associate the generated code with the .sql file</li><li>compilation failures cause the test to fail</li></ul></li><li><code>do_make</code> : as before this causes <code>make</code> to build the compiland (<code>run_test</code>)<ul><li>this build target includes the necessary bootstrap code to open a database and start the tests</li><li>any failures cause the test to fail</li></ul></li><li><code>a.out</code> : the tests execute<ul><li>the tests return a failure status code if anything goes wrong</li><li>any failure causes the test to fail</li></ul></li></ul><p>The test file <code>run_test.sql</code> includes test macros from <code>cqltest.h</code> -- all of these are very
simple.  The main ones are <code>BEGIN_SUITE</code>, <code>END_SUITE</code>, <code>BEGIN_TEST</code> and <code>END_TEST</code> for
structure; and <code>EXPECT</code> to verify a boolean expression.</p><p>Here&#x27;s a simple test case with several expectations:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN_TEST(arithmetic)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO((1 + 2) * 3 == 9);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(1 + 2 * 3 == 7);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(6 / 3 == 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(7 - 5 == 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(6 % 5 == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(5 / 2.5 == 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(-(1+3) == -4);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(-1+3 == 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(1+-3 == -2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(longs.neg == -1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(-longs.neg == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPECT_SQL_TOO(- -longs.neg == -1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END_TEST(arithmetic)</span></div></div></div></div></div><p>We should also reveal <code>EXPECT_SQL_TOO</code>, discussed below:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">-- use this for both normal eval and SQLite eval</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define EXPECT_SQL_TOO(x) EXPECT(x); EXPECT((select x))</span></div></div></div></div></div><p>Now back to the test:</p><ul><li><code>EXPECT(x)</code> : verifies that <code>x</code> is true (i.e. a non-zero numeric)<ul><li>not used directly in this example</li></ul></li><li><code>EXPECT_SQL_TOO</code> : as the definition shows,<ul><li><code>x</code> must be true (as above)</li><li><code>(select x)</code> must also be true,<ul><li>i.e. when SQLite is asked to evaluate the expression the result is also a &quot;pass&quot;</li></ul></li><li>this is used to verify consistency of order of operations and other evaluations that must be the same in both forms</li><li>note that when <code>(select ...)</code> is used, CQL plays no part in evaluating the expression, the text of the expression goes to SQLite and any variables are bound as described in Part 3.</li></ul></li></ul><p>The run test exercises many features, but the testing strategy is always the same:</p><ul><li>exercise some code pattern</li><li>use <code>EXPECT</code> to validate the results are correct</li><li>the expressions in the <code>EXPECT</code> are usually crafted carefully to show that a certain mistake is not being made<ul><li>e.g. expressions where the result would be different if there are bugs in order of operations</li><li>e.g. expressions that would crash with divide by zero if code that isn&#x27;t supposed to run actually ran</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-upgrade-testing"></a>Schema Upgrade Testing<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-upgrade-testing" title="Direct link to heading">#</a></h3><p>The schema upgrade tester is quite a bit different than the others and relies heavily on execution
of the upgraders.  Before we get into that there is a preliminary topic:</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="previous-schema-validation"></a>&quot;Previous Schema&quot; Validation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#previous-schema-validation" title="Direct link to heading">#</a></h4><p>In order to ensure that it is possible to create an upgrader, CQL provides features to validate
the current schema against the previous schema ensuring that nothing has been done that would
make an upgrader impossible. This is more fully discussed in
<a href="https://cgsql.dev/cql-guide/ch11" target="_blank" rel="noopener noreferrer">Chapter 11</a> of the Guide.</p><p>&quot;Previous Schema&quot; validation is a form of semantic check and so its testing happens as
described above. Importantly, as with the other back-end passes the schema upgrader does
not have to concern itself with error cases as they are already ruled out.  The upgrader
itself will be the subject of Part 5.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="packing-list"></a>Packing List<a aria-hidden="true" tabindex="-1" class="hash-link" href="#packing-list" title="Direct link to heading">#</a></h4><p>The test assets for upgrade tests are found in the <code>upgrade</code> directory and consist of</p><ul><li><code>SchemaPersistentV0.sql</code> : baseline version of the test schema</li><li><code>SchemaPersistentV1.sql</code> : v1 of the test schema</li><li><code>SchemaPersistentV2.sql</code> : v2 of the test schema</li><li><code>SchemaPersistentV3.sql</code> : v3 of the test schema</li><li><code>downgrade_test.c</code> : a test that simulates attemping to go backwards in schema versions</li><li><code>upgrade_test.c</code> : the C harness that launches the upgraders and fires the tests</li><li><code>upgrade_test.sh</code> : the shell script that makes all this happen</li><li><code>upgrade_validate.sql</code> : some simple code that sanity checks the recorded schema version against tables in it<ul><li>used to ensure that the schema we are on is the schema we think we are on, not to validate all facets of it</li><li>also renders the contents of <code>sqlite_master</code> in a canonical form</li></ul></li></ul><p>We haven&#x27;t yet discussed the internals of schema upgrade, so for purposes of this part we&#x27;re only going
to discuss how the testing proceeds.  The upgrade will be considered &quot;magic&quot; for now.</p><p>In addition to these assets, we also have reference files:</p><ul><li><code>upgrade_schema_v0.out.ref</code> : expected content of v0</li><li><code>upgrade_schema_v1.out.ref</code> : expected content of v1</li><li><code>upgrade_schema_v2.out.ref</code> : expected content of v2</li><li><code>upgrade_schema_v3.out.ref</code> : expected content of v3</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="upgrade_validatesql"></a><code>upgrade_validate.sql</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#upgrade_validatesql" title="Direct link to heading">#</a></h4><p>This file has a single procedure <code>validate_transition</code> which does the two jobs:</p><ul><li>emits the canonicalized version of <code>sqlite_master</code> to the output<ul><li>this is needed because <code>sqlite_master</code> text can vary between Sqlite versions</li></ul></li><li>checks for basic things that should be present in a given version</li></ul><p>The output of the validator looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">reference results for version 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">----- g1 -----</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">type: table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tbl_name: g1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE TABLE g1(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  id INTEGER PRIMARY KEY,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name TEXT)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">----- sqlite_autoindex_test_cql_schema_facets_1 -----</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">type: index</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tbl_name: test_cql_schema_facets</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">----- test_cql_schema_facets -----</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">type: table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tbl_name: test_cql_schema_facets</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE TABLE test_cql_schema_facets(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  facet TEXT NOT NULL PRIMARY KEY,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  version LONG_INT NOT NULL)</span></div></div></div></div></div><p>The formatting rules are very simple and so the output is pretty readable.</p><p>The verifications are very simple.</p><p>First this happens:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">let version :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> cast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">test_cql_get_facet_version</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;cql_schema_version&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">as</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">integer</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>The printing happens, then this simple validation:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let recreate_sql :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">select</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">sql</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">from</span><span class="token plain"> sqlite_master</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">where</span><span class="token plain"> name </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;test_this_table_will_become_create&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> nothing </span><span class="token boolean" style="color:rgb(255, 88, 116)">null</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> switch version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">when</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> recreate_sql </span><span class="token operator" style="color:rgb(137, 221, 255)">is</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">null</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">or</span><span class="token plain"> recreate_sql </span><span class="token operator" style="color:rgb(137, 221, 255)">not</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">like</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;%xyzzy INTEGER%&#x27;</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">then</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token keyword" style="font-style:italic">call</span><span class="token plain"> printf</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;ERROR! test_this_table_will_become_create should have a column named xyzzy in v%d\n&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> version</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      throw</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">end</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">if</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">call</span><span class="token plain"> printf</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;ERROR! expected schema version v%d\n&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> version</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">end</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>In short, the version number must be one of the valid versions and each version is expecting
that particular table to be in some condition it can recognize.</p><p>The real validation is done by noting any changes in the reference output plus a series of invariants.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="prosecution-of-the-upgrade-test"></a>Prosecution of the Upgrade Test<a aria-hidden="true" tabindex="-1" class="hash-link" href="#prosecution-of-the-upgrade-test" title="Direct link to heading">#</a></h4><p><strong> Launch </strong></p><p>We kick things off as follows:</p><ul><li><code>test.sh</code> calls <code>upgrade/upgrade_test.sh</code><ul><li>this test doesn&#x27;t usually run standalone (but it can)</li></ul></li></ul><p><strong> Build Stage </strong></p><p>This creates the various binaries we will need:</p><ul><li><code>upgrade_validate.sql</code> is compiled down to C<ul><li>this code works for all schema versions, it&#x27;s generic</li></ul></li><li><code>SchemaPersistentV[0-3].sql</code> are compiled into C (this takes two steps)<ul><li>first, the CQL upgrader is generated from the schema</li><li>second, the CQL upgrader is compiled to C</li></ul></li><li><code>make</code> is used to lower all of the C into executables <code>upgrade[0-3]</code> plus <code>downgrade_test</code><ul><li>the shared validation code is linked into all 4 upgraders</li><li><code>downgrade_test.c</code> is linked with the code for <code>upgrade1</code></li></ul></li></ul><p><strong> Basic Upgrades </strong></p><p>Here we test going from scratch to each of the 4 target versions:</p><ul><li><code>upgrade[0-3]</code> are each run in turn with no initial database<ul><li>i.e. their target database is deleted before each run</li></ul></li><li>the validation output is compared against the reference output<ul><li>any differences fail the test</li></ul></li></ul><p><strong> Previous Schema Validation </strong></p><p>This sanity checks that the chain of schema we have built should work
when upgrading from one version to the next:</p><ul><li>try each schema with this predecessor:<ul><li><code>SchemaPersistentV1.sql</code> with <code>SchemaPersistentV0.sql</code> as the previous</li><li><code>SchemaPersistentV2.sql</code> with <code>SchemaPersistentV1.sql</code> as the previous</li><li><code>SchemaPersistentV3.sql</code> with <code>SchemaPersistentV2.sql</code> as the previous</li></ul></li><li>if any of these produce errors something is structurally wrong with the test or else previous schema validation is broken</li></ul><p><strong> Two-Step Upgrades </strong></p><p>Now we verify that we can go from any version to any other version with a stop in between to persist.</p><p>An example should make this clearer:</p><ul><li>We start from scratch and go to v2<ul><li>this should produce the v2 reference schema output as before</li></ul></li><li>We run the v4 upgrader on this v2 schema<ul><li>this should produce the v4 reference schema output as before</li><li>i.e. if we go from nothing to v2 to v4 we get the same as if we just go to v4 directly</li></ul></li></ul><p>There are quite a few combinations like this, the test output lists them all:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v0, then to v0 -- must match direct update to v0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v0, then to v1 -- must match direct update to v1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v1, then to v1 -- must match direct update to v1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v0, then to v2 -- must match direct update to v2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v1, then to v2 -- must match direct update to v2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v2, then to v2 -- must match direct update to v2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v0, then to v3 -- must match direct update to v3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v1, then to v3 -- must match direct update to v3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v2, then to v3 -- must match direct update to v3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Upgrade from nothing to v3, then to v3 -- must match direct update to v3</span></div></div></div></div></div><p>Note that one of the combinations tested is starting on <code>Vn</code> and &quot;upgrading&quot;
from there to <code>Vn</code>. This should do nothing.</p><p><strong> Testing downgrade </strong></p><p>Here we make sure that any attempt to &quot;go backwards&quot; results in an error.</p><ul><li>the <code>v3</code> schema created by the previous test is used as input to the downgrade test</li><li>the downgrade test was linked with the <code>v2</code> upgrader</li><li>when executed the <code>v2</code> upgrader should report the error<ul><li>this test&#x27;s verifier checks for a correct error report</li></ul></li><li>the test test fails if the error is no correctly reported</li></ul><p>The combination of testing reference outputs plus testing these many invariants
at various stages results in a powerful integration test.  The actual schema
for the varios versions includes all the supported transitions such as
creating and deleting tables and columns, and recreating views, indicies, and triggers.</p><p>All of the possible transitions are more fully discussed in
<a href="https://cgsql.dev/cql-guide/ch10" target="_blank" rel="noopener noreferrer">Chapter 10</a> of the Guide which pairs nicely
with the previous schema validions discussed in
<a href="https://cgsql.dev/cql-guide/ch11" target="_blank" rel="noopener noreferrer">Chapter 11</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="testing-the-line-directives-produced-by-cql"></a>Testing the <code>#line</code> directives produced by CQL<a aria-hidden="true" tabindex="-1" class="hash-link" href="#testing-the-line-directives-produced-by-cql" title="Direct link to heading">#</a></h3><p>[An additional section should be added for the code that verifies the source line number mappings
even though this is a pretty exotic case.]</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="summary"></a>Summary<a aria-hidden="true" tabindex="-1" class="hash-link" href="#summary" title="Direct link to heading">#</a></h3><p>While there are a few more isolated verifications that happen in <code>test.sh</code> and of course
there is the plumbing necessary to let <code>cov.sh</code> use the test script to create coverage reports,
the above forms make up the vast majority of the test patterns.</p><p>Generally, the test files are designed to hold as many tests as can reasonably fit with
the gating factor being cases where different flags are necessary.  There are two different
stages were many different tiny input files are used to create trivial failures like missing
command line arguments and such.  But those cases are all just looking for simple error
text and a failure code, so they should be self-evident.  With so many options, many
such baby tests are needed.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-5-cql-runtime"></a>Part 5: CQL Runtime<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-5-cql-runtime" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-4"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-4" title="Direct link to heading">#</a></h3><p>Part 5 continues with a discussion of the essentials of the CQL Runtime.
As in the previous sections, the goal here is not to go over every detail but rather to give
a sense of how the runtime works in general -- the core strategies and implementation choices --
so that when reading the source you will have an idea how it all hangs together. To accomplish
this, we&#x27;ll illustrate the key pieces that can be customized and we&#x27;ll discuss some
interesting cases.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cql-runtime"></a>CQL Runtime<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cql-runtime" title="Direct link to heading">#</a></h2><p>The parts of the runtime that you can change are in <code>cqlrt.h</code>, that file invariably ends by including
<code>cqlrt_common.h</code> which are the runtime parts that you shouldn&#x27;t change.  Of course this is open source
so you can change anything, but the common things usually don&#x27;t need to change -- <code>cqlrt.h</code> should
provide you with everything you need to target new environments.</p><p>The compiler itself can be customized see <code>rt.c</code> to emit different strings to work with your runtime.
This is pretty easy to do without creating a merge hell for yourself. Meta Platforms, for instance,  has its
own CQL runtime customized for use on phones that is not open source (and really I don&#x27;t think anyone
would want it anyway).  But the point is that you can make your own. In fact I know of two just within
Meta Platforms.</p><p>We&#x27;ll go over <code>cqlrt.h</code> bit by bit.  Keeping in mind it might change but this is
essentially what&#x27;s going on.  And the essentials don&#x27;t change very often.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="standard-headers"></a>Standard headers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#standard-headers" title="Direct link to heading">#</a></h3><p>The rest of the system will use these, <code>cqlrt.h</code> is responsible for bringing in what you need
later, or what <code>cqlrt_common.h</code> needs on your system.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma once</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;assert.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stddef.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdint.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;math.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;sqlite3.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#ifndef __clang__</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#ifndef _Nonnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    /* Hide Clang-only nullability specifiers if not Clang */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    #define _Nonnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    #define _Nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="contract-and-error-macros"></a>Contract and Error Macros<a aria-hidden="true" tabindex="-1" class="hash-link" href="#contract-and-error-macros" title="Direct link to heading">#</a></h3><p>CQL has a few different macros it uses for errors.  <code>contract</code>, <code>invariant</code>, and <code>tripwire</code>
usually all map to <code>assert</code>.  Note that <code>tripwire</code> doesn&#x27;t have to be fatal, it can log
in production and continue.  This is a &quot;softer&quot; assertion.  Something that you&#x27;re trying out
that you&#x27;d like to be a <code>contract</code> but maybe there are lingering cases that have to be fixed
first.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_contract assert</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_invariant assert</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_tripwire assert</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_log_database_error(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_error_trace()</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-value-types"></a>The Value Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-value-types" title="Direct link to heading">#</a></h3><p>You can define these types to be whatever is appropriate on your system.
Usually the mapping is pretty obvious.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// value types</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef unsigned char cql_bool;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_true (cql_bool)1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_false (cql_bool)0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef unsigned long cql_hash_code;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef int32_t cql_int32;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef uint32_t cql_uint32;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef uint16_t cql_uint16;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef sqlite3_int64 cql_int64;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef double cql_double;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef int cql_code;</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-reference-types"></a>The Reference Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-reference-types" title="Direct link to heading">#</a></h3><p>The default runtime first defines 4 types of reference objects.
These are the only reference types that CQL creates itself. In
fact CQL doesn&#x27;t actually create <code>CQL_C_TYPE_OBJECT</code> but the tests
do.  CQL never creates raw object things, only external functions
can do that.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// metatypes for the straight C implementation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CQL_C_TYPE_STRING 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CQL_C_TYPE_BLOB 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CQL_C_TYPE_RESULTS 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CQL_C_TYPE_BOXED_STMT 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CQL_C_TYPE_OBJECT 4</span></div></div></div></div></div><p>All the reference types are reference counted. So they
need a simple shape that allows them to know their own
type and have a count.  They also have a finalize method
to clean up their memory when the count goes to zero.</p><p>You get to define <code>cql_type_ref</code> to be whatever you want.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// base ref counting struct</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_type *cql_type_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_type {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int ref_count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void (*_Nullable finalize)(cql_type_ref _Nonnull ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_type;</span></div></div></div></div></div><p>Whatever you do with the types you&#x27;ll need to define
a retain and release method that uses them as the signature.
Normal references should have a generic value comparison and a hash.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void cql_retain(cql_type_ref _Nullable ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void cql_release(cql_type_ref _Nullable ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_hash_code cql_ref_hash(cql_type_ref _Nonnull typeref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_bool cql_ref_equal(cql_type_ref _Nullable typeref1, cql_type_ref _Nullable typeref2);</span></div></div></div></div></div><p>Now each of the various kinds of reference types needs an
object which probably includes the base type above.  It doesn&#x27;t
have to.  You can arrange for some other universal way to do
these.  On iOS these can be easily mapped to <code>CF</code> types.</p><p>The <code>retain</code> and <code>release</code> macros should all map to the same thing.
The compiler emits different variations for readability only. It
doesn&#x27;t really work if they don&#x27;t have common retain/release
semantics.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// builtin object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_object *cql_object_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_object {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_type base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const void *_Nonnull ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_object;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_object_retain(object) cql_retain((cql_type_ref)object);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_object_release(object) cql_release((cql_type_ref)object);</span></div></div></div></div></div><p>Boxed statement gets its own implementation, same as object.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// builtin statement box</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_boxed_stmt *cql_boxed_stmt_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_boxed_stmt {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_type base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sqlite3_stmt *_Nullable stmt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_boxed_stmt;</span></div></div></div></div></div><p>Same for blob, and blob has a couple of additional helper macros
that are used to get information. Blobs also have hash and equality
functions.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// builtin blob</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_blob *cql_blob_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_blob {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_type base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const void *_Nonnull ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_uint32 size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_blob;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_blob_retain(object) cql_retain((cql_type_ref)object);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_blob_release(object) cql_release((cql_type_ref)object);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_blob_ref _Nonnull cql_blob_ref_new(const void *_Nonnull data, cql_uint32 size);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_get_blob_bytes(data) (data-&gt;ptr)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_get_blob_size(data) (data-&gt;size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_hash_code cql_blob_hash(cql_blob_ref _Nullable str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_bool cql_blob_equal(cql_blob_ref _Nullable blob1, cql_blob_ref _Nullable blob2);</span></div></div></div></div></div><p>Strings are the same as the others but they have many more functions
associated with them.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// builtin string</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_string *cql_string_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_string {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_type base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nullable ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_string;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull cql_string_ref_new(const char *_Nonnull cstr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_string_retain(string) cql_retain((cql_type_ref)string);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_string_release(string) cql_release((cql_type_ref)string);</span></div></div></div></div></div><p>The compiler uses this macro to create a named string literal. You decide
how those will be implemented right here.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_string_literal(name, text) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string name##_ = { \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .base = { \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .type = CQL_C_TYPE_STRING, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .ref_count = 1, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .finalize = NULL, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .ptr = text, \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref name = &amp;name##_</span></div></div></div></div></div><p>Strings get assorted comparison and hashing functions. Note blob also had a hash.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int cql_string_compare(cql_string_ref _Nonnull s1, cql_string_ref _Nonnull s2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_hash_code cql_string_hash(cql_string_ref _Nullable str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_bool cql_string_equal(cql_string_ref _Nullable s1, cql_string_ref _Nullable s2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int cql_string_like(cql_string_ref _Nonnull s1, cql_string_ref _Nonnull s2);</span></div></div></div></div></div><p>Strings can be converted from their reference form to standard C form. These
macros define how this is done.  Note that temporary allocations are possible
here but the standard implementation does not actually need to do an alloc.  It
stores UTF8 in the string pointer so it&#x27;s ready to go.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_alloc_cstr(cstr, str) const char *_Nonnull cstr = (str)-&gt;ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_free_cstr(cstr, str) 0</span></div></div></div></div></div><p>The macros for result sets have somewhat less flexibility.  The main thing
that you can do here is add additional fields to the &quot;meta&quot; structure.  It
needs those key fields because it is created by the compiler.  However the
API is used to create a result set so that can be any object you like.  It
only has to respond to the <code>get_meta</code>, <code>get_data</code>, and <code>get_count</code> apis.
Those can be mapped as you desire.  In principle there could have been
a macro to create the &quot;meta&quot; as well (a PR for this is welcome) but it&#x27;s
really a pain for not much benefit.  The advantage of defining your own &quot;meta&quot;
is that you can use it to add additional custom APIs to your result set that
might need some storage.</p><p>The additional API <code>cql_result_set_note_ownership_transferred(result_set)</code>
is used in the event that you are moving ownership of the buffers from
out of CQL&#x27;s universe.  So like maybe JNI is absorbing the result, or
Objective C is absorbing the result.  The default implementation is a no-op.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// builtin result set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_result_set *cql_result_set_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_result_set_meta {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct cql_result_set {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_type base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_result_set_meta meta;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nonnull data;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} cql_result_set;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_type_decl(result_set_type, result_set_ref) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  typedef struct _##result_set_type *result_set_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_result_set_ref _Nonnull cql_result_set_create(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nonnull data,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 count,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_result_set_meta meta);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_retain(result_set) cql_retain((cql_type_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_release(result_set) cql_release((cql_type_ref)result_set);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_note_ownership_transferred(result_set)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_get_meta(result_set) (&amp;((cql_result_set_ref)result_set)-&gt;meta)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_get_data(result_set) ((cql_result_set_ref)result_set)-&gt;data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_result_set_get_count(result_set) ((cql_result_set_ref)result_set)-&gt;count</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="mocking"></a>Mocking<a aria-hidden="true" tabindex="-1" class="hash-link" href="#mocking" title="Direct link to heading">#</a></h3><p>The CQL run test needs to do some mocking.  This bit is here for that test.  If you
want to use the run test with your version of <code>cqlrt</code> you&#x27;ll need to define a
shim for <code>sqlite3_step</code> that can be intercepted.  This probably isn&#x27;t going to come up.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#ifdef CQL_RUN_TEST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define sqlite3_step mockable_sqlite3_step</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SQLITE_API cql_code mockable_sqlite3_step(sqlite3_stmt *_Nonnull);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="profiling"></a>Profiling<a aria-hidden="true" tabindex="-1" class="hash-link" href="#profiling" title="Direct link to heading">#</a></h3><p>If you want to support profiling you can implement <code>cql_profile_start</code> and <code>cql_profile_stop</code>
to do whatever you want.  The CRC uniquely identifies a procedure (you can log that).  The
<code>index</code> provides you with a place to store something that you can use as a handle in
your logging system.  Typically an integer.  This lets you assign indices to the procedures
you actually saw in any given run and then log them or something like that.  No data
about parameters is provided, this is deliberate.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// No-op implementation of profiling</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * Note: we emit the crc as an expression just to be sure that there are no compiler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   errors caused by names being incorrect.  This improves the quality of the CQL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   code gen tests significantly.  If these were empty macros (as they once were)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   you could emit any junk in the call and it would still compile.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_profile_start(crc, index) (void)crc; (void)index;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define cql_profile_stop(crc, index)  (void)crc; (void)index;</span></div></div></div></div></div><p>The definitions in <code>cqlrt_common.c</code> can provide codegen than either has generic
&quot;getters&quot; for each column type (useful for JNI) or produces a unique getter that isn&#x27;t
shared.  The rowset metadata will include the values for <code>getBoolean</code>, <code>getDouble</code> etc.
if <code>CQL_NO_GETTERS</code> is 0.  Getters are a little slower for C but give you a small number
of functions that need to have JNI if you are targeting Java.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the basic version doesn&#x27;t use column getters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CQL_NO_GETTERS 1</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="encoding-of-sensitive-columns"></a>Encoding of Sensitive Columns<a aria-hidden="true" tabindex="-1" class="hash-link" href="#encoding-of-sensitive-columns" title="Direct link to heading">#</a></h3><p>By setting an attribute on any procedure that produces a result set you can
have the selected sensitive values encoded.  If this happens CQL first asks
for the encoder and then calls the encode methods passing in the encoder.
These aren&#x27;t meant to be cryptograhically secure but rather to provide some
ability to prevent mistakes.  If you opt in, sensitive values have to be deliberately
decoded and that provides an audit trail.</p><p>The default implementation of all this is a no-op.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// implementation of encoding values. All sensitive values read from sqlite db will</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// be encoded at the source. CQL never decode encoded sensitive string unless the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// user call explicitly decode function from code.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_object_ref _Nullable cql_copy_encoder(sqlite3 *_Nonnull db);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_bool cql_encode_bool(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int32 cql_encode_int32(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int64 cql_encode_int64(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_double cql_encode_double(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull cql_encode_string_ref_new(...);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_blob_ref _Nonnull cql_encode_blob_ref_new(..);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_bool cql_decode_bool(...);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int32 cql_decode_int32(...);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_int64 cql_decode_int64(...);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_double cql_decode_double(...);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_ref _Nonnull cql_decode_string_ref_new(...);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_blob_ref _Nonnull cql_decode_blob_ref_new(...);</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="boxing-statements"></a>Boxing Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#boxing-statements" title="Direct link to heading">#</a></h3><p>You must provide helpers to &quot;box&quot; and &quot;unbox&quot; a SQLite statement
into a <code>cql_ref_type</code> of the appropriate type.  These are used
to create boxed cursors.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_object_ref _Nonnull cql_box_stmt(sqlite3_stmt *_Nullable stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">sqlite3_stmt *_Nullable cql_unbox_stmt(cql_object_ref _Nonnull ref);</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-common-headers"></a>The Common Headers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-common-headers" title="Direct link to heading">#</a></h3><p>The standard APIs all build on the above, so they should be included last.</p><p>Now in some cases the signature of the things you provide in <code>cqlrt.h</code> is basically fixed,
so it seems like it would be easier to move the prototpyes into <code>cqlrt_common.h</code>.
However, in many cases additional things are needed like <code>declspec</code> or <code>export</code> or
other system specific things.  The result is that <code>cqlrt.h</code> is maybe a bit more
verbose that it strictly needs to be.  Also some versions of cqlrt.h choose to
implement some of the APIs as macros...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// NOTE: This must be included *after* all of the above symbols/macros.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &quot;cqlrt_common.h&quot;</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-cqlrt_cf-runtime"></a>The <code>cqlrt_cf</code> Runtime<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-cqlrt_cf-runtime" title="Direct link to heading">#</a></h3><p>In order to use the Objective-C code-gen (<code>--rt objc</code>) you need a runtime that has reference
types that are friendly to Objective-C.  For this purpose we created an open-source
version of such a runtime: it can be found in the <code>sources/cqlrt_cf</code> directory.
This runtime is also a decent example of how much customization you can do with just
a little code. Some brief notes:</p><ul><li>This runtime really only makes sense on macOS, iOS, or maybe some other place that Core Foundation (<code>CF</code>) exists<ul><li>As such its build process is considerably less portable than other parts of the system</li></ul></li><li>The CQL reference types have been redefined so that they map to:<ul><li><code>CFStringRef</code> (strings)</li><li><code>CFTypeRef</code> (objects)</li><li><code>CFDataRef</code> (blobs)</li></ul></li><li>The key worker functions use <code>CF</code>, e.g.<ul><li><code>cql_ref_hash</code> maps to <code>CFHash</code></li><li><code>cql_ref_equal</code> maps to <code>CFEqual</code></li><li><code>cql_retain</code> uses <code>CFRetain</code> (with a null guard)</li><li><code>cql_release</code> uses <code>CFRelease</code> (with a null guard)</li></ul></li><li>Strings use <code>CF</code> idioms, e.g.<ul><li>string literals are created with <code>CFSTR</code></li><li>C strings are created by using <code>CFStringGetCStringPtr</code> or <code>CFStringGetCString</code> when needed</li></ul></li></ul><p>Of course, since the meaning of some primitive types has changed, the contract to the CQL generated
code has changed accordingly.  For instance:</p><ul><li>procedures compiled against this runtime expect string arguments to be <code>CFStringRef</code></li><li>result sets provide <code>CFStringRef</code> values for string columns</li></ul><p>The consequence of this is that the Objective-C code generation <code>--rt objc</code> finds friendly
contracts that it can freely convert to types like <code>NSString *</code> which results in
seamless integration with the rest of an Objective-C application.</p><p>Of course the downside of all this is that the <code>cqlrt_cf</code> runtime is less portable.  It can only go
where <code>CF</code> exists.  Still, it is an interesting demonstration of the flexablity of the system.</p><p>The system could be further improved by creating a custom result type (e.g. <code>--rt c_cf</code>) and using
some of the result type options for the C code generation. For instance, the compiler could do these things:</p><ul><li>generate <code>CFStringRef foo;</code> instead of <code>cql_string_ref foo;</code> for declarations</li><li>generate <code>SInt32 an_integer</code> instead of <code>cql_int32 an_integer</code></li></ul><p>Even though <code>cqlrt_cf</code> is already mapping <code>cql_int32</code> to something compatible with <code>CF</code>,
making such changes would make the C output a little bit more <code>CF</code> idiomatic. This educational
exercise could probably be completed in just a few minutes by interested readers.</p><p>The <code>make.sh</code> file in the <code>sources/cqlrt_cf</code> directory illustrates how to get CQL to use
this new runtime.  The demo itself is a simple port of the code in <a href="https://cgsql.dev/cql-guide/x10" target="_blank" rel="noopener noreferrer">Appendix 10</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap-2"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap-2" title="Direct link to heading">#</a></h3><p>The CQL runtime, <code>cqlrt.c</code>, is intended to be replaced.  The version that ships with the distribution
is a simple, portable implementation that is single threaded. Serious users of CQL will likely
want to replace the default version of the runtime with something more tuned to their use case.</p><p>Topics covered included:</p><ul><li>contract, error, and tracing macros</li><li>how value types are defined</li><li>how reference types are defined</li><li>mocking (for use in a test suite)</li><li>profiling</li><li>encoding of sensitive columns</li><li>boxing statements</li><li>the <code>cqlrt_cf</code> runtime</li></ul><p>As with the other parts, no attempt was made to cover every detail.  That is
best done by reading the source code.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-6-schema-management"></a>Part 6: Schema Management<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-6-schema-management" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-5"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-5" title="Direct link to heading">#</a></h3><p>Part 6 continues with a discussion of the essentials of schema management in the CQL compiler.
As in the previous parts, the goal here is not to go over every detail of the system but rather to give
a sense of how schema management happens in general -- the core strategies and implementation choices --
so that when reading the management code you will have an idea how it all hangs together. To accomplish
this, various key data structures will be explained in detail and accompanied by examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-management"></a>Schema Management<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-management" title="Direct link to heading">#</a></h2><p>The primary goal of the schema management features of the CQL compiler is to provide the ability
to create a &quot;schema upgrader&quot; that can move a given user&#x27;s database from a previous version
of the schema to the current version.  Because of the limitations of SQL in general, and
SQLite in particular, not all transforms are possible; so additionally the system must correctly
detect and prevent upgrades that cannot be safely performed.</p><p>The full set of schema attributes and their meaning is described in <a href="https://cgsql.dev/cql-guide/ch10" target="_blank" rel="noopener noreferrer">Chapter 10</a>
and the full set of validations is described in <a href="https://cgsql.dev/cql-guide/ch11" target="_blank" rel="noopener noreferrer">Chapter 11</a>.  Briefly the
directives are:</p><ul><li><code>@create(n)</code>: indicates a table/column is to be created at version <code>n</code>.</li><li><code>@delete(n)</code>: indicates a table/column is to be deleted at version <code>n</code>.</li><li><code>@recreate</code>: indicates the table contents are not precious<ul><li>the table can be dropped and created when its schema changes</li><li>this does not combine with <code>@create</code></li><li>it applies only to tables</li><li>views, triggers, and indices are always on the <code>@recreate</code> plan and do not have to be marked so</li></ul></li></ul><p>Now the various annotations can occur substantially in any order as there are no rules that require that
tables that are created later in time appear later in the input.  This means the appearance order
of tables is in general very inconvenient for any upgrading logic.  However, the semantic validation
pass gathers all the annotations into two large <code>bytebuf</code> objects which can be readily sorted --
one for things on the <code>@create</code> plan and one for the <code>@recreate</code> plan.  These will be discussed below.</p><p>At this point it&#x27;s probably best to start looking at some of the code fragments. We&#x27;re going to be looking
at all the steps in the top level function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for schema upgrade code-gen.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_schema_upgrade_main(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(options.file_names_count == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Note that the schema upgrader code generator in CQL does not produce <code>C</code> but rather it produces
more <code>CQL</code> which then has to be compiled down to <code>C</code>.  This choice means that the codegen is a
lot more readable and gets the benefit of the usual CQL error checking and exception management.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="check-for-errors-check-for---global_proc"></a>Check for errors, check for <code>--global_proc</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#check-for-errors-check-for---global_proc" title="Direct link to heading">#</a></h3><p>We start with some simple error checks:  Any semantic errors abort the code-generation.
The <code>--global_proc</code> names the procedure that will do the upgrade. It is also used
as a prefix on all of the tables that the upgrader requires. This makes it possible,
if desired, to have separate upgraders for different parts of your schema, or to
combine upgraders from two different unrelated subsystems in the same database.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_exit_on_semantic_errors(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  exit_on_no_global_proc();</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preparing-the-attributes"></a>Preparing the Attributes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preparing-the-attributes" title="Direct link to heading">#</a></h3><p>The two arrays <code>schema_annotations</code> and <code>recreate_annotations</code> are sorted.
The item count can be easily computed using the allocated size of these items,
both of which are of type <code>bytebuf</code>.  The comparators provided to <code>qsort</code>
put these arrays in exactly the order needed.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // first sort the schema annotations according to version, type etc.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // we want to process these in an orderly fashion and the upgrade rules</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // are nothing like the declared order.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *base = schema_annotations-&gt;ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t schema_items_size = sizeof(schema_annotation);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t schema_items_count = schema_annotations-&gt;used / schema_items_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  schema_annotation *notes = (schema_annotation*)base;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t max_schema_version = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (schema_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     qsort(base, schema_items_count, schema_items_size, annotation_comparator);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     max_schema_version = notes[schema_items_count - 1].version;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // likewise, @recreate annotations, in the correct upgrade order (see comparator)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  base = recreate_annotations-&gt;ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t recreate_items_size = sizeof(recreate_annotation);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  size_t recreate_items_count = recreate_annotations-&gt;used / recreate_items_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (recreate_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    qsort(base, recreate_items_count, recreate_items_size, recreate_comparator);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  recreate_annotation *recreates = (recreate_annotation *)base;</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="creating-the-global-crc"></a>Creating the Global CRC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#creating-the-global-crc" title="Direct link to heading">#</a></h3><p>Schema upgrade is expensive, so we want to be able to quickly detect if the schema
installed is already the latest version. To do this we compute a single global
64-bit CRC for the current version of the schema.  This can be compared against a
stored schema CRC from the last run. If the CRCs match, no work needs to be done.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(all_schema);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // emit canonicalized schema for everything we will upgrade</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this will include the schema declarations for the ad hoc migrations, too;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_generate_schema_by_mode(&amp;all_schema, SCHEMA_TO_UPGRADE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // compute the master CRC using schema and migration scripts</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  llint_t schema_crc = (llint_t)crc_charbuf(&amp;all_schema);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(all_schema);</span></div></div></div></div></div><p>The schema generator is used to emit the full schema, including annotations, into
a buffer. A raw CRC of the buffer gives us the &quot;global&quot; or &quot;overall&quot; CRC for the
whole schema.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="output-fragments"></a>Output Fragments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#output-fragments" title="Direct link to heading">#</a></h3><p>A number of buffers will hold the various pieces of output.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(preamble);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(main);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(decls);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(pending);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(upgrade);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(baseline);</span></div></div></div></div></div><p>These will be assembled as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(output_file);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s\n&quot;, decls.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, preamble.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, main.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], output_file.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(output_file);</span></div></div></div></div></div><p>In short:</p><ul><li>first <code>decls</code>, this declares the schema among other things</li><li>then, <code>preamble</code>, this contains helper procedures</li><li>then, <code>main</code>, the primary upgrader steps go here</li></ul><p>We&#x27;ll go over all of these in subsequent sections.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="declarations-section"></a>Declarations Section<a aria-hidden="true" tabindex="-1" class="hash-link" href="#declarations-section" title="Direct link to heading">#</a></h3><p>The result type includes a customizable prefix string.  This is the first thing to go out.
Typically this is the appropriate copyright notice.  <code>rt.c</code> has this information and that
file is replaceable.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;%s&quot;, rt-&gt;source_prefix);</span></div></div></div></div></div><p>The schema upgrade script is in the business of creating tables from old versions and then altering them.
The table declarations will be for the final shape.  We need to emit <code>@SCHEMA_UPGRADE_SCRIPT</code> so that
the CQL compiler knows that there will be multiple declarations of the same table and they might not
be identical. The upgrade script is in the business of getting things to the end state.  Likewise
it is normal for the schema upgrade script to refer to columns that have been deleted, this is because
a column might be created in say version 5 and then deleted in version 10.  The upgrade code goes
through the columns lifecycle, so even though the declarations already say the column is doomed
to die in version 10, the creation code in version 5 is legal -- and necessary.  Schema migration steps
that run in version 6, 7, 8, or 9 might use the contents of the column as part of essential data migration.
We can never know what version we might find in a database that is being upgraded, it could be very far in
the past, at a time where a deleted column still existed.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- no columns will be considered hidden in this script\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- DDL in procs will not count as declarations\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;@SCHEMA_UPGRADE_SCRIPT;\n\n&quot;);</span></div></div></div></div></div><p>A convenience comment goes in the <code>decls</code> section with the CRC.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- schema crc %lld\n\n&quot;, schema_crc);</span></div></div></div></div></div><p>There are a set of functions that allow the creation of, and access to, an in-memory
cache of the facet state.  These functions are all defined in <code>cqlrt_common.c</code>.  But
they have to be declared to CQL to use them.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_emit_facet_functions(&amp;decls);</span></div></div></div></div></div><p>The table <code>sqlite_master</code> is used to read schema state.  That table has to be declared.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_emit_sqlite_master(&amp;decls);</span></div></div></div></div></div><p>The full schema may be used by the upgraders, we need a declaration of all of that.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- declare full schema of tables and views to be upgraded and their dependencies -- \n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_generate_schema_by_mode(&amp;decls, SCHEMA_TO_DECLARE);</span></div></div></div></div></div><p>At this point a quick side-step to the output modes and region arguments is appropriate.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-region-arguments"></a>Schema Region Arguments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-region-arguments" title="Direct link to heading">#</a></h4><p>The upgrader honors the arguments <code>--include_regions</code> and <code>--exclude_regions</code>.  If they are absent
that is the same as &quot;include everything&quot; and &quot;exclude nothing&quot;.  Recall that schema regions allow
you to group schema as you wish.  A typical use might be to define some &quot;core&quot; schema in a set
of regions (maybe just one) and then a set of &quot;optional&quot; schema in some additional regions.</p><p>An upgrader for just &quot;core&quot; could be created by adding <code>--include_regions core</code>.  When creating
upgraders for the optional parts, there are two choices:</p><ul><li><code>--include-regions optional1</code> : makes an upgrader for <code>optional1</code> and <code>core</code> (the assumption being that <code>optional1</code> was declared to depend on <code>core</code>)</li><li><code>--include-regions optional1</code> <code>--exclude-regions core</code> : makes an upgrader for <code>optional1</code> which should run after the standalone <code>core</code> upgrader has already run<ul><li>this allows you to share the &quot;core&quot; parts between any number of &quot;optional&quot; parts</li><li>and of course this can nest; there can be several &quot;core&quot; parts; and so forth</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-output-modes"></a>Schema Output Modes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-output-modes" title="Direct link to heading">#</a></h4><p>The flag bits are these:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We declare all schema we might depend on in this upgrade (this is the include list)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// e.g. we need all our dependent tables so that we can legally use them in an FK</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_TO_DECLARE 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We only emit schema that we are actually updating (this is include - exclude)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// e.g. a table on the exclude list is assumed to be upgraded by its own script</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// in a different run.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_TO_UPGRADE 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We get TEMP items IF and ONLY IF this bit is set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_TEMP_ITEMS 4</span></div></div></div></div></div><p>As we saw before, the schema we CRC is <code>SCHEMA_TO_UPGRADE</code>.  This is all the regions that were selected
but not their dependencies.  The point of this is that you might make an upgrader for say a &quot;core&quot;
part of your schema which can be shared and then make additional upgraders for various parts that
use the &quot;core&quot; but are otherwise &quot;optional&quot;.  Each of those &quot;optional&quot; upgraders needs its own CRC that
includes its schema but not the &quot;core&quot; schema.  However the &quot;optional&quot; schema can refer to &quot;core&quot;
schema (e.g. in foreign keys) so all of the tables are declared.  This is <code>SCHEMA_TO_DECLARE</code> mode.</p><ul><li>declare all schema you are allowed to refer to</li><li>CRC, and upgrade, only the parts selected by the region arguments</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-schema-helpers"></a>The Schema Helpers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-schema-helpers" title="Direct link to heading">#</a></h3><p>This bit generates the <code>facets</code> table, the full name is <code>your_global_proc_cql_schema_facets</code> where
<code>your_global_proc</code> is the <code>--global_proc</code> argument. This is referred to simply as the <code>facets</code> table.
There is an identical temporary table that is used to store the contents of the <code>facets</code> table
upon startup.  This allows the upgrader to produce a complete difference.  The <code>facets</code> table
is nothing more than a mapping between the name of some facet of the schema (like a table, a view,
a column) and its last known verison info -- usually its CRC.</p><ul><li>NOTE: this temp table predates the in-memory facets data structure so it could probably be removed<ul><li>the diff would have to work against the in-memory datastructure which is immutable hence just as good as a temp table</li><li>look for a change like this soon</li></ul></li></ul><p>The remaining procedures are for testing facet state or <code>sqlite_master</code> state.  All of them get the
usual global prefix.  For ease of discussion I will elide the prefix for the rest of this document.</p><ul><li><code>check_column_exists</code> : checks if the indicated column is present in <code>sqlite_master</code><ul><li>necessary because there is no <code>ALTER TABLE ADD COLUMN IF NOT EXISTS</code> command</li></ul></li><li><code>create_cql_schema_facets_if_needed</code> : actually creates the <code>facets</code> table if it does not exist</li><li><code>save_cql_schema_facets</code> : creates the <code>cql_schema_facets_saved</code> temp table and populates it</li><li><code>cql_set_facet_version</code> : sets one facet to the indicated value<ul><li>this writes to the database, not the in-memory version of the table</li></ul></li><li><code>cql_get_facet_version</code> : reads a facet value from the facet table<ul><li>this is only used to check the master schema value, after that the in-memory version is used</li></ul></li><li><code>cql_get_version_crc</code> : gets the CRC for a given schema version<ul><li>each schema version has its own CRC in addition to the global CRC</li><li>this information is stored in the facets table with a simple naming convention for the facet name</li><li>the in memory version of the table is always used here</li></ul></li><li><code>cql_set_version_crc</code> : sets the CRC for a given schema version in the facet table<ul><li>this writes to the database, not the in-memory version of the table</li></ul></li><li><code>cql_drop_legacy_triggers</code> : drops any triggers of the from <code>tr__*</code><ul><li>for historical reasons the original triggers did not include tombstones when deleted</li><li>this kludge is here to clean up legacy triggers and its peculiar to Messenger only</li><li>this should really be removed from the OSS version but it&#x27;s never been a priority</li><li>sorry...</li></ul></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_helpers(&amp;decls);</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="declared-upgrade-procedures"></a>Declared Upgrade Procedures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#declared-upgrade-procedures" title="Direct link to heading">#</a></h3><p>The annotations can include an upgrade procedure. The term &quot;migration&quot; procedure is sometimes used
as well and is synonymous.  This is some code that should run after the schema alteration has
been made to create/delete/move some data around in the new schema.  Each of these must be
declared before it is used and the declarations will be here, at the end of the <code>decls</code> section
after this introductory comment.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;decls, &quot;-- declared upgrade procedures if any\n&quot;);</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-upgrading-workers"></a>The Upgrading Workers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-upgrading-workers" title="Direct link to heading">#</a></h3><p>The main upgrader will invoke these key workers to do its job.  This is where the <code>preamble</code>
section starts. It contains the meat of the upgrade steps wrapped in procedures that do
the job.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_emit_baseline_tables_proc(&amp;preamble, &amp;baseline);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t view_creates = 0, view_drops = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_manage_views(&amp;preamble, &amp;view_drops, &amp;view_creates);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t index_creates = 0, index_drops = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_manage_indices(&amp;preamble, &amp;index_drops, &amp;index_creates);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t trigger_creates = 0, trigger_drops = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_schema_manage_triggers(&amp;preamble, &amp;trigger_drops, &amp;trigger_creates);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (recreate_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_schema_manage_recreate_tables(&amp;preamble, recreates, recreate_items_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t has_temp_schema = cg_schema_emit_temp_schema_proc(&amp;preamble);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t one_time_drop_needed = false;</span></div></div></div></div></div><p>These are the last of the worker methods:</p><ul><li><code>cg_schema_emit_baseline_tables_proc</code> : emits a procedure that will create the schema at its baseline version<ul><li>this means whatever &quot;v0&quot; of the schema was, no creates or deletes have yet happened</li></ul></li><li><code>cg_schema_manage_views</code> : creates the view management procedures<ul><li><code>cql_drop_all_views</code> : drops all views</li><li><code>cql_create_all_views</code> : creates all views</li><li>both of these run unless the global CRC matches</li></ul></li><li><code>cg_schema_manage_indices</code> : creates the index management procedures<ul><li><code>cql_drop_all_indices</code> : drops any index that exists and whose CRC changed</li><li><code>cql_create_all_indices</code> : creates any index whose CRC changed</li><li>recreating indices can be costly so it is only done if the index actually changed</li></ul></li><li><code>cg_schema_manage_triggers</code> : creates the trigger management procedures<ul><li><code>cql_drop_all_triggers</code> : drops all triggers</li><li><code>cql_create_all_triggers</code> : creates all triggers</li><li>both of these run unless the global CRC matches</li><li>additionally any legacy triggers will be deleted (see <code>cql_drop_legacy_triggers</code>)</li></ul></li><li><code>cg_schema_manage_recreate_tables</code> : creates the <code>cql_recreate_tables</code> worker<ul><li>the <code>recreate_annotations</code> array is used to find all the recreate tables</li><li>the entries are sorted by group, then name, so that annotations within a group are together</li><li>the procedure contains code to delete the procedure or group and recreate it if the CRC does not match</li><li>the CRC is computed using the code for create instructions and is stored in a facet with a suitable name</li><li>the easiest way to think of this code is that it always emits a chunk of recreates for a group<ul><li>ungrouped tables are a group of 1</li><li>group delete/create instructions accumulate until the next entry is in a different group</li></ul></li></ul></li><li><code>cg_schema_emit_temp_schema_proc</code> : emits a procedure to create any temporary schema<ul><li>temp tables are always created in full at the latest version</li><li>this code is run regardless of whether the global CRC matches or not</li></ul></li></ul><p>All of these functions semantic outputs like <code>all_indices_list</code>, <code>all_views_list</code>, etc. to do their job (except
<code>cg_schema_manage_recreate_tables</code> as noted). Generally they have all the data they need handed to them
on a silver platter by the semantic pass. This is not an accident.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reading-the-facets-into-memory"></a>Reading the Facets into Memory<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reading-the-facets-into-memory" title="Direct link to heading">#</a></h4><p>The <code>setup_facets</code> procedure simply selects out the entire <code>facets</code> table with a cursor
and uses <code>cql_facet_add</code> to get them into a hash table.  This is the primary source of
facets information during the run.  This is a good example of what the codegen looks like
so we&#x27;ll include this one in full.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // code to read the facets into the hash table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;@attribute(cql:private)\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;CREATE PROCEDURE %s_setup_facets()\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  BEGIN TRY\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    SET %s_facets := cql_facets_new();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    DECLARE C CURSOR FOR SELECT * from %s_cql_schema_facets;\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    LOOP FETCH C\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;      LET added := cql_facet_add(%s_facets, C.facet, C.version);\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;    END;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  END TRY;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  BEGIN CATCH\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;   -- if table doesn&#x27;t exist we just have empty facets, that&#x27;s ok\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;  END CATCH;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;preamble, &quot;END;\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">### The Main Upgrader</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">And now we come to the main upgrading procedure `perform_upgrade_steps`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">We&#x27;ll go over this section by section.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#### Standard Steps</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">```C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the main upgrade worker</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;\n@attribute(cql:private)\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;CREATE PROCEDURE %s_perform_upgrade_steps()\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;  DECLARE schema_version LONG INTEGER NOT NULL;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (view_drops) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    -- dropping all views --\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_drop_all_views();\n\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (index_drops) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    -- dropping condemned or changing indices --\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_drop_all_indices();\n\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (trigger_drops) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    -- dropping condemned or changing triggers --\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_drop_all_triggers();\n\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (baseline.used &gt; 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    llint_t baseline_crc = (llint_t)crc_charbuf(&amp;baseline);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    ---- install baseline schema if needed ----\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_get_version_crc(0, schema_version);\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    IF schema_version != %lld THEN\n&quot;, baseline_crc);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;      CALL %s_cql_install_baseline_schema();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;      CALL %s_cql_set_version_crc(0, %lld);\n&quot;, global_proc_name, baseline_crc);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    END IF;\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>First we deal with the preliminaries:</p><ul><li>drop the views if there are any</li><li>drop the indices that need dropping</li><li>drop the triggers if there are any</li><li>install the baseline schema if there is any</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="process-standard-annotations"></a>Process Standard Annotations<a aria-hidden="true" tabindex="-1" class="hash-link" href="#process-standard-annotations" title="Direct link to heading">#</a></h4><p>In this phase we walk the annotations from <code>schema_annotations</code> which are now stored in <code>notes</code>.</p><p>They have been sorted in exactly the right order to process them (by version, then type, then target).
We&#x27;ll create one set of instructions per version number as we simply accumulate instructions for any
version while we&#x27;re still on the same version then spit them all out.  Adding <code>target</code> to the sort
order ensures that the results have a total ordering (there are no ties that might yield an ambiguous order).</p><p>We set up a loop to walk over the annotations and we flush if we ever encounter an annotation for
a different version number.  We&#x27;ll have to force a flush at the end as well.  <code>cg_schema_end_version</code>
does the flush.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t prev_version = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int32_t i = 0; i &lt; schema_items_count; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    schema_annotation *note = &amp;notes[i];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *version_annotation = note-&gt;annotation_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    uint32_t type = note-&gt;annotation_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(type &gt;= SCHEMA_ANNOTATION_FIRST &amp;&amp; type &lt;= SCHEMA_ANNOTATION_LAST);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(is_ast_version_annotation(version_annotation));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_OPTION(vers, version_annotation-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(note-&gt;version == vers);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(vers &gt; 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (prev_version != vers) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_schema_end_version(&amp;main, &amp;upgrade, &amp;pending, prev_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      prev_version = vers;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>If we find any item that is in a region we are not upgrading, we skip it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CSTR target_name = note-&gt;target_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(type &gt;= SCHEMA_ANNOTATION_FIRST &amp;&amp; type &lt;= SCHEMA_ANNOTATION_LAST);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!include_from_region(note-&gt;target_ast-&gt;sem-&gt;region, SCHEMA_TO_UPGRADE)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>There are several annotation types.  Each one requires appropriate commands</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    switch (type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_CREATE_COLUMN: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... emit ALTER TABLE ADD COLUMN if the column does not already exist</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_COLUMN: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... it&#x27;s not possible to delete columns in SQLite (this is changing)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... we simply emit a comment and move on</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_CREATE_TABLE: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... if the table is moving from @recreate to @create we have to drop any stale version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... of it one time.  We emit a call to `cql_one_time_drop` and record that we need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... to generate that procedure in `one_time_drop_needed`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ...in all cases emit a CREATE TABLE IF NOT EXISTS</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_TABLE: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... emit DROP TABLE IF EXISTS for the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_INDEX:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_VIEW:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_DELETE_TRIGGER:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... this annotation indicates there is a tombstone on the item</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... this was handled in the appropriate `manage` worker above, nothing needs</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... to be done here except run any migration procs (see below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case SCHEMA_ANNOTATION_AD_HOC:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... ad hoc migration procs allow for code to be run one time when we hit</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ... a particular schema version, this just allows the migration proc to run</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        // no annotation based actions other than migration proc (handled below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Contract(version_annotation-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bprintf(&amp;upgrade, &quot;      -- ad hoc migration proc %s will run\n\n&quot;, target_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>The above constitutes the bulk of the upgrading logic which, as you can see, isn&#x27;t that complicated.</p><p>Any of the above might have a migration proc.  If there is one in the node, then generate:</p><ul><li>emit a call to <code>cql_facet_find</code> to see if the migration proc has already run</li><li>emit a declaration for the migration proc into the <code>decls</code> section</li><li>emit a call to the procedure (it accept no arguments)</li><li>emit a call to <code>cql_set_facet_version</code> to record that the migrator ran</li></ul><p>When the loop is done, any pending migration code is flushed using <code>cg_schema_end_version</code> again.</p><p>At this point we can move on to the finalization steps.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="finalization-steps"></a>Finalization Steps<a aria-hidden="true" tabindex="-1" class="hash-link" href="#finalization-steps" title="Direct link to heading">#</a></h4><p>With the standard upgrade finished, there is just some house keeping left:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (recreate_items_count) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_recreate_tables();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (view_creates) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_create_all_views();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (index_creates) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_create_all_indices();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (trigger_creates) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;main, &quot;    CALL %s_cql_create_all_triggers();\n&quot;, global_proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;    CALL %s_cql_set_facet_version(&#x27;cql_schema_version&#x27;, %d);\n&quot;, global_proc_name, prev_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;    CALL %s_cql_set_facet_version(&#x27;cql_schema_crc&#x27;, %lld);\n&quot;, global_proc_name, schema_crc);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;main, &quot;END;\n\n&quot;);</span></div></div></div></div></div><ul><li><code>cql_recreate_tables</code> : must run if there are any tables marked recreate<ul><li>this procedure will have code to drop and recreate any changed tables</li><li>this procedure was created by <code>cg_schema_manage_recreate_tables</code> and that process is described above<ul><li>basically, it uses <code>recreate_annotations</code> to do the job</li></ul></li><li>any that were condemned by marking with <code>@delete</code> will not be created again here</li></ul></li><li><code>cql_create_all_views</code> : must run if there are any views, they need to be put back<ul><li>any that were condemned by marking with <code>@delete</code> are not created again here</li></ul></li><li><code>cql_create_all_indices</code> : must run if there are any indices, this will create any that are missing<ul><li>any that were changing were previously deleted, this is where they come back</li><li>any that were condemned by marking with <code>@delete</code> are not created again here</li></ul></li><li><code>cql_create_all_triggers</code> : must run if there are any triggers, they need to be put back<ul><li>any that were condemned by marking with <code>@delete</code> are not created again here</li><li>triggers might cause weird side-effects during upgrade hence they are always dropped</li><li>stale triggers especially could be problematic</li><li>any triggers that refer to views couldn&#x27;t possibly run as the views are gone</li><li>hence, triggers are always dropped and recreated</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-main-steps"></a>The &quot;Main&quot; Steps<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-main-steps" title="Direct link to heading">#</a></h4><p>We&#x27;re getting very close to the top level now</p><ul><li><p><code>perform_needed_upgrades</code> : this orchestrates the upgrade, if it is called there is one</p><ul><li><code>cql_facet_find</code> : is used to check for a schema &quot;downgrade&quot;<ul><li>abort with an error if that happens</li></ul></li><li><code>save_cql_schema_facets</code> : saves the facets as they exist so we can diff them</li><li><code>perform_upgrade_steps</code> : does the upgrade</li><li>a <code>LEFT OUTER JOIN</code> between <code>cql_schema_facets</code> and <code>cql_schema_facets_saved</code> reports differences</li><li>any errors will cause the normal CQL error flow</li></ul></li><li><p>the main entry point is named by <code>global_proc_name</code></p><ul><li><code>create_cql_schema_facets_if_needed</code> is used to create the <code>facets</code> table if it doesn&#x27;t already exist</li><li>the special facet <code>cql_schema_crc</code> is read from the <code>facets</code> table</li><li>if the CRC stored there matches our target then we return &quot;no differences&quot;, otherwise</li><li><code>setup_facets</code> : loads the in-memory version of the facets table</li><li><code>perform_needed_upgrades</code> : does the work and creates the diff</li><li><code>cql_facets_delete</code> is used to free the in-memory storage, even if there were errors in <code>perform_needed_upgrades</code></li></ul></li><li><p><code>cql_install_temp_schema</code> : installs temporary schema if there is any, regardless of the CRC</p></li><li><p>the <code>one_time_drop</code> code is emitted if it was needed</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="writing-the-buffer"></a>Writing the Buffer<a aria-hidden="true" tabindex="-1" class="hash-link" href="#writing-the-buffer" title="Direct link to heading">#</a></h4><p>At this point the main buffers <code>decls</code>, <code>preamble</code>, and <code>main</code> are ready to go.  We&#x27;re back to where we started
but we can quickly recap the overall flow.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(output_file);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s\n&quot;, decls.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, preamble.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;output_file, &quot;%s&quot;, main.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], output_file.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(output_file);</span></div></div></div></div></div><p>There is nothing left but to <code>CHARBUF_CLOSE</code> the interim buffers we created.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap-3"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap-3" title="Direct link to heading">#</a></h3><p>At present <code>cg_schema.c</code> accomplishes a lot and is fairly light at only 1313 lines (at present).
It is able to do so because it can leverage heavy lifting done in the semantic analysis phase
and schema generation that can be done like all other SQL generation by the echoing code
discussed in <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>.</p><p>Topics covered included:</p><ul><li>the essential sources of schema information from the semantic pass</li><li>the state tables used in the database and helpers for read/write of the same</li><li>the interaction with schema regions</li><li>the prosecution steps for tables, columns, views, triggers, indices</li><li>the key annotation types and what code they create</li><li>the handling of recreate tables, temp tables, and the base schema</li><li>how all of these are wired together starting from the upgrader&#x27;s &quot;main&quot;</li></ul><p>As with the other parts, no attempt was made to cover every function in detail.  That is
best done by reading the source code. But there is overall structure here and an understanding
of the basic principles is helpful before diving into the source code.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-7-json-generation"></a>Part 7: JSON Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-7-json-generation" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-6"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-6" title="Direct link to heading">#</a></h3><p>Part 7 continues with a discussion of the JSON generation code.
As in the previous sections, the goal here is not to go over every detail but rather to give
a sense of how JSON creation works in general -- the core strategies and implementation choices --
so that when reading the source you will have an idea how it all hangs together. To accomplish
this, we&#x27;ll illustrate the key strategies used to extract the data and format the JSON.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="json-schema"></a>JSON Schema<a aria-hidden="true" tabindex="-1" class="hash-link" href="#json-schema" title="Direct link to heading">#</a></h2><p>The JSON schema is described in <a href="https://cgsql.dev/cql-guide/ch13" target="_blank" rel="noopener noreferrer">Chapter 13</a> of the Guide and there
is a nice diagram of its <a href="https://cgsql.dev/json-diagram" target="_blank" rel="noopener noreferrer">grammar</a> for reference.  So, we won&#x27;t be
discussing all the details of the output.  Instead we&#x27;re going to go over the theory of how the
JSON generator works. It is structured very much like the other code generators but it happens
to produce a JSON file.  It&#x27;s call the &quot;JSON Schema&quot; because most of the content is a description
of the database schema in JSON form.  As such it&#x27;s almost entirely just a simple walk of the AST
in the correct order.  The only really tricky bit is the extra dependency analysis on the AST.
This allows us to emit usage information in the output for downstream tools to use as needed.</p><p>We&#x27;ll cover these topics:</p><ul><li>walking the AST</li><li>formatting</li><li>computing the dependencies</li></ul><p>This should be a short chapter compared to the others, this output really is much simpler to
create than the C or the schema upgrader.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="walking-the-ast"></a>Walking the AST<a aria-hidden="true" tabindex="-1" class="hash-link" href="#walking-the-ast" title="Direct link to heading">#</a></h3><p>If you run this command:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">$ cql --in x --rt json_schema --cg x.json</span></div></div></div></div></div><p>Where <code>x</code> is an empty file, you&#x27;ll get the following skeletal JSON, lightly reformatted for brevity:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-JSON codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;tables&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;virtualTables&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;views&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;indices&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;triggers&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;attributes&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;queries&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;inserts&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;generalInserts&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;updates&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;deletes&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;general&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;regions&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;adHocMigrationProcs&quot; : [  ],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;enums&quot; : [  ]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>From this we can deduce a great deal of the structure of the code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for json schema format</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_json_schema_main(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(options.file_names_count == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_exit_on_semantic_errors(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  tables_to_procs = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(main);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *output = &amp;main;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;%s&quot;, rt-&gt;source_prefix);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // master dictionary begins</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\n{\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(defs, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_tables(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_virtual_tables(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_views(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_indices(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_triggers(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_stmt_list(output, head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_regions(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_ad_hoc_migration_procs(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_enums(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (options.test) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_table_users(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(defs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\n}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], output-&gt;ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(main);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(tables_to_procs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>cg_json_schema_main</code> is the main function and you can see that it mirrors that skeletal
JSON output nearly exactly with some additional test output options.  We&#x27;ll cover
the test output in a later section when we&#x27;ve had a chance to discuss the dependency
analysis.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-json-writer-views"></a>Example JSON Writer: Views<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-json-writer-views" title="Direct link to heading">#</a></h4><p>These are sufficiently easy that we can just walk through one of the procedures front to back.
Let&#x27;s look at the &quot;views&quot; section.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The set of views look rather like the query section in as much as</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// they are in fact nothing more than named select statements.  However</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the output here is somewhat simplified.  We only emit the whole select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// statement and any binding args, we don&#x27;t also emit all the pieces of the select.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_views(charbuf *output) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;views\&quot; : [\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(views, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t i = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = all_views_list; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *ast = item-&gt;ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(is_ast_create_view_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *misc_attrs = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *attr_target = ast-&gt;parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_stmt_and_attr(attr_target)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target-&gt;parent);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      misc_attrs = misc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_test_details(output, ast, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_OPTION(flags, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(view_and_attrs, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(name_and_select, view_and_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(select_stmt, name_and_select-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, name_and_select-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (i &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;{\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool_t is_deleted = ast-&gt;sem-&gt;delete_version &gt; 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    BEGIN_INDENT(view, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\&quot;name\&quot; : \&quot;%s\&quot;&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;CRC\&quot; : \&quot;%lld\&quot;&quot;, crc_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;isTemp\&quot; : %d&quot;, !!(flags &amp; VIEW_IS_TEMP));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;isDeleted\&quot; : %d&quot;, is_deleted);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_deleted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n\&quot;deletedVersion\&quot; : %d&quot;, ast-&gt;sem-&gt;delete_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_deleted_migration_proc(output, view_and_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_emit_region_info(output, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_misc_attrs(output, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_projection(output, select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_fragment_with_params(output, &quot;select&quot;, select_stmt, gen_one_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_dependencies(output, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    END_INDENT(view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\n}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    i++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(views);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;]&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="view-loop"></a>View Loop<a aria-hidden="true" tabindex="-1" class="hash-link" href="#view-loop" title="Direct link to heading">#</a></h4><p>Already we can see the structure emerging, and of course its nothing
more than a bunch of <code>bprintf</code>.  Let&#x27;s do it section by section:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(output, &quot;\&quot;views\&quot; : [\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN_INDENT(views, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (list_item *item = all_views_list; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ..</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END_INDENT(views);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(output, &quot;]&quot;);</span></div></div></div></div></div><p>Unsurprisingly, this code will iterate the <code>all_views_list</code> which was
created precisely for this kind of output.  The semantic pass populates
this list for use downstream.</p><p>We&#x27;ll deal with <code>BEGIN_INDENT</code> a bit later, but it should be clear what
it does by the name for now.  So we&#x27;ve made the &quot;views&quot; section and
we&#x27;ll put 0 or more views in it.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="view-extraction"></a>View Extraction<a aria-hidden="true" tabindex="-1" class="hash-link" href="#view-extraction" title="Direct link to heading">#</a></h4><p>The next section extracts the necessary information and emits
the test output:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *ast = item-&gt;ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(is_ast_create_view_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *misc_attrs = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *attr_target = ast-&gt;parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_stmt_and_attr(attr_target)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target-&gt;parent);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      misc_attrs = misc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_test_details(output, ast, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_OPTION(flags, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(view_and_attrs, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(name_and_select, view_and_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(select_stmt, name_and_select-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, name_and_select-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div></div></div></div></div><p>The <code>is_ast_stmt_and_attr</code> node tell us if there were any misc attributes on the
statement.  Those attributes can be extracted and printed.  We have to look up
the tree a little bit from where we are because this is the &quot;all views&quot; list,
if there were attributes on this view they were attached two levels up.  In any
case <code>misc_attrs</code> ends with attributes if there are any.</p><p>After the test output, the necessary view attributes are extracted the usual
way with <code>EXTRACT</code> macros for the view shape.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="test-output"></a>Test Output<a aria-hidden="true" tabindex="-1" class="hash-link" href="#test-output" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_test_details(charbuf *output, ast_node *ast, ast_node *misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (options.test) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\nThe statement ending at line %d\n&quot;, ast-&gt;lineno);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_set_output_buffer(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      gen_with_callbacks(misc_attrs, gen_misc_attrs, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_with_callbacks(ast, gen_one_stmt, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;\n\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>All of the JSON fragments have the usual test pattern &quot;The statement ending at line nnn&quot;.
This means that the normal validator will be able to find comments in the test file
and associate them with json parts.  The testing strategies are discussed in
[Part 4]((<a href="https://cgsql.dev/cql-guide/int04" target="_blank" rel="noopener noreferrer">https://cgsql.dev/cql-guide/int04</a>).</p><p>In addition, while in test mode, we also emit the original statement that caused
this JSON fragment to be created. This allows the test patterns to cross check
the input and output and also makes the test output more readable for humans.</p><p>Note that in test mode the JSON is effectively corrupted by the test output as it
is not well-formed JSON in any way.  So use of --test is strictly for validation only.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="view-basics"></a>View Basics<a aria-hidden="true" tabindex="-1" class="hash-link" href="#view-basics" title="Direct link to heading">#</a></h4><p>All of the things that go into the JSON have some attributes that are universally present
and generally come directly from the AST.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (i &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;{\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t is_deleted = ast-&gt;sem-&gt;delete_version &gt; 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(view, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;name\&quot; : \&quot;%s\&quot;&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n\&quot;CRC\&quot; : \&quot;%lld\&quot;&quot;, crc_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n\&quot;isTemp\&quot; : %d&quot;, !!(flags &amp; VIEW_IS_TEMP));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;,\n\&quot;isDeleted\&quot; : %d&quot;, is_deleted);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_deleted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;deletedVersion\&quot; : %d&quot;, ast-&gt;sem-&gt;delete_version);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_deleted_migration_proc(output, view_and_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\n}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  i++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This part of the output is the simplest</p><ul><li>we emit a comma if we need one (only the first entry doesn&#x27;t)</li><li>we start the view object &#x27;{&#x27;</li><li>more indenting for the interior of the view</li><li>emit the view name</li><li>emit the CRC of the view (this makes it easy to see if the view changed)<ul><li><code>crc_stmt</code> computes the CRC by echoing the statement into a scratch buffer and then running the CRC algorithm on that buffer</li></ul></li><li>note the &quot;,\n&quot; pattern, this pattern is used because sometimes there are optional parts and using a leading &quot;,\n&quot; makes it clear which part is supposed to emit the comma<ul><li>it turns out getting the commas right is one of the greater annoyances of JSON output</li></ul></li><li>emit &quot;isTemp&quot;</li><li>emit &quot;isDeleted&quot;</li><li>if the view is deleted, emit &quot;deletedVersion&quot;</li><li>if there is a migration procedure on the <code>@delete</code> attribute emit that as well<ul><li><code>cg_json_deleted_migration_proc</code> scans the attribute list for <code>@delete</code> attribute and emits the procedure name on that attribute if there is one</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="optional-info"></a>Optional Info<a aria-hidden="true" tabindex="-1" class="hash-link" href="#optional-info" title="Direct link to heading">#</a></h4><p>The next fragment emits two optional pieces that are present in many types of objects:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_emit_region_info(output, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(output, &quot;,\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_json_misc_attrs(output, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><ul><li><p>if there is a region assocatied with this view, we emit it here</p><ul><li><code>cg_json_emit_region_info</code> emits two things:<ul><li>the view&#x27;s region</li><li>the &quot;deployment region&quot; of that region if any (regions are contained in deployable groups)</li><li>see <a href="https://cgsql.dev/cql-guide/ch10#schema-regions" target="_blank" rel="noopener noreferrer">Chapter 10</a> for more info on regions and deployment regions</li></ul></li></ul></li><li><p>if there are any miscellaneous attributes they are emitted</p><ul><li>we&#x27;ll use <code>cg_json_misc_attrs</code> as our general formatting example when we get to that</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-view-details"></a>The View Details<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-view-details" title="Direct link to heading">#</a></h4><p>There is very little left in the view emitting code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_projection(output, select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fragment_with_params(output, &quot;select&quot;, select_stmt, gen_one_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_json_dependencies(output, ast);</span></div></div></div></div></div><ul><li><code>cg_json_projection</code> emits the name and type of each column in the view select list</li><li><code>cg_fragment_with_params</code> emits the statement that creates the view in an attribute named &quot;select&quot;<ul><li>the normal echoing code emits the statement</li><li>views have no variables to bind but other statement forms inside of procedures can have variables in the statement</li><li>the variable names are replace with &quot;?&quot; in the text of the statement</li><li>the names of the variable appear in &quot;selectArgs&quot; (always empty for views)</li></ul></li><li><code>cg_json_dependencies</code> emits the tables and views that were used by this view, it gets its own section</li></ul><p>Those few things produce all JSON for a view. All the other schema elements do basically the same things.  Most of the
helpers are shared so, for instance, regions, misc attributes, and dependencies appear in nearly every kind of object
in the JSON.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="formatting-the-json"></a>Formatting the JSON<a aria-hidden="true" tabindex="-1" class="hash-link" href="#formatting-the-json" title="Direct link to heading">#</a></h3><p>To make the JSON pretty we want to indent it appropriately and put commas in the right
places.  There are some useful macros for this, and they all rely on the fact that
the emitted text goes to a <code>charbuf</code> variable creatively called <code>output</code>.</p><p>Here&#x27;s a sample procedure that was mentioned earlier, it does the usual things:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a list of attributes for the current entity, it could be any kind of entity.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Whatever it is we spit out the attributes here in array format.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_misc_attrs(charbuf *output, ast_node *_Nonnull list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_misc_attrs(list));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;attributes\&quot; : [\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_INDENT(attr, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN_LIST;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *item = list; item; item = item-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    COMMA;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_json_misc_attr(output, item-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_LIST;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END_INDENT(attr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;]&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The miscellaneous attributes are going to be emitted in a list, and since any
one attribute can actually be a list of attributes, this ends up being recursive
(<code>cg_json_misc_attr</code> can end up calling back to <code>cg_json_misc_attrs</code>).  Attributes
are actually quite flexible.  Let&#x27;s look at the helpers that will be used
to do this formatting.</p><p>From <code>charbuf.h</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These helpers push a buffer and use it for the output temporarily.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// When the buffer is finished (at END_INDENT) bindent is used to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indent it by the indicated amount.  They assume the output buffer is called</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;output&quot;.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define BEGIN_INDENT(name, level) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *name##_saved = output; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t name##_level = level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  output = &amp;name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define END_INDENT(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  output = name##_saved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bindent(output, &amp;name, name##_level); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(name); \</span></div></div></div></div></div><ul><li><code>BEGIN_INDENT</code> : sets up the indenting<ul><li>save the current output buffer</li><li>stash the desired indent level in a named local</li><li>make a new scratch buffer using the given name</li><li>set the output to be the scratch buffer</li></ul></li><li><code>END_INDENT</code> : flushes the indented stuff<ul><li>restores the output buffer to what it was</li><li>writes the temporary buffer into the output buffer, indenting it by the desired abount</li><li>close the temporrary buffer</li></ul></li><li><code>bindent</code> : a <code>charbuf</code> helper that reads the input line by line and writes it with indenting spaces to the output</li></ul><p>The rest of the helpers  manage the commas in the (nested) lists:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These little helpers are for handling comma seperated lists where you may or may</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// not need a comma in various places.  The local tracks if there is an item already</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// present and you either get &quot;,\n&quot;  or just &quot;\n&quot; as needed.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define BEGIN_LIST bool_t list_start = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CONTINUE_LIST bool_t list_start = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define COMMA if (!list_start) bprintf(output, &quot;,\n&quot;); else list_start = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define END_LIST if (!list_start) bprintf(output, &quot;\n&quot;)</span></div></div></div></div></div><ul><li><code>BEGIN_LIST</code> : starts a list, records that we are at the beginning of the list</li><li><code>CONTINUE_LIST</code> : starts a list, but assumes things have already been put into it</li><li><code>COMMA</code> : a new item is about to be emitted, add a comma if one is needed<ul><li>i.e. add a comma if we are not on the first item</li></ul></li><li><code>END_LIST</code> : emits a blank line if anything went into the list<ul><li>this puts us in the write place to put an end marker such as &#x27;]&#x27; or &#x27;}&#x27;</li></ul></li></ul><p>So reviewing this bit of code,</p><ul><li>emit the attribute name and start the array &quot;[&quot;</li><li>we start indenting</li><li>we start a list</li><li>we emit a comma if needed</li><li>we emit the new misc attribute<ul><li>this will crack the AST, and get the attribute name and value</li><li>this can recurse</li><li><code>cg_json_misc_attr</code> is pretty simple and a good exercise for the reader</li></ul></li><li>repeat for all attributes</li><li>end the list</li><li>end the indenting</li><li>emit the attribute end &quot;]&quot;</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="quoted-text"></a>Quoted Text<a aria-hidden="true" tabindex="-1" class="hash-link" href="#quoted-text" title="Direct link to heading">#</a></h4><p>Most quoted text in the JSON output is either hard-coded constants,
or else is a CQL identifier and therefore has no special characters.
Those two cases are very simple and no escaping or special formatting
is needed.  We just emit the text with quotes around it. However,
there are cases where general text that might have special characters
in it needs to be emitted.  When that happens a call like this is used:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_pretty_quote_plaintext(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sql.ptr,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    output,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    PRETTY_QUOTE_JSON | PRETTY_QUOTE_SINGLE_LINE);</span></div></div></div></div></div><p><code>cg_pretty_quote_plaintext</code> has been discussed before when it was used to
create SQL strings for the C output. This usage is similar.
Here we&#x27;re using <code>PRETTY_QUOTE_JSON</code> to indicate that only
escape sequences supported by JSON should appear in the output. The format for
hexadecimal escape sequences for non-printable characters is different than C
and some of the C short escapes are not supported
(e.g. &quot;\a&quot; is not legal JSON).  We always use <code>PRETTY_QUOTE_SINGLE_LINE</code>
in the JSON output so that multi-line SQL is rendered as one line.
Remember here we are are JSON-escaping the SQL so the embedded newlines
in the original SQL were already converted to &#x27;\&#x27; &#x27;n&#x27; (two characters)
and therefore any newlines still in the string are those placed there by the
line breaking of the SQL not by newlines in string literals.  Hence
those newlines are optional, any whitespace will do.</p><p>In any case, <code>cg_pretty_quote_plaintext</code> is just the function to do what we need
and this output is only slightly different than what would be emitted for
the C codegen.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="dependency-analysis"></a>Dependency Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#dependency-analysis" title="Direct link to heading">#</a></h3><p>There are a number of places where dependencies have to be computed. To do this job,
this function is used universally:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// For procedures and triggers we want to walk the statement list and emit a set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// of dependency entries that show what the code in question is using and how.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We track tables that are used and if they appear in say the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// (or some other read-context) or if they are the subject of an insert, update,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// or delete.  We also track the use of nested procedures and produce a list of</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// procs the subject might call.  Of course no proc calls ever appear in triggers.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_json_dependencies(charbuf *output, ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>In general this code walks any AST looking for a variety of patterns in the AST
that correspond to use of tables, directly or indirectly. Actually more accurately,
<code>cg_json_dependencies</code> uses <code>find_table_refs</code> to do the job, and it does so by:</p><ul><li>creating an output buffer for each kind of thing <code>find_table_refs</code> might find</li><li>setting up a simple callback to fill in the buffer</li><li>invoking <code>find_table_refs</code></li><li>formatting the buffers that have any resulting dependency data and emitting them as dependencies</li></ul><p>This works for any kind of AST really, though typically you do this for procedures
or triggers because they have an interesting body.  But the analysis also makes sense for views
because views can refer to other views and to tables.</p><p>The primary code looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  table_callbacks callbacks = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_any_table = cg_found_table,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_any_view = cg_found_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_inserts = cg_found_insert,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_updates = cg_found_update,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_deletes = cg_found_delete,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_from = cg_found_from,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_proc = cg_found_proc,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .callback_context = &amp;context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  find_table_refs(&amp;callbacks, ast);</span></div></div></div></div></div><p>And an example callback:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the callback function that tells us a view name was found in the body</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// of the stored proc we are currently examining.  The void context information</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is how we remember which proc we were processing.   For each table we have</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// a character buffer.  We look it up, create it if not present, and write into it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We also write into the buffer for the current proc which came in with the context.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_found_view(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR view_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node* table_ast,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void* pvContext)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  json_context *context = (json_context *)pvContext;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(context-&gt;cookie == cookie_str);  // sanity check</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(context-&gt;used_views);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_name_to_output(context-&gt;used_views, view_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The callback gets the <code>pvContext</code> back, which is the <code>context</code> local variable
from <code>cg_json_dependencies</code>.  This has all the buffers in it.  All
we have to do is add the name to the buffer, which is done as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void add_name_to_output(charbuf* output, CSTR table_name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(output);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (output-&gt;used &gt; 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;, &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(output, &quot;\&quot;%s\&quot;&quot;, table_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>add a comma if needed</li><li>add the name</li><li>done :D</li></ul><p>Note: The added name of course doesn&#x27;t have to be a table name, but it usually is.</p><p>So we can see that <code>find_table_refs</code> will tell us the kind of thing it found and the name of the thing.</p><p>When all this is done each kind of dependency is emitted if it exists, like so:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (used_views.used &gt; 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(output, &quot;,\n\&quot;usesViews\&quot; : [ %s ]&quot;, used_views.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>This gives us a quoted list of the dependencies.  Now, how do we find these?</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="walking-the-ast-for-dependencies"></a>Walking the AST for Dependencies<a aria-hidden="true" tabindex="-1" class="hash-link" href="#walking-the-ast-for-dependencies" title="Direct link to heading">#</a></h4><p><code>find_table_refs</code> is a fairly simple tree walk that looks for certain key patterns
actually the tree walk happens in <code>find_table_node</code> which looks for tables and
procedure calls in the nested AST.</p><p><code>find_table_refs</code> records the callbacks that were specified, and it makes some symbol
tables so that the same table/view/procedure is not reported twice.  After that
it starts walking the AST recursively looking for the patterns.  Here&#x27;s an example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Recursively finds table nodes, executing the callback for each that is found.  The</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// callback will not be executed more than once for the same table name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void find_table_node(table_callbacks *callbacks, ast_node *node) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Check the type of node so that we can find the direct references to tables. We</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // can&#x27;t know the difference between a table or view in the ast, so we will need to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // later find the definition to see if it points to a create_table_stmt to distinguish</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // from views.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  find_ast_str_node_callback alt_callback = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *alt_visited = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_or_view_name_ast = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_ast_delete_stmt(node)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, node-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    table_or_view_name_ast = name_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    alt_callback = callbacks-&gt;callback_deletes;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    alt_visited = callbacks-&gt;visited_delete;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The code afterward will do these steps:</p><ul><li>notice that <code>table_or_view_name_ast</code> was set, hence something was found</li><li>determine that it is in fact a table</li><li>call the general callback for any table seen (but only once for this table)</li><li>call the alternate callback that this is a table being deleted (but only once)</li></ul><p>Almost all the other operations work similarly:</p><ul><li><code>table_or_view_name_ast</code> is set</li><li><code>alt_callback</code> is called but only if</li><li><code>alt_visited</code> doesn&#x27;t already have the symbol</li></ul><p>The exception to the above is the processing that&#x27;s done for procedure calls.
We&#x27;ve actually only talked about table dependencies so far but, additionally,
any procedure includes dependencies on the procedures it calls.</p><p>If a procedure call is found then <code>callbacks-&gt;callback_proc</code> is used and
<code>callbacks-&gt;visited_proc</code> verifies that there are no duplicates.  So much
the same except the names are procedure names.</p><p>Note that the code does not do transitive closure of procedure calls because
in general the called procedure is likely in a different translation unit.
However with the direct calls in place it is easy enough to do transitive closure
from the JSON if you do have all the procedures in one unit or if you have
several JSON results from different compilations.</p><p>However, when a view is encountered, the code does follow into the view body
and recursively reports what the view uses. This means that the reported tables
do include any tables that were used indirectly via views.</p><p>Finally, any CTEs that are used will not be reported because
<code>find_table_or_view_even_deleted</code> will fail for a CTE.  However the body
of the CTE is processed so while the CTE name does not appear, what the
CTE uses does appear, just like any other table usage.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="additional-test-output"></a>Additional Test Output<a aria-hidden="true" tabindex="-1" class="hash-link" href="#additional-test-output" title="Direct link to heading">#</a></h3><p>The extra test output is simply a reverse index:  a mapping that goes
from any table to the procedures that depend on that table.</p><p>The mapping can easily be created by processing the JSON for procedures,
each such procedure includes its dependency information.  As a result it&#x27;s only
used for additional validation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap-4"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap-4" title="Direct link to heading">#</a></h3><p>The JSON output produced by <code>cg_json_schema.c</code> is similar to other codegen
output but lacks most of the complexities.  It deals largely with the
declared schema and the declared procedures and their parameters.  Most
of the output it needs to produce is well supported by the normal text
emission features in the compiler and so we end up with a very straightforward
walk of the AST, visiting each of the relevant kinds of nodes in order.</p><p>Topics covered included:</p><ul><li>the types of output that will be produced</li><li>the general structure of the main JSON emitter</li><li>an example emitter</li><li>typical formatting features necessary to produce good quality JSON</li><li>a tour of the dependency emitter</li></ul><p>As with the other parts, no attempt was made to cover every function in detail.  That is
best done by reading the source code. But there is overall structure here and an understanding
of the basic principles is helpful before diving into the source code.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-8-test-helpers"></a>Part 8: Test Helpers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-8-test-helpers" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-7"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-7" title="Direct link to heading">#</a></h3><p>Part 8 continues with a discussion of the Test Helper  generation code.
As in the previous sections, the goal here is not to go over every detail but rather to give
a sense of how helpers are created in general -- the core strategies and implementation choices --
so that when reading the source you will have an idea how it all hangs together.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="test-helpers"></a>Test Helpers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#test-helpers" title="Direct link to heading">#</a></h2><p>The testability features are described in <a href="https://cgsql.dev/cql-guide/ch12" target="_blank" rel="noopener noreferrer">Chapter 12</a> of the Guide
So, we won&#x27;t be discussing all the details of what can be created.  Instead we&#x27;re going to go over
the theory of how the generator works. This generator is somewhat different than others in that
it only concerns itself with procedures and only those that have been suitably annotated --
there are large parts of the tree that are of no interest to the test helper logic, including,
importantly the body of procedures.  Only the signature matters.  As we&#x27;ll see there is a fairly
large family of generators that are like this.</p><p>We&#x27;ll have one section for every kind of output, but really only the <code>dummy_test</code> helper is
worthy of detailed discussion the others, as we&#x27;ll see, are very simple.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initialization"></a>Initialization<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initialization" title="Direct link to heading">#</a></h3><p>The generator is wired like the others with a suitable main, this one is pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for test_helpers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_test_helpers_main(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(options.file_names_count == 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_exit_on_semantic_errors(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  exit_on_validating_schema();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_reset_globals();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(output_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_th_output = &amp;output_buf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;%s&quot;, rt-&gt;source_prefix);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_stmt_list(head);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_write_file(options.file_names[0], cg_th_output-&gt;ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(output_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_reset_globals();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The text output will be ultimately put into <code>output_buf</code> defined here and <code>helper_flags</code> will track which kinds of helpers
we saw.  This helps us to emit the right sections of output as we&#x27;ll see.</p><p>The code iterates the AST looking at the top level statement list only and in particular looking for <code>CREATE PROC</code>
statements.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Iterate through statement list</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_test_helpers_stmt_list(ast_node *head) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_stmt_list(head));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_all_trigger_per_table();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init_all_indexes_per_table();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(procs_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(decls_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_th_procs = &amp;procs_buf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_th_decls = &amp;decls_buf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *ast = head; ast; ast = ast-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_create_proc_stmt(stmt)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      EXTRACT_STRING(proc_name, stmt-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      cg_test_helpers_create_proc_stmt(stmt, misc_attrs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;%s&quot;, decls_buf.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_output, &quot;%s&quot;, procs_buf.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(decls_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(procs_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(all_tables_with_triggers);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_tables_with_triggers = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(all_tables_with_indexes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_tables_with_indexes = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>There are some preliminaries:</p><ul><li>we make a symbol table that maps from tables names to the list of triggers on that table by walking all the triggers</li><li>we make a symbol table that maps from tables names to the list of indices on that table by walking all the indices</li><li>we&#x27;ll need two buffers one for declarations (that must go first) and one for procedure bodies</li><li>each <code>CREATE PROC</code> statement potentially contributes to both sections</li><li><code>cg_test_helpers_create_proc_stmt</code> checks for the helper attributes and sets up the dispatch to emit the test helpers</li></ul><p>To do this we have to walk any misc attributes on the procedure we&#x27;re looking for things of the form <code>@attribute(cql:autotest=xxx)</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_test_helpers_create_proc_stmt(ast_node *stmt, ast_node *misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_create_proc_stmt(stmt));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (misc_attrs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dummy_test_infos = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    find_misc_attrs(misc_attrs, test_helpers_find_ast_misc_attr_callback, stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    symtab_delete(dummy_test_infos);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dummy_test_infos = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><code>find_misc_attrs</code> calls <code>test_helpers_find_ast_misc_attr_callback</code>.  We&#x27;re going to keep track of
which kinds of helpers we have found to help us with the output.  This is where <code>helper_flags</code>
comes in. The flags are:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_TABLE           1 // dummy_table attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_INSERT          2 // dummy_insert attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_SELECT          4 // dummy_select attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_RESULT_SET      8 // dummy_result_set attribute flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define DUMMY_TEST         0x10 // dummy_test attribute flag</span></div></div></div></div></div><p>And now we&#x27;re ready for actual dispatch:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is invoked for every misc attribute on every create proc statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// in this translation unit.  We&#x27;re looking for attributes of the form cql:autotest=(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and we ignore anything else.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void test_helpers_find_ast_misc_attr_callback(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR _Nullable misc_attr_prefix,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR _Nonnull misc_attr_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *_Nullable ast_misc_attr_value_list,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable context)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *stmt = (ast_node *)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_create_proc_stmt(stmt));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (misc_attr_prefix &amp;&amp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      misc_attr_name &amp;&amp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      !Strcasecmp(misc_attr_prefix, &quot;cql&quot;) &amp;&amp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      !Strcasecmp(misc_attr_name, &quot;autotest&quot;)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The main dispatch looks like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// In principle, any option can be combined with any other but some only make sense for procs with</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// a result.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">EXTRACT_STRING(autotest_attr_name, misc_attr_value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (is_autotest_dummy_test(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_test_helpers_dummy_test(stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// these options are only for procs that return a result set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (has_result_set(stmt) || has_out_stmt_result(stmt) || has_out_union_stmt_result(stmt)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_autotest_dummy_table(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_TABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_table(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_autotest_dummy_insert(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_INSERT;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_insert(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_autotest_dummy_select(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_SELECT;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_select(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else if (is_autotest_dummy_result_set(autotest_attr_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    helper_flags |= DUMMY_RESULT_SET;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cg_test_helpers_dummy_result_set(proc_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Most of these options are very simple indeed.   <code>cg_test_helpers_dummy_test</code> is the trickiest
by far and we&#x27;ll save it for last, let&#x27;s dispense with the easy stuff.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="dummy-table-dummy-insert-dummy-select-dummy-result-set"></a>Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set<a aria-hidden="true" tabindex="-1" class="hash-link" href="#dummy-table-dummy-insert-dummy-select-dummy-result-set" title="Direct link to heading">#</a></h3><p>All of these are a very simple template.  The language includes just the right features
to emit these procedures as nearly constant strings. The <code>LIKE</code> construct was literally
designed to make these patterns super simple.  You can see all the patterns
in <a href="https://cgsql.dev/cql-guide/ch12" target="_blank" rel="noopener noreferrer">Chapter 12</a> but let&#x27;s look at the code for
the first one.  This is &quot;dummy table&quot;.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit an open proc which creates a temp table in the form of the original proc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit a close proc which drops the temp table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_test_helpers_dummy_table(CSTR name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;CREATE PROC open_%s()\n&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;  CREATE TEMP TABLE test_%s(LIKE %s);\n&quot;, name, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;END;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;CREATE PROC close_%s()\n&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;BEGIN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;  DROP TABLE test_%s;\n&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_th_procs, &quot;END;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The purpose of this is to create helper functions that can create a temporary
table with the same columns in it as the procedure you are trying to mock.
You can then select rows out of that table (with <code>dummy_select</code>) or insert
rows into the table (with <code>dummy_insert</code>).  Or you can make a single
row result set (often enough) with <code>dummy_result_set</code>.</p><p>As we can see we simply prepend <code>open_</code> to the procedure name and use
that to create a test helper that make the temporary table.  The table&#x27;s
columns are defined to be <code>LIKE</code> the result shape of the procedure under
test.  Recall this helper is only available to procedures that return a result set.
The temporary table gets a <code>test_</code> prefix.  Assuming the procedure with the
annotation is <code>foo</code> then this code is universal:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">CREATE</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TEMP</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TABLE</span><span class="token plain"> test_foo</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">LIKE</span><span class="token plain"> foo</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Is universal, no matter the result shape of <code>foo</code> you get a table with those columns.</p><p>For this to work we need to emit a declaration of <code>foo</code> before this code.  However,
since we have the full definition of <code>foo</code> handy that is no problem.  We remember
that we&#x27;ll need it by setting a flag in <code>helper_flags</code>.</p><p>The code for <code>close_foo</code> is even simpler if that&#x27;s possible.  The great thing is
all need to know the columns of <code>foo</code> has been removed from the test helper.  The
CQL compiler handles this as a matter of course and it is generally useful.
See <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a>
for more examples.</p><p>All the others are equally simple and use similar tricks.  These were the first
test helpers.  They&#x27;re actually not that popular because they are so easy to create
yourself anyway.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="dummy-test"></a>Dummy Test<a aria-hidden="true" tabindex="-1" class="hash-link" href="#dummy-test" title="Direct link to heading">#</a></h3><p>The dummy test code emitter is non-trivial.  Let&#x27;s quickly review the things it has to
do and then we can go over how each of these is accomplished.  Assuming we have an procedure
<code>your_proc</code> that has been annotated like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@attribute(cql:autotest=(dummy_test))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">create proc your_proc(..args...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">begin</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  -- assorted references to tables and views</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">end;</span></div></div></div></div></div><p>Dummy test will produce the following:</p><ul><li><code>test_your_proc_create_tables</code><ul><li>a procedure that creates all the tables and views that <code>your_proc</code> needs</li></ul></li><li><code>test_your_proc_drop_tables</code><ul><li>a procedure that drops those same tables and views</li></ul></li><li><code>test_your_proc_create_indexes</code><ul><li>a procedure that creates your indices, in a test you may or may not want to create the indices</li></ul></li><li><code>test_your_proc_drop_indexes</code><ul><li>a procedure the drops those same indices</li></ul></li><li><code>test_your_proc_create_triggers</code><ul><li>a procedure that creates your trigger, in a test you may or may not want to create the triggers</li></ul></li><li><code>test_your_proc_drop_triggers</code><ul><li>a procedure the drops those same triggers</li></ul></li><li><code>test_your_proc_read_table1</code><ul><li>for each table or view in the <code>create_tables</code> a procedure that selects all the data out of that object is created in case you need it</li></ul></li><li><code>test_your_proc_populate_tables</code><ul><li>a procedure that loads all the tables from <code>create_tables</code> with sample data</li><li>FK relationships are obeyed</li><li>user data may be specified in an attribute and that data will be used in preference to auto-generated data</li></ul></li></ul><p>These are more fully discussed in <a href="https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern" target="_blank" rel="noopener noreferrer">Chapter 12</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="building-the-trigger-and-index-mappings"></a>Building the Trigger and Index mappings<a aria-hidden="true" tabindex="-1" class="hash-link" href="#building-the-trigger-and-index-mappings" title="Direct link to heading">#</a></h4><p>In order to know which indices and triggers we might need we have to be able to map from the tables/views in <code>your_proc</code> to the indices.
To set up for this a general purpose reverse mapping is created.  We&#x27;ll look at the triggers version. The indices version is nearly identical.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Walk through all triggers and create a dictionnary of triggers per tables.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void init_all_trigger_per_table() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(all_tables_with_triggers == NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_tables_with_triggers = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = all_triggers_list; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(create_trigger_stmt, item-&gt;ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_body_vers, create_trigger_stmt-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_def, trigger_body_vers-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_condition, trigger_def-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_op_target, trigger_condition-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(trigger_target_action, trigger_op_target-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(table_name_ast, trigger_target_action-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(table_name, table_name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (create_trigger_stmt-&gt;sem-&gt;delete_version &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // dummy_test should not emit deleted trigger</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    symtab_append_bytes(all_tables_with_triggers, table_name, &amp;create_trigger_stmt, sizeof(create_trigger_stmt));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The steps are pretty simple:</p><ul><li>we make a symbol table that will map from the table name to an array of statements</li><li>there is a convenient <code>all_triggers</code> list that has all the triggers</li><li>from each trigger we <code>EXTRACT</code> the table or view name (named <code>table_name</code> even if it&#x27;s a view)</li><li>we append the trigger statement pointer to the end of such statements for the table</li><li>any triggers marked with <code>@delete</code> are not included for obvious reasons</li></ul><p>At the end of this looking up the table name will give you a list of trigger statement AST pointers.  From there
of course you can get everything you need.</p><p>The index version is basically the same, the details of the <code>EXTRACT</code> ops to go from index to table name are different
and of course we start from the <code>all_indices_list</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="computing-the-dependencies-of-a-procedure"></a>Computing The Dependencies of a Procedure<a aria-hidden="true" tabindex="-1" class="hash-link" href="#computing-the-dependencies-of-a-procedure" title="Direct link to heading">#</a></h4><p>Sticking with our particular example, in order to determine that tables/views that <code>your_proc</code> might need,
the generator has to walk its entire body looking for things that are tables.  This is handled by the
<code>find_all_table_nodes</code> function.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void find_all_table_nodes(dummy_test_info *info, ast_node *node) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  table_callbacks callbacks = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .callback_any_table = found_table_or_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .callback_any_view = found_table_or_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .callback_context = info,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .notify_table_or_view_drops = true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .notify_fk = true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .notify_triggers = true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  info-&gt;callbacks  = &amp;callbacks;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  find_table_refs(&amp;callbacks, node);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // stitch the views to the tables to make one list, views first</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (list_item *item = info-&gt;found_views; item; item = item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     if (!item-&gt;next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       item-&gt;next = info-&gt;found_tables;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       info-&gt;found_tables = info-&gt;found_views;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this shouldn&#x27;t be used after it&#x27;s been linked in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  info-&gt;found_views = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This code uses the general dependency walker in <code>cg_common.c</code> to visit all tables and views. It is a recursive
walk and the general steps for prosecution go something like this:</p><ul><li>starting from <code>your_proc</code> the entire body of the procedure is visited</li><li>references to tables or views in update, delete, insert, select etc. statements are identified</li><li>each such table/view is added to the found tables list (at most once)</li><li>for views, the recursion proceeds to the body of the view as though the body had been inline in the procedure</li><li>for tables, the recursion proceeds to the body of the table to discover any FK relationships that need to be followed</li><li>if any found item has triggers, the trigger body is walked, any tables/views mentioned there become additional found items</li><li>any given table/view and hence trigger is only visited once</li></ul><p>The net of all this, the &quot;found items&quot;, is a list of all the tables and views that the procedure uses, directly
or indirectly.  As discussed in <a href="https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern" target="_blank" rel="noopener noreferrer">Chapter 12</a>
this walk does not include tables and views used by procedures that <code>your_proc</code> calls.</p><p>To get the dependencies in the correct order, the tables have been walked following the foreign key chain and all
views go after all tables.  The views are stitched together.  The business of diving into views/tables/triggers and
maintainence of the found items is done by the callback function <code>found_table_or_view</code>.  The actual source
is more descriptive comments than code but the code is included here as it is brief.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// comments elided for brevity, the why of all this is described in the code</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void found_table_or_view(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR _Nonnull table_or_view_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *_Nonnull table_or_view,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable context)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  dummy_test_info *info = (dummy_test_info *)context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool deleted = table_or_view-&gt;sem-&gt;delete_version &gt; 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!deleted) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    continue_find_table_node(info-&gt;callbacks, table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_create_view_stmt(table_or_view)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      add_item_to_list(&amp;info-&gt;found_views, table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      add_item_to_list(&amp;info-&gt;found_tables, table_or_view);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    find_all_triggers_node(info, table_or_view_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The general purpose walker notifies exactly once on each visited table/view and <code>continue_find_table_node</code> is used to
dive into the bodies of views/tables that would otherwise not be searched.  Likewise <code>find_all_triggers_node</code>
dives into the body of any triggers that are on the found item.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="emitting-indices-and-triggers"></a>Emitting Indices and Triggers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#emitting-indices-and-triggers" title="Direct link to heading">#</a></h4><p>With the &quot;found tables&quot; computed (creatively stored in a field called <code>found_tables</code>) it&#x27;s very easy to loop over these
and generate the necessary indices for each found table (keeping in mind the &quot;found table&quot; can be a view).</p><p>The <code>create index statement</code> is emitted by the usual <code>gen_statement_with_callbacks</code> form that echos the AST.</p><p>The <code>drop index</code> can be trivially created by name.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Emit create and drop index statement for all indexes on a table.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_emit_index_stmt(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR table_name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *gen_create_indexes,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *gen_drop_indexes,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callbacks *callback)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_entry *indexes_entry = symtab_find(all_tables_with_indexes, table_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf *buf = indexes_entry ? (bytebuf *)indexes_entry-&gt;val : NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node **indexes_ast = buf ? (ast_node **)buf-&gt;ptr : NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t count = buf ? buf-&gt;used / sizeof(*indexes_ast) : 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_set_output_buffer(gen_create_indexes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int32_t i = 0; i &lt; count; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *index_ast = indexes_ast[i];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(create_index_stmt, index_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_NOTNULL(create_index_on_list, create_index_stmt-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(index_name_ast, create_index_on_list-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(index_name, index_name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_statement_with_callbacks(index_ast, callback);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(gen_create_indexes, &quot;;\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(gen_drop_indexes, &quot;DROP INDEX IF EXISTS %s;\n&quot;, index_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Triggers are done in exactly the same way except that instead of looping over found tables we can
actually generate them as they are discovered inside of <code>find_all_triggers_node</code>.  Recal that we
had to visit the triggers when computing the found tables anyway.  We did not have to visit the indices
hence the difference.</p><p>These walks allow us to produce: <code>test_your_proc_create_indexes</code>, <code>test_your_proc_drop_indexes</code>, <code>test_your_proc_create_triggers</code>, <code>test_your_proc_drop_triggers</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="emitting-tables-and-views"></a>Emitting Tables and Views<a aria-hidden="true" tabindex="-1" class="hash-link" href="#emitting-tables-and-views" title="Direct link to heading">#</a></h4><p>Starting from the found tables, again it is very easy to generate the code to create and drop the tables and views.  The only trick here is that the
tables depend on one another so order is important.  The tables are discovered with the deepest dependency first, new found items are added to the head
of the found tables but it&#x27;s a post-order walk so that means that the deepest tables/views are at the front of the list.  This means the list
is naturally in the order that it needs to be to delete the tables (parent tables at the end).  So the algorithm goes like this:</p><ul><li>emit the drop tables/views in the found order</li><li>reverse the list</li><li>emit the create tables/views in the reverse order</li><li>for each table/view emit the reader `test<em>your_proc_read</em>[item]</li><li>for tables we emit an insertion fragment into <code>test_your_proc_populate_tables</code> using <code>cg_dummy_test_populate</code><ul><li>population is discussed in the following sections</li></ul></li></ul><p>As in the other cases <code>gen_statement_with_callbacks</code> is used to create the DDL statements:</p><ul><li><code>CREATE TABLE</code></li><li><code>CREATE VIEW</code></li><li><code>CREATE VIRTUAL TABLE</code></li></ul><p>The delete side is easily created with ad hoc <code>DROP TABLE</code> or <code>DROP VIEW</code> statements.</p><p>The reading procedure is always of the form <code>SELECT * FROM foo</code> so that too is trivial to generate with a fixed template.  The &quot;echoing&quot; system
once again is doing a lot of the heavy lifting.</p><p>These walks give us <code>test_your_proc_create_tables</code>, <code>test_your_proc_drop_tables</code>, and <code>test_your_proc_read_[item]</code> and drive the population process</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="gathering-ad-hoc-data-to-be-inserted"></a>Gathering Ad Hoc Data To Be Inserted<a aria-hidden="true" tabindex="-1" class="hash-link" href="#gathering-ad-hoc-data-to-be-inserted" title="Direct link to heading">#</a></h4><p>Before we get into the mechanics of the population code, we have to visit one more area.  It&#x27;s possible to include data in the the
<code>dummy_test</code> annotaiton itself.  This is data that you want to have populated.  This data will be included in the overall data populator.
If there is enough of it (at least 2 rows per candidate table) then it might be all the data you get.  Now the data format here is
not designed to be fully general, after all it&#x27;s not that hard to just write <code>INSERT ... VALUES</code> for all your tables anyway.  The goal
is to provide something that will help you not have to remember all the FK relationships and maybe let you economically specify some leaf
data you need and get the rest for free.  It&#x27;s also possible to manually create dummy data that just won&#x27;t work, again, scrubbing all
this is way beyond the ability of a simple test helper.  When the code runs you&#x27;ll get SQLite errors which can be readily addressed.</p><p>So keeping in mind this sort of &quot;entry level data support&quot; as the goal, we can take a look at how the system works -- it&#x27;s all
in the function <code>collect_dummy_test_info</code> which includes this helpful comment on structure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the data attribute looks kind of like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// @attribute(cql:autotest = (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   .. other auto test attributes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   (dummy_test,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     (table_name1, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     (table_name2, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//     ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   .. other auto test attributes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// we&#x27;re concerned with the dummy_test entries here, they have a very specific format</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// i.e. first the table then the column names, and then a list of matching columns and values</span></div></div></div></div></div><p>So we&#x27;re going to walk a list of attributes each one begins with a table name, then a list of columns, and then a list of values.</p><p>All of the data is in the symbol table <code>dummy_test_infos</code> which is indexed by table name.  For each table name we find
we ensure there is a symbol table at that slot.  So <code>dummy_test_infos</code> is a symbol table of symbol tables.  It&#x27;s actually
going to be something like <code>value_list = dummy_test_infos[&#x27;table&#x27;][&#x27;column&#x27;]</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // collect table name from dummy_test info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_list = dummy_attr-&gt;left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(table_name, table_list-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *col_syms = symtab_ensure_symtab(dummy_test_infos, table_name);</span></div></div></div></div></div><p>Next we&#x27;re going to find the column names, they are the next entry in the list so we go <code>right</code> to get the <code>column_name_list</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// collect column names from dummy_test info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *column_name_list = table_list-&gt;right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (ast_node *list = column_name_list-&gt;left; list; list = list-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(column_name, list-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t col_type = find_column_type(table_name, column_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // store the column meta data, create space to hold values in databuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf_append_var(&amp;col_data_buf, column_values);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf_append_var(&amp;col_type_buf, col_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bytebuf_append_var(&amp;col_name_buf, column_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The primary purpose of this part of the loop is then to add the column names to <code>col_syms</code> so that they are linked to the dummy info for this table.
The line <code>bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);</code> does this.  And this also creates the byte buffer that will hold
the eventual values.</p><p>We also keep a side set of buffers that has the column name, type, and the values in the <code>col_name</code>, <code>col_type</code>, and <code>col_data</code> buffers respectively.
These are used to handle the foreign key work shortly and they allow us to not have to look up all the names over and over.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// collect column value from dummy_test info. We can have multiple rows of column value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (ast_node *values_ast = column_name_list-&gt;right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     values_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     values_ast = values_ast-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t column_index = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // collect one row of column value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *list = values_ast-&gt;left; list; list = list-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast_node *misc_attr_value = list-&gt;left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(col_data_buf.used);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bytebuf *column_values = ((bytebuf **) col_data_buf.ptr)[column_index];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_t column_type = ((sem_t *) col_type_buf.ptr)[column_index];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CSTR column_name = ((CSTR *) col_name_buf.ptr)[column_index];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bytebuf_append_var(column_values, misc_attr_value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    column_index++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...foreign key stuff goes here...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .. some cleanup</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The most important part is <code>bytebuf_append_var(column_values, misc_attr_value);</code> this is where the
attribute value is added to the list of values that are on the column.</p><p>Finally, the &quot;foreign key stuff&quot;.  What we need to do here is check the column name in the table to see if it&#x27;s part of a foreign
key and if it is we recursively add the current data value to the referenced column in the reference table.  That way
if you add an initalizer to a leaf table you don&#x27;t also have to add it to all the parent tables.  If it wasn&#x27;t for this
feature the manual data wouldn&#x27;t be very useful at all, hand written <code>INSERT</code> statements would be just as good.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If a column value is added to dummy_test info for a foreign key column then</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// we need to make sure that same column value is also added as a value in the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the referenced table&#x27;s dummy_test info.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// e.g.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   create table A(id integer primary key);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   create table B(id integer primary key references A(id));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is sample data provided for B.id then we must also ensure that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the value provided for B.id is also add as a sample row in A with the same</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// value for id.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (is_foreign_key(column_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  add_value_to_referenced_table(table_name, column_name, column_type, misc_attr_value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>When this is a done all of the initializers will have been added to the appropriate column of the appropriate table.
Again the overall structure is something like: <code>value_list = dummy_test_infos[&#x27;table&#x27;][&#x27;column&#x27;]</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="emitting-the-table-population-fragments"></a>Emitting the Table Population Fragments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#emitting-the-table-population-fragments" title="Direct link to heading">#</a></h4><p>With any custom initalizers in the <code>dummy_test_infos</code> structure we can do the population fragment for any given table.</p><p>The general algorithm here goes like this:</p><ul><li>the total number of rows we will generate will be the number of column values in the initializers or else <code>DUMMY_TEST_INSERT_ROWS</code>, whichever is larger</li><li>the insert statement generated will include <code>dummy_seed([value_seed])</code> where value_seed starts at 123 and goes up 1 for every row generated<ul><li>dummy_seed will create values for any missing columns using the seed so any combination of included columns is ok, we&#x27;ll always get a complete insert</li></ul></li><li>foreign key columns use a provided intializer from the parent table if there is one, or else they use 1, 2, 3 etc.<ul><li>likewise if a column is referenceable by some other table it uses the known sequence 1, 2, 3 etc. for its value rather than the varying seed</li><li>in this way child tables can know that partent tables will have a value they can use since both tables will have at least <code>DUMMY_TEST_INSERT_ROWS</code> and any rows that were not manually initialized will match</li><li>note that foreign key columns always get this treatment, whether they were mentioned or not</li></ul></li><li>to mix things up the <code>dummy_nullables</code> and <code>dummy_defaults</code> are added on every other row which makes missing values be NULL and/or the default value if one is present</li></ul><p>This is enough to generate a set of insert statements for the table in question and since the fragments are generated in the table creation order the resulting insert statements will have the parent tables first so the foreign keys of later tables will be correct.</p><p>This can go wrong if the manual initializations use keys that conflict with the default generation or if the manual intializations have PK conflicts or other such things.  No attempt is made to sort that out.  The run time errors should be clear and these are, after all, only test helpers.  It&#x27;s very easy to avoid these hazards
and you get a pretty clear error message if you don&#x27;t so that seems good enough.</p><p>These fragments are ultimately combined to make the body of the procedure <code>test_your_proc_populate_tables</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap-5"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap-5" title="Direct link to heading">#</a></h3><p>The test helpers in <code>cg_test_helpers.c</code> are very simple nearly-constant templates with the exception of <code>dummy_test</code> which includes:</p><ul><li>table and view creation</li><li>index creation</li><li>trigger creation</li><li>data population</li></ul><p>Topics covered included:</p><ul><li>how the candidate procedures are discovered</li><li>how the attributes are scanned for test directives</li><li>how each dummy test type is dispatched</li><li>how <code>dummy_test</code> handles data initialization</li><li>how <code>dummy_test</code> does its dependency analysis</li></ul><p>As with the other parts, no attempt was made to cover every function in detail.  That is
best done by reading the source code. But there is overall structure here and an understanding
of the basic principles is helpful before diving into the source code.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-03-15T21:48:25.000Z" class="docLastUpdatedAt_217_">3/15/2022</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#part-1-lexing-parsing-and-the-ast" class="table-of-contents__link">Part 1: Lexing, Parsing, and the AST</a><ul><li><a href="#preface" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#general-structure" class="table-of-contents__link">General Structure</a><ul><li><a href="#lexical-analysis" class="table-of-contents__link">Lexical Analysis</a></li><li><a href="#parsing-and-the-abstract-syntax-tree" class="table-of-contents__link">Parsing and the Abstract Syntax Tree</a></li><li><a href="#examples" class="table-of-contents__link">Examples</a></li><li><a href="#ast-definitions" class="table-of-contents__link">AST definitions</a></li></ul></li><li><a href="#echoing-the-ast" class="table-of-contents__link">Echoing the AST</a><ul><li><a href="#configuring-the-output-with-callbacks-and-flags" class="table-of-contents__link">Configuring the Output with Callbacks and Flags</a></li><li><a href="#invoking-the-generator" class="table-of-contents__link">Invoking the Generator</a></li><li><a href="#generator-internals" class="table-of-contents__link">Generator Internals</a></li></ul></li><li><a href="#part-2-semantic-analysis" class="table-of-contents__link">Part 2: Semantic Analysis</a><ul><li><a href="#preface-1" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#semantic-analysis" class="table-of-contents__link">Semantic Analysis</a><ul><li><a href="#decorated-ast-examples" class="table-of-contents__link">Decorated AST examples</a></li><li><a href="#the-base-data-structures" class="table-of-contents__link">The Base Data Structures</a></li><li><a href="#initiating-semantic-analysis" class="table-of-contents__link">Initiating Semantic Analysis</a></li><li><a href="#semantic-errors" class="table-of-contents__link">Semantic Errors</a></li><li><a href="#the-primitive-types" class="table-of-contents__link">The Primitive Types</a></li><li><a href="#unary-operators" class="table-of-contents__link">Unary Operators</a></li><li><a href="#binary-operators" class="table-of-contents__link">Binary Operators</a></li><li><a href="#simple-statement-validation" class="table-of-contents__link">Simple Statement Validation</a></li><li><a href="#expression-contexts" class="table-of-contents__link">Expression Contexts</a></li><li><a href="#name-resolution" class="table-of-contents__link">Name Resolution</a></li><li><a href="#flow-analysis" class="table-of-contents__link">Flow Analysis</a></li><li><a href="#nullability-improvements" class="table-of-contents__link">Nullability Improvements</a></li><li><a href="#initialization-improvements" class="table-of-contents__link">Initialization Improvements</a></li><li><a href="#structure-types-and-the-notion-of-shapes" class="table-of-contents__link">Structure types and the notion of Shapes</a></li><li><a href="#join-types" class="table-of-contents__link">Join Types</a></li><li><a href="#schema-regions" class="table-of-contents__link">Schema Regions</a></li><li><a href="#results-of-semantic-analysis" class="table-of-contents__link">Results of Semantic Analysis</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li><li><a href="#part-3-c-code-generation" class="table-of-contents__link">Part 3: C Code Generation</a><ul><li><a href="#preface-2" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#c-code-generation" class="table-of-contents__link">C Code Generation</a><ul><li><a href="#launching-the-code-generator" class="table-of-contents__link">Launching the Code Generator</a></li><li><a href="#character-buffers-and-byte-buffers" class="table-of-contents__link">Character Buffers and Byte Buffers</a></li><li><a href="#expressions" class="table-of-contents__link">Expressions</a></li><li><a href="#basic-control-flow-patterns" class="table-of-contents__link">Basic Control Flow Patterns</a></li><li><a href="#cleanup-and-errors" class="table-of-contents__link">Cleanup and Errors</a></li><li><a href="#string-literals" class="table-of-contents__link">String Literals</a></li><li><a href="#executing-sqlite-statements" class="table-of-contents__link">Executing SQLite Statements</a></li><li><a href="#reading-single-values" class="table-of-contents__link">Reading Single Values</a></li><li><a href="#reading-rows-with-cursors" class="table-of-contents__link">Reading Rows With Cursors</a></li><li><a href="#fetching-data-from-cursors" class="table-of-contents__link">Fetching Data From Cursors</a></li><li><a href="#cursors-with-storage" class="table-of-contents__link">Cursors With Storage</a></li><li><a href="#flowing-sqlite-statements-between-procedures" class="table-of-contents__link">Flowing SQLite Statements Between Procedures</a></li><li><a href="#value-cursors" class="table-of-contents__link">Value Cursors</a></li><li><a href="#returning-value-cursors" class="table-of-contents__link">Returning Value Cursors</a></li><li><a href="#result-sets" class="table-of-contents__link">Result Sets</a></li><li><a href="#recap-1" class="table-of-contents__link">Recap</a></li></ul></li><li><a href="#part-4-testing" class="table-of-contents__link">Part 4: Testing</a><ul><li><a href="#preface-3" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#testing" class="table-of-contents__link">Testing</a><ul><li><a href="#parse-tests" class="table-of-contents__link">Parse Tests</a></li><li><a href="#sematic-tests" class="table-of-contents__link">Sematic Tests</a></li><li><a href="#code-generation-tests" class="table-of-contents__link">Code Generation Tests</a></li><li><a href="#run-tests" class="table-of-contents__link">Run Tests</a></li><li><a href="#schema-upgrade-testing" class="table-of-contents__link">Schema Upgrade Testing</a></li><li><a href="#testing-the-line-directives-produced-by-cql" class="table-of-contents__link">Testing the <code>#line</code> directives produced by CQL</a></li><li><a href="#summary" class="table-of-contents__link">Summary</a></li></ul></li><li><a href="#part-5-cql-runtime" class="table-of-contents__link">Part 5: CQL Runtime</a><ul><li><a href="#preface-4" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#cql-runtime" class="table-of-contents__link">CQL Runtime</a><ul><li><a href="#standard-headers" class="table-of-contents__link">Standard headers</a></li><li><a href="#contract-and-error-macros" class="table-of-contents__link">Contract and Error Macros</a></li><li><a href="#the-value-types" class="table-of-contents__link">The Value Types</a></li><li><a href="#the-reference-types" class="table-of-contents__link">The Reference Types</a></li><li><a href="#mocking" class="table-of-contents__link">Mocking</a></li><li><a href="#profiling" class="table-of-contents__link">Profiling</a></li><li><a href="#encoding-of-sensitive-columns" class="table-of-contents__link">Encoding of Sensitive Columns</a></li><li><a href="#boxing-statements" class="table-of-contents__link">Boxing Statements</a></li><li><a href="#the-common-headers" class="table-of-contents__link">The Common Headers</a></li><li><a href="#the-cqlrt_cf-runtime" class="table-of-contents__link">The <code>cqlrt_cf</code> Runtime</a></li><li><a href="#recap-2" class="table-of-contents__link">Recap</a></li></ul></li><li><a href="#part-6-schema-management" class="table-of-contents__link">Part 6: Schema Management</a><ul><li><a href="#preface-5" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#schema-management" class="table-of-contents__link">Schema Management</a><ul><li><a href="#check-for-errors-check-for---global_proc" class="table-of-contents__link">Check for errors, check for <code>--global_proc</code></a></li><li><a href="#preparing-the-attributes" class="table-of-contents__link">Preparing the Attributes</a></li><li><a href="#creating-the-global-crc" class="table-of-contents__link">Creating the Global CRC</a></li><li><a href="#output-fragments" class="table-of-contents__link">Output Fragments</a></li><li><a href="#declarations-section" class="table-of-contents__link">Declarations Section</a></li><li><a href="#the-schema-helpers" class="table-of-contents__link">The Schema Helpers</a></li><li><a href="#declared-upgrade-procedures" class="table-of-contents__link">Declared Upgrade Procedures</a></li><li><a href="#the-upgrading-workers" class="table-of-contents__link">The Upgrading Workers</a></li><li><a href="#recap-3" class="table-of-contents__link">Recap</a></li></ul></li><li><a href="#part-7-json-generation" class="table-of-contents__link">Part 7: JSON Generation</a><ul><li><a href="#preface-6" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#json-schema" class="table-of-contents__link">JSON Schema</a><ul><li><a href="#walking-the-ast" class="table-of-contents__link">Walking the AST</a></li><li><a href="#formatting-the-json" class="table-of-contents__link">Formatting the JSON</a></li><li><a href="#dependency-analysis" class="table-of-contents__link">Dependency Analysis</a></li><li><a href="#additional-test-output" class="table-of-contents__link">Additional Test Output</a></li><li><a href="#recap-4" class="table-of-contents__link">Recap</a></li></ul></li><li><a href="#part-8-test-helpers" class="table-of-contents__link">Part 8: Test Helpers</a><ul><li><a href="#preface-7" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#test-helpers" class="table-of-contents__link">Test Helpers</a><ul><li><a href="#initialization" class="table-of-contents__link">Initialization</a></li><li><a href="#dummy-table-dummy-insert-dummy-select-dummy-result-set" class="table-of-contents__link">Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set</a></li><li><a href="#dummy-test" class="table-of-contents__link">Dummy Test</a></li><li><a href="#recap-5" class="table-of-contents__link">Recap</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/metaOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Meta Platforms Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2022 Meta Platforms, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.a144e2e4.js"></script>
<script src="/runtime~main.88fe9dcb.js"></script>
<script src="/main.a8f5bad0.js"></script>
<script src="/1.146bcdda.js"></script>
<script src="/2.38f10475.js"></script>
<script src="/3.356a0a8e.js"></script>
<script src="/1be78505.7b59e2c1.js"></script>
<script src="/104.e5f87727.js"></script>
<script src="/5456faf3.142564bd.js"></script>
<script src="/17896441.d78200b7.js"></script>
<script src="/7d22b040.6f2a5b40.js"></script>
</body>
</html>