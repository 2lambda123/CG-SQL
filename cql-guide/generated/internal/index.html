<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">internal | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="internal | CG/SQL"><meta data-react-helmet="true" name="description" content="Part 1: Lexing, Parsing, and the AST"><meta data-react-helmet="true" property="og:description" content="Part 1: Lexing, Parsing, and the AST"><meta data-react-helmet="true" property="og:url" content="https://cgsql.dev/cql-guide/generated/internal"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cgsql.dev/cql-guide/generated/internal"><link rel="stylesheet" href="/styles.efe3e8f9.css">
<link rel="preload" href="/styles.4a61b4b3.js" as="script">
<link rel="preload" href="/runtime~main.7f4ba451.js" as="script">
<link rel="preload" href="/main.9cd58f71.js" as="script">
<link rel="preload" href="/1.bac24c28.js" as="script">
<link rel="preload" href="/2.29ab4659.js" as="script">
<link rel="preload" href="/3.9ee6d42d.js" as="script">
<link rel="preload" href="/1be78505.ae32d621.js" as="script">
<link rel="preload" href="/87.9cf8ff91.js" as="script">
<link rel="preload" href="/5456faf3.d3330067.js" as="script">
<link rel="preload" href="/17896441.923fd9c6.js" as="script">
<link rel="preload" href="/7d22b040.9dd88c74.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CG/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/int01">CQL Internals</a></li><li class="menu__list-item"><a class="menu__link" href="/program-diagram">Railroad Diagram</a></li><li class="menu__list-item"><a class="menu__link" href="/json-diagram">Railroad Diagram: JSON</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">internal</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-1-lexing-parsing-and-the-ast"></a>Part 1: Lexing, Parsing, and the AST<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-1-lexing-parsing-and-the-ast" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface" title="Direct link to heading">#</a></h3><p>The following is a summary of the implementation theory of the CQL compiler.  This is
an adjuct to the Guide proper, which describes the language, and to a lesser extent
the code that the compiler generates.</p><p>The actual code is heavily commented, so it&#x27;s better to read the code to see the details
of how any particular operation happens rather than try to guess from the language specification
or from this overview.  However, some things, like general principles, really are nowhere
(or everywhere) in the codebase and it&#x27;s important to understand how things hang together.</p><p>If you choose to go on adventures in the source code, especially if you aren&#x27;t already familiar
with compilers and how they are typically built, this document is a good place to start.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="general-structure"></a>General Structure<a aria-hidden="true" tabindex="-1" class="hash-link" href="#general-structure" title="Direct link to heading">#</a></h2><p>The CQL compiler uses a very standard lex+yacc parser, though to be more precise it&#x27;s flex+bison.
The grammar is a large subset of the SQLite dialect of SQL augmented with control flow and compiler
directives.  As a consequence, it&#x27;s a useful asset in-and-of-itself. If you&#x27;re looking for an
economical SQL grammar, you could do a lot worse than start with the one CQL uses.  The grammar is
of course in the usual <code>.y</code> format that bison consumes but it&#x27;s also extracted into more readable
versions for use in the railroad diagram and the Guide documentation.  Any of those sources would be
a good starting place for a modest SQL project in need of a grammar.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="lexical-analysis"></a>Lexical Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#lexical-analysis" title="Direct link to heading">#</a></h3><p>Inside of <code>cql.l</code> you&#x27;ll find the formal defintion of all the tokens.  These of course correspond to the
various tokens needed to parse the SQL language, plus a few more of the CQL control flow extensions.
There&#x27;s no need to discuss the approximately 150 such tokens, but the following points are of general interest:</p><ul><li>the lexer expects plain text files, and all the tokens are defined in plain ASCII only, however<ul><li>the presence of UTF8 characters in places where any text is legal (such as string literals) should just work</li></ul></li><li>all of the tokens are case-insensitive<ul><li>this means only vanilla ASCII insensitivity, no attempt is made to understand more complex UNICODE code-points</li></ul></li><li>multi-word tokens typically are defined with an expression like this:  <code>IS[ \t]+NOT[ \t]+FALSE/[^A-Z_]</code><ul><li>in most cases, to avoid ambiguity, and to get order of operations correct, the entire word sequence is one token</li><li>only spaces and tabs are allowed between the words</li><li>the token ends on non-identifier characters, so the text &quot;X IS NOT FALSEY&quot; must become the tokens { <code>X</code>, <code>IS_NOT</code>, <code>FALSEY</code> } and not { <code>X</code>, <code>IS_NOT_FALSE</code>, <code>Y</code> }<ul><li>the second option is actually the longest token, so without the trailing qualifier it would be preferred</li><li>hence, where a continuation is possible, the trailing context must be specified in multi=word tokens</li><li>a quick reading shows this isn&#x27;t done completely consistently and that should be fixed...</li></ul></li></ul></li><li>there is special processing needed to lex <code>/* ... */</code> comments correctly</li><li>there are token types for each of the sorts of literals that can be encountered<ul><li>special care is taken to keep the literals in string form so that no precision is lost</li><li>integer literals are compared against 0x7fffffff and if greater they automatically become long literals even if they are not marked with the trailing <code>L</code> as in <code>1L</code></li><li>string literals include the quotation marks in the token text which distinguishes them from identifiers, they are otherwise encoded similarly</li></ul></li><li>the character class <code>[-+&amp;~|^/%*(),.;!&lt;&gt;:=]</code> produces single character tokens for operators, other non-matching single characters (e.g. <code>&#x27;$&#x27;</code> produce an error)</li><li>line directives <code>^#\ [0-9]+\ \&quot;[^&quot;]*\&quot;.*</code> get special processing so that pre-processed input does not lose file and line number fidelity</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="parsing-and-the-abstract-syntax-tree"></a>Parsing and the Abstract Syntax Tree<a aria-hidden="true" tabindex="-1" class="hash-link" href="#parsing-and-the-abstract-syntax-tree" title="Direct link to heading">#</a></h3><p>Inside of <code>cql.y</code> you will find the token declarations, precedence rules, and all of the productions in the overall grammar. The grammar processing
does as little as possible in that stage to create an abstract syntax tree (AST). The AST itself is a simple binary tree; where nodes might require more than just
left and right children to specify the syntax fully, additional nodes are used in the tree shape rather than introduce n-ary nodes.  This means the tree is
sometimes bigger, but generally not very much bigger.  The benefit of this choice is that the AST can always be walked generically as a binary tree, so if you need
to find all the <code>table_factor</code> nodes it is easy to do so without having to worry about how every kind of node expands.  If new node types come along
the generic walkers can go through those new nodes as well.  All of the grammar productions simply make one or more AST nodes and link them together so that in the
end there is a single root for the entire program in a binary tree.</p><p>There are 4 kinds of AST nodes, they all begin with the following five fields, these represent the AST &quot;base type&quot; if you like.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nonnull type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_node *_Nullable sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nullable parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t lineno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nonnull filename;</span></div></div></div></div></div><ul><li><code>type</code> : a string literal that uniquely identifies the node type<ul><li>the string literal is compared for identity (it&#x27;s an exact pointer match) you don&#x27;t <code>strcmp</code> types</li></ul></li><li><code>sem</code> : begins as <code>NULL</code> this is where the semantic type goes once semantic processing happens</li><li><code>parent</code> : the parent node in the AST (not often used but sometimes indispensible)</li><li><code>lineno</code> : the line number of the file that had the text that led to this AST (useful for errors)</li><li><code>filename</code> : the name of the file that had the text that led to this AST (useful for errors)<ul><li>this string is durable, should not be mutated, and is shared between MANY nodes</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-generic-binary-ast-node-ast_node"></a>The Generic Binary AST node <code>ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-generic-binary-ast-node-ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nullable left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nullable right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} ast_node;</span></div></div></div></div></div><p>This node gives the tree its shape, this is is how all the expression operators and statments get encoded.  An example shows this more clearly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SET X := 1 + 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {assign}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name X}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 3}</span></div></div></div></div></div><p>In the above &quot;assign&quot; and &quot;add&quot; are the generic nodes.  Note that this node type can be a leaf but usually is not.  The other types
are always leaves.</p><p>Note that in the above output, the node <code>type</code> was directly printed (because it&#x27;s a meaningful name).  Likewise, the type needs no decoding
when viewing the AST in a debugger.  Simply printing the node with something like <code>p *ast</code> in lldb will show you
all the node fields and the type in a human readable fashion.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-grammar-code-node-int_ast_node"></a>The Grammar Code Node <code>int_ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-grammar-code-node-int_ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct int_ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int64_t value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} int_ast_node;</span></div></div></div></div></div><p>This kind of node holds an integer that quantifies some kind of choice in the grammar.  Note that this does NOT hold numeric literals (see below).
The file <code>ast.h</code> includes many <code>#define</code> constants for this purpose such as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_INNER 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_CROSS 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_LEFT_OUTER 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_RIGHT_OUTER 4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_LEFT 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">define JOIN_RIGHT 6</span></div></div></div></div></div><p>The integer for this fragment will be one of those defined values.  It can be a bitmask, or an enumeration.  In this statement:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> x</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> a</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">LEFT</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">OUTER</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">JOIN</span><span class="token plain"> b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>a part of the AST will look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">| {join_clause}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">| | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">| | | {name a}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">| | {join_target_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|   | {join_target}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|     | {int 3}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|     | {table_join}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|       | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">|         | {name b}</span></div></div></div></div></div><p>The <code>{int 3}</code> above is an <code>int_ast_node</code> and it corresponds to <code>JOIN_LEFT_OUTER</code>.</p><p>This node type is always a leaf.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-string-node-str_ast_node"></a>The String Node <code>str_ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-string-node-str_ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct str_ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nullable value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t cstr_literal;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} str_ast_node;</span></div></div></div></div></div><p>This node type holds:</p><ul><li><p>string literals</p></li><li><p>blob literals</p></li><li><p>identifiers</p></li><li><p><code>value</code> : the text of the string</p></li><li><p><code>cstr_literal</code> : true if the string was specified using &quot;C&quot; syntax (see below)</p></li></ul><p>CQL supports C style string literals with C style escapes such as <code>&quot;foo\n&quot;</code>.  These are normalized into the SQL version of the same literal
so that SQLite will see a literal it understands.  However, if the origin of the string was the C string form (i.e. like <code>&quot;foo&quot;</code> rather than <code>&#x27;bar&#x27;</code>)
then the <code>cstr_literal</code> boolean flag will be set.  When echoing the program back as plain text, the C string will be converted back to the C form
for display to a user. But when providing the string to Sqlite, it&#x27;s in SQL format.</p><p>Identifiers can be distinguised from string literals because the quotation marks (always <code>&#x27;&#x27;</code>) are still in the string.</p><p>This node type is always a leaf.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-number-node-num_ast_node"></a>The Number Node <code>num_ast_node</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-number-node-num_ast_node" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct num_ast_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... the common fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t num_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const char *_Nullable value;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} num_ast_node;</span></div></div></div></div></div><ul><li><code>num_type</code> : the kind of numeric</li><li><code>value</code> : the text of the number</li></ul><p>All numerics are stored as strings so that there is no loss of precision.  This is important because it is entirely possible that
the CQL compiler is built with a different floating point library, than the target system, or different integer sizes.  As a result
CQL does not evaluate anything outside of an explicit <code>const(...)</code> expression.  This policy avoids integer overflows at compile time or loss
of floating point precesion. Constants in the text of the output are emitted byte-for-byte as they appeared in the source code.</p><p>This node type is always a leaf.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="examples"></a>Examples<a aria-hidden="true" tabindex="-1" class="hash-link" href="#examples" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-1-a-let-statement-and-expression"></a>Example 1: A LET statement and expression<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-1-a-let-statement-and-expression" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">LET x := 1 + (3 - 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {sub}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {int 3}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {int 2}</span></div></div></div></div></div><p>Note that there are no parentheses in the AST but it exactly and authoritatively captures the precedence with its shape.
This means, among other things, that when CQL echos its input, any redundant parentheses will be gone.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-2-an-ifelse-construct"></a>Example 2: An IF/ELSE construct<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-2-an-ifelse-construct" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">IF x THEN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET x := 1.5e7;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ELSE IF y THEN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET y := &#x27;that&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ELSE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET z := &quot;this&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END IF;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {if_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {cond_action}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {stmt_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {dbl 1.5e7}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {if_alt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {elseif}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | | {cond_action}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |   | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |   | {stmt_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |     | {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |       | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    |       | {strlit &#x27;that&#x27;}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {else}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {stmt_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        | {let_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          | {name z}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          | {strlit &#x27;this&#x27;}</span></div></div></div></div></div><p>Note that the string &quot;this&quot; was normalized to &#x27;this&#x27; (which was trivial in this case) but rest assured that
<code>cstr_literal</code> was set.  This is shown because the text of the statement came out with double quotes.
The text above was not the input to the compiler, the compiler was actually given this text</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">if x then let x := 1.5e7; else if y then let y := &#x27;that&#x27;; else let z := &quot;this&quot;; end if;</span></div></div></div></div></div><p>And it was normalized into what you see as part of the output.  We&#x27;ll talk about this output echoing in coming sections.
As you can see, the compiler can be used as a SQL normalizer/beautifier.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-3-a-select-statement"></a>Example 3: A SELECT statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-3-a-select-statement" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FROM foo</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INNER JOIN bar</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHERE foo.x = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">LIMIT 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {select_stmt}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_core_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {select_core}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {select_expr_list_con}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_expr_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {star}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_from_etc}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {join_clause}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | | | {name foo}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | | {join_target_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |   | {join_target}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |     | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |     | {table_join}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |       | {table_or_subquery}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       |         | {name bar}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {select_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {opt_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | | {eq}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | {dot}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | | {name foo}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         |   | {int 1}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {select_groupby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |           | {select_having}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_orderby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {select_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {opt_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | | {int 3}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {select_offset}</span></div></div></div></div></div><p>As you can see the trees rapidly get more complex.  The <code>SELECT</code> statement has many optional pieces and
so the AST actually has places in its skeleton where these could go but are absent (e.g. <code>GROUP BY</code>,
<code>HAVING</code>, <code>ORDER BY</code>, and <code>OFFSET</code> are all missing).</p><p>The shape of the AST is largely self evident from the above, but you can easily cross check it against
what&#x27;s in <code>cql.y</code> for details and then look at <code>gen_sql.c</code> for decoding tips (discussed below).</p><p>The compiler can produce these diagrams in &#x27;dot&#x27; format which makes pretty pictures, but the reality is that
for non-trivial examples those pictures are so large as to be unreadable whereas the simple text format
remains readable even up to several hundred lines of output. The text is also readily searchable, and diffable.
The test suites for semantic analysis do pattern matching on the text of the AST to verify correctness.</p><p>We&#x27;ll discuss semantic analysis in <a href="https://cgsql.dev/cql-guide/int02" target="_blank" rel="noopener noreferrer">Part 2</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ast-definitions"></a>AST definitions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ast-definitions" title="Direct link to heading">#</a></h3><p><code>ast.h</code> defines all the tree types mentioned above. There are helper methods to create AST nodes
with type safety.  It includes helper functions for the various leaf types mentioned above
but also for the various &quot;normal&quot; types.  These are specified using the AST macros <code>AST</code>, <code>AST1</code>, and <code>AST0</code>.</p><p>Examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">AST0(star)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">AST1(not)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">AST(or)</span></div></div></div></div></div><p>This says that:</p><ul><li>the <code>star</code> AST node (used in <code>select *</code>) is a leaf, it has 0 children<ul><li>this means the left and right nodes will always be <code>NULL</code></li></ul></li><li>the <code>not</code> AST node (used in <code>select NOT x</code>) is unary<ul><li>this means only the left node is populated, the right is always <code>NULL</code></li><li>node many unary nodes have optional children, so the left node might still be <code>NULL</code></li></ul></li><li>the <code>or</code> AST node (used in <code>select x OR y</code>) is binary<ul><li>this means both its left and right children are populated</li><li>note that some binary nodes have optional children, so left or right still might be <code>NULL</code></li></ul></li></ul><p>At present there are about 300 unique AST node types.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="echoing-the-ast"></a>Echoing the AST<a aria-hidden="true" tabindex="-1" class="hash-link" href="#echoing-the-ast" title="Direct link to heading">#</a></h2><p>The first set of features that were built (after parsing) provided the ability to echo back the parse tree as SQL again.
This all happens in <code>gen_sql.c</code>. Since this code has to be able to echo back any tree, it often has the best
and simplest examples of how to crack the AST for any particular type of node you might be interested in.</p><p>There are several reasons why we might want to echo the SQL, but the inescapable one is this: any hunk of
SQL that appears as part of a CQL program (i.e. DDL/DML rather than control flow like <code>IF</code>/<code>WHILE</code>) has to go
to SQLite and SQLite expects that code to be plain text.  So the AST must be reformatted as plain text that is
exactly equivalent to the original input.  The process of parsing removes extra white space and parentheses, so
to get something that looks reasonable some standard formatting (including indenting) is applied to the output text.
This has the effect of normalizing the input and potentially beautifying it as well (especially if it was
poorly formatted initially).</p><p>To see these features you need only run cql with no arguments, by default it reads <code>stdin</code>, makes the AST, and
then emits the normalized, formatted text. If there are no syntax errors, the input and the output should be
equivalent.</p><p>Standard formatting is essential, but CQL also has a number of extra demands.</p><p>CQL includes a lot of versioning directives like <code>@create(...)</code> <code>@delete(...)</code> and so forth.  SQLite should
never see these things when the DDL for SQLite is emitted.  But when echoing the input they should be included.
Additionally, any local or global variables in a SQL statement should be replaced with <code>?</code> in the text
that goes to SQLite and then followed up with binding instructions.  We&#x27;ll cover the binding more in the
section code generation, but importantly this also has to significantly alter the output.
As a result the standard formatter includes extensive configurably to get these various results.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="configuring-the-output-with-callbacks-and-flags"></a>Configuring the Output with Callbacks and Flags<a aria-hidden="true" tabindex="-1" class="hash-link" href="#configuring-the-output-with-callbacks-and-flags" title="Direct link to heading">#</a></h3><p>Some of these features, like variable binding, require a callback to the formatter&#x27;s client.  The client
gets a notification, along with a few control variables, and it can then decide exactly what goes in the output
The control structure is <code>struct gen_sql_callbacks</code>, and it is described below.  This structure includes the various
callbacks (all of which are optional) and each callback gets a &#x27;context&#x27; pointer of its choice.  The context pointer
is some arbitrary <code>void *</code> value that you provide, which will be given to your function along with the AST pointer
relevant to the call.  The callback also gets the current output buffer so it can choose to emit something (like &#x27;?&#x27;)
into the stream.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// signature for a callback, you get your context plus the ast</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if you return true then the normal output is suppressed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// in any case the output you provide is emitted</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef bool_t (*_Nullable gen_sql_callback)(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct ast_node *_Nonnull ast,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *_Nonnull output</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">);</span></div></div></div></div></div><p>The meaning of the <code>bool_t</code> return value varies depend on which callback it is.</p><p>The coarsest control is provided by the generation mode.  It is one of these values:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These modes control the overall style of the output</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">enum gen_sql_mode {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_mode_echo,          // Prints everything in the original, with standard whitespace and parentheses</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_mode_sql,           // Prints the AST formatted for SQLite consumption, omits anything CQL specific</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_mode_no_annotations // Equivalent to gen_mode_echo without versioning attributes or generic attribues</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                          // * @create, @delete, @recreate, and @attribute are removed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                          // * statements like @echo are not affected, nor is the type specifier @sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div></div></div><p>The actual callbacks structure is optional, if it is <code>NULL</code> then a full echo of the AST with no changes will
be produced.  Otherwise the callbacks and flags alter the behavior of the echoer somewhat.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Callbacks allow you to significantly alter the generated sql, see the particular flags below.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct gen_sql_callbacks {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Each time a local/global variable is encountered in the AST, this callback is invoked</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this is to allow the varialbe reference to be noted and replaced with ? in the generated SQL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable variables_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable variables_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Each time a column definition is emitted this callback is invoked, it may choose to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // suppress that column.  This is used to remove columns that were added in later schema</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // versions from the baseline schema.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable col_def_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable col_def_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This callback is used to expland the * in select * or select T.*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable star_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable star_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This callback is used to force the &quot;IF NOT EXISTS&quot; form of DDL statements when generating</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // schema upgrade steps.  e.g. a &quot;CREATE TABLE Foo declarations get &quot;IF NOT EXISTS&quot; added</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // to them in upgrade steps.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_sql_callback _Nullable if_not_exists_callback;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void *_Nullable if_not_exists_context;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If true, hex literals are converted to decimal.  This is for JSON which does not support hex literals.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t convert_hex;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If true casts like &quot;CAST(NULL as TEXT)&quot; are reduced to just NULL.  The type information is not needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // by SQLite so it just wasts space.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t minify_casts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If true then unused aliases in select statements are elided to save space.  This is safe because</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // CQL always binds the top level select statement by ordinal anyway.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t minify_aliases;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // mode to print cql statement: gen_mode_echo, gen_mode_sql, gen_mode_no_annotations.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // gen_mode_sql mode causes the AS part of virtual table to be suppressed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  enum gen_sql_mode mode;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // If CQL finds a column such as &#x27;x&#x27; below&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // create table foo(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //   x long_int primary key autoincrement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // that column must be converted to this form:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // create table foo(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //   x integer primary key autoincrement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This is because SQLite mandates that autoincrement must be exactly</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // in the second example above however, it is also the case that in SQLite</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // an integer can store a 64 bit value.  So sending &quot;integer&quot; to SQLite while</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // keeping the sense that the column is to be treated as 64 bits in CQL works</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // just fine.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // However, when we are emitting CQL (rather than SQL) we want to keep</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the original long_int type so as not to lose fidelity when processing</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // schema for other semantic checks (such as matching FK data types).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This flag is for that purpose: It tells us that the target isn&#x27;t SQLite</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // and we don&#x27;t need to do the mapping (yet). Indeed, we shouldn&#x27;t, or the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // types will be messed up.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // In short, if CQL is going to process the output again, use this flag</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // to control the autoincrement transform.  It might be possible to fold</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this flag with the mode flag but it&#x27;s sufficiently wierd that this</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // extra documention and special handling is probably worth the extra</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // boolean storage.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t long_to_int_conv;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} gen_sql_callbacks;</span></div></div></div></div></div><p>Each callback can be best understood by reading the source, so we&#x27;ll avoid
trying to precisely define it here.  But it is helpful to give the jist
of these options.</p><ul><li><code>mode</code> : one of the three enum modes that control overall behavior</li><li><code>variables_callback</code> : invoked when a variable appears in the SQL, the caller can record the specific variable and then use it for binding</li><li><code>col_def_callback</code> : when creating the &quot;baseline&quot; schema you don&#x27;t want column defintions from later schema to be included, this gives you a chance to suppress them</li><li><code>star_callback</code> : normally the <code>*</code> in <code>select *</code> or <code>select T.*</code> is expanded when emitting for SQLite, this callback does the expansion when appropriate</li><li><code>if_not_exists_callback</code> : when generating DDL for schema upgrade you typically want to force <code>IF NOT EXISTS</code> to be added to the schema even if it wasn&#x27;t present in the declaration, this callback lets you do that</li><li><code>convert_hex</code> : if true, hex constants are converted to decimal; used when emitting JSON because JSON doesn&#x27;t understand hex constants</li><li><code>minify_casts</code> : minification converts casts like <code>CAST(NULL AS TEXT)</code> to just <code>NULL</code> -- the former is only useful for type information, SQLite does need to see it</li><li><code>minify_aliases</code> : unused column aliases as in <code>select foo.x as some_really_long_alias</code> can be removed from the output when targetting SQLite to save space</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="invoking-the-generator"></a>Invoking the Generator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#invoking-the-generator" title="Direct link to heading">#</a></h3><p>There are several generation functions but they all follow a similar pattern, the differences are essentially what fragment of the AST
they expect to begin on.  We&#x27;ll just cover one here.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_statement_with_callbacks(ast_node *_Nonnull ast, gen_sql_callbacks *_Nullable _callbacks);</span></div></div></div></div></div><p>This has the typical signature for all these generators:</p><ul><li><code>ast</code> : the part of the tree to print</li><li><code>_callbacks</code> : the optional callbacks described above</li></ul><p>To use these you&#x27;ll need to these functions as well.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_init(void);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_cleanup(void);</span></div></div></div></div></div><p>You&#x27;ll want to call <code>gen_init()</code> one time before doing any generation.  That sets up the necessary tables.
When you&#x27;re done use <code>gen_cleanup()</code> to release any memory that was allocated in setup.
You don&#x27;t have to do the cleanup step if the process is going to exit anyway, however, because of the amalgam
options, <code>cql_main()</code> assumes it might be called again and so it tidies things up rather than risk leaking.</p><p>With the one time initialization in place there are these preliminaries:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void init_gen_sql_callbacks(gen_sql_callbacks *_Nullable callbacks);</span></div></div></div></div></div><p>Use <code>init_gen_sql_callbacks</code> to fill in your callback structure with the normal defaults.  This give you normal echo for SQL by default.
To get a full echo, a <code>NULL</code> callback may be used.  And of course other options are possible.</p><p>Finally,</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_set_output_buffer(struct charbuf *_Nonnull buffer);</span></div></div></div></div></div><p>Use this before the call to <code>gen_&lt;something&gt;_with_callbacks</code> to redirect the output into a growable character buffer of your choice.</p><p>The buffers can then be written where they are needed.  Maybe further processed into a C string literal for compiler output, or into
a C style comment, or just right back to stdout.</p><p>There are a few simplified versions of this sequence like this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_stmt_list_to_stdout(ast_node *_Nullable ast);</span></div></div></div></div></div><p>This uses <code>NULL</code> for the callbacks and emits directly to stdout with no extra steps.  The extra wiring is done for you.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generator-internals"></a>Generator Internals<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generator-internals" title="Direct link to heading">#</a></h3><p>The generator has to be able to walk the entire tree and emit plain text, and in many areas the tree is very flexible
so we want a simple dynamic dispatch mechanism that can call the right formatting function from anywhere in the tree.</p><p>It turns out two different signatures are needed to do this properly, one for formatting statements and the other
for expressions -- the difference being that expressions have to concern themselves with the precedence of the various
operators so that parentheses can be correctly (re)inserted into the output.</p><p>To do this there are two symbol tables that map from an AST node type string to a formatting function.  They are initialized
with a series of statements similar to these:</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generating-expressions"></a>Generating Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generating-expressions" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void gen_init() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_stmts = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_exprs = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, gen_binary, &quot;*&quot;, EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(div, gen_binary, &quot;/&quot;, EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, gen_binary, &quot;%&quot;, EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(add, gen_binary, &quot;+&quot;, EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(sub, gen_binary, &quot;-&quot;, EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, gen_unary, &quot;NOT &quot;, EXPR_PRI_NOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, gen_unary, &quot;~&quot;, EXPR_PRI_TILDE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>These statements populate the symbol tables.</p><ul><li>For statements, the entry maps <code>if_stmt</code> to the function <code>gen_if_stmt</code></li><li>For expressions, the entry maps <code>mul</code> to <code>gen_binary</code> including the metadata <code>&quot;*&quot;</code> and <code>EXPR_PRI_MUL</code></li></ul><p>As you can see, nearly all binary operators are handled identically as are all unary operators.
Let&#x27;s look at those two in detail.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_binary(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We add parens if our priority is less than the parent prioirty</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // meaning something like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // * we&#x27;re a + node, our parent is a * node</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // * we need parens because the tree specifies that the + happens before the *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Also, grouping of equal operators is left to right</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so for so if our right child is the same precendence as us</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // that means there were parens there in the original expression</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // e.g.  3+(4-7);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // effectively it&#x27;s like we&#x27;re one binding strength higher for our right child</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so we call it with pri_new + 1.  If it&#x27;s equal to us it must emit parens</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;(&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_expr(ast-&gt;left, pri_new);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot; %s &quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_expr(ast-&gt;right, pri_new + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;)&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The convention gives us:</p><ul><li><code>ast</code> : pointer to the current AST node</li><li><code>op</code> : the text of the operator (<code>CSTR</code> is simply <code>const char *</code>)</li><li><code>pri</code> : the binding strength of the node above us</li><li><code>pri_new</code> : the binding strength of this node (the new node)</li></ul><p>So generically, if the binding strength of the current opereator <code>pri_new</code> is weaker than the context it is contained in <code>pri</code>,
then parentheses are required to preserve order of operations. See the comment for more details.</p><p>With parens taken care of, we emit the left expression, the operator, and the right expression.</p><p>And as you can see below, unary operators are much the same.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_unary(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;(&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot;%s&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_expr(ast-&gt;left, pri_new);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (pri_new &lt; pri) gen_printf(&quot;)&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>There are special case formatters for some of the postfix operators and other cases that are special
like <code>CASE... WHEN... THEN... ELSE... END</code> but they operate on the same principles down to the leaf nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generating-statements"></a>Generating Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generating-statements" title="Direct link to heading">#</a></h4><p>With no binding strength to worry about, statement processing is quite a bit simpler.</p><p>Here&#x27;s the code for the <code>IF</code> statement mentioned above.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_if_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_if_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NOTNULL(cond_action, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NOTNULL(if_alt, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(elseif, if_alt-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NAMED(elsenode, else, if_alt-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot;IF &quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_cond_action(cond_action);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (elseif) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_elseif_list(elseif);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (elsenode) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_printf(&quot;ELSE\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT(stmt_list, elsenode-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gen_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot;END IF&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>There is a general boiler plate sort of recursive form to all of these, they follow the same basic shape.
These patterns are designed to make it impossible to walk the tree incorrectly. If the tree shape changes
because of a grammar change, you get immediate concrete failures were the tree walk has to change.  Since
there are test cases to cover every tree shape you can always be sure you have it exactly right if the
macros do not force assertion failures.</p><p>The steps were:</p><ul><li>use <code>Contract</code> to assert that the node we are given is the type we expect</li><li>use <code>EXTRACT</code> macros (detailed below) to get the tree parts you want starting from your root</li><li>use <code>gen_printf</code> to emit the constant pieces of the statement</li><li>use recursion to print sub fragments (like the IF condition in this case)</li><li>test the tree fragments where optional peices are present, emit them as needed</li></ul><p>It might be instructive to include <code>gen_cond_action</code>, it is entirely unremarkable:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void gen_cond_action(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_cond_action(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_root_expr(ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_printf(&quot; THEN\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gen_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>A <code>cond_action</code> node has an expression on the left and a statement list on the right it can appear
in the base <code>IF x THEN y</code> part of the <code>IF</code> or as <code>ELSE IF x THEN y</code>.  Either case is formatted the same.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="extraction-macros"></a>Extraction Macros<a aria-hidden="true" tabindex="-1" class="hash-link" href="#extraction-macros" title="Direct link to heading">#</a></h4><p>These macros are used by all the parts of CQL that walk the AST.  They are designed to make it impossible
for you to get the tree shape wrong without immediately failing.  We do not ever want to walk off
the tree in some exotic way and then continue to several levels of recursion before things go wrong.  CQL
locks this down by checking the node type at every step -- any problems are found immediately, exactly
at the extraction site, and can be quickly corrected.  Again 100% coverage of all the tree shapes makes
this rock solid, so CQL never compromises on 100% code coverage.  The most common macros all appear in this
example:</p><ul><li><code>EXTRACT_NOTNULL(cond_action, ast-&gt;left);</code><ul><li>read ast-&gt;left, assert that it is of type <code>cond_action</code>, it must not be NULL</li><li>declare a local variable named <code>cond_action</code> to hold the result</li></ul></li><li><code>EXTRACT_NOTNULL(if_alt, ast-&gt;right);</code><ul><li>read ast-&gt;right, assert that it is of type <code>if_alt</code>, it must not be NULL</li><li>declare a local variable named <code>if_alt</code> to hold the result</li></ul></li><li><code>EXTRACT(elseif, if_alt-&gt;left);</code><ul><li>read <code>if_alt-&gt;left</code>, assert that it is either NULL or else of type <code>elseif</code></li><li>declare a variable named <code>elseif</code> to hold the result</li></ul></li><li><code>EXTRACT_NAMED(elsenode, else, if_alt-&gt;right);</code><ul><li>read <code>if_alt-&gt;right</code>, assert that it is either NULL or else of type <code>else</code></li><li>declare a variable named <code>elsenode</code> to hold the result</li><li>note that we can&#x27;t use a variable named <code>else</code> because <code>else</code> is a keyword in C</li></ul></li></ul><p>Other options:</p><ul><li><code>EXTRACT_NAMED_NOTNULL</code> : like the <code>NAMED</code> variant</li><li><code>EXTRACT_ANY</code> : if the tree type is not known (e.g. <code>expr-&gt;left</code> could be any expression type)</li><li><code>EXTRACT_ANY_NOTNULL</code> : as above but not optional</li><li><code>EXTRACT_NUM_TYPE</code> : extracts the num_type field from a numeric AST node</li></ul><p>The <code>ANY</code> variants are usually re-dispatched with something like <code>gen_expr</code> that uses the name table again (and that will check the type) or
else extracted value is checked with ad hoc logic immediately after extraction if it&#x27;s perhaps one of two or three variations.
In all cases the idea is to force a failure very quickly.  <code>gen_root_expr()</code> for instance in the <code>if_cond</code> example will fail immediately
if the node it gets is not an expression type.</p><p>Because of the clear use of <code>EXTRACT</code>, the <code>gen_</code> family of functions are often the best/fastest way to understand the shape of the AST.
You can dump a few sample and look at the <code>gen_</code> function and quickly see exactly what the options are authoritatively.  As a result
it&#x27;s very normal to paste the extraction code from a <code>gen_</code> function into a new/needed semantic analysis or code-generation functions.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-2-semantic-analysis"></a>Part 2: Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-2-semantic-analysis" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-1"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-1" title="Direct link to heading">#</a></h3><p>Part 2 continues with a discussion of the essentials of the semantic analysis pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every single rule but rather to give
a sense of how semantic analysis happens in general -- the core strategies and implementation choices --
so that when reading the code you have an idea how smaller pieces fit into the whole. To accomplish
this, various key data structures will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="semantic-analysis"></a>Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#semantic-analysis" title="Direct link to heading">#</a></h2><p>The overall goal of the semantic analysis pass is to verify that a correct program has been submitted
to the compiler. The compiler does this by &quot;decorating&quot; the AST with semantic information.  This information
is mainly concerned about the &quot;types&quot; of the various things in the program.  A key function of the semantic
analyzer, the primary &quot;weapon&quot; in computing these types if you will, is name resolution.  The semantic analyzer
decides what any given name means in any context and then uses that meaning, which is itself based on the
AST constructs that came before, to compute types and then check those types for errors.</p><p>Broadly speaking the errors that can be discovered are of these forms:</p><ul><li>mentioned names do not exist<ul><li>e.g. using a variable or table or column without declaring it</li></ul></li><li>mentioned names are not unique or are ambiguous<ul><li>e.g. table names need to be unique or aliased when joining tables</li></ul></li><li>operands are not compatible with each other or with the operation<ul><li>e.g. you can&#x27;t add a string to a real</li><li>e.g. you can&#x27;t do the &#x27;%&#x27; operation on a real</li><li>e.g. the expression in a <code>WHERE</code> clause must be numeric</li><li>e.g. the first argument to <code>printf</code> must be a string literal.</li><li>e.g. you can&#x27;t assign a long value to an integer variable</li><li>e.g. you can&#x27;t assign a possibly null result to a not-null variable</li></ul></li><li>there are too many or two few operands for an operation<ul><li>e.g. an <code>INSERT</code> statement must include sufficiently many columns and no extras</li><li>e.g. a function or procedure call must have the correct number of operands</li></ul></li><li>an operation is happening in a context where it is not allowed<ul><li>e.g. use of aggregate functions in the <code>WHERE</code> clause</li><li>e.g. use of unique SQLite functions outside of a SQL statement</li></ul></li></ul><p>There are several hundred possible errors, no attempt will be made to cover them all here but we will
talk about how errors are created, recorded, and reported.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="decorated-ast-examples"></a>Decorated AST examples<a aria-hidden="true" tabindex="-1" class="hash-link" href="#decorated-ast-examples" title="Direct link to heading">#</a></h3><p>Recalling the AST output from Part 1, this is what it looks like with semantic information attached.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">LET X := 1 + 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {let_stmt}: X: integer notnull variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {name X}: X: integer notnull variable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {add}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 1}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {int 3}: integer notnull</span></div></div></div></div></div><p>And here&#x27;s an example with some structure types</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SELECT 1 AS x, 3.2 AS y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {select_stmt}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_core_list}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | | {select_core}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |   | {select_expr_list_con}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_expr_list}: select: { x: integer notnull, y: real notnull }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {select_expr}: x: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | | {int 1}: integer notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | | {opt_as_alias}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | |   | {name x}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | | {select_expr_list}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |   | {select_expr}: y: real notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |     | {dbl 3.2}: real notnull</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |     | {opt_as_alias}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     |       | {name y}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |     | {select_from_etc}: ok</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |       | {select_where}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |         | {select_groupby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  |           | {select_having}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  | {select_orderby}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    | {select_limit}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      | {select_offset}</span></div></div></div></div></div><p>These can be generated by adding <code>--sem --print</code> to the CQL command line along with <code>--in your_file.sql</code>.</p><p>Keep these shapes in mind as we discuss the various sources of type information.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-base-data-structures"></a>The Base Data Structures<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-base-data-structures" title="Direct link to heading">#</a></h3><p>First recall that every AST node has this field in it:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct sem_node *_Nullable sem;</span></div></div></div></div></div><p>This is the pointer to the semantic information for that node. Semantic analysis happens immediately
after parsing and before any of the code-generators run.  Importantly code generators never run
if semantic analysis reported any errors.  Before we get into the shape of the semantic node, we
should start with the fundamental unit of type info <code>sem_t</code> which is usually stored in a variable
called <code>sem_type</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef uint64_t sem_t;</span></div></div></div></div></div><p>The low order bits of a <code>sem_t</code> encode the core type and indeed there is an helper macro
to extract the core type from a <code>sem_t</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Strips out all the flag bits and gives you the base/core type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport sem_t core_type_of(sem_t sem_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_type &amp; SEM_TYPE_CORE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The core bits are as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_NULL 0         // the subtree is a null literal (not just nullable)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BOOL 1         // the subtree is a bool</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_INTEGER 2      // the subtree is an integer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_LONG_INTEGER 3 // the subtree is a long integer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_REAL 4         // the subtree is a real</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_TEXT 5         // the subtree is a text type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BLOB 6         // the subtree is a blob type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OBJECT 7       // the subtree is any object type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_STRUCT 8       // the subtree is a table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_JOIN 9         // the subtree is a join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_ERROR 10       // marks the subtree as having a problem</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OK 11          // sentinel for ok but no type info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_PENDING 12     // sentinel for type calculation in flight</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_REGION 13      // the ast is a schema region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CORE 0xff      // bit mask for the core types</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) // the last unitary type</span></div></div></div></div></div><p>These break into a few categories:</p><ul><li><code>NULL</code> to <code>OBJECT</code> are the &quot;unitary&quot; types, these are the types that a single simple variable can be<ul><li>a column can be any of these except <code>OBJECT</code> or <code>NULL</code></li><li>the <code>NULL</code> type begins only from the <code>NULL</code> literal which has no type</li><li>instance of say a <code>TEXT</code> column might have a <code>NULL</code> value but they are known to be <code>TEXT</code></li></ul></li><li><code>STRUCT</code> indicates that the object has many fields, like a table, or a cursor</li><li><code>JOIN</code> indicates that the object is the concatenation of many <code>STRUCT</code> types<ul><li>e.g. <code>T1 inner join T2</code> is a <code>JOIN</code> type with <code>T1</code> and <code>T2</code> being the parts</li><li>a <code>JOIN</code> can be flattend to <code>STRUCT</code> but this is typically not done</li><li>the type of a <code>SELECT</code> statement will be a <code>STRUCT</code> representing the columns that were selected which in turn came from the <code>JOIN</code> that was the <code>FROM</code> clause</li></ul></li><li><code>ERROR</code> indicates that the subtree had an error, it will have been already reported, this generally cascades up the AST to the root</li><li><code>OK</code> indicates that there is no type information but there was no problem, for instance a correct <code>IF</code> statement will resolve to simply <code>OK</code> (no error)</li><li><code>PENDING</code> is used sometimes while a type computation is in progress, it doesn&#x27;t appear in the AST but has its own unique value so as to not conflict with any others</li><li><code>REGION</code> used to identify AST fragments that correspond to schema regions (see the Guide for mor info on regions)</li><li><code>CORE</code> is the mask for the core parts, <code>0xf</code> would do the job but for easy reading in the debugger we use <code>0xff</code><ul><li>new core types are not added very often, adding a new one is usually a sign that you are doing something wrong</li></ul></li></ul><p>The core type can be modified by various flags.  The flags in principle can be combined in any way but in practice many combinations make no sense.
for instance, <code>HAS_DEFAULT</code> is for table columns and <code>CREATE_FUNC</code> is for function declarations. There is no one object that could require both of these.</p><p>The full list as of this writing is as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_NOTNULL               _64(0x0100) // set if and only if null is not possible</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) // set for table columns with a default</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) // set for table columns with autoinc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VARIABLE              _64(0x0800) // set for variables and parameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_IN_PARAMETER          _64(0x1000) // set for in parameters (can mix with below)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) // set for out paramters (can mix with above)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DML_PROC              _64(0x4000) // set for stored procs that have DML/DDL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) // set for a cursor with simplified fetch syntax</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CREATE_FUNC          _64(0x10000) // set for a function that returns a created object +1 ref</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_SELECT_FUNC          _64(0x20000) // set for a sqlite UDF function declaration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DELETED              _64(0x40000) // set for columns that are not visible in the current schema version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VALIDATED            _64(0x80000) // set if item has already been validated against previous schema</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_USES_OUT            _64(0x100000) // set if proc has a one rowresult using the OUT statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) // set if proc uses the OUT UNION form for multi row result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_PK                  _64(0x400000) // set if column is a primary key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_FK                  _64(0x800000) // set if column is a foreign key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_UK                 _64(0x1000000) // set if column is a unique key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) // set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_SENSITIVE          _64(0x4000000) // set if the object is privacy sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) // set if the object is a deployable region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_BOXED             _64(0x10000000) // set if a cursor&#x27;s lifetime is managed by a box object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_CHECK         _64(0x20000000) // set for table column with a &quot;check&quot; clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) // set for table column with a &quot;collate&quot; clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) // set if inferred to not be nonnull (but was originally nullable)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_VIRTUAL          _64(0x100000000) // set if and only if this is a virtual table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) // set if and only if hidden column on a virtual table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_TVF              _64(0x400000000) // set if and only table node is a table valued function</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_IMPLICIT         _64(0x800000000) // set if and only the variable was declare implicitly (via declare out)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) // set if proc calls an out union proc for</span></div></div></div></div></div><p>Going over the meaning of all of the above is again beyond the scope of this document, some of them are very specialized and essentially the validation
requires a bit of storage in the tree to do its job so that storage is provided with a bit.  However two flag bits are especially important and
are computed almost everywhere <code>sem_t</code> is used.  These are <code>SEM_TYPE_NOTNULL</code> and <code>SEM_TYPE_SENSITIVE</code>.</p><ul><li><code>SEM_TYPE_NOTNULL</code> indicates that the marked item is known to be <code>NOT NULL</code>, probably because it was declared as such or directly derived from a not null item<ul><li>Typically when two operands are combined both must be marked <code>NOT NULL</code> for the result to still be NOT NULL (there are exceptions like <code>COALESCE</code>)</li><li>Values that might be null cannot be assigned to targets that must be not null</li></ul></li><li><code>SEM_TYPE_SENSITIVE</code> indicates that the marked item is some kind of PII or other sensitive data.<ul><li>Any time a sensitive item is combined with some other piece of data the result is a new sensitive piece of data, there are very few ways to &quot;get rid&quot; of the sensitive bit.  It corresponds to the presence of <code>@sensitive</code> in the data type declaration.</li><li>Values that are sensitive cannot be assigned to targets that are not also marked sensitive</li></ul></li></ul><p>The semantic node <code>sem_node</code> carries all the possible semantic info we might need, the <code>sem_type</code> holds the flags above and tells us how to interpret it.
There are many fields, we&#x27;ll talk about some of the most important ones here to give you a sense of how things hang together.</p><p>Note that <code>CSTR</code> is simply an alias for <code>const char *</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_node {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type;                   // core type plus flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR name;                        // for named expressions in select columns etc.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kind;                        // the Foo in object&lt;Foo&gt;, not a variable or column name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR error;                       // error text for test output, not used otherwise</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct *sptr;          // encoded struct if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_join *jptr;            // encoded join if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t create_version;           // create version if any (really only for tables and columns)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t delete_version;           // create version if any (really only for tables and columns)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t recreate;                  // for tables only, true if marked @recreate</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR recreate_group_name;         // for tables only, the name of the recreate gruop if they are in one</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR region;                      // the schema region, if applicable, null means unscoped (default)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *used_symbols;             // for select statements, we need to know which of the ids in the select list was used if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  list_item *index_list;            // for tables we need the list of indices that use this table (so we can recreate them together if needed)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct eval_node *value;          // for enum values we have to store the evaluated constant value of each member of the enum</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_node;</span></div></div></div></div></div><ul><li><code>sem_type</code> : already discussed above, this tells you how to interpret everything else</li><li><code>name</code> : variables, columns, etc. have a canonical name, when a name case-insenstively resolves, the canonical name is stored here<ul><li>typically you want to emit the canonical variable name (e.g. <code>FoO</code> and <code>fOO</code> might both resolve to <code>foo</code> if that is how it was declared)</li></ul></li><li><code>kind</code> : in CQL any type can be discriminated as in <code>declare foo real&lt;meters&gt;</code>, the kind here is <code>meters</code><ul><li>expressions of the same core type (e.g. <code>real</code>) are incompatible if they have a <code>kind</code> and the <code>kind</code> does not match</li><li>e.g. you can&#x27;t assign if you have <code>bar real&lt;liters&gt;</code> then <code>set foo := bar;</code> is an error even though both are <code>real</code>.</li></ul></li><li><code>sptr</code> : if the item&#x27;s core type is <code>SEM_TYPE_STRUCT</code> then this is populated, see below</li><li><code>jptr</code> : if the item&#x27;s core type is <code>SEM_TYPE_JOIN</code> then this is populated, see below</li></ul><p>If the object is a structure type then this is simply an array of names, kinds, and semantic types.  In fact the semantic types will be all be unitary possibly modified by <code>NOT_NULL</code> or <code>SENSITIVE</code> but none of the other flags apply.  A single <code>sptr</code> directly corresponds to the notion of a <code>shape</code> in the analyzer.  Shapes come from anything
that looks like a table, such as a cursor, or the result of a <code>SELECT</code> statement.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for tables and views and the result of a select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_struct {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR struct_name;               // struct name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // field names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *kinds;                    // the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *semtypes;                // typecode for each field</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_struct;</span></div></div></div></div></div><p>If the object is a join type (such as the parts of the <code>FROM</code> clause) then the <code>jptr</code> field will be populated. This is nothing more than a named list of struct types.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for the data type of (parts of) the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// sometimes I refer to as a &quot;joinscope&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_join {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of table/views in the join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // names of the table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct **tables;     // struct type of each table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_join;</span></div></div></div></div></div><p>With these building blocks we can represent the type of anything in the CQL language.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="initiating-semantic-analysis"></a>Initiating Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#initiating-semantic-analysis" title="Direct link to heading">#</a></h3><p>The semantic analysis pass runs much the same way as the AST emitter.  In <code>sem.c</code> there is the essential function <code>sem_main</code>. It suffices
to call <code>sem_main</code> on the root of your AST, that is expect to be a <code>stmt_list</code> node.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This method loads up the global symbol tables in either empty state or</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the appropriate tokens ready to go.  Using our own symbol tables for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// dispatch saves us a lot of if/else string comparison verbosity.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void sem_main(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // restore all globals and statics we own</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_cleanup();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  eval_init();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>As you can see, <code>sem_main</code> begins by reseting all the state.  You can of course do this yourself after calling <code>sem_main</code> (when you&#x27;re done with the results).</p><p><code>sem_main</code> sets a variety of useful and public global variables that describe the results of the analysis.  The ones in <code>sem.h</code> are part of the contract and
you should feel free to use them in a downstream code-generator.  Other items are internal and should be avoided.  These are typically defined statically in <code>sem.c</code>.</p><p>The cleanup has this structure:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This method frees all the global state of the semantic analyzer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void sem_cleanup() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  eval_cleanup();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(deployable_validations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(recreate_annotations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BYTEBUF_CLEANUP(schema_annotations);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(funcs);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(globals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(indices);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SYMTAB_CLEANUP(locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_ad_hoc_list = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  all_functions_list = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div></div></div></div></div><p><code>sem_main</code> of course has to walk the AST and it does so in much the same way as we saw in <code>gen_sql.c</code> there are a set of symbol tables
whose key is an ast type and whose value is a function plus arguments to dispatch (effectively a lambda).  The semantic analyzer doesn&#x27;t
have to think about things like &quot;should I emit parentheses&quot; so the signature of each type of lambda can be quite a bit simpler.  We&#x27;ll
go over each kind with some examples.</p><p>First we have the non-sql statements, these are basic flow control or other things that SQLite will never see directly.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *syms = non_sql_stmts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(leave_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><p>Here <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>if_stmt</code> and the function <code>sem_if_stmt</code>.  This lets us dispatch any part of the AST
directly.</p><p>Next we have the SQL statements.  These get analyzed in the same way as the others, and with functions that have the same signature, however,
if you use one of these it means that procedure that contained this statement must get a database connection in order to run.  This changes
its signature and causes the <code>SEM_TYPE_DML_PROC</code> flag bit to be set on it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  syms = sql_stmts;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_index_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(create_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(select_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(delete_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(update_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(insert_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div></div></div></div></div><p>Again <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>delete_stmt</code> and the function <code>sem_delete_stmt</code>.  This lets us dispatch any part of the AST
directly.</p><p>Next we have expression types, these are set up with <code>EXPR_INIT</code>.  Many of the operators require exactly the same kinds of verification so in order to be
able to share the code, the expression analysis functions get an extra argument for the operator in question.  Typically the string of the operator
is only needed so make a good quality error message and validation is otherwise identical.  Here are some samples...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, sem_expr_num, &quot;NUM&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, sem_expr_str, &quot;STR&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(blob, sem_expr_blob, &quot;BLB&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, sem_expr_null, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, sem_expr_dot, &quot;DOT&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(const, sem_expr_const, &quot;CONST&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, sem_binary_math, &quot;*&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, sem_binary_integer_math, &quot;%&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, sem_unary_logical, &quot;NOT&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(is_true, sem_unary_is_true_or_false, &quot;IS TRUE&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, sem_unary_integer_math, &quot;~&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, sem_unary_math, &quot;-&quot;);</span></div></div></div></div></div><p>Looking at the very first entry as an example we see that <code>EXPR_INIT</code> creates a mapping between the AST type <code>num</code> and the analysis function <code>sem_expr_num</code> and that function will get the text <code>&quot;NUM&quot;</code> as an extra argument.</p><p>Let&#x27;s quickly go over this list as these are the most important analyzers</p><ul><li><code>sem_expr_num</code> : analyzes any numeric constant</li><li><code>sem_expr_str</code> : analyzes any string literal or identifier</li><li><code>sem_expr_blob</code> : analyzes any blob literal</li><li><code>sem_expr_null</code> : analyzes the NULL literal (and nothing else)</li><li><code>sem_expr_dot</code> : analyzes a compound name like <code>T1.id</code></li><li><code>sem_expr_const</code> : analyzes a <code>const(...)</code> expression, doing the constant evaluation</li><li><code>sem_binary_math</code> : analyzes any normal binary math operator like &#x27;+&#x27;, &#x27;-&#x27;, &#x27;/&#x27; etc.</li><li><code>sem_binary_integer_math</code> : analyzes any binary math operator where the operands must be integers like &#x27;%&#x27; or &#x27;|&#x27;</li><li><code>sem_unary_logical</code> : analyzes any unary logical operator (the result is a bool), this is really only <code>NOT</code></li><li><code>sem_unary_is_true_or_false</code> : analyzes any of the <code>IS TRUE</code>, <code>IS FALSE</code>, family of postfix unary operators</li><li><code>sem_unary_integer_math</code> : any unary operator where the operand must be an integer, this is really only <code>~</code></li><li><code>sem_unary_math</code> : any math unary, presently only unary negation (but in the future unary <code>+</code> too)</li></ul><p>The final plentiful group of associations are for builtin functions, like these.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(changes);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(strftime);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(date);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(time);</span></div></div></div></div></div><p>Each of these is dispatched when a function call is found in the tree.  By way of example <code>FUNC_INIT(changes)</code> causes the <code>changes</code> function to map to <code>sem__func_changes</code>.</p><p>There are a few other similar macros for more exotic cases but the general pattern should be clear now.  We these in place it&#x27;s very easy to traverse arbitary statement lists and arbitary expressions with sub expressions and have the correct function be called without having large <code>switch</code> blocks all over.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="semantic-errors"></a>Semantic Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#semantic-errors" title="Direct link to heading">#</a></h3><p>Some of the following examples will show the handling of semantic errors more precisely but the theory is pretty simple.  Each of these analyzers that has
been registered is responsible for putting an appropriate <code>sem_node</code> into the AST it was invoked on.  The caller will look to see if that <code>sem_node</code>
is of type <code>SEM_TYPE_ERROR</code> using <code>is_error(ast)</code>.  If it is the caller will mark its own AST as errant using <code>record_error(ast)</code> and this continues all
the way up the tree.  The net of this is that wherever you begin semantic analysis you can know if there were any problems by checking for an error at the
top of the tree you provided.</p><p>At the point of the initial error, the analyzer is expected to also call <code>report_error</code> providing a suitable message.  This will be logged to stderr.  In test mode it is also stored in the AST so that verification steps can confirm that errors were reported at exactly the right place.</p><p>If there is no error, then either a suitable <code>sem_node</code> is created or else at minimum <code>record_ok(ast)</code> is used to place the shared &quot;OK&quot; type on the node.
The OK type indicates no type information but no errors either.  &quot;OK&quot; is helpful for statements that don&#x27;t involve expressions like <code>DROP TABLE Foo</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-primitive-types"></a>The Primitive Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-primitive-types" title="Direct link to heading">#</a></h3><p>Perhaps the simplest analysis of all happens at the leaves of the AST.  By way of example, here is the code for expression nodes of type <code>num</code>, the numeric literals.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expression type for numeric primitives</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_expr_num(ast_node *ast, CSTR cstr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_num(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_NUM_TYPE(num_type, ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (num_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_BOOL:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_INT:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  case NUM_LONG:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  default:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // this is all that&#x27;s left</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(num_type == NUM_REAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ast-&gt;sem = new_sem(SEM_TYPE_REAL | SEM_TYPE_NOTNULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>As you can see the code simply looks at the AST node, confirming first that it is a <code>num</code> node.  Then it extract the <code>num_type</code>.
<code>ast-&gt;sem</code> is set to a semantic node of the matching type adding in <code>SEM_TYPE_NOTNULL</code> because literals are never null.</p><p>The <code>new_sem</code> function is used to make an empty <code>sem_node</code> with the <code>sem_type</code> filled in as specified.  Nothing can go wrong creating a literal so there are no failure modes.</p><p>It doesn&#x27;t get much simpler unless maybe...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expression type for constant NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_expr_null(ast_node *ast, CSTR cstr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="unary-operators"></a>Unary Operators<a aria-hidden="true" tabindex="-1" class="hash-link" href="#unary-operators" title="Direct link to heading">#</a></h3><p>Let&#x27;s dive in to a simple case -- the unary operators.  There are comparatively few and there isn&#x27;t much code required to handle them all.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The only unary math operators are &#x27;-&#x27; and &#x27;~&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Reference types are not allowed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_unary_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_unary_prep(ast, &amp;core_type, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_validate_numeric(ast, core_type, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The result of unary math promotes to integer.  Basically this converts</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // bool to integer.  Long integer and Real stay as they are.  Text is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // already ruled out.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_result = sem_combine_types(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (core_type | combined_flags));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(sem_type_result);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;kind = ast-&gt;left-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // note ast-&gt;sem-&gt;name is NOT propogated because SQLite doesn&#x27;t let you refer to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the column &#x27;x&#x27; in &#x27;select -x&#x27; -- the column name is actually &#x27;-x&#x27; which is useless</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // so we have no name once you apply unary math (unless you use &#x27;as&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // hence ast-&gt;sem-&gt;name = ast-&gt;left-&gt;sem-&gt;name is WRONG here and it is not missing on accident</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p><em>Unary Prep</em></p><p>OK already we need to pause, there is a &quot;prep&quot; pattern here common to most of the shared operators.
This takes care of most of the normal error handling which is the same for all the unary operators.
The same pattern happens in binary operators.  Let&#x27;s take a look at that function.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The unary operators all have a similar prep to the binary.  We need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to visit the left side (it&#x27;s always the left node even if the operator goes on the right)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if that&#x27;s ok then we need the combined_flags and core type.  There is only</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the one.  Returns true if everything is ok.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_unary_prep(ast_node *ast, sem_t *core_type, sem_t *combined_flags) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // op left | left op</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(ast-&gt;left)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *combined_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_node *sem = ast-&gt;left-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type = core_type_of(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *combined_flags = not_nullable_flag(sem_type) | sensitive_flag(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Reviewing the steps:</p><ul><li>first evaluate the operand, it will be in <code>ast-&gt;left</code></li><li>if that&#x27;s an error, just return the error code from the prep steps</li><li>now that it&#x27;s not an error, pull the core type out of the operand</li><li>pull the not nullable and sensitive flag bits out of the operand</li><li>return a boolean indicating the presence of an error or not for convenience</li></ul><p>This is useful setup for all the unary operators, and as we&#x27;ll see, the binary operator case has a similar prep step.</p><p><em>Back to Unary Processing</em></p><p>Looking at the overall step we see:</p><ul><li><code>sem_unary_prep</code> : verifies that the operand is not an error, and gets its core type and flag bits</li><li><code>sem_validate_numeric</code> : verifies that the operand is a numeric type</li><li><code>sem_combine_types</code> : creates the smallest type that holds two compatible types<ul><li>by combining with integer not null we ensure that the resulting type is at least as big as an integer</li><li>if the argument is of type <code>long</code> or <code>real</code> then it will be the bigger type and the resulting type will be <code>long</code> or <code>real</code></li><li>in short, <code>bool</code> is promoted to <code>int</code>, everything else stays the same</li><li><code>sem_combine_types</code> also combines the nullability and sensitivity appropriately</li></ul></li><li>a new <code>sem_node</code> is created of the combined type<ul><li>the type kind of the operand is preserved (e.g. the <code>meters</code> in <code>real&lt;meters&gt;</code>)</li><li>any column alias or variable name is not preserved, the value is now anonymous</li></ul></li></ul><p>These primitives are designed to combine well, for instance, consider <code>sem_unary_integer_math</code>, the steps are</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_unary_integer_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_unary_math(ast, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_reject_real(ast, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_unary_math</code> : do all the above</li><li><code>sem_reject_real</code> : report/record an error if the type is <code>real</code> otherwise do nothing</li></ul><p>Note that in all cases the <code>op</code> string simply gets pushed down to the place where the errors happen.  Let&#x27;s take a quick look at one of
the sources of errors in the above.  Here&#x27;s the numeric validator:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_validate_numeric(ast_node *ast, sem_t core_type, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_blob(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0045: blob operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0046: object operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_text(core_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0047: string operand not allowed in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This is pretty much dumb as rocks.  The non-numeric types are blob, object, and text.  There is a custom error for each type (it could have been shared
but specific error messages seem to help users).  This code doesn&#x27;t know it&#x27;s context, but all it needs is <code>op</code> to tell it what the numeric-only
operator was and it can produce a nice error message.  It leaves an error in the AST using <code>record_error</code> and so its caller can simply <code>return</code>
if anything goes wrong.</p><p>It&#x27;s not hard to guess how <code>sem_reject_real</code> works:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Some math operators like &lt;&lt; &gt;&gt; &amp; | % only make sense on integers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function does the extra checking to ensure they do not get real values</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// as arguments.  It&#x27;s a post-pass after the normal math checks.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_reject_real(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!is_error(ast)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_t core_type = core_type_of(ast-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (core_type == SEM_TYPE_REAL) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      report_error(ast, &quot;CQL0001: operands must be an integer type, not real&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>if the AST node isn&#x27;t already an error, and it is of type real, report an error</li><li>it assumes the type is already known to be numeric</li><li>the pre-check for errors is to avoid double reporting if something has already gone wrong, the core type will be <code>SEM_TYPE_ERROR</code></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="binary-operators"></a>Binary Operators<a aria-hidden="true" tabindex="-1" class="hash-link" href="#binary-operators" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="binary-prep"></a>Binary Prep<a aria-hidden="true" tabindex="-1" class="hash-link" href="#binary-prep" title="Direct link to heading">#</a></h4><p>The code pretty much speaks for itself, we&#x27;ll walk through it</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// All the binary ops do the same preparation, they evaluate the left and the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// right expression, then they check those for errors.  Then they need</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the types of those expressions and the combined_flags of the result.  This</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// does exactly that for its various callers.  Returns true if all is well.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_binary_prep(ast_node *ast, sem_t *core_type_left, sem_t *core_type_right, sem_t *combined_flags) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(left, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(right, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // left op right</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_expr(right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(left) || is_error(right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type_left = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *core_type_right = SEM_TYPE_ERROR;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *combined_flags = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type_left = core_type_of(left-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *core_type_right = core_type_of(right-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *combined_flags = combine_flags(left-&gt;sem-&gt;sem_type, right-&gt;sem-&gt;sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type_left));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(is_unitary(*core_type_right));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_expr</code> is used to recursively walk the left and right nodes</li><li><code>is_error</code> checks if either had errors, if so, simply propogate the error</li><li>extract the left and right core types</li><li>combine nullability and sensitivity flags</li></ul><p>These are the standard prep steps, the caller now has the core types of left and right plus combined flags on a silver platter.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-is-or-is-not"></a>Example: Is or Is Not<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-is-or-is-not" title="Direct link to heading">#</a></h4><p>This analyzer is the simplest of all the binaries</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// IS and IS NOT are special in that they return a not null boolean.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_binary_is_or_is_not(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type_left, core_type_right, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_binary_prep(ast, &amp;core_type_left, &amp;core_type_right, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the result of is or is not is always a bool and never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | sensitive_flag(combined_flags));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_binary_prep</code> checks for errors in the left or right</li><li><code>sem_verify_compat</code> ensures that left and right operands are type compatible (discussed later)</li><li>the result is always of type <code>bool not null</code></li></ul><p>If either step goes wrong the error will naturally propogate.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-binary-math"></a>Example: Binary Math<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-binary-math" title="Direct link to heading">#</a></h4><p>This is the general worker for binary math operations, the most common operations like &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27; and so forth.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// For all math operations, we combine the types and yield the type that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// holds both using the helper.  If any text, that&#x27;s an error.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_binary_math(ast_node *ast, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type_left, core_type_right, combined_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_binary_prep(ast, &amp;core_type_left, &amp;core_type_right, &amp;combined_flags)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_object(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_blob_types(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (error_any_text_types(ast, core_type_left, core_type_right, op)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t core_type = sem_combine_types(core_type_left, core_type_right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kind = sem_combine_kinds(ast-&gt;right, ast-&gt;left-&gt;sem-&gt;kind);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(ast-&gt;right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(core_type | combined_flags);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;kind = kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_binary_prep</code> checks for errors on the left or right</li><li><code>error_any_object</code> reports an error if the left or right is of type object</li><li><code>error_any_blob_types</code> reports an error if the left or right is of type blob</li><li><code>error_any_text_types</code> reports an error if the left or right is of type text</li><li><code>sem_combine_type</code> computes the combined type, the smallest numeric type that holds both left and right<ul><li>note the operands are now known to be numeric</li><li>the three type error checkers give nice right errors about the left or right operand</li></ul></li><li><code>sem_combine_kinds</code> tries to create a single type <code>kind</code> for both operands<ul><li>if their <code>kind</code> is incompatible, records an error on the right</li></ul></li><li><code>new_sem</code> creates a <code>sem_node</code> with the combined type, flags, and then the <code>kind</code> is set.</li></ul><p>At this point it might help to look a few more of the base validators, they are very unremarkable.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator-error_any_object"></a>Example Validator: error_any_object<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator-error_any_object" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If either of the types is an object then produce an error on the ast.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t error_any_object(ast_node *ast, sem_t core_type_left, sem_t core_type_right, CSTR op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type_left)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0002: left operand cannot be an object in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_object(core_type_right)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;right, &quot;CQL0003: right operand cannot be an object in&quot;, op);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>is_object</code> checks a <code>sem_type</code> against <code>SEM_TYPE_OBJECT</code></li><li>if left or right is an object an appropraite error is generated</li><li>there is no strong convention about returning <code>true</code> if ok or <code>true</code> if error, it&#x27;s pretty ad hoc<ul><li>this doesn&#x27;t seem to cause a lot of problems</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator-sem_combine_kinds"></a>Example Validator: sem_combine_kinds<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator-sem_combine_kinds" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we check that type&lt;Foo&gt; only combines with type&lt;Foo&gt; or type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is a current object type, then the next item must match</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If there is no such type, then an object type that arrives becomes the required type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if they ever don&#x27;t match record an error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CSTR sem_combine_kinds_general(ast_node *ast, CSTR kleft, CSTR kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (kleft) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (strcmp(kleft, kright)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        CSTR errmsg = dup_printf(&quot;CQL0070: expressions of different kinds can&#x27;t be mixed: &#x27;%s&#x27; vs. &#x27;%s&#x27;&quot;, kright, kleft);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        report_error(ast, errmsg, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return kright;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return kleft;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// helper to crack the ast nodes first and then call the normal comparisons</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static CSTR sem_combine_kinds(ast_node *ast, CSTR kright) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR kleft = ast-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_combine_kinds_general(ast, kleft, kright);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_combine_kinds</code> uses the worker <code>sem_combine_kinds_general</code> after extracting the <code>kind</code> from the left node<ul><li>usually you already have one <code>kind</code> and you want to know if another <code>kind</code> is compatible hence this helper</li></ul></li><li><code>sem_combine_kinds_general</code> applies the general rules<ul><li>NULL + NULL =&gt; NULL</li><li>NULL + x  =&gt; x</li><li>x + NULL =&gt; x</li><li>x + x =&gt; x</li><li>x + y =&gt; error if x != y</li></ul></li><li>this is one of the rare functions that creates a dynamic error message</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--is_numeric_compat"></a>Example Validator : is_numeric_compat<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--is_numeric_compat" title="Direct link to heading">#</a></h4><p>This helper is frequently called several times in the course of other semantic checks.
This one produces no errors, that&#x27;s up to the caller. Often there is a numeric path
and a non-numeric path so this helper can&#x27;t create the errors.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport bool_t is_numeric_compat(sem_t sem_type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_type = core_type_of(sem_type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sem_type &gt;= SEM_TYPE_NULL &amp;&amp; sem_type &lt;= SEM_TYPE_REAL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It operates by checking the core type for the numeric range.  Note that <code>NULL</code> is compatible with numerics
because expressions like <code>NULL + 2</code> have meaning in SQL.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--sem_combine_types"></a>Example Validator : sem_combine_types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--sem_combine_types" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The second workhorse of semantic analysis, given two types that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// are previously known to be compatible, it returns the smallest type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// that holds both.  If either is nullable the result is nullable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note: in the few cases where that isn&#x27;t true the normal algorithm for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// nullablity result must be overrided (see coalesce for instance).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static sem_t sem_combine_types(sem_t sem_type_1, sem_t sem_type_2) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>This beast is rather lengthy but unremarkable. It follows these rules:</p><ul><li>text is only compatible with text</li><li>object is only compatible with object</li><li>blob is only compatible with blob</li><li>numerics are only compatible with any other numerics<ul><li>NULL promotes the other operand, whatever it is</li><li>bool promotes to integer</li><li>integer promotes to long integer</li><li>long integer promotes to real</li><li>the combined type is the smallest numeric type according to the promotion rules</li></ul></li></ul><p>Some examples might be helpful:</p><ul><li>1 + 2L  -&gt;  long</li><li>false + 3.1 -&gt; real</li><li>2L + 3.1 -&gt; real</li><li>true + 2 -&gt; integer</li><li>&#x27;x&#x27; + 1 -&gt; not compatible</li></ul><p>Note that <code>sem_combine_types</code> assumes the types have already been checked for compatiblitiy and will use <code>Contract</code> to enforce
this.  You should be using other helpers like <code>is_numeric_compat</code> and friends to ensure the types agree before computing
the combined type.  A list of values that must be compatible with each other (e.g. in <code>needle IN (haystack)</code>) can be
checked using <code>sem_verify_compat</code> repeatedly.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-validator--sem_verify_assignment"></a>Example Validator : sem_verify_assignment<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-validator--sem_verify_assignment" title="Direct link to heading">#</a></h4><p>The <code>sem_verify_assignment</code> function is use any time there is something like a logical <code>assignment</code> going on.  There are
two important cases:</p><ul><li><code>SET x := y</code> : an actual assignment</li><li><code>call foo(x)</code> : the expression <code>x</code> must be &quot;assignable&quot; to the formal variable for the argument of <code>foo</code></li></ul><p>This is a lot like normal binary operator compatibility with one extra rule.  The expression must not be a bigger type than the target.
i.e. you cannot assign a <code>long</code> to an <code>integer</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This verifies that the types are compatible and that it&#x27;s ok to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// the expression to the variable.  In practice that means:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable type core type and kind must be compatible with the expression core type and kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable must be nullable if the expression is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable must be sensitive if the assignment is sensitive</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the variable type must be bigger than the expression type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here ast is used only to give a place to put any errors.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_verify_assignment(ast_node *ast, sem_t sem_type_needed, sem_t sem_type_found, CSTR var_name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_compat(ast, sem_type_needed, sem_type_found, var_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_safeassign(ast, sem_type_needed, sem_type_found, var_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type_found) &amp;&amp; is_not_nullable(sem_type_needed)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0013: cannot assign/copy possibly null expression to not null target&quot;, var_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (sensitive_flag(sem_type_found) &amp;&amp; !sensitive_flag(sem_type_needed)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0014: cannot assign/copy sensitive expression to non-sensitive target&quot;, var_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>sem_verify_compat</code> checks for standard type compatibility between the left and the right</li><li><code>sem_verify_safeassign</code> checks that if the types are different the right operand is the smaller</li><li>nullability checks ensure you aren&#x27;t trying to assign a nullable value to a not null variable</li><li>sensitivity checks ensure you aren&#x27;t trying to assign a sensitive value to a not sensitive variable</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="simple-statement-validation"></a>Simple Statement Validation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#simple-statement-validation" title="Direct link to heading">#</a></h3><p>With the expression building blocks, most of the usual kind of language statements become quite simple to check
for correctness.  It&#x27;s probably easiest to illustrate this with an example, let&#x27;s look at validation for
the <code>WHILE</code> statement.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// While semantic analysis is super simple.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the condition must be numeric</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the statement list must be error-free</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * loop_depth is increased allowing the use of interior leave/continue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_numeric_expr(expr, ast, &quot;WHILE&quot;, SEM_EXPR_CONTEXT_NONE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_error(expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (stmt_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loop_depth++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loop_depth--;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_error(stmt_list)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>first we pull out the tree parts we need using <code>EXTRACT</code> macros</li><li>the loop expression verified to be numeric</li><li>then the statement list is recursively validated</li></ul><p>Note: the while expression is one of the loop constructs which means <code>LEAVE</code> and <code>CONTINUE</code> are legal inside it, the <code>loop_depth</code> global tracks the fact that we are in a loop so that <code>LEAVE</code> and <code>CONTINUE</code> can report errors if we are not.</p><p>It&#x27;s not hard to imagine that <code>sem_stmt_list</code> will basically walk the AST, pulling out statements and dispatching them using the <code>STMT_INIT</code> tables previously discussed.  Hence you could land right back in <code>sem_while_stmt</code> for a nested <code>WHILE</code>.  It&#x27;s turtles all the way down.</p><p>If <code>SEM_EXPR_CONTEXT_NONE</code> is a mystery, don&#x27;t worry it&#x27;s covered in the next section.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-contexts"></a>Expression Contexts<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-contexts" title="Direct link to heading">#</a></h3><p>It turns out that in the SQL language some expression types are only valid in some parts of a SQL statement (e.g. aggregate functions can&#x27;t appear in a <code>LIMIT</code> clause) and so there is always a context for any numeric expression.  When a new root expression is being evaluated, it sets the xpression context according to the caller.</p><p>The expression contexts are as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_NONE           0x0001</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WHERE          0x0004</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_ON             0x0008</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_HAVING         0x0010</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_LIMIT          0x0080</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_OFFSET         0x0100</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_TABLE_FUNC     0x0200</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WINDOW         0x0400</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000</span></div></div></div></div></div><p>The idea here is simple, you set the context bit that correponds to the current context such as <code>SEM_EXPR_CONTEXT_WHERE</code> if the expression is in
the <code>WHERE</code> clause.  The validators check this context, in particular anything that is only available in some contexts has a bit-mask of
the context bits where it can be used.  It checks the possibilities against the current context with one bitwise &quot;and&quot; operation. A zero result
indicates that the operation is not valid in the current context.</p><p>This bitwise &quot;and&quot; is performed by one of these two helper macros which makes the usage a little clearer</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context &amp; (x)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context &amp; (x)))</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-context-example--concat"></a>Expression Context Example : Concat<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-context-example--concat" title="Direct link to heading">#</a></h4><p>The concatenation operator <code>||</code> is challenging to successfully emulate because it does many different kinds of
numeric conversions automatically.  Rather than perenially getting this wrong, we simply do not support
this operator in a context where SQLite isn&#x27;t going to be doing the concatenation.  So typically you
use &quot;printf&quot; instead to get your formatting done outside of a SQL state.  The check for this is very simple
and it happens of course in <code>sem_concat</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0241: CONCAT may only appear in the context of a SQL statement&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expression-context-example--in"></a>Expression Context Example : IN<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expression-context-example--in" title="Direct link to heading">#</a></h4><p>A slightly more complex example happens processing the <code>IN</code> operator.  This operator has two forms,
the form with an expression list, which can be used anywhere, and the form with a select statement.
The latter form can only appear in some sections of SQL and not at all in loose expressions.  For
instance, that form may not appear in the <code>LIMIT</code> or <code>OFFSET</code> sections of a SQLite statement.</p><p>We use this construct to get all the bits we like.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    uint32_t valid = SEM_EXPR_CONTEXT_SELECT_LIST</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_WHERE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_ON</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_HAVING</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    |SEM_EXPR_CONTEXT_TABLE_FUNC;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (CURRENT_EXPR_CONTEXT_IS_NOT(valid)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      report_error( ast, &quot;CQL0078: [not] in (select ...) is only allowed inside &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         &quot;of select lists, where, on, and having clauses&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div></div></div><p>If the reader is interested in a simple learning exercise, run down the purpose of <code>SEM_EXPR_CONTEXT_TABLE_FUNC</code>, it&#x27;s simple
but important and it only has one use case so it&#x27;s easy to find.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="name-resolution"></a>Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#name-resolution" title="Direct link to heading">#</a></h3><p>We&#x27;ve gotten pretty far without talking about the elephant in the room: name resolution.</p><p>Like SQL, many statements in CQL have names in positions where the type of the name is completely unambiguous.  For instance
nobody could be confused what sort of symbol <code>Foo</code> is in <code>DROP INDEX Foo;</code></p><p>These are the easiest name resolutions, and there are a lot in this form.  Let&#x27;s do an example</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="example-index-name-resolution"></a>Example: Index Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-index-name-resolution" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This is the basic checking for the drop index statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * the index must exist (have been declared) in some version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// * it could be deleted now, that&#x27;s ok, but the name has to be valid</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_drop_index_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_drop_index_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *index_ast = find_usable_index(name, name_ast,  &quot;CQL0112: index in drop statement was not declared&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!index_ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Well, this is interesting.  But what&#x27;s going on with <code>find_usable_index</code> what is usable?  Why aren&#x27;t we just looking up the index
name in some name table and that&#x27;s it.  Let&#x27;s have a look at the details:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// returns the node only if it exists and is not restricted by the schema region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static ast_node *find_usable_index(CSTR name, ast_node *err_target, CSTR msg) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *index_ast = find_index(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!index_ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(err_target, msg, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_validate_object_ast_in_current_region(name, index_ast, err_target, msg)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return index_ast;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We haven&#x27;t discussed schema regions yet but what you need to know about them for now is this:  any piece of schema can be
in a region and these can be nested.  A region may depend on other regions.  If this is done then the region may only
use schema parts that are in its dependencies (transitively).  The point of this is that you might have a rather large
schema and you probably don&#x27;t want any peice of code to use any piece of schema.  You can use regions to ensure that
the code for feature &quot;X&quot; doesn&#x27;t try to use schema designed exclusively for feature &quot;Y&quot;.</p><p>So now <code>usable</code> simply means, we can find the name in the symbol table for indices that&#x27;s <code>find_index</code> and it is
accessible by the current region.</p><p>If we had used an example requiring a table or a column the same considerations would apply however additionally
tables can be deprecated with <code>@delete</code> so we might need additional checks to make sure we&#x27;re talking about
a table, not a table&#x27;s tombstone.</p><p>In short, these cases just require looking up the entity and verifying that it&#x27;s accessible in the current context.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="flexible-name-resolution"></a>Flexible Name Resolution<a aria-hidden="true" tabindex="-1" class="hash-link" href="#flexible-name-resolution" title="Direct link to heading">#</a></h4><p>The &quot;hard case&quot; for name resolution is where the name is occuring in an expression.  Such a name might mean a lot
of things.  It could be a global variable, a local variable, an argument, a table column, a field in a cursor, and
others.  The general name resolution goes through several phases looking for the name.  Each phase can either report
an affirmative success or error (in which case the search stops), or it may simply report that the name was not found
but the search should continue.</p><p>We can demystify this a bit by looking at the two most common ways to get this done.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Resolves a (potentially qualified) identifier, writing semantic information</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// into `ast` if successful, or reporting and recording an error for `ast` if</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// not.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_resolve_id(ast_node *ast, CSTR name, CSTR scope) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_id(ast) || is_ast_dot(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We have no use for `type` and simply throw it away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *type = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_resolve_id_with_type(ast, name, scope, &amp;type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The name resolver works on either a vanilla name (e.g. <code>x</code>) or a scoped name (e.g. <code>T1.x</code>).  The name and scope are provided.
The <code>ast</code> parameter is used only as a place to report errors, there is no further cracking of the ast needed to resolve
the name.  As you can see <code>sem_resolve_id</code> just calls the more general function <code>sem_resolve_id_with_type</code> and is used
in the most common case where you don&#x27;t need the sematic type info for the identifier.</p><p>Let&#x27;s move on to the &quot;real&quot; resolver.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function is responsible for resolving both unqualified identifiers (ids)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and qualified identifiers (dots). It performs the following two roles:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// - If an optional `ast` is provided, it works the same way most semantic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   analysis functions work: semantic information will be written into into the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   ast, errors will be reported to the user, and errors will be recorded in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   the AST.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// - `*typr_ptr` will be set to mutable type (`sem_t *`) in the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   environment if the identifier successfully resolves to a type. (There are,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   unfortunately, a few exceptions in which a type will be successfully</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   resolved and yet `*typr_ptr` will not be set. These include when a cursor</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   in an expression position, when the expression is `rowid` (or similar), and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   when the id resolves to an enum case. The reason no mutable type is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   returned in these cases is that a new type is allocated as part of semantic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   analysis, and there exists no single, stable type in the environment to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   which a pointer could be returned. This is a limitation of this function,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//   albeit one that&#x27;s currently not problematic.)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  Resolution is attempted in the order that the `sem_try_resolve_*` functions</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  appear in the `resolver` array. Each takes the same arguments: An (optional)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  identifier provided to one of these resolvers is resolved successfully, *or*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  if the correct resolver was found but there was an error in the program,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  `SEM_RESOLVE_STOP` is returned and resolution is complete, succesful or not.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  If a resolver is tried and it determines that it is not the correct resolver</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned and the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  next resolver is tried.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This function should not be called directly. If one is interested in</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// performing semantic analysis, call `sem_resolve_id` (or, if within an</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expression, `sem_resolve_id_expr`). Alternatively, if one wants to get a</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// mutable type from the environment, call `find_mutable_type`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_resolve_id_with_type(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(type_ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *type_ptr = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_resolve (*resolver[])(ast_node *ast, CSTR, CSTR, sem_t **) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_arguments,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_column,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_rowid,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_cursor_as_expression,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_variable,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_enum,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_cursor_field,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sem_try_resolve_arg_bundle,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (uint32_t i = 0; i &lt; sizeof(resolver) / sizeof(void *); i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (resolver[i](ast, name, scope, type_ptr) == SEM_RESOLVE_STOP) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  report_resolve_error(ast, &quot;CQL0069: name not found&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_resolve_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>A lot is well described in the comments, but already we can see the structure.  There are &quot;mini-resolvers&quot;
which are attempted in order</p><ul><li><code>sem_try_resolve_arguments</code> : an argument in the argument list</li><li><code>sem_try_resolve_column</code> : a column name (possibly scoped)</li><li><code>sem_try_resolve_rowid</code> : the virtual rowid column (possibly scoped)</li><li><code>sem_try_resolve_cursor_as_expression</code> : use of a cursor as a boolean, the bool is true if the cursor has data</li><li><code>sem_try_resolve_variable</code> : local or global variables</li><li><code>sem_try_resolve_enum</code> : the constant value of an enum (must be scoped)</li><li><code>sem_try_resolve_cursor_field</code> : a field in a cursor (must be scoped)</li><li><code>sem_try_resolve_arg_bundle</code> : a field in an argument bundle (must be scoped)</li></ul><p>These all use this enum to communicate progress:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// indicate that the correct resolver was found. Continuing implies that no</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// failure has (yet) occurred, but stopping implies neither success nor failure.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef enum {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SEM_RESOLVE_CONTINUE = 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SEM_RESOLVE_STOP = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_resolve;</span></div></div></div></div></div><p>Each of these mini-resolvers will have a series of rules, for example <code>sem_try_resolve_cursor_field</code> is going to have to do
something like this:</p><ul><li>if there is no scope it can&#x27;t be a cursor field, return <code>CONTINUE</code></li><li>if the scope is not the name of a cursor, return <code>CONTINUE</code></li><li>if the name is a field in the cursor, return <code>STOP</code> with success</li><li>else, report that the name is not a valid member of the cursor, and return <code>STOP</code> with an error</li></ul><p>All the mini-resolvers are similarly structured:</p><ul><li>if it&#x27;s not my case, return <code>CONTINUE</code></li><li>if it is my case return <code>STOP</code> with an error as appropriate</li></ul><p>Some of the resolvers have quite a few steps but any one resolver is only about a screenful of code
and it does one job.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="structure-types-and-the-notion-of-shapes"></a>Structure types and the notion of Shapes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#structure-types-and-the-notion-of-shapes" title="Direct link to heading">#</a></h3><p>Earlier we discussed <code>SEM_TYPE_STRUCT</code> briefly and recall the basic notion of the <code>structure</code> type</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for tables and views and the result of a select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_struct {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR struct_name;               // struct name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of fields</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // field names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *kinds;                    // the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t *semtypes;                // typecode for each field</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_struct;</span></div></div></div></div></div><p>The structure is nothing more than an array of names, types and kinds with a count.  But it creates the notion of
what&#x27;s usually called a &quot;shape&quot; in the codebase. Shapes can be used in a variety of ways as is described in
<a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the CQL Guide. But before we get
into shapes, let&#x27;s look at an example of how a structure type is created.</p><p>The code that follows is the back end of <code>sem_create_table_stmt</code>.  At this point the bulk of the analysis is
done and the columns all have their types.  We&#x27;re about to build the struct type for the table.  Let&#x27;s see how
that goes.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // now create a struct type with the correct number of columns</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the types have already been computed so all we have to do is</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // check for duplicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_struct *sptr = new_sem_struct(name, cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab *columns = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t col = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (ast_node *item = col_key_list; item; item = item-&gt;right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Contract(is_ast_col_key_list(item));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(def, item-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_ast_col_def(def)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(def-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(col &lt;= cols);  // it&#x27;s possible that the rest are deleted and we&#x27;re at the end.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // columns must be unique, including deleted columns</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (!symtab_add(columns, def-&gt;sem-&gt;name, NULL)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_NOTNULL(col_def_type_attrs, def-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        EXTRACT_ANY_NOTNULL(col_def_ast, col_def_name_type-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        report_error(col_def_ast, &quot;CQL0142: duplicate column name&quot;, def-&gt;sem-&gt;name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        symtab_delete(columns);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        goto cleanup;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (is_deleted(def-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        continue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Invariant(col &lt; cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;names[col] = def-&gt;sem-&gt;name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;semtypes[col] = def-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sptr-&gt;kinds[col] = def-&gt;sem-&gt;kind;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      col++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_delete(columns);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(col == cols);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_STRUCT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;sptr = sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;jptr = sem_join_from_sem_struct(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;region = current_region;</span></div></div></div></div></div><ul><li><code>new_sem_struct</code> makes a struct to hold the result, we already have the count of columns and the table name</li><li><code>symtab_new</code> is going to gives us a scratch symbol table so we can check for duplicate column names</li><li>we walk all the items in the table and use <code>is_ast_col_def(def)</code> to find the column definitions</li><li><code>Invariant(def-&gt;sem-&gt;name)</code> claims that we must have already computed the semantic info for the column and it has its name populated<ul><li>this was done earlier</li></ul></li><li><code>symtab_add(columns, def-&gt;sem-&gt;name, NULL)</code> adds a nil entry under the column name, if this fails we have a duplicate column<ul><li>in which case we report errors and stop</li></ul></li><li><code>is_deleted</code> tells us if the column was marked with <code>@delete</code> in which case it no longer counts as part of the table</li><li>if all this is good we set the <code>names</code>, <code>kinds</code>, and <code>semtypes</code> from the column definition&#x27;s semnatic info</li><li><code>symtab_delete</code> cleans up the temporary symbol table</li><li>and finally we create a <code>sem_node</code> of type <code>SEM_TYPE_STRUCT</code> and fill it in</li><li><code>sem_join_from_sem_struct</code> will be discussed shortly, but it creates a jptr with one table in it</li></ul><p>Structure types are often rooted in the shape of a table, but other things can create a structure type.  For instance, the
columns of a view, or any select statement are also described by a structure type and are therefore valid &quot;shapes&quot;.  The
return type of a procedure usually comes from a <code>SELECT</code> statement so the procedure too can be the source of a shape.
The arguments of a procedure form a shape.  The fields of a cursor form a shape.  You can even have a named subset
of the arguments of a procedure and use them like a shape. All of these things are described by structure types.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="shapes-and-the-like-construct"></a>Shapes and the LIKE construct<a aria-hidden="true" tabindex="-1" class="hash-link" href="#shapes-and-the-like-construct" title="Direct link to heading">#</a></h4><p>There are many cases where you want to be able to capture or re-use something with a known shape and you don&#x27;t
want to have to fully re-declare the thing.  CQL uses the <code>LIKE</code> construct to do these sorts of things.  This is
more fully explained in <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms" target="_blank" rel="noopener noreferrer">Chapter 5</a> of the Guide,
but for now let&#x27;s look at two different cases that are of interest.</p><p>First, a cursor:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE C CURSOR LIKE Foo;  -- Foo something with a shape</span></div></div></div></div></div><p>So, in the above, Foo could be a table, a view, a procedure with a result, another cursor, and so forth.</p><p>How might we do this?  This is the business of <code>sem_declare_cursor_like_name</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we&#x27;re going to make a new value cursor using the indicated name for the shape.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The name has to be &quot;likeable&quot; meaning it refers to some named thing with a shape</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// such as a table, a view, another cursor, or a procedure that returns a result set.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// These are the so called &quot;value cursors&quot; in that they have no underlying statement</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// that they move through.  You can just load them up with a row and pass them around.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_declare_cursor_like_name(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_declare_cursor_like_name(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(new_cursor_ast, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(new_cursor_name, new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(like_ast, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(name_ast, like_ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(like_name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // no duplicates allowed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!sem_verify_legal_variable_name(ast, new_cursor_name)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be a valid shape</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *found_shape = sem_find_likeable_ast(like_ast, LIKEABLE_FOR_VALUES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!found_shape) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // good to go, make our cursor, with storage.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name_ast-&gt;sem = like_ast-&gt;sem = found_shape-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem-&gt;sptr = found_shape-&gt;sem-&gt;sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  new_cursor_ast-&gt;sem-&gt;name = new_cursor_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_cursor_ast-&gt;sem;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  symtab_add(current_variables, new_cursor_name, new_cursor_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><code>EXTRACT</code> the pieces we need from the AST</li><li><code>sem_verify_legal_variable_name</code> makes sure the cursor name is unique and doesn&#x27;t hide a table name</li><li><code>sem_find_likeable_ast</code> searches for something with a suitable name that has a shape</li><li>re-use the semantic type of what we found in the name node</li><li>make a new <code>sem_node</code> for the cursor variable</li><li>use the <code>sptr</code> from the discovered shape for the type</li></ul><p>Note: <code>name_ast-&gt;sem</code> isn&#x27;t actually interesting but it is helpful for debugging and if the AST is printed it
shows the original unmodified semantic type on those nodes.</p><p>Briefly <code>sem_find_likeable_ast</code> does these steps:</p><ul><li>if the right of the <code>LIKE</code> refers to procedure arguments (e.g. C LIKE Foo ARGUMENTS), get the args of the named procedure and use them as a shape</li><li>if the right is a local or global, and its a cursor, use the shape of that cursor for the new cursor</li><li>if the right is the name of an argument bundle, use the shape of the bundle<ul><li>e.g. in <code>CREATE PROC Foo(p1 like Person, p2 like Person)</code> <code>p1</code> and <code>p2</code> are the names of argument bundles shaped like <code>Person</code></li></ul></li><li>if the right is the name of a table or view, use that shape</li><li>if the right is the name of a procedure with a structure result, use that shape</li><li>if it&#x27;s none of these, produce an error</li></ul><p>This is the primary source of shape reuse.  Let&#x27;s look at how we might use that.  Suppose we want to write a procedure
that inserts a row into the table <code>Foo</code>.  We could certainly list the columns of <code>Foo</code> as arguments like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC InsertIntoFoo(id integer, t text, r real, b blob)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSERT INTO Foo(id, t, r, b) VALUES(id, t, r, b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>That is going to get a lot less exciting when there are lots of columns and it will be increasingly a maintenance headach.</p><p>Compare with</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC InsertIntoFoo(row LIKE Foo)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSERT INTO Foo FROM row;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>These two things compile into the same code.  The semantic analyzer expands the <code>(row LIKE Foo)</code> into
<code>(row_id integer, row_t text, row_r real, row_b blob)</code> and then replaces <code>FROM row</code> with
<code>(row_id, row_t, row_r, row_b)</code>.  In both case it simply looked up the shape using <code>sem_find_likeable_ast</code>
and then altered the AST to the canonical pattern.  This kind of &quot;shape sugar&quot; is all over CQL and
greatly increases maintainability while eliminating common errors.  The most common operation is simply
to expland a &quot;shape&quot; into a list of arguments or columns (maybe with or without type).  SQLite doesn&#x27;t
know any of this shape magic so by the time SQLite sees the code it has to look &quot;normal&quot; -- the shapes
are all resolved.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="join-types"></a>Join Types<a aria-hidden="true" tabindex="-1" class="hash-link" href="#join-types" title="Direct link to heading">#</a></h3><p>The last of the type building data structure is the join type.  Recall that we have this shape:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// for the data type of (parts of) the FROM clause</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// sometimes I refer to as a &quot;joinscope&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct sem_join {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t count;                 // count of table/views in the join</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR *names;                    // names of the table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  struct sem_struct **tables;     // struct type of each table/view</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} sem_join;</span></div></div></div></div></div><p>This is an array of named structure types, which is exactly what you get when you do something like this</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select * from T1 INNER JOIN T2;</span></div></div></div></div></div><p>The result has all of the columns of T1 and all of the columns of T2.  They can be referred to with scoped
names like <code>T1.x</code> which means &quot;find the <code>sptr</code> corresponding to the name <code>T1</code> then within that structure
find the column named <code>x</code>&quot;.  In general, when we join, we take a <code>jptr</code> on the left and concatenate it
with a <code>jptr</code> on the right.  And for all this to work we have to start somewhere, usually single tables.
As we saw when we make a table we use <code>sem_join_from_sem_struct</code> to make its initial <code>jptr</code>.  Let&#x27;s
have a look at that now.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create a base join type from a single struct.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static sem_join *sem_join_from_sem_struct(sem_struct *sptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_join *jptr = new_sem_join(1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  jptr-&gt;names[0] = sptr-&gt;struct_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  jptr-&gt;tables[0] = new_sem_struct_strip_table_flags(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return jptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>It doesn&#x27;t get much simpler than the above:</p><ul><li><code>new_sem_join</code> gives us an empty <code>sem_join</code> with room for 1 table</li><li>we use the struct name for the name and the table&#x27;s <code>sptr</code> for the shape</li><li><code>new_sem_struct_strip_table_flags</code> copies the table&#x27;s <code>sptr</code> keeping only the essential flags<ul><li><code>SEM_TYPE_HIDDEN_COL</code></li><li><code>SEM_FLAG_NOTNULL</code></li><li><code>SEM_FLAG_SENSITIVE</code></li></ul></li></ul><p>The other flags (e.g. <code>SEM_TYPE_PK</code>) have no value in doing type checking and were only needed to help validate the table itself.  They
would be harmless but they would also contaminate all of the debug output so they are stripped.  As a result the type of columns
as they appear in say <code>SELECT</code> statements is simpler than how they appear in a <code>CREATE TABLE</code> statement.</p><p>When we need to create a new join type we simply (*) make a new join type that is the concatenation of the left and right parts of the join.</p><ul><li>some join types change the nullability of columns like <code>LEFT JOIN</code> so we have to handle that too</li><li>the names of the table in the new joinscope have to be unique so there is also error checking to do</li><li>but basically it&#x27;s just a concat...</li></ul><p>Importantly, we call the thing a &quot;joinscope&quot; because it creates a namespace.  When we are evaluating names inside of the <code>FROM</code> clause or
even later in say a <code>WHERE</code> clause, the joinscope that we have created so far controls the same of <code>table.column</code> combinations you can
use in expressions.  This changes again when there is a subquery, so the joinscopes can be pushed and popped as needed.</p><p>By way of example, you&#x27;ll see these two patterns in the code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PUSH_JOIN(from_scope, select_from_etc-&gt;sem-&gt;jptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error = sem_select_orderby(select_orderby);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  POP_JOIN();</span></div></div></div></div></div><ul><li>use the <code>jptr</code> from the <code>FROM</code> clause to put things back in scope for the <code>ORDER BY</code> clause</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PUSH_JOIN_BLOCK();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_numeric_expr(ast-&gt;left, ast, &quot;LIMIT&quot;, SEM_EXPR_CONTEXT_LIMIT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  POP_JOIN();</span></div></div></div></div></div><ul><li><code>PUSH_JOIN_BLOCK</code> causes the name search to stop, nothing deeper in the stack is searched</li><li>in this case we do not allow <code>LIMIT</code> expressions to see any joinscopes, they may not use any columns.<ul><li>even if the <code>LIMIT</code> clause is appearing in a subquery it can&#x27;t refer to columns in the parent query.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="schema-regions"></a>Schema Regions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#schema-regions" title="Direct link to heading">#</a></h3><p>We touched briefly on schema regions earlier in this section.  The purpose and language for regions
is described more fully in <a href="https://cgsql.dev/cql-guide/ch10#schema-regions" target="_blank" rel="noopener noreferrer">Chapter 10</a> of the Guide.
In this section we&#x27;ll deal with how they are implemented and what you should expect to see in the code.</p><p>When a region declaration is found this method is used.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// A schema region is an partitioning of the schema such that it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// only uses objects in the same partition or one of its declared</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// dependencies.  One schema region may be upgraded independently</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// from any others (assuming they happen such that dependents are done first).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we validate:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the region name is unique</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  * the dependencies (if any) are unique and exist</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_declare_schema_region_stmt(ast_node *ast)  { ... }</span></div></div></div></div></div><p>The general rules are described in the comment, but effectively it accumulates the list of
this regions dependencies.  Sometimes these are called the antecedent regions.  Since
a region can only depend on other regions that have already been declared, it&#x27;s not possible
to make any cycles.  Regions are declared before you put anything into them.</p><p>Pieces of schema or procedures (or anything really) can go into a region by putting it
in a begin/end pair for the name region.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token variable" style="color:rgb(191, 199, 213)">@begin_schema_region</span><span class="token plain"> your_region</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- your stuff</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token variable" style="color:rgb(191, 199, 213)">@end_schema_region</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>Now whatever happens to be in &quot;your stuff&quot; is:</p><ul><li>limited to seeing only the things that <code>your_region</code> is allowed to see and</li><li>contributes its contents to <code>your_region</code> thereby limiting how others will be able to use &quot;your stuff&quot;</li></ul><p>To see how this happens, let&#x27;s have a look at <code>sem_begin_schema_region_stmt</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Entering a schema region makes all the objects that follow part of that</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// region.  It also means that all the contained objects must refer to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// only pieces of schema that are in the same region or a dependent region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Here we validate that region we are entering is in fact a valid region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and that there isn&#x27;t already a schema region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void sem_begin_schema_region_stmt(ast_node * ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_begin_schema_region_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(name, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // @BEGIN_SCHEMA_REGION name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!verify_schema_region_out_of_proc(ast)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (current_region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast, &quot;CQL0246: schema regions do not nest; end the current region before starting a new one&quot;, NULL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *region = find_region(name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    report_error(ast-&gt;left, &quot;CQL0244: unknown schema region&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record_error(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Get the canonical name of the region (case adjusted)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_region(region));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_STRING(region_name, region-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // we already know we are not in a region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(!current_region_image);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  current_region_image = symtab_new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_accumulate_public_region_image(current_region_image, region_name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // this is the one and only text pointer value for this region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  current_region = region_name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  record_ok(ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>We see these basic steps:</p><ul><li><code>EXTRACT</code> the region name</li><li><code>verify_schema_region_out_of_proc</code> makes sure we are out of any procedure (we have to be at the top level)<ul><li>errors if in a procedure</li></ul></li><li><code>current_region</code> is tested to make sure we are not already in a region (no nesting)<ul><li>errors if already in a region</li></ul></li><li><code>find_region</code> is used to find the region AST by name<ul><li>errors if the region name isn&#x27;t valid</li></ul></li><li><code>EXTRACT</code> is used again to get the canoncial name of the region<ul><li>you could say <code>@begin_schema_region YoUr_ReGION;</code> we want the canonical name <code>your_region</code> as it was declared</li></ul></li><li><code>symtab_new</code> creates a new symbol table <code>current_region_image</code></li><li><code>sem_accumulate_public_region_image</code> populates <code>current_region_image</code> by recursively walking this region adding the names of all the regions we find along the way<ul><li>note the regions form a DAG so we might find the same name twice, we can stop if we find a region that is already in the symbol table</li></ul></li><li><code>current_region</code> is set to the now new current region</li></ul><p>Now we&#x27;re all set up.</p><ul><li>We can use <code>current_region</code> to set the region name in the <code>sem_node</code> of anything we encounter</li><li>We can use <code>current_region_image</code> to quickly see if we are allowed to use any given region (if it&#x27;s in the table we can use it)</li></ul><p>Recall that at the end of <code>sem_create_table_stmt</code> we do this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem = new_sem(SEM_TYPE_STRUCT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;sptr = sptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;jptr = sem_join_from_sem_struct(sptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast-&gt;sem-&gt;region = current_region;</span></div></div></div></div></div><p>Which should make a lot more sense now.</p><p>When doing the symmetric check in <code>sem_validate_object_ast_in_current_region</code> we see this pattern:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Validate whether or not an object is usable with a schema region. The object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can only be a table, view, trigger or index.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static bool_t sem_validate_object_ast_in_current_region(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *table_ast,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *err_target,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR msg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We&#x27;re in a non-region therefore no validation needed because non-region stmt</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // can reference schema in any region.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!current_region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (table_ast-&gt;sem &amp;&amp; table_ast-&gt;sem-&gt;region) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // if we have a current region then the image is always computed!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(current_region_image);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!symtab_find(current_region_image, table_ast-&gt;sem-&gt;region)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // The target region is not accessible from this region</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // while in schema region &#x27;%s&#x27;, accessing an object that isn&#x27;t in a region is invalid</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>I&#x27;ve elided some of the code here, but only the part that generates error messages.  The essential logic is:</p><ul><li>if we are not in a region we can access anything</li><li>if we&#x27;re in a region then...<ul><li>the thing we&#x27;re trying to access must also be in a region, and</li><li>that region must be in <code>current_region_image</code></li><li>otherwise, we can&#x27;t access it</li></ul></li></ul><p>This is enough to do all the region validation we need.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="results-of-semantic-analysis"></a>Results of Semantic Analysis<a aria-hidden="true" tabindex="-1" class="hash-link" href="#results-of-semantic-analysis" title="Direct link to heading">#</a></h3><p>Semantic Analysis leaves a lot of global state ready for the remaining stages to harvest.  If the state
is defined in <code>sem.h</code> then it&#x27;s ok to harvest.  We&#x27;ll highlight some of the most important things you
can use.  These are heavily used in the code generators.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_tables_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_functions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_views_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_indices_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_triggers_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_regions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_ad_hoc_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_select_functions_list );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( struct list_item *all_enums_list );</span></div></div></div></div></div><p>These linked lists are authoritiative, they let you easily enumerate all the objects of the specified type.  If you
wanted to do some validation of all indices you could simply walk the all indices list.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_proc(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_region(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_func(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_table_or_view_even_deleted(CSTR name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport ast_node *find_enum(CSTR name);</span></div></div></div></div></div><p>These functions give you access to the core name tables (which are still valid!) so that you can look up procedures, functions,
tables, etc. by name.</p><p>Finally, information about all the schema annotations is invaluable for building schema upgraders.  These
two buffers hold dense arrays of annotation records as shown below.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( bytebuf *schema_annotations );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( bytebuf *recreate_annotations );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct recreate_annotation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR target_name;               // the name of the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR group_name;                // group name or &quot;&quot; if no group (not null, safe to sort)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *target_ast;           // top level target (table, view, or index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *annotation_ast;       // the actual annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t ordinal;                // when sorting we want to use the original order (reversed actually) within a group</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} recreate_annotation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct schema_annotation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t version;                // the version number (always &gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *target_ast;           // top level target (table, view, or index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR target_name;               // the name of the target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t annotation_type;       // one of the codes below for the type of annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *annotation_ast;       // the actual annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t column_ordinal;         // -1 if not a column</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ast_node *column_ast;           // a particular column if column annotation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} schema_annotation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note: schema annotations are processed in the indicated order: the numbers matter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_INVALID 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_FIRST 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_CREATE_TABLE 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_CREATE_COLUMN 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_TRIGGER 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_VIEW 4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_INDEX 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_COLUMN 6</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_DELETE_TABLE 7</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_AD_HOC 8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define SCHEMA_ANNOTATION_LAST 8</span></div></div></div></div></div><p>And of course, each &quot;back end&quot; is provided with the root of the AST so that it can also search
and/or walk the AST in its own manner.  We will see examples of this in later sections.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recap"></a>Recap<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recap" title="Direct link to heading">#</a></h3><p>At present, there are nearly 20000 lines in <code>sem.c</code> and it would no doubt take more than 20000 lines of text
to explain what they all do, and that would be more imprecise than the source code, and probably less
readable.  <code>sem.c</code> includes over 4000 lines of comments, and probably should have more.  While there
is a lot of code there it&#x27;s very readable and I encourage you to do so to get your answers.</p><p>The point of this part of the Internals Guide isn&#x27;t to fully explain all 400+ error checks in about
as many semantic error checking functions, it&#x27;s to showcase the key concepts shared by all of them. Things like:</p><ul><li>errors are reported largely in the AST and percolate up</li><li>expressions and statements have general purpose dispatch logic for continuing a statement walk</li><li>EXTRACT macros are used to keep the tree walk on track and correct in the face of changes</li><li>regions are used for visibility</li><li>versioning contributes to visibility</li><li>nullability and sensitivity are tracked throughout using type bits</li><li>type kind is managed by a simple string in the <code>sem_node</code> payload</li><li>the three main payloads are<ul><li><code>sem_node</code> for basic info, and</li><li><code>sem_struct</code> or <code>sem_join</code> for the non-unitary types</li></ul></li></ul><p>This isn&#x27;t everything but it should leave you well armed to begin your own exploration of <code>sem.c</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="part-3-c-code-generation"></a>Part 3: C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#part-3-c-code-generation" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preface-2"></a>Preface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#preface-2" title="Direct link to heading">#</a></h3><p>Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.
As in the previous sections, the goal here is not to go over every detail of code generation but rather to give
a sense of how codegen happens in general -- the core strategies and implementation choices --
so that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish
this, various key data structures will be explained in detail as well as selected examples of their use.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="c-code-generation"></a>C Code Generation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#c-code-generation" title="Direct link to heading">#</a></h2><p>There are several key pieces of C code that we have to generate to make working CQL procedures using C
functions.  This all happens in <code>cg_c.c</code>.  From a big picture perspective, these are the essential problems:</p><ul><li>we have to compile SQL expressions into C<ul><li>including expressions with variables that are nullable</li><li>including SQL expressions that are highly complex like <code>CASE..WHEN..THEN..END</code> and <code>IN (..)</code></li></ul></li><li>we have to generate control flow for things like <code>IF</code>, <code>WHILE</code> and, <code>SWITCH</code></li><li>we have to make result sets<ul><li>including the code to slurp up all the rows from a SQL statement into an array of values</li><li>we want to do this very economically</li></ul></li><li>we have to be able to create the text for every SQLite statement and bind any variables to it</li><li>we have to check every SQLite API for errors and throw exceptions consistently and deal with them<ul><li>including constructs that allow users to handle exceptions, such as <code>TRY/CATCH</code></li></ul></li><li>we have to track any reference types carefully so that retain/release pairs are done consistently<ul><li>even in the presence of SQLite errors or other exceptions</li></ul></li><li>we have to produce a <code>.h</code> and a <code>.c</code> file for the C compiler<ul><li>contributions to these files could come from various places</li><li>the <code>.c</code> file will itself have various sections and we might need to contribute to them at various points in the compilation</li></ul></li><li>we want to do this all in one pass over the AST</li><li>we get to assume that the program is error free, codegen never runs unless semantic analysis reports zero errors<ul><li>so nothing can be wrong by the time the codegen pass runs, we never detect errors here</li><li>sometimes we add <code>Contract</code> and <code>Invariant</code> statements to <code>cg.c</code> that make our assumptions clear and prevent regressions</li></ul></li></ul><p>There are some very important building blocks used to solve these problems we will start with those, then move to
a discussion of each of the essential kinds of code generation that we have to do to get working programs.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="launching-the-code-generator"></a>Launching the Code Generator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#launching-the-code-generator" title="Direct link to heading">#</a></h3><p>Once semantic analysis is done all of the code generators have the same contract: they
have a main function like <code>cg_c_main</code> for the C code generator.  It gets the root of
the AST and it can use the public interface of the semantic analyzer to get additional
information.  See <a href="https://cgsql.dev/cql-guide/int02" target="_blank" rel="noopener noreferrer">Part 2</a> for those details.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Main entry point for code-gen.  This will set up the buffers for the global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// variables and any loose calls or DML.  Any code that needs to run in the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// global scope will be added to the global_proc.  This is the only codegen</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// error that is possible.  If you need global code and you don&#x27;t have a global</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// proc then you can&#x27;t proceed.  Semantic analysis doÆ’esn&#x27;t want to know that stuff.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Otherwise all we do is set up the most general buffers for the global case and</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// spit out a function with the correct name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void cg_c_main(ast_node *head) { ... }</span></div></div></div></div></div><p>In addition to initializing its scratch storage, the main entry point also sets up a
symbol table for AST dispatch just like the <code>gen_</code> and <code>sem_</code> functions do.  Here
are some samples from that table with the most common options:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(drop_view_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_table_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DDL_STMT_INIT(create_view_stmt);</span></div></div></div></div></div><p>The DDL (Data Definition Lanaguage) statements all get the same handling:  The text of the statement
is generated from the AST. Any variables are bound and then the statement is executed.  The work
is done with <code>cg_bound_sql_statement</code> which will be discussed later.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DDL invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// We don&#x27;t minify the aliases because DDL can have views and the view column names</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// can be referred to in users of the view.  Loose select statements can have</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// no external references to column aliases.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_any_ddl_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>DML (Data Manipulation Language) statements are declared similarly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(begin_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(commit_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(rollback_trans_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(savepoint_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STD_DML_STMT_INIT(delete_stmt);</span></div></div></div></div></div><p>They are handled by <code>cg_std_dml_exec_stmt</code>; the processing is identical to
DDL except <code>CG_MINIFY_ALIASES</code> is specified.  This allows the code generator
to remove unused column aliases in select statements to save space.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Straight up DML invocation.  The ast has the statement, execute it!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_std_dml_exec_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Note that this flag difference only matters for the <code>create view</code> statement
but for symmetry all the DDL is handled with one macro and all the DML
with the second macro.</p><p>Next, the easiest case... there are a bunch of statements that create
no code-gen at all.  These are type defintions that are interesting
only to the semantic analyzer or other control statements.  Some examples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_enum_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NO_OP_STMT_INIT(declare_named_type);</span></div></div></div></div></div><p>Next, the general purpose statement handler.  This creates a mapping
from the <code>if_stmt</code> AST node to <code>cg_if_stmt</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(if_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(switch_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(while_stmt);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STMT_INIT(assign);</span></div></div></div></div></div><p>The next group is the expressions, with precedence and operator specified. There is a lot of code sharing
as you can see from this sample:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(num, cg_expr_num, &quot;num&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(str, cg_expr_str, &quot;STR&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(null, cg_expr_null, &quot;NULL&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(dot, cg_expr_dot, &quot;DOT&quot;, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mul, cg_binary, &quot;*&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(div, cg_binary, &quot;/&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(mod, cg_binary, &quot;%&quot;, C_EXPR_PRI_MUL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(add, cg_binary, &quot;+&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(sub, cg_binary, &quot;-&quot;, C_EXPR_PRI_ADD);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(not, cg_unary, &quot;!&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(tilde, cg_unary, &quot;~&quot;, C_EXPR_PRI_UNARY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXPR_INIT(uminus, cg_unary, &quot;-&quot;, C_EXPR_PRI_UNARY);</span></div></div></div></div></div><p>Most (not all) of the binary operators are handled with one function <code>cg_binary</code> and likewise
most unary operators are handled with <code>cg_unary</code>.</p><p>Note: the precedence constants are the <code>C_EXPR_PRI_*</code> flavor because parentheses will be
generated based on the C rules at this point.  Importantly, the AST still, and always
has the user-specified order of operations encoded in it, there&#x27;s no change there.  The
only thing that changes is where parentheses are needed to get the desired result.  Parens
may need to be added and some that were present in the original text might no longer be needed.</p><p>e.g.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* NOT is weaker than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET x := (NOT 1) + (NOT 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := NOT 1 + 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_bool x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* ! is stronger than + */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! 1 + ! 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = ! (1 + 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Finally, many built-in functions need special codegen.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(coalesce);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  FUNC_INIT(printf);</span></div></div></div></div></div><p><code>FUNC_INIT(coalesce)</code> creates a mapping between the function name <code>coalesce</code> and the generator <code>cg_func_coalesce</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="character-buffers-and-byte-buffers"></a>Character Buffers and Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#character-buffers-and-byte-buffers" title="Direct link to heading">#</a></h3><p>The first kind of text output that CQL could produce was the AST echoing.  This was original done directly with <code>fprintf</code> but
that was not flexible enough as the output had to be captured to be emitted into other places like comments or the text of
SQL statements to go to SQLite.  This forces that pass to use character buffers, which we touched on in Part 1.  Code generation
has a more profound dependency on character buffers -- they are literally all over <code>cg_c.c</code> and we need to go over how hey are used.</p><p>The public interace is in <code>charbuf.h</code> and it&#x27;s really quite simple.  You allocate a <code>charbuf</code> and then you can <code>bprintf</code> into it.
Let&#x27;s be a bit more specific:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_INTERNAL_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_GROWTH_SIZE 1024</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct charbuf</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char *ptr;      // pointer to stored data, if any</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t used;  // bytes used in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  uint32_t max;   // max bytes in current buffer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // builtin buffer storage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  char internal[CHARBUF_INTERNAL_SIZE];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} charbuf;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_data_decl( int32_t charbuf_open_count );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bopen(charbuf* b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bclose(charbuf *b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_noexport void bprintf(charbuf *b, const char *format, ...);</span></div></div></div></div></div><p>The typical pattern goes something like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf foo;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;foo);</span></div></div></div></div></div><p>Note that <code>charbuf</code> includes <code>CHARBUF_INTERNAL_SIZE</code> of storage that does not
have to be allocated with <code>malloc</code> and it doesn&#x27;t grow very aggressively.
This reflects that fact that most <code>charbuf</code> instances are very small.
Of course a <code>charbuf</code> could go on the heap if it needs to outlive
the function it appears in, but this is exceedingly rare.</p><p>To make sure buffers are consistently closed (and this is a problem because
there are often a lot of them.  They are allocated with these simple helper
macros.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_OPEN(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int32_t __saved_charbuf_count##x = charbuf_open_count; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf x; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bopen(&amp;x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CHARBUF_CLOSE(x) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bclose(&amp;x); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Invariant(__saved_charbuf_count##x == charbuf_open_count)</span></div></div></div></div></div><p>the earlier example would be written more properly:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(&amp;foo, &quot;Hello %s\n&quot;, &quot;World&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // do something with foo.ptr</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_CLOSE(foo);</span></div></div></div></div></div><p>If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure.</p><p>It&#x27;s normal to create several buffers in the course of doing code generation.  In fact some of these buffers
become &quot;globally&quot; visible and get swapped out as needed.  For instance this kind of chaining is normal.
Inside of <code>cg_create_proc_stmt</code> there is these sequence:</p><p>Make new buffers...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_fwd_ref);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_body);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_locals);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(proc_cleanup);</span></div></div></div></div></div><p>Save what we got...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_main = cg_main_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_decls = cg_declarations_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_scratch = cg_scratch_vars_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_cleanup = cg_cleanup_output;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  charbuf *saved_fwd_ref = cg_fwd_ref_output;</span></div></div></div></div></div><p>Switch to the new...</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_fwd_ref_output = &amp;proc_fwd_ref;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_main_output = &amp;proc_body;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_declarations_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_scratch_vars_output = &amp;proc_locals;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_cleanup_output = &amp;proc_cleanup;</span></div></div></div></div></div><p>And of course the code puts the original values back when it&#x27;s done and closes the buffers.</p><p>This means that while processing a procedure the codegen that declares say scratch variables,
which would go to <code>cg_scratch_vars_output</code> is going to target the <code>proc_locals</code> buffer
which will be emitted before the <code>body</code>.  By the time <code>cg_stmt_list</code> is invoked the
<code>cg_main_output</code> variable will be pointing to the procedure body, thus any statements
will go into there rather than being acculated at the global level -- it&#x27;s possible to
have code that is not in a procedure (see <a href="https://cgsql.dev/cql-guide/x1#--global_proc-name" target="_blank" rel="noopener noreferrer"><code>--global_proc</code></a>).</p><p>But in general, it&#x27;s very useful to have different buffers going on at the same time.  New local variables
or scratch variables can be added to their own buffer which goes before the code runs.  New cleanup
steps that are necessary can be added to the cleanup output which will appear at the end.  The final
function combines all of these pieces with maybe some glue.  Everything works like this, <code>IF</code> statements,
expressions, all of it.</p><p>One interesting but unexpected feature of <code>charbuf</code> is that it provides helper methods for indenting
buffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C
code because of course you want (e.g.) the body of an <code>if</code> statement to be indented.  CQL tries to create
well formatted code that is readable by humans as much as possible.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="byte-buffers"></a>Byte Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#byte-buffers" title="Direct link to heading">#</a></h4><p>These are less commonly used but there is a peer to <code>charbuf</code> creatively called <code>bytebuf</code>.  This gives you
a growable binary buffer.  It&#x27;s often used to hold arrays of structures.  Interestingly, <code>cg_c.c</code> doesn&#x27;t
currently consume byte buffers, the presence of <code>bytebuf.c</code> actually came late to the CQL compiler. However
the CQL runtime <code>cqlrt.c</code> (and <code>cqlrt_common.c</code>) provide <code>cql_bytebuf_open</code>, <code>cql_bytebuf_alloc</code> and,
<code>cql_bytebuf_close</code> which are akin to the <code>charbuf</code> methods.  These functions are used in the generated
code to create result sets at runtime.  The <code>bytebuf</code> was so useful that it found its way back from the
runtime into the compiler itself, and is used by other code-generators like the schema upgrader.   The
semantic analyzer also uses it to help with query fragments and to track the various upgrade annotations.</p><p>Both <code>charbuf</code> and <code>bytebuf</code> are simple enough that they don&#x27;t need discussion. It&#x27;s easier to just read
the code and the comments.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="expressions"></a>Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#expressions" title="Direct link to heading">#</a></h3><p>Many of the output needs of CQL stemmed from the base case of creating expressions.  A simple CQL
expression like</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> x :</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>seems innocuous enough, we&#x27;d like this to compile to this code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div></div></div></div></div><p>And indeed, it might.  Here&#x27;s some actual output from the compiler:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>(*) the output above was created by using <code>out/cql --in x --cg x.h x.c --nolines</code> to avoid all the # directives</p><p>Looks easy enough.  And indeed if all expressions were like this, you could do expression compilation pretty simply --
every binary operator would look something like this:</p><ul><li>recurse left</li><li>emit infix operator</li><li>recurse right</li></ul><p>This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have
the whole expression.</p><p>This doesn&#x27;t work at all.  To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result
is telling:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x, y INTEGER;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := x + y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;p&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div></div></div></div></div><p>All that&#x27;s happened in the above is that <code>x</code> and <code>y</code> became nullable variables, that is the <code>NOT NULL</code> was
removed from the declaration.  This makes all the difference in the world, and this is a fairly easy case.
The problem is that nullable value types like cql_nullable_int32 have an integer and a boolean and these
don&#x27;t flow into expressions that use operators like <code>+</code>, <code>-</code>, <code>/</code> and so forth.  This means that even
simple expressions involving nullable types actually expand into several statements.  And, in general,
these statements need a place to put their temporary results to accumulate the answer, so scratch variables
are required to make all this work.</p><p>Here&#x27;s a more realistic example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET result := 5 * x + 3 * y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _PROC_ &quot;combine&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)result, 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 _tmp_n_int_2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_int_2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(*result); // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#undef _PROC_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div></div></div></div></div><ul><li><code>_tmp_n_int_1</code> holds the product of x and 5, it&#x27;s null if <code>x.is_null</code> is true</li><li><code>_tmp_n_int_2</code> holds the product of y and 3, it&#x27;s null if <code>y.is_null</code> is true</li><li><code>*result</code> holds the answer, it&#x27;s null if either of <code>_tmp_n_int_1.is_null</code>, <code>_tmp_n_int_2.is_null</code> is true<ul><li>otherwise it&#x27;s <code>_tmp_n_int_1.value + _tmp_n_int_2.value</code></li></ul></li></ul><p>So, in general, we need to emit arbitarily many statements in the course of evaluating even simple looking expressions
and we need good mechanisms to manage that.  This is what we&#x27;ll talk about in the coming sections.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="managing-scratch-variables"></a>Managing Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#managing-scratch-variables" title="Direct link to heading">#</a></h4><p>The function that actually assigns scratch variables is <code>cg_scratch_var</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The scratch variable helper uses the given sem_type and the current</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// stack level to create a temporary variable name for that type at that level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the variable does not already have a declaration (as determined by the masks)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// then a declaration is added to the scratch_vars section.  This is one of the root</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ways of getting an .is_null and .value back.  Note that not null variables always</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// have a .is_null of &quot;0&quot; which becomes important when deciding how to assign</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// one result to another.  Everything stays uniform.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)</span></div></div></div></div></div><p>The signature is a bit unexpected so we&#x27;ll go over this, some of this will make more
sense as we learn about expressions generally but this is as good an introduction as any.</p><ul><li><code>ast</code> holds a reference to a variable we want to assign to, this is normally <code>NULL</code> for scratch variables, it&#x27;s not null for the <code>RESULT</code> macros which we&#x27;ll study later, so for now ignore this</li><li><code>sem_type</code> holds the type of the variable we need, it must be a unitary type, optionally with <code>SEM_TYPE_NOTNULL</code> set</li><li><code>var</code> is a character buffer that will get the name of the variable</li><li><code>is_null</code> is a character buffer that will get the <code>is_null</code> expression for this variable (more below)</li><li><code>value</code> is a character buffer that will get the <code>value</code> expression for this variable (more below)</li></ul><p>And this is a good time to talk about <code>is_null</code> and <code>value</code> because they will be everywhere.</p><p>Every expression evaluation in the C code generator has two essential results, the text that corresponds to the current
value so far (e.g. &quot;(1+2)*3&quot;) and the text for the current expression that will tell you if the result is null,
this could be as simple as &quot;0&quot; for a expression that is known to be not null.  So let&#x27;s make this a little more concrete:</p><p>Suppose you ask for a scratch not null integer we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_n_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;0&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_n_int_1&quot;</code></li></ul><p>Meaning: if you want the value, use the text &quot;_tmp_n_int_1&quot; if you want to know if the variable is null, use the text &quot;0&quot;
Note: many parts of <code>cg_c.c</code> special case an <code>is_null</code> value of <code>&quot;0&quot;</code> to make better code because such a thing is known to
be not null at compile time.</p><p>Now let&#x27;s suppose you ask for a scratch nullable integer, we get results like this:</p><ul><li><code>var</code>:  <code>&quot;_tmp_int_1&quot;</code></li><li><code>is_null</code>: <code>&quot;_tmp_int_1.is_null&quot;</code></li><li><code>value</code>: <code>&quot;_tmp_int_1.value&quot;</code></li></ul><p>So again, you have exactly the text you need to test for null and the test you need to get the value.</p><p>Additional notes:</p><ul><li>scratch variables can be re-used, they are on a &quot;stack&quot;</li><li>a bitmask is used to track which scratch variables have aleady had a declaration emitted, so they are only declared once</li><li>the variable name is based on the current value of the <code>stack_level</code> variable which is increased in a push/pop fashion as temporaries come in and out of scope</li><li>this strategy isn&#x27;t perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad</li><li>importantly there is one stacklevel variable for all temporaries not one stacklevel for every type of temporary, this seemed like a reasonable simplification</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocating-scratch-variables"></a>Allocating Scratch Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocating-scratch-variables" title="Direct link to heading">#</a></h4><p>The most common reason for a scratch variable is that a temporary is needed for some part of the computation.
The most common reason for a temporary variable is to hold an intermediate result of a computation involving
nullable arithmetic.</p><p>These temporaries are created with <code>CG_PUSH_TEMP</code> which simply creates the three <code>charbuf</code> variables you need and then asks for a
scratch variable of the type you need.  The variables follow a simple naming convention.  The stack level is increased.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// with the text needed to refer to the variable.  cg_scratch_var picks the name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// based on stack level-and type.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_TEMP(name, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(NULL, sem_type, &amp;name, &amp;name##_is_null, &amp;name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>Symetrically, <code>CG_POP_TEMP</code> releases the charbufs and restores the stack level.  As with the other macros, these are designed to
make it impossible to forget to free your buffers or get the stack wrong.  In fact, the stack is checked at strategic places
to ensure its back to baseline.  You can always just snapshot <code>stacklevel</code>, do some work that should be clean, and then
add an <code>Invariant</code> that <code>stacklevel</code> is back to where it was.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Release the buffers for the temporary, restore the stack level.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_TEMP(name) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(name); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level--;</span></div></div></div></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursing-sub-expressions"></a>Recursing Sub-expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursing-sub-expressions" title="Direct link to heading">#</a></h4><p>Now that we understand that we can create scratch variables as needed, it&#x27;s time to take a look at the typical evaluation patterns
and how the evaluation works within that pattern.  This is everywhere in <code>cg_c.c</code>.</p><p>So let&#x27;s look at an actual evaluator, the simplest of them all, this one does code generation for the <code>NULL</code> literal.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_null(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_null(expr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // null literal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(value, &quot;NULL&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Now this may be looking familiar: the signature of the code generator is something very much like the
signature of the the <code>gen_</code> functions in the echoing code.  That&#x27;s really because in some sense
the echoing code is like a very simple code generator itself.</p><ul><li><code>expr</code> : the AST we are generating code for</li><li><code>op</code> : the relevant operator if any (operators share code)</li><li><code>is_null</code> : a <code>charbuf</code> into which we can write the <code>is_null</code> expression text</li><li><code>value</code> : a <code>charbuf</code> into which we can write the <code>value</code> expression text</li><li><code>pri</code> : the binding strength of the node above this one</li><li><code>pri_new</code> : the binding strength of this node</li></ul><p>This particular generator is going to produce <code>&quot;NULL&quot;</code> for the <code>value</code> and <code>&quot;1&quot;</code> for the <code>is_null</code> expression.</p><p><code>is_null</code> and <code>value</code> are the chief outputs, and the caller will use these to create its own expression results
with recursive logic.  But the expression logic can also write into the statement stream, and as we&#x27;ll see,
it does.</p><p><code>pri</code> and <code>pri_new</code> work exactly like they did in the echoing code (see <a href="https://cgsql.dev/cql-guide/int01" target="_blank" rel="noopener noreferrer">Part 1</a>),
they are used to allow the code generator to decide if it needs to emit parentheses.  But recall that the binding strengths
now will be the C binding strengths NOT the SQL binding strengths (discussed above).</p><p>Let&#x27;s look at one of the simplest operators: the <code>IS NULL</code> operator handled by <code>cg_expr_is_null</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The code-gen for is_null is one of the easiest.  The recursive call</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// produces is_null as one of the outputs.  Use that.  Our is_null result</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// is always zero because IS NULL is never, itself, null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type_expr = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // expr IS NULL</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(is_null, &quot;0&quot;); // the result of is null is never null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The fact that this is not constant not null for not null reference types reflects</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the weird state of affairs with uninitualized reference variables which</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // must be null even if they are typed not null.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_not_nullable(sem_type_expr) &amp;&amp; !is_ref_type(sem_type_expr)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Note, sql has no side-effects so we can fold this away.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;0&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(value, &quot;%s&quot;, expr_is_null.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>So walking through this:</p><ul><li>the result of <code>IS NULL</code> is never null, so we can immediately put &quot;0&quot; into the <code>is_null</code> buffer</li><li>if the operand is a not-null numeric type then the result of <code>IS NULL</code> is <code>0</code></li><li>if the operand might actually be null then<ul><li>use <code>CG_PUSH_EVAL</code> to recursively do codegen for it</li><li>copy its <code>expr_is_null</code> text into our <code>value</code> text</li></ul></li></ul><p>Note: the code reveals one of the big CQL secrets that not null reference variables can be null...  C has the same issue with <code>_Nonnull</code> globals.</p><p>Now let&#x27;s look at those helper macros, they are pretty simple:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical naming convention</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// burn the stack slot so that any type and numbered temporary that was needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// won&#x27;t be re-used until this scope is over.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>The push macro simply creates buffers to hold the <code>is_null</code> and <code>value</code> results, then it calls <code>cg_expr</code> to dispatch the indicated expression.
The <code>pri</code> value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is your <code>pri_new</code>
value but often you can use <code>C_EXPR_PRI_ROOT</code> if you know that, because of your current context, the callee will never need parentheses.</p><p>How do we know this here? It seems like the operand of <code>IS NULL</code> could be anything surely it might need parentheses?  Let&#x27;s consider:</p><ul><li>if the operand is of not null numeric type then we aren&#x27;t even going to evaluate it, we&#x27;re on the easy &quot;no it&#x27;s not null&quot; path</li><li>if the operand is nullable then the only place the answer can be stored is in a scratch variable and its <code>is_null</code> expression will be exactly like <code>var.is_null</code></li><li>if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is <code>is_null</code> expression will be like <code>!var</code></li></ul><p>None of these require further wrapping regardless of what is above this node in the tree because of he strength of the <code>.</code> and <code>!</code> operators.</p><p>Other cases are usually simpler, such as &quot;no parentheses need to be added by the child node becasue it will be used as the argument to a helper
function so there will always be parens hard-coded anyway&quot;.  However these things need to be carefully tested hence the huge variety of codegen tests.</p><p>Note that after calling <code>cg_expr</code> the stack level was artificially increased.  We&#x27;ll get to that in the next section.  For now, looking at <code>POP_EVAL</code> we
can see it&#x27;s very straightforward:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Close the buffers used for the above.  Return the stack level to its original state.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Numbered scratch variables are re-used as though they were a stack.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_POP_EVAL(expr) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_CLOSE(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level--;</span></div></div></div></div></div><p><code>CG_POP_EVAL</code> simply closes the buffers and restores the stack.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="result-variables"></a>Result Variables<a aria-hidden="true" tabindex="-1" class="hash-link" href="#result-variables" title="Direct link to heading">#</a></h4><p>When recursion happens in the codegen, the common place that the result will be found is
in a temporary variable -- the generated code will use one or more statements to arrange for the correct
answer to be in that variable.  To do this, the codegen needs to first get the name of a suitable
result variable of a suitable type.  This is the &quot;other&quot; reason for making scratch variables.</p><p>There are three macros that make this pretty simple.  The first is <code>CG_RESERVE_RESULT_VAR</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a scratch variable to hold the final result of an evaluation.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// It may or may not be used.  It should be the first thing you put</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// so that it is on the top of your stack.  This only saves the slot.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_RESERVE_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_reserved = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">sem_t sem_type_reserved = sem_type; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ast_node *ast_reserved = ast; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>If this looks a lot like <code>PUSH_TEMP</code> that shouldn&#x27;t be surprising.  The name of the variable
and the expression parts always go into <code>charbuf</code> variables named <code>result_var</code> <code>result_var_is_null</code> and <code>result_var_value</code>
but the scratch variable isn&#x27;t actually allocated!  However -- we burn the stack_level as though it had been
allocated.  What&#x27;s up with that?</p><p>The name might be a clue, this macro reserves stack level slot for the result variable, it&#x27;s used if you might
need a result variable, but you might not.  When you want it we can artificially move the stack level back
to this spot where the slot was burned, allocate the scratch variable, and then put the stack back.
The <code>CG_USE_RESULT_VAR</code> macro does exactly that.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// If the result variable is going to be used, this writes its name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// and .value and .is_null into the is_null and value fields.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_USE_RESULT_VAR() \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int32_t stack_level_now = stack_level; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_reserved; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level = stack_level_now; \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Invariant(result_var.used &gt; 1); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(is_null, &quot;%s&quot;, result_var_is_null.ptr); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bprintf(value, &quot;%s&quot;, result_var_value.ptr)</span></div></div></div></div></div><p>Once the code generator decides that it will in fact be using a result variable to represent the answer, then
the <code>is_null</code> and <code>value</code> buffers can be immediately populated to whatever the values were
for the result variable.  That text will be correct regardless of what codegen is used
to populate the variable.</p><p>There is a simpler macro that reserves and uses the result variable in one step, it&#x27;s very common.  The
&quot;reserve&quot; pattern is only necessary when there are some paths that need a result variable and some
that don&#x27;t.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// This does reserve and use in one step</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_SETUP_RESULT_VAR(ast, sem_type) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CG_RESERVE_RESULT_VAR(ast, sem_type); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CG_USE_RESULT_VAR();</span></div></div></div></div></div><p>And now armed with this knowledge we can go back to a previous mystery, let&#x27;s look at <code>CG_PUSH_EVAL</code> again</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Make a temporary buffer for the evaluation results using the canonical naming convention</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// burn the stack slot so that any type and numbered temporary that was needed</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// won&#x27;t be re-used until this scope is over.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define CG_PUSH_EVAL(expr, pri) \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_is_null); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CHARBUF_OPEN(expr##_value); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri); \</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stack_level++;</span></div></div></div></div></div><p>The reason that <code>CG_PUSH_EVAL</code> includes <code>stack_level++</code> is that it is entirely possible, even likely,
that the result of <code>cg_expr</code> is in a result variable.  The convention is that if the codegen
requires a result variable it is allocated <em>first</em> before any other temporaries.  This is why
there is a way to reserve a variable that you <em>might</em> need.  When the codegen is complete,
and before anything else happens, <code>stack_level</code> is increased so that the temporary that is
holding the result will not be re-used!  Any other temporaries are available but the result
is still live.  This might be easy to get wrong but the macros make it easy to get it right.</p><p>Now, armed with the knowledge that there a result variables and temporary variables and both
come from the scratch variable we can resolve the last mystery we left hanging.  Why does
the scratch variable API accept an AST pointer?</p><p>The only place that pointer can be not null is in the <code>CG_USE_RESULT_VAR</code> macro, it was
this line:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value);</span></div></div></div></div></div><p>And <code>ast_reserved</code> refers to the AST that we are trying to evaluate.  There&#x27;s an important
special case that we want to optimize that saves a lot of scratch variables.  It&#x27;s handled
by this code in <code>cg_scratch_var</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_assignment_target_reusable(ast, sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Invariant(ast &amp;&amp; ast-&gt;parent &amp;&amp; ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_ANY_NOTNULL(name_ast, ast-&gt;parent-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EXTRACT_STRING(name, name_ast);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (is_out_parameter(name_ast-&gt;sem-&gt;sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;*%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bprintf(var, &quot;%s&quot;, name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div></div></div><p>The idea is that if the generator is doing an assignment like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := a + b;</span></div></div></div></div></div><p>Then the code generator doesn&#x27;t need a scratch variable to hold the result of the expression <code>a + b</code> like it would
in many other contexts.  It can use <code>x</code> as the result variable!  The <code>SET</code> codegen will discover
that the value it&#x27;s supposed to set is already in <code>x</code> so it does nothing and everything just
works out.  The price of this is a call to <code>is_assignment_target_reusable</code> and then some
logic to handle the case where <code>x</code> is an out argument (hence call by reference, hence needs to be used as <code>*x</code>).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="basic-control-flow-patterns"></a>Basic Control Flow Patterns<a aria-hidden="true" tabindex="-1" class="hash-link" href="#basic-control-flow-patterns" title="Direct link to heading">#</a></h3><p>To get a sense of how the compiler generates code for statements, we can look at some of the easiest cases.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;While&quot; suffers from the same problem as IF and as a consequence</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// generating while (expression) would not generalize.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The overall pattern for while has to look like this:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    prep statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    condition = final expression;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    if (!condition) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    statements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Note that while can have leave and continue substatements which have to map</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// to break and continue.   That means other top level statements that aren&#x27;t loops</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// must not create a C loop construct or break/continue would have the wrong target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_while_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_while_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT_ANY_NOTNULL(expr, ast-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  EXTRACT(stmt_list, ast-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  sem_t sem_type = expr-&gt;sem-&gt;sem_type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // WHILE [expr] BEGIN [stmt_list] END</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;for (;;) {\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (is_nullable(sem_type)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!cql_is_nullable_true(%s, %s)) break;\n&quot;, expr_is_null.ptr, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bprintf(cg_main_output, &quot;if (!(%s)) break;\n&quot;, expr_value.ptr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t loop_saved = cg_in_loop;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CG_POP_EVAL(expr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_stmt_list(stmt_list);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;}\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cg_in_loop = loop_saved;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The comment before the <code>cg_while_stmt</code> actually says it pretty clearly; the issue is
that the expression in the while statement might actually require many C statements
to evaluate.  There are many cases of this sort of thing, but the simplest is
probably when any nullable types are in that expression.  A particular example
illustrates this pretty clearly.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER NOT NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_int32 x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  x = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /* in trickier cases there would be code right here */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!(x &lt; 5)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    x = x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>In this case, the <code>while</code> pattern could have been used because the condition is simply <code>x &lt; 5</code> so this whole pattern is
overkill.  But consider this program just a tiny bit different.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE x INTEGER;  -- x is nullable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  SET x := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WHILE x &lt; 5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET x := x + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void p(void) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_int32 x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_nullable_bool _tmp_n_bool_0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_null(_tmp_n_bool_0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_notnull(x, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (;;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_nullable(_tmp_n_bool_0, x.is_null, x.value &lt; 5);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cql_set_nullable(x, x.is_null, x.value + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Even for this small little case, the nullable arithmetic macros have to be used to keep <code>x</code> up to date.
The result of <code>x &lt; 5</code> is of type &quot;bool&quot; rather than &quot;bool not null&quot; so a temporary variable captures
the result of the expression.  This is an easy case but similar things happen if the expression
includes <code>CASE...WHEN...</code> or <code>IN</code> constructs.  There are many other cases.</p><p>So with this in mind, let&#x27;s reconsider what <code>cg_while_stmt</code> is doing:</p><ul><li>we start the <code>for</code> statement in the output<ul><li>there&#x27;s a bprintf for that</li></ul></li><li>we evaluate the while expression, the details will be in <code>is_null</code> and <code>value</code><ul><li>we use CG_PUSH_EVAL for that</li></ul></li><li>if the result is nullable there is a helper macro <code>cql_is_nullable_true</code> that tells us if the value is not null and true</li><li>if the result is not nullable we can use <code>expr_value.ptr</code> directly</li><li>we make a note that we&#x27;re in a loop (this matters for statement cleanup, more on that later)</li><li>we recurse to do more statements with <code>cg_stmt_list</code></li><li>finally we end the <code>for</code> that we began</li></ul><p>This kind of structure is common to all the control flow cases.  Generally, we have to deal with the
fact that CQL expressions become C statements so we use a more general flow control strategy. But with this
in mind, it&#x27;s easy to imagine how <code>IF</code> <code>LOOP</code> and <code>SWITCH</code> are handled.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cleanup-and-errors"></a>Cleanup and Errors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cleanup-and-errors" title="Direct link to heading">#</a></h3><p>There are a number of places where things can go wrong when running a CQL procedure.  The most
common sources are: (1) SQLite APIs, almost all of which can fail, and, (2) calling other procedures
which also might fail.  Here&#x27;s a very simple example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC something_that_might_fail (arg TEXT) USING TRANSACTION;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_string_literal(_literal_1_test_p, &quot;test&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cql_cleanup:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Let&#x27;s look at this carefully:</p><ul><li>first, we had to declare <code>something_that_might_fail</code><ul><li>the declaration includes <code>USING TRANSACTION</code> indicating the procedure uses the database</li><li>we didn&#x27;t provide the definition, that will lead to a link time error but we&#x27;re ignoring that for now</li></ul></li><li>there is a string literal named <code>_literal_1_test_p</code> that is auto-created<ul><li><code>cql_string_literal</code> can expand into a variety of things, whatever you want &quot;make a string literal&quot; to mean</li><li>its defined in <code>cqlrt.h</code> and it&#x27;s designed to be replaced</li></ul></li><li><code>cql_set_string_ref(&amp;arg, _literal_1_test_p);</code> is expected to &quot;retain&quot; the string (+1 ref count)</li><li><code>cql_cleanup</code> is the exit label, this code will run for sure<ul><li>cleanup statements are accumulated by writing to <code>cg_cleanup_output</code> which usually writes to the <code>proc_cleanup</code> buffer</li><li>because cleanup is in its own buffer you can add to it freely whenever a new declaration that requires cleanup arises</li><li>in this case the declaration of the string literal caused the <code>C</code> variable <code>arg</code> to be created and also the cleanup code</li></ul></li><li>now we call <code>something_that_might_fail</code> passing it our database pointer and the argument</li><li>the hidden <code>_db_</code> pointer is passed to all procedures that use the database</li><li>these are also the ones that can fail</li><li>any failed return code (not <code>SQLITE_OK</code>) causes two things<ul><li>the <code>cql_error_trace()</code> macro is invoked (this macro typically expands to nothing)</li><li>the code stops what it&#x27;s doing and runs the cleanup code via <code>goto cql_cleanup;</code></li></ul></li></ul><p>The essential sequence is this one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }</span></div></div></div></div></div><p>The C code generator uses this pattern all over to check if anything went wrong and to exit with an error code.
Extensive logging can be very expensive but in debug builds, it&#x27;s quite normal for <code>cql_error_trace</code> to expand
into something like <code>fprintf(stderr, &quot;error %d in %s %s:%d\n&quot;, _rc_, _PROC_, __FILE__, __LINE_)</code> which probably
a lot more logging than you want in a production build but great if you&#x27;re debugging.  Recall that CQL generates
<code>#define _PROC_ &quot;p&quot;</code> before every procedure.</p><p>This pattern generalizes well and indeed if we use the exception handling pattern, we get a lot of control.
Let&#x27;s generalize this a tiny bit.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-SQL codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC p (OUT success BOOL NOT NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LET arg := &quot;test&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN TRY</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    CALL something_that_might_fail(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END TRY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN CATCH</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SET success := 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  END CATCH;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span></div></div></div></div></div><p>CQL doesn&#x27;t have complicated exception objects or anything like that, exceptions are just simple
control flow.  Here&#x27;s the code for the above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_bool *_Nonnull success) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_contract_argument_notnull((void *)success, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_code _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_ref arg = NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  *success = 0; // set out arg to non-garbage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_set_string_ref(&amp;arg, _literal_1_test_p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // try</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _rc_ = something_that_might_fail(_db_, arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    goto catch_end_1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_start_1: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    *success = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  catch_end_1:;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  _rc_ = SQLITE_OK;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cql_string_release(arg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return _rc_;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The code is nearly the same.  Let&#x27;s look at the essential differences:</p><ul><li>If there is an error, the code hits <code>goto catch_start_1</code></li><li>If the try block succeeds, the code hits <code>goto catch_end_1</code></li><li>both branches set the <code>success</code> out parameter</li><li>we added that out argument, CQL generated an error check to ensure that arg 1 is not null<ul><li><code>cql_contract_argument_notnull((void *)success, 1)</code>, the 1 means arg 1</li><li>the hidden <code>_db_</code> arg doesn&#x27;t count</li></ul></li></ul><p>How does this happen?  <code>cg_trycatch_helper</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Very little magic is needed to do try/catch in our context.  The error</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// handlers for all the sqlite calls check _rc_ and if it&#x27;s an error they</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;goto&quot; the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Inside the try block, the cleanup handler is changed to the catch block.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The catch block puts it back.  Otherwise, generate nested statements as usual.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_start);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CHARBUF_OPEN(catch_end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // We need unique labels for this block</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ++catch_block_count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_start, &quot;catch_start_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(&amp;catch_end, &quot;catch_end_%d&quot;, catch_block_count);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Divert the error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  CSTR saved_error_target = error_target;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool_t saved_error_target_used = error_target_used;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target = catch_start.ptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> ...</span></div></div></div></div></div><p>All of the error handling does goto <code>error_target</code> whatever that is.  The
try/catch pattern simply changes the current error target.  The rest of
the code is just to save the current error target and to create unique
labels for the the control flow.</p><p>The important notion is that, if anything goes wrong, whatever it is,
the generator simply does a <code>goto error_target</code> and that will either
hit the catch block or else go to cleanup.</p><p>The <code>THROW</code> operation illustrates this well:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-C codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Convert _rc_ into an error code.  If it already is one keep it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Then go to the current error target.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void cg_throw_stmt(ast_node *ast) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Contract(is_ast_throw_stmt(ast));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;_rc_ = cql_best_error(%s);\n&quot;, rcthrown_current);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bprintf(cg_main_output, &quot;goto %s;\n&quot;, error_target);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  error_target_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  rcthrown_used = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li>first we make sure <em>rc</em> has some kind of error in it either <code>rcthrown_current</code> or else <code>SQLITE_ERROR</code></li><li>then we goto the current error target</li><li><code>error_target_used</code> tracks whether there were any possible errors, this is just to avoid C compiler errors about unused labels.<ul><li>if the label is not used it won&#x27;t be emitted</li><li>the code never jump back to an error label so we&#x27;ll always know if it was used before we need to emit it</li></ul></li></ul><p>Note: every catch block captures the value of <code>_rc_</code> in a local variable whose name is in <code>rcthrown_current</code>.
This is the current failing result code accessible by <code>@RC</code> in CQL.</p><p>A catch block can therefore do stuff like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-sql codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">IF</span><span class="token plain"> </span><span class="token variable" style="color:rgb(191, 199, 213)">@RC</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">THEN</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  THROW</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">ELSE</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">call</span><span class="token plain"> attempt_retry</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">END</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">IF</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div></div></div><p>or something like that.</p><p>This entire mechanism is built with basically just a few state variables that nest.  There is no complicated stack walking
or anything like that.  All the code has to do is chain the error labels together and let users create new catch blocks
with new error labels.  All that together gives you very flexible try/catch behaviour.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-08-20T20:58:47.000Z" class="docLastUpdatedAt_217_">8/20/2021</time> by <strong>Rico Mariani</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#part-1-lexing-parsing-and-the-ast" class="table-of-contents__link">Part 1: Lexing, Parsing, and the AST</a><ul><li><a href="#preface" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#general-structure" class="table-of-contents__link">General Structure</a><ul><li><a href="#lexical-analysis" class="table-of-contents__link">Lexical Analysis</a></li><li><a href="#parsing-and-the-abstract-syntax-tree" class="table-of-contents__link">Parsing and the Abstract Syntax Tree</a></li><li><a href="#examples" class="table-of-contents__link">Examples</a></li><li><a href="#ast-definitions" class="table-of-contents__link">AST definitions</a></li></ul></li><li><a href="#echoing-the-ast" class="table-of-contents__link">Echoing the AST</a><ul><li><a href="#configuring-the-output-with-callbacks-and-flags" class="table-of-contents__link">Configuring the Output with Callbacks and Flags</a></li><li><a href="#invoking-the-generator" class="table-of-contents__link">Invoking the Generator</a></li><li><a href="#generator-internals" class="table-of-contents__link">Generator Internals</a></li></ul></li><li><a href="#part-2-semantic-analysis" class="table-of-contents__link">Part 2: Semantic Analysis</a><ul><li><a href="#preface-1" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#semantic-analysis" class="table-of-contents__link">Semantic Analysis</a><ul><li><a href="#decorated-ast-examples" class="table-of-contents__link">Decorated AST examples</a></li><li><a href="#the-base-data-structures" class="table-of-contents__link">The Base Data Structures</a></li><li><a href="#initiating-semantic-analysis" class="table-of-contents__link">Initiating Semantic Analysis</a></li><li><a href="#semantic-errors" class="table-of-contents__link">Semantic Errors</a></li><li><a href="#the-primitive-types" class="table-of-contents__link">The Primitive Types</a></li><li><a href="#unary-operators" class="table-of-contents__link">Unary Operators</a></li><li><a href="#binary-operators" class="table-of-contents__link">Binary Operators</a></li><li><a href="#simple-statement-validation" class="table-of-contents__link">Simple Statement Validation</a></li><li><a href="#expression-contexts" class="table-of-contents__link">Expression Contexts</a></li><li><a href="#name-resolution" class="table-of-contents__link">Name Resolution</a></li><li><a href="#structure-types-and-the-notion-of-shapes" class="table-of-contents__link">Structure types and the notion of Shapes</a></li><li><a href="#join-types" class="table-of-contents__link">Join Types</a></li><li><a href="#schema-regions" class="table-of-contents__link">Schema Regions</a></li><li><a href="#results-of-semantic-analysis" class="table-of-contents__link">Results of Semantic Analysis</a></li><li><a href="#recap" class="table-of-contents__link">Recap</a></li></ul></li><li><a href="#part-3-c-code-generation" class="table-of-contents__link">Part 3: C Code Generation</a><ul><li><a href="#preface-2" class="table-of-contents__link">Preface</a></li></ul></li><li><a href="#c-code-generation" class="table-of-contents__link">C Code Generation</a><ul><li><a href="#launching-the-code-generator" class="table-of-contents__link">Launching the Code Generator</a></li><li><a href="#character-buffers-and-byte-buffers" class="table-of-contents__link">Character Buffers and Byte Buffers</a></li><li><a href="#expressions" class="table-of-contents__link">Expressions</a></li><li><a href="#basic-control-flow-patterns" class="table-of-contents__link">Basic Control Flow Patterns</a></li><li><a href="#cleanup-and-errors" class="table-of-contents__link">Cleanup and Errors</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Facebook Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2021 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4a61b4b3.js"></script>
<script src="/runtime~main.7f4ba451.js"></script>
<script src="/main.9cd58f71.js"></script>
<script src="/1.bac24c28.js"></script>
<script src="/2.29ab4659.js"></script>
<script src="/3.9ee6d42d.js"></script>
<script src="/1be78505.ae32d621.js"></script>
<script src="/87.9cf8ff91.js"></script>
<script src="/5456faf3.d3330067.js"></script>
<script src="/17896441.923fd9c6.js"></script>
<script src="/7d22b040.9dd88c74.js"></script>
</body>
</html>