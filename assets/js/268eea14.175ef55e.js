"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9032],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return m},MDXProvider:function(){return c},mdx:function(){return g},useMDXComponents:function(){return d},withMDXComponents:function(){return u}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var m=a.createContext({}),u=function(e){return function(n){var t=d(n.components);return a.createElement(e,o({},n,{components:t}))}},d=function(e){var n=a.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(m.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=d(t),c=r,h=u["".concat(l,".").concat(c)]||u[c]||p[c]||o;return t?a.createElement(h,s(s({ref:n},m),{},{components:t})):a.createElement(h,s({ref:n},m))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=h;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var m=2;m<o;m++)l[m]=t[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},66895:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return s},metadata:function(){return m},toc:function(){return d}});var a=t(83117),r=t(80102),o=(t(67294),t(3905)),l=["components"],s={slug:"like-forms-tutorial",title:"A quick tutorial on LIKE forms",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},i=void 0,m={permalink:"/blog/like-forms-tutorial",editUrl:"https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2020-11-20-like-forms-tutorial.md",source:"@site/blog/2020-11-20-like-forms-tutorial.md",title:"A quick tutorial on LIKE forms",description:"Everyone knows the usual expression syntax x LIKE y to do a string match.  But the CQL compiler also uses",date:"2020-11-20T00:00:00.000Z",formattedDate:"November 20, 2020",tags:[{label:"facebook",permalink:"/blog/tags/facebook"},{label:"cg-sql",permalink:"/blog/tags/cg-sql"},{label:"errors",permalink:"/blog/tags/errors"}],readingTime:7.61,hasTruncateMarker:!1,authors:[{name:"CG/SQL Team",title:"Maintainer of CG/SQL",url:"https://github.com/facebookincubator",imageURL:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4"}],frontMatter:{slug:"like-forms-tutorial",title:"A quick tutorial on LIKE forms",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},prevItem:{title:"Introducing Declare Enum",permalink:"/blog/declare-enum-intro"},nextItem:{title:"Error Tracing Helper Macro",permalink:"/blog/error-tracing-macro"}},u={authorsImageUrls:[void 0]},d=[],c={toc:d};function p(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.mdx)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Everyone knows the usual expression syntax ",(0,o.mdx)("inlineCode",{parentName:"p"},"x LIKE y")," to do a string match.  But the CQL compiler also uses\n",(0,o.mdx)("inlineCode",{parentName:"p"},"LIKE")," in a different way that's powerful and important.  CQL has the notion of data shapes and you use\n",(0,o.mdx)("inlineCode",{parentName:"p"},"LIKE")," to refer to them.  The simplest source of a data shape, and maybe the most common, is a table.\nMaybe something like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create table T(\n id integer not null,\n name text not null,\n age integer not null\n);\n")),(0,o.mdx)("p",null,"Now suppose you want to write a procedure that can insert a row into that table, You could write"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc insert_into_T(\n  id_ integer not null, \n  name_ text not null, \n  age_ integer not null\n)\nbegin\n  insert into T(id, name, age)  values(id_, name_, age_);\nend;\n")),(0,o.mdx)("p",null,"This is all fine and well but what if T had 50 columns?  That gets old fast.  And how can you\nbe sure that you inserted the columns into T in the right order?  This second example also compiles\neven though it's clearly wrong:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"  insert into T(id, name, age) values(age_, name_, id_);\n")),(0,o.mdx)("p",null,"And of course you can imagine things get only more complicated with more columns in T."),(0,o.mdx)("p",null,"We started adding the ",(0,o.mdx)("inlineCode",{parentName:"p"},"LIKE")," form to ease these issues and to ensure some consistency in the APIs while preventing\nsimple transpostion errors.  So you can instead write:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"create proc insert_into_T(like T)\nbegin\n  insert into T from arguments;\nend;\n")),(0,o.mdx)("p",null,"so here the ",(0,o.mdx)("inlineCode",{parentName:"p"},"like T"),' in the argument list simply means "make arguments that are the same as the columns of table T" -- well,\nalmost. It also adds an ',(0,o.mdx)("inlineCode",{parentName:"p"},"_")," to the end of each name so you end up exactly the same declaration as the long form above.\nBut you won't miss any arguments, and they'll be in the right order."),(0,o.mdx)("p",null,"And notice that we used ",(0,o.mdx)("inlineCode",{parentName:"p"},"from arguments")," to indicate that we wanted the values to come from the arguments in order. Again\nthis saves you from a lot of typing and a lot of error checking.  You can't get the arguments in the wrong order."),(0,o.mdx)("p",null,"These are the most basic patterns. But there are quite a few more."),(0,o.mdx)("p",null,"Let's suppose you want to write a procedure that returns in row with the highest age in the above.  Maybe you write\nsomething like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc highest_age()\nbegin\n  declare C cursor for select * from T;\n  declare M cursor like C;\n  loop fetch C\n  begin\n     if (not M or M.age < C.age) then\n       fetch M from C;\n     end if;\n  end;\n  out M;\nend;\n")),(0,o.mdx)("p",null,"Here we made a cursor ",(0,o.mdx)("inlineCode",{parentName:"p"},"M")," that is the same as the cursor ",(0,o.mdx)("inlineCode",{parentName:"p"},"C")," and then we are going to generate a single row result\nfrom the cursor.  Note that if you use a cursor name like ",(0,o.mdx)("inlineCode",{parentName:"p"},"M")," in an expression it refers to the hidden boolean\nthat says if the cursor has a row in it or not.  So ",(0,o.mdx)("inlineCode",{parentName:"p"},"M")," begins empty and we will load it if it's empty or if the age\nis higher than what we've already got."),(0,o.mdx)("p",null,"Let's show a few more of the forms.  Suppose we don't want to return ",(0,o.mdx)("inlineCode",{parentName:"p"},"name"),", just the ",(0,o.mdx)("inlineCode",{parentName:"p"},"id")," and the ",(0,o.mdx)("inlineCode",{parentName:"p"},"age"),".  We can\nchange things up a tiny bit."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc highest_age()\nbegin\n  declare C cursor for select * from T;\n  declare M cursor like select 1 id, 99 age;\n  loop fetch C\n  begin\n     if (not M or M.age < C.age) then\n       fetch M from cursor C(like M);\n     end if;\n  end;\n  out M;\nend;\n")),(0,o.mdx)("p",null,"So two things to notice.  We used an ",(0,o.mdx)("em",{parentName:"p"},"ad hoc")," shape, making a fake ",(0,o.mdx)("inlineCode",{parentName:"p"},"select")," statement that returns the shape we want.  This\nselect doesn't run but it does define types and columns easily.  Two not null integers in this case.  Now ",(0,o.mdx)("inlineCode",{parentName:"p"},"M")," is not the\nsame as ",(0,o.mdx)("inlineCode",{parentName:"p"},"C")," so we can't use the simplest form ",(0,o.mdx)("inlineCode",{parentName:"p"},"fetch M from C")," we have to use the more general form. "),(0,o.mdx)("p",null,"Fully expanded, what we wrote becomes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  FETCH M(id, age) FROM VALUES(C.id, C.age);\n")),(0,o.mdx)("p",null,"But as you can see, we didn't have to type all those column names.  And that's kind of the point of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"LIKE")," construct."),(0,o.mdx)("p",null,"So we've covered a bunch of the shape sources already:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"a table name"),(0,o.mdx)("li",{parentName:"ul"},"a cursor name"),(0,o.mdx)("li",{parentName:"ul"},"a select statement that gives the shape in an ad hoc fashion")),(0,o.mdx)("p",null,"There are three more"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"a view name "),(0,o.mdx)("li",{parentName:"ul"},"the return shape of a procedure that returns a result set"),(0,o.mdx)("li",{parentName:"ul"},"the arguments of a procedure")),(0,o.mdx)("p",null,"View names are pretty simple, and they work the same as table names so we don't need to discuss those. Let's look\nat some of the other uses with procedures."),(0,o.mdx)("p",null,"Suppose we have a procedure that can return a result set shape but we want to be able to mock its results so we\ncan fake whatever result we need for testing.  "),(0,o.mdx)("p",null,"We'll complicate this a bit adding a new table (keeping short table names for the sample to save typing)"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create table U(\n id integer not null,\n email text not null\n);\n")),(0,o.mdx)("p",null,"And here's a procedure:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc my_proc()\nbegin\n   select T.*, U.email from T inner join U on T.id = U.id;\nend;\n")),(0,o.mdx)("p",null,"Now we want to be able to make any fake result we want, so maybe want a temp table. No problem:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc _init_fake_results()\nbegin\n  create temp table if not exists fake_results(\n   like my_proc\n  );\nend;\n\ncreate proc add_fake_result(like fake_results)\nbegin\n  insert into fake_results from arguments;\nend;\n\ncreate proc get_fake_results()\nbegin\n  select * from fake_results;\nend;\n")),(0,o.mdx)("p",null,"The above is very generic and will maintain well.  You can see we made a temp table that will have\nexactly the same shape as whatever ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_proc")," returns.  In this case it becomes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"CREATE PROC _init_fake_results ()\nBEGIN\n  CREATE TEMP TABLE IF NOT EXISTS fake_results(\n    id INTEGER NOT NULL,\n    name TEXT NOT NULL,\n    age INTEGER NOT NULL,\n    email TEXT NOT NULL\n  );\nEND;\n")),(0,o.mdx)("p",null,"And the rest are patterns we've seem before."),(0,o.mdx)("p",null,"The last source of shapes are procedure arguments.  There's lots of good cases for those, I wrote an ",(0,o.mdx)("a",{parentName:"p",href:"https://cgsql.dev/blog/update"},"entry")," on those previously but I'll give a simple example here too."),(0,o.mdx)("p",null,"Suppose we have this weird procedure:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc delete_stuff(age_ integer, name_ text)\nbegin\n  if age_ is not null then\n     delete from T where T.age = age_;\n  end if;\n\n  if name_ is not null then\n     delete from T where T.name = name_;\n  end if;\nend;\n")),(0,o.mdx)("p",null,"What if we wanted to log any errors that happen here?  Maybe make a verison that logs.  We can do it like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},'create proc delete_and_log(like delete_stuff arguments)\nbegin\n  begin try\n    call delete_stuff(from arguments);\n  end try;\n  begin catch\n    call printf("delete failed\\n"); -- or whatever\n    throw;\n  end catch;\nend;\n')),(0,o.mdx)("p",null,"The nice thing about this logging wrapper procedure is that if ",(0,o.mdx)("inlineCode",{parentName:"p"},"delete_stuff")," changes, the wrapper will change with it."),(0,o.mdx)("p",null,"That covers all of the shape sources and as we saw we can use them to create things like cursors, tables, and argument lists.\nWe can use them to specify a subset of columns that might be of interest when fetching or updating cursors.  And we can use\nthem in one last way -- to restrict arguments to a particular shape.  Let's see how that works by making the previous logger\na little different.  Here we added an argument which tells if we should look.  And that might look like it would\nspoil the ",(0,o.mdx)("inlineCode",{parentName:"p"},"from arguments")," part of the forwarding, but there is the final way to use ",(0,o.mdx)("inlineCode",{parentName:"p"},"LIKE"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},'create proc delete_and_log2(log bool not null, like delete_stuff arguments)\nbegin\n  if log and age_ is not null then\n    call printf("deleting %d\\n", age_); -- or whatever\n  end if;\n  if log and name_ is not null then\n    call printf("deleting %d\\n", name_); -- or whatever\n  end if;\n\n  call delete_stuff(from arguments like delete_stuff arguments);\nend;\n')),(0,o.mdx)("p",null,"So this form lets you use some of your arguments, the ones that match a certain shape.  And as we saw in\nthe previous article you can also use ",(0,o.mdx)("inlineCode",{parentName:"p"},"from C")," to pass arguments where ",(0,o.mdx)("inlineCode",{parentName:"p"},"C")," is a cursor and in that case\nyou can also specify that arguments be matched by name ",(0,o.mdx)("inlineCode",{parentName:"p"},"from C like shape"),'.  In both those cases the\nformal parameter names of the called procedure are matched against the names of the shape and passed in\nthe order of the formals.  So this is like "call by name", the fields of the cursor or the order of\narguments in the argument list might be different than the formals but you\'ll get the correct items\nin the correct order regardless, because it matches by name.'),(0,o.mdx)("p",null,"These forms can save you a lot of typing... and are excellent at avoiding errors and improving maintainability.\nWhere they appear in SQL statements, everything is expanded before it goes to SQLite so SQLite will see\nnormal syntax forms.  Which is good because obviously SQLite doesn't know anything about this enhanced\n",(0,o.mdx)("inlineCode",{parentName:"p"},"LIKE")," business."),(0,o.mdx)("p",null,"In the examples above there were only one or two columns with very short names, but in real world code\nthere can easily be dozens of columns with very long names.  In those cases, these forms really shine."))}p.isMDXComponent=!0}}]);