"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8345],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),u=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(n),f=a,h=m["".concat(i,".").concat(f)]||m[f]||p[f]||r;return n?o.createElement(h,l(l({ref:t},c),{},{components:n})):o.createElement(h,l({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var u=2;u<r;u++)l[u]=n[u];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6674:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return i},default:function(){return f},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),l=["components"],s={slug:"columns-sugar",title:"Using the LIKE form in the SELECT statement",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql"]},i=void 0,u={permalink:"/blog/columns-sugar",editUrl:"https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2022-02-03-columns-sugar.md",source:"@site/blog/2022-02-03-columns-sugar.md",title:"Using the LIKE form in the SELECT statement",description:'One of the signature features of the CQL language is the ability to use the "LIKE" form to',date:"2022-02-03T00:00:00.000Z",formattedDate:"February 3, 2022",tags:[{label:"facebook",permalink:"/blog/tags/facebook"},{label:"cg-sql",permalink:"/blog/tags/cg-sql"}],readingTime:3.68,truncated:!1,authors:[{name:"CG/SQL Team",title:"Maintainer of CG/SQL",url:"https://github.com/facebookincubator",imageURL:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4"}],frontMatter:{slug:"columns-sugar",title:"Using the LIKE form in the SELECT statement",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql"]},prevItem:{title:"Introducing Expression Fragments",permalink:"/blog/expression-frags"},nextItem:{title:"Control Flow Analysis in CQL",permalink:"/blog/flow-analysis"}},c={authorsImageUrls:[void 0]},p=[],m={toc:p};function f(e){var t=e.components,n=(0,a.Z)(e,l);return(0,r.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'One of the signature features of the CQL language is the ability to use the "LIKE" form to\nslice out columns that conform to a shape.  This notion appears in many places in the language.\nFor instance if I have a table ',(0,r.kt)("inlineCode",{parentName:"p"},"Foo"),". I can make a cursor for that shape like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"declare C cursor like Foo;\n")),(0,r.kt)("p",null,"Which says I want the columns of ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," to be like the columns of ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo"),"."),(0,r.kt)("p",null,"If I have a cursor ",(0,r.kt)("inlineCode",{parentName:"p"},"D")," that has the ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," columns but maybe more and maybe in a different order I can load ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),"\nas follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"fetch C from D(like Foo)\n")),(0,r.kt)("p",null,"Which again saves me from having to list all the (potentially dozens) of Foo columns.  This construct is in many places:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"declare proc P(like Foo)\nbegin\n  insert into Foo from arguments;\nend;\n")),(0,r.kt)("p",null,"even"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"declare proc P(f like Foo, b like Bar)\nbegin\n  insert into Foo from f;\n  insert into Bar from b;\nend;\n")),(0,r.kt)("p",null,"And other examples...  This is discussed more fully in\n",(0,r.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms"},"Chapter 5")," of the Guide."),(0,r.kt)("p",null,"However, one of the few places that shapes are interesting but not supported was in the select list.\nAnd so, just a couple of days ago, we added the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLUMNS")," construct to the language which allows for\na sugared syntax for extracting columns in bulk.  It's kind of a generalization of the ",(0,r.kt)("inlineCode",{parentName:"p"},"select T.*"),"\npattern but with CQL-style slicing and type-checking."),(0,r.kt)("p",null,"These forms are supported:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"columns from a join table or tables")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-- same as A.*\nselect columns(A) from ...;\n\n-- same as A.*, B.*\nselect columns(A, B) from ...;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"columns from a particular join table that match a shape")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-- the columns of A that match the shape Foo\nselect columns(A like Foo) from ...;\n\n-- get the Foo shape from A and the Far shape from B\nselect columns(A like Foo, B like Bar) from ...;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"columns from any join table that match a shape")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--- get the Foo shape from anywhere in the join\nselect columns(like Foo) from ...;\n\n-- get the Foo and Bar shapes, from anywhere in the join\nselect columns(like Foo, like Bar) from ...;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"specific columns")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-- x and y columns plus the foo shape\nselect columns(T1.x, T2.y, like Foo) from ...;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"distinct columns from the above (not distinct values!)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-- removes duplicate column names\n-- e.g. there will be one copy of 'pk'\nselect columns(distinct A, B) from A join B using(pk);\n\n-- if both Foo and Bar have an (e.g.) 'id' field you only get one copy\nselect columns(distinct like Foo, like Bar) from ...;\n\n-- if a specific column is mentioned it is always included\n-- but later clauses that are not a specific column will avoid it\n-- if F or B has an x it won't appear again, just T.x\nselect columns(distinct T.x, F like Foo, B like Bar) from F, B ..;\n")),(0,r.kt)("p",null,"Of course this is all just sugar, so it all ends up being a column list with table\nqualifications -- but the syntax is very powerful.  For instance, for narrowing a\nwide table, or for fusing joins that share common keys"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-- just the Foo columns\nselect columns(like Foo) from Superset_Of_Foo_From_Many_Joins_Even;\n\n-- only one copy of 'pk'\nselect columns(distinct A,B,C) from\n  A join B using (pk) join C using (pk);\n")),(0,r.kt)("p",null,"And of course you can define shapes however you like and then use them\nto slice off column chucks of your choice.  There are many ways to build\nup shapes from other shapes.  Probably the easiest is to declare procedures\nthat return the shape you want and never actual create them.  E.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"declare proc shape1() (x integer, y real, z text);\ndeclare proc shape2() (like shape1, u bool, v bool);\n")),(0,r.kt)("p",null,"With this combination you can easily define common column shapes and slice them\nout of complex queries without having to type the columns names over and over..."),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLUMNS(...)")," form is not a general replacement for the select list.\nFor instance, general expressions are not allowed inside of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLUMNS(...)")," but,\nwhere extraction of lots of columns is needed, or even re-ordering of colummns,\nit's a very good option indeed and it composes well with the other ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," features."),(0,r.kt)("p",null,"This was the last significant area where shapes are useful but totally absent."))}f.isMDXComponent=!0}}]);