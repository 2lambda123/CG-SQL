"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1869],{3905:function(e,t,r){r.d(t,{Zo:function(){return s},kt:function(){return h}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},s=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),m=u(r),h=o,d=m["".concat(l,".").concat(h)]||m[h]||p[h]||a;return r?n.createElement(d,i(i({ref:t},s),{},{components:r})):n.createElement(d,i({ref:t},s))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var u=2;u<a;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},6129:function(e,t,r){r.r(t),r.d(t,{assets:function(){return s},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return p}});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),i=["components"],c={slug:"error-tracing-macro",title:"Error Tracing Helper Macro",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},l=void 0,u={permalink:"/blog/error-tracing-macro",editUrl:"https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2020-11-18-error-tracing-macro.md",source:"@site/blog/2020-11-18-error-tracing-macro.md",title:"Error Tracing Helper Macro",description:"Following up on the last blog entry, I thought it would be useful to present a simple error tracing macro that you can use",date:"2020-11-18T00:00:00.000Z",formattedDate:"November 18, 2020",tags:[{label:"facebook",permalink:"/blog/tags/facebook"},{label:"cg-sql",permalink:"/blog/tags/cg-sql"},{label:"errors",permalink:"/blog/tags/errors"}],readingTime:2.33,truncated:!1,authors:[{name:"CG/SQL Team",title:"Maintainer of CG/SQL",url:"https://github.com/facebookincubator",imageURL:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4"}],frontMatter:{slug:"error-tracing-macro",title:"Error Tracing Helper Macro",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},prevItem:{title:"A quick tutorial on LIKE forms",permalink:"/blog/like-forms-tutorial"},nextItem:{title:"Introducing General Purpose Error Tracing",permalink:"/blog/error-tracing-intro"}},s={authorsImageUrls:[void 0]},p=[],m={toc:p};function h(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Following up on the last blog entry, I thought it would be useful to present a simple error tracing macro that you can use\nto see what kind of error flow is going on when you're having trouble understanding why a procedure is returning\nan error code. The idea is we want to create a macro that we can use like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"BEGIN_VERBOSE_STDERR_TRACING;\n\n-- Some procedure(s) that you want to trace\n\nEND_VERBOSE_STDERR_TRACING;\n")),(0,a.kt)("p",null,"We can do that with something like the below macros.  These particular ones cause the output to go to ",(0,a.kt)("inlineCode",{parentName:"p"},"stderr")," via ",(0,a.kt)("inlineCode",{parentName:"p"},"fprintf")," but if that isn't what you need you can simply edit the macro. The macros looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'-- manually force tracing on by redefining the cql_error_trace macro\n#define BEGIN_VERBOSE_STDERR_TRACING \\\n    @echo c, "#undef cql_error_trace\\n"; \\\n    @echo c, "#define cql_error_trace() fprintf(stderr, \\"CQL Trace at %s:%d in %s: %d %s\\\\n\\", __FILE__, __LINE__, _PROC_, _rc_, sqlite3_errmsg(_db_))\\n"\n\n#define END_VERBOSE_STDERR_TRACING \\\n    @echo c, "#undef cql_error_trace\\n"; \\\n    @echo c, "#define cql_error_trace()\\n"\n')),(0,a.kt)("p",null,"So basically it's telling CQL to emit a ",(0,a.kt)("inlineCode",{parentName:"p"},"#define")," into its output stream.  In this case:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'#define cql_error_trace() fprintf(stderr, "CQL Trace at %s:%d in %s: %d %s\\n", __FILE__, __LINE__, _PROC_, _rc_, sqlite3_errmsg(_db_))\n')),(0,a.kt)("p",null,"You could change that to any function you like, you can have it dump the errors where you like, or you can make it some dummy function you add so that you can set a breakpoint on it."),(0,a.kt)("p",null,"Whatever you do, do not leave your code with this sort of tracing enabled -- it's far too expensive in terms of code size.  But it's perfect if you have this one procedure that is failing and it's hard for you to see where."),(0,a.kt)("p",null,"Obviously if you're making a custom trace thingy you don't need the macro at all, you can just emit your own ",(0,a.kt)("inlineCode",{parentName:"p"},"#define")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"@echo")," as needed."),(0,a.kt)("p",null,"Note: ",(0,a.kt)("inlineCode",{parentName:"p"},"@echo")," is quite a sledgehammer so don't use it lightly and not in production code but it is quite helpful for this sort of thing.  CQL tests often use it to help make things visible to the tests.  If you use ",(0,a.kt)("inlineCode",{parentName:"p"},"@echo")," in weird ways you might not get working code when the codegen changes in the future."),(0,a.kt)("p",null,"The relevant state that is available to you inside a macro like this is:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"__FILE__")," the current filename (comes from the C pre-processor, this is the .c file name not the .sql)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"__LINE__")," the current line number (comes from the C pre-processor, this is the .c line number)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_rc_")," the current SQLite result code (always the current return code in every CQL procedure that uses SQLite)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_db_")," the current SQLite database pointer (always the current database in every CQL procedure that uses SQLite)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_PROC_")," the current procedure name (CQL has a ",(0,a.kt)("inlineCode",{parentName:"li"},"#define")," for this for you)")))}h.isMDXComponent=!0}}]);