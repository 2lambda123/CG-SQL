"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[958],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var u=2;u<o;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6067:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return c}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),l=["components"],i={id:"ch05",title:"Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH",sidebar_label:"Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH"},s=void 0,u={unversionedId:"ch05",id:"ch05",title:"Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH",description:"\x3c!---",source:"@site/../CQL_Guide/ch05.md",sourceDirName:".",slug:"/ch05",permalink:"/cql-guide/ch05",draft:!1,tags:[],version:"current",lastUpdatedBy:"Elena Luo",lastUpdatedAt:1661827518,formattedLastUpdatedAt:"8/30/2022",frontMatter:{id:"ch05",title:"Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH",sidebar_label:"Chapter 5: Types of Cursors, Shapes, OUT and OUT UNION, and FETCH"},sidebar:"someSidebar",previous:{title:"Chapter 4: Procedures, Functions, and Control Flow",permalink:"/cql-guide/ch04"},next:{title:"Chapter 6: Calling Procedures Defined Elsewhere",permalink:"/cql-guide/ch06"}},p={},c=[{value:"Statement Cursors",id:"statement-cursors",level:3},{value:"Value Cursors",id:"value-cursors",level:3},{value:"Benefits of using named typed to declare a cursor",id:"benefits-of-using-named-typed-to-declare-a-cursor",level:4},{value:"OUT Statement",id:"out-statement",level:3},{value:"OUT UNION Statement",id:"out-union-statement",level:3},{value:"Result Set Cursors",id:"result-set-cursors",level:3},{value:"Reshaping Data, Cursor <code>LIKE</code> forms",id:"reshaping-data-cursor-like-forms",level:3},{value:"Fetch Statement Specifics",id:"fetch-statement-specifics",level:3},{value:"Fetch with Statement or Result Set Cursors",id:"fetch-with-statement-or-result-set-cursors",level:4},{value:"Fetch with Value Cursors",id:"fetch-with-value-cursors",level:4},{value:"Calling Procedures with Argument Bundles",id:"calling-procedures-with-argument-bundles",level:3},{value:"Using Named Argument Bundles",id:"using-named-argument-bundles",level:3},{value:"The COLUMNS/LIKE construct in the SELECT statement",id:"the-columnslike-construct-in-the-select-statement",level:3},{value:"Columns from a join table or tables",id:"columns-from-a-join-table-or-tables",level:4},{value:"Columns from a particular joined table that match a shape",id:"columns-from-a-particular-joined-table-that-match-a-shape",level:4},{value:"Columns from any that match a shape, from anywhere in the FROM",id:"columns-from-any-that-match-a-shape-from-anywhere-in-the-from",level:4},{value:"Specific columns",id:"specific-columns",level:4},{value:"Distinct columns",id:"distinct-columns",level:4},{value:"Missing Data Columns, Nulls and Dummy Data",id:"missing-data-columns-nulls-and-dummy-data",level:3},{value:"Generalized Cursor Lifetimes aka Cursor &quot;Boxing&quot;",id:"generalized-cursor-lifetimes-aka-cursor-boxing",level:3}],m={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In the previous chapters we have used cursor variables without fully discussing them.\nMost of the uses are fairly self-evident but a more exhaustive discussion is also useful."),(0,o.kt)("p",null,"First there are three types of cursors, as we will see below."),(0,o.kt)("h3",{id:"statement-cursors"},"Statement Cursors"),(0,o.kt)("p",null,"A statement cursor is based on a SQL ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," statement.  A full example might look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"-- elsewhere\ncreate table xy_table(x integer, y integer);\n\ndeclare C cursor for select x, y from xy_table;\n")),(0,o.kt)("p",null,"When compiled, this will result in creating a SQLite statement object (type ",(0,o.kt)("inlineCode",{parentName:"p"},"sqlite_stmt *"),")\nand storing it in a variable called ",(0,o.kt)("inlineCode",{parentName:"p"},"C_stmt"),".  This statement can then be used later in various ways."),(0,o.kt)("p",null,"Here's perhaps the simplest way to use the cursor above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare x, y integer;\nfetch C into x, y;\n")),(0,o.kt)("p",null,"This will have the effect of reading one row from the results of the query into\nthe local variables ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,o.kt)("p",null,"These variables might then be used to create some output such as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'/* note use of double quotes so that \\n is legal */\ncall printf("x:%d y:%d\\n", ifnull(x, 0), ifnull(y,0));\n')),(0,o.kt)("p",null,"More generally, there the cursor may or may not be holding fetched values.\nThe cursor variable ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," can be used by itself as a boolean indicating the\npresence of a row.  So a more complete example might be"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'if C then\n  call printf("x:%d y:%d\\n", ifnull(x, 0), ifnull(y,0));\nelse\n  call printf("nada\\n");\nend if\n')),(0,o.kt)("p",null,"And even more generally"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'loop fetch C into x, y\nbegin\n  call printf("x:%d y:%d\\n", ifnull(x, 0), ifnull(y,0));\nend;\n')),(0,o.kt)("p",null,"The last example above reads all the rows and prints them."),(0,o.kt)("p",null,"Now if the table ",(0,o.kt)("inlineCode",{parentName:"p"},"xy_table")," had instead had dozens of columns, those declarations\nwould be very verbose and error prone, and frankly annoying, especially if\nthe table definition was changing over time."),(0,o.kt)("p",null,"To make this a little easier, there are so-called 'automatic' cursors.  These\nhappen implicitly and include all the necessary storage to exactly match\nthe rows in their statement.  Using the automatic syntax for the above looks like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from xy_table;\nfetch C;\nif C then\n  call printf("x:%d y:%d\\n", ifnull(C.x, 0), ifnull(C.y,0));\nend if;\n')),(0,o.kt)("p",null,"or the equivalent loop form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from xy_table;\nloop fetch C\nbegin\n  call printf("x:%d y:%d\\n", ifnull(C.x, 0), ifnull(C.y,0));\nend;\n')),(0,o.kt)("p",null,'All the necessary local state is automatically created, hence "automatic" cursor.\nThis pattern is generally preferred, but the loose variables pattern is in\nsome sense more general.'),(0,o.kt)("p",null,"In all the cases if the number or type of variables do not match the select statement,\nsemantic errors are produced."),(0,o.kt)("h3",{id:"value-cursors"},"Value Cursors"),(0,o.kt)("p",null,'The purpose of value cursors is to make it possible for a stored procedure to\nwork with structures as a unit rather than only field by field.  SQL doesn\'t have\nthe notion of structure types, but structures actually appear pretty directly\nin many places.  Generally we call these things "Shapes" and there are a variety\nof source for shapes including:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the columns of a table"),(0,o.kt)("li",{parentName:"ul"},"the projection of a ",(0,o.kt)("inlineCode",{parentName:"li"},"SELECT")," statement"),(0,o.kt)("li",{parentName:"ul"},"the columns of a cursor"),(0,o.kt)("li",{parentName:"ul"},"the result type of a procedure that returns a select"),(0,o.kt)("li",{parentName:"ul"},"the arguments of a procedure"),(0,o.kt)("li",{parentName:"ul"},"other things derived from the above")),(0,o.kt)("p",null,"Let's first start with how you declare a value cursor.  It is providing one of the\nshape sources above."),(0,o.kt)("p",null,"So:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare C cursor like xy_table;\ndeclare C cursor like select 1 a, 'x' b;\ndeclare C cursor like (a integer not null, b text not null);\ndeclare C cursor like my_view;\ndeclare C cursor like my_other_cursor;\ndeclare C cursor like my_previously_declared_stored_proc;\ndeclare C cursor like my_previously_declared_stored_proc arguments;\n")),(0,o.kt)("p",null,"Any of those forms define a valid set of columns -- a shape.  Note that the\n",(0,o.kt)("inlineCode",{parentName:"p"},"select")," example in no way causes the query provided to run. Instead, the select\nstatement is analyzed and the column names and types are computed.  The cursor\ngets the same field names and types.  Nothing happens at run time."),(0,o.kt)("p",null,"The last two examples assume that there is a stored procedure defined somewhere\nearlier in the same translation unit and that the procedure returns a result set\nor has arguments, respectively."),(0,o.kt)("p",null,"In all cases the cursor declaration makes a cursor that could hold the indicated result.\nThat result can then be loaded with ",(0,o.kt)("inlineCode",{parentName:"p"},"FETCH")," or emitted with ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," which\nwill be discussed below."),(0,o.kt)("p",null,"Once we have declared a value cursor we can load it with values using ",(0,o.kt)("inlineCode",{parentName:"p"},"FETCH")," in its\nvalue form. Here are some examples:"),(0,o.kt)("p",null,"Fetch from compatible values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"fetch C from values(1,2);\n")),(0,o.kt)("p",null,"Fetch from a call to a procedure that returns a single row:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"fetch C from call my_previously_declared_stored_proc();\n")),(0,o.kt)("p",null,"Fetch from another cursor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"fetch C from D;\n")),(0,o.kt)("p",null,'In this last case if D is a statement cursor it must also be "automatic" (i.e. it has\nthe storage).  This form lets you copy a row and save it for later.  For instance, in\na loop you could copy the current max-value row into a value cursor and use it after\nthe loop, like so:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare C cursor for select * from somewhere;\ndeclare D cursor like C;\n\nloop fetch C\nbegin\n  if (not D or D.something < C.something) then\n    fetch D from C;\n  end if;\nend;\n")),(0,o.kt)("p",null,"After the loop, D either empty because there were no rows (thus ",(0,o.kt)("inlineCode",{parentName:"p"},"if D")," would fail)\nor else it has the row with the maximum value of ",(0,o.kt)("inlineCode",{parentName:"p"},"something"),", whatever that is."),(0,o.kt)("p",null,'Value cursors are always have their own storage, so you could say all value cursors\nare "automatic".'),(0,o.kt)("p",null,"And as we saw above, value cursors may or may not be holding a row."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'declare C cursor like xy_table;\nif not C then\n  call printf("this will always print because C starts empty\\n");\nend if;\n')),(0,o.kt)("p",null,"When you call a procedure you may or may not get a row as we'll see below."),(0,o.kt)("p",null,"The third type of cursor is a \"result set\" cursor but that won't make any sense\nuntil we've discussed result sets a little which requires ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," and/or ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION"),"\nand so we'll go on to those statements next.  As it happens, we are recapitulating\nthe history of cursor features in the CQL language by exploring the system in this way."),(0,o.kt)("h4",{id:"benefits-of-using-named-typed-to-declare-a-cursor"},"Benefits of using named typed to declare a cursor"),(0,o.kt)("p",null,"This form allows any kind of declaration, for instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"declare C cursor like ( id integer not null, val real, flag boolean );\n")),(0,o.kt)("p",null,"This wouldn't really give us much more than the other forms, however typed name lists can include LIKE in them again, as part of the list.  Which means you can do this kind of thing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"declare C cursor like (like D, extra1 real, extra2 bool)\n")),(0,o.kt)("p",null,"You could then load that cursor like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"fetch C from values (from D, 2.5, false);\n")),(0,o.kt)("p",null,"and now you have D plus 2 more fields which maybe you want to output."),(0,o.kt)("p",null,"Importantly this way of doing it means that C always includes D, even if D changes over time.  As long as the ",(0,o.kt)("inlineCode",{parentName:"p"},"extra1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"extra2")," fields don't conflict names it will always work."),(0,o.kt)("h3",{id:"out-statement"},"OUT Statement"),(0,o.kt)("p",null,"Value cursors were initially designed to create a convenient way for\na procedure to return a single row from a complex query\nwithout having a crazy number of ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," parameters.  It's easiest\nto illustrate this with an example."),(0,o.kt)("p",null,'Suppose you want to return several variables, the "classic" way to do so\nwould be a procedure like this:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc get_a_row(\n  id_ integer not null,\n  out got_row bool not null,\n  out w integer not null,\n  out x integer,\n  out y text not null,\n  out z real)\nbegin\n  declare C cursor for\n    select w, x, y, z from somewhere where id = id_;\n  fetch C into w, x, y, z;\n  set got_row := C;\nend;\n")),(0,o.kt)("p",null,"This is already verbose, but you can imagine the situation gets very annoying\nif ",(0,o.kt)("inlineCode",{parentName:"p"},"get_a_row")," has to produce a couple dozen column values.  And of course you\nhave to get the types exactly right. And they might evolve over time.  Joy."),(0,o.kt)("p",null,"On the receiving side you get to do something just as annoying:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare w integer not null\ndeclare x integer;\ndeclare y text;\ndeclare z real;\ndeclare got_row bool not null;\ncall get_a_row(id, got_row, w, x, y, z);\n")),(0,o.kt)("p",null,"Using the ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," statement we get the equivalent functionality with a much\nsimplified pattern. It looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc get_a_row(id_ integer not null)\nbegin\n  declare C cursor for\n    select w, x, y, z from somewhere where id = id_;\n  fetch C;\n  out C;\nend;\n")),(0,o.kt)("p",null,"To use the new procedure you simply do this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare C cursor like get_a_row;\nfetch C from call get_a_row(id);\n")),(0,o.kt)("p",null,"In fact, originally you did the two steps above in one statement and that was the\nonly way to load a value cursor. Later, the calculus was generalized. The original\nform still works:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare C cursor fetch from call get_a_row(id);\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," statement lets you return a single row economically and\nlets you then test if there actually was a row and if so, read the columns.\nIt infers all the various column names and types so it is resilient\nto schema change and generally a lot less error prone than having a\nlarge number of ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," arguments to your procedure."),(0,o.kt)("p",null,"Once you have the result in a value cursor you can do the usual\ncursor operations to move it around or otherwise work with it."),(0,o.kt)("p",null,"The use of the ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," keyword to refer to groups of columns spread\nto other places in CQL as a very useful construct, but it began here\nwith the need to describe a cursor shape economically, by reference."),(0,o.kt)("h3",{id:"out-union-statement"},"OUT UNION Statement"),(0,o.kt)("p",null,"The semantics of the ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," statement are that it always produces one row\nof output (a procedure can produce no row if an ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," never actually rans\nbut the procedure does use ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT"),")."),(0,o.kt)("p",null,"If an ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," statement runs more than once, the most recent row becomes the\nresult.  So the ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," statement really does mirror having one ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," variable\nfor each output column.  This was its intent and procedures that return at most,\nor exactly, one row are very common so it works well enough."),(0,o.kt)("p",null,"However, in general, one row results do not suffice; you might want to produce a\nresult set from various sources, possibly with some computation as part of\nthe row creation process.  To make general results, you need to be able to emit\nmultiple rows from a computed source.  This is exactly what ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," provides."),(0,o.kt)("p",null,"Here's a (somewhat contrived) example of the kind of thing you can do with this form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc foo(n integer not null)\nbegin\n  declare C cursor like select 1 value;\n  let i := 0;\n  while i < n\n  begin\n     -- emit one row for every integer\n     fetch C from values(i);\n     out union C;\n     set i := i + 1;\n  end;\nend;\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," above, we make an entire result set out of thin air.  It isn't a very\ninteresting result, but of course any computation would have been possible."),(0,o.kt)("p",null,"This pattern is very flexible as we see below in ",(0,o.kt)("inlineCode",{parentName:"p"},"bar")," where\nwe merge two different data streams."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create table t1(id integer, stuff text, [other things too]);\ncreate table t2(id integer, stuff text, [other things too]);\n\ncreate proc bar()\nbegin\n  declare C cursor for select * from t1 order by id;\n  declare D cursor for select * from t2 order by id;\n\n  fetch C;\n  fetch D;\n\n  -- we're going to merge these two queries\n  while C or D\n  begin\n    -- if both have a row pick the smaller id\n    if C and D then\n       if C.id < D.id then\n         out union C;\n         fetch C;\n       else\n         out union D;\n         fetch D;\n       end if;\n    else if C then\n      -- only C has a row, emit that\n      out union C;\n      fetch C;\n    else\n      -- only D has a row, emit that\n      out union D;\n      fetch D;\n    end if;\n  end;\nend;\n")),(0,o.kt)("p",null,"Just like ",(0,o.kt)("inlineCode",{parentName:"p"},"foo"),", in ",(0,o.kt)("inlineCode",{parentName:"p"},"bar"),", each time ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," runs a new row is accumulated."),(0,o.kt)("p",null,"Now, if you build a procedure that ends with a ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," statement CQL automatically\ncreates a fetcher function that does something like an ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," loop -- it loops\nover the SQLite statement for the ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," and fetches each row, materializing a result."),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," you take manual control of this process, allowing you to build arbitrary\nresult sets.  Note that either of ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," above could have been modified, replaced,\nskipped, normalized, etc. with any kind of computation.  Even entirely synthetic rows can\nbe computed and inserted into the output as we saw in ",(0,o.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,o.kt)("h3",{id:"result-set-cursors"},"Result Set Cursors"),(0,o.kt)("p",null,"Now that we have ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," it makes sense to talk about the final type of cursor."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," makes it possible to create arbitrary result sets using a mix of sources\nand filtering.  Unfortunately this result type is not a simple row, nor is it a SQLite\nstatement.  This meant that neither of the existing types of cursors could hold the\nresult of a procedure that used ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION"),". -- CQL could not itself consume its own\nresults."),(0,o.kt)("p",null,"To address this hole, we need an additional cursor type.  The syntax is exactly the same\nas the statement cursor cases described above but, instead of holding a SQLite statement,\nthe cursor holds a result set pointer and the current and maximum row numbers.\nStepping through the cursor simply increments the row number and fetches the next row\nout of the rowset instead of from SQLite."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'-- reading the above\ncreate proc reader()\nbegin\n  declare C cursor for call bar();\n  loop fetch C\n  begin\n    call printf("%d %s\\n", C.id, C.stuff);  -- or whatever fields you need\n  end;\nend;\n')),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"bar")," had been created with a ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"UNION ALL"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"ORDER BY")," to merge the\nresults, the above would have worked with ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," being a standard statement cursor,\niterating over the union. Since ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," produces a result set, CQL transparently produces\na suitable cursor implementation behind the scenes, but otherwise the usage is the same."),(0,o.kt)("p",null,"Note this is a lousy way to simply iterate over rows; you have to materialize the entire\nresult set so that you can just step over it.  Re-consuming like this is not recommended\nat all for production code, but it is ideal for testing result sets that were made with\n",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," which otherwise would require C/C++ to test.  Testing CQL with CQL is\ngenerally a lot easier."),(0,o.kt)("h3",{id:"reshaping-data-cursor-like-forms"},"Reshaping Data, Cursor ",(0,o.kt)("inlineCode",{parentName:"h3"},"LIKE")," forms"),(0,o.kt)("p",null,"There are lots of cases where you have big rows with many columns, and there are various manipulations you might need to do."),(0,o.kt)("p",null,"What follows is a set of useful syntactic sugar constructs that simplify handling\ncomplex rows.  The idea is that pretty much anywhere you can specify a list of columns\nyou can instead use the ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE x")," construct to get the columns as they appear in the\nshape ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," -- which is usually a table or a cursor."),(0,o.kt)("p",null,"It\u2019s a lot easier to illustrate with examples, even though these are, again, a bit contrived."),(0,o.kt)("p",null,"First we need some table with lots of columns -- usually the column names are much bigger which makes it all the more important to not have to type them over and over, but\nin the interest of some brevity, here's a big table:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create table big (\n  id integer primary key,\n  id2 integer unique,\n  a integer,\n  b integer,\n  c integer,\n  d integer,\n  e integer,\n  f integer);\n")),(0,o.kt)("p",null,"This example showcases several of the cursor and shape slicing features by emitting\ntwo related rows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc foo(id_ integer not null)\nbegin\n  -- this is the shape of the result we want -- it's some of the columns of \"big\"\n  -- note this query doesn't run, we just use its shape to create a cursor\n  -- with those columns.\n  declare result cursor like select id, b, c, d from big;\n\n  -- fetch the main row, specified by id_\n  -- main row has all the fields, including id2\n  declare main_row cursor for select * from big where id = id_;\n  fetch main_row;\n\n  -- now fetch the result columns out of the main row\n  -- 'like result' means \"the column names found in 'result'\"\n  fetch result from cursor main_row(like result);\n\n  -- this is our first result row\n  out union result;\n\n  -- now we want the related row, but we only need two columns\n  -- from the related row, 'b' and 'c'\n  declare alt_row cursor for select b, c from big where big.id2 = main_row.id2;\n  fetch alt_row;\n\n  -- update some of the fields 'result' from the the new cursor\n  update cursor result(like alt_row) from cursor alt_row;\n\n  -- and emit the 2nd row\n  out union result;\nend;\n")),(0,o.kt)("p",null,"Now let's briefly discuss what is above.  The two essential parts are:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"fetch result from cursor main_row(like result);")),(0,o.kt)("p",null,"and"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"update cursor result(like alt_row) from cursor alt_row;")),(0,o.kt)("p",null,"In the first case what we're saying is that we want to load the columns\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"main_row")," but we only want to take the columns that are\nactually present in ",(0,o.kt)("inlineCode",{parentName:"p"},"result"),".  So this is a narrowing of a wide row into a\nsmaller row.  In this case, the smaller row, ",(0,o.kt)("inlineCode",{parentName:"p"},"result"),", is what we want to emit.\nWe needed the other columns to compute ",(0,o.kt)("inlineCode",{parentName:"p"},"alt_row"),"."),(0,o.kt)("p",null,"The second case, what we're saying is that we want to update ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," by\nreplacing the columns found in ",(0,o.kt)("inlineCode",{parentName:"p"},"alt_row")," with the values in ",(0,o.kt)("inlineCode",{parentName:"p"},"alt_row"),".\nSo in this case we're writing a smaller cursor into part of a wider cursor.\nNote that we used the ",(0,o.kt)("inlineCode",{parentName:"p"},"update cursor")," form here because it preserves all other\ncolumns.  If we used ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch")," we would be rewriting the entire row contents,\nusing ",(0,o.kt)("inlineCode",{parentName:"p"},"NULL")," if necessary, and that is not desired here."),(0,o.kt)("p",null,"Here is the rewritten version of the above procedure; this is what ultimately gets\ncompiled into C."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROC foo (id_ INTEGER NOT NULL)\nBEGIN\n  DECLARE result CURSOR LIKE SELECT id, b, c, d FROM big;\n  DECLARE main_row CURSOR FOR SELECT * FROM big WHERE id = id_;\n  FETCH main_row;\n\n  FETCH result(id, b, c, d)\n    FROM VALUES(main_row.id, main_row.b, main_row.c, main_row.d);\n  OUT UNION result;\n\n  DECLARE alt_row CURSOR FOR SELECT b, c FROM big WHERE big.id2 = main_row.id2;\n  FETCH alt_row;\n\n  UPDATE CURSOR result(b, c) FROM VALUES(alt_row.b, alt_row.c);\n  OUT UNION result;\nEND;\n")),(0,o.kt)("p",null,"Of course you could have typed the above directly but if there are 50 odd columns it\ngets old fast and is very error prone.  The sugar form is going to be 100% correct\nand will require much less typing and maintenance."),(0,o.kt)("p",null,"Finally, while I've shown both ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," forms separately, they can also be used together.  For instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"  update cursor C(like X) from cursor D(like X);\n")),(0,o.kt)("p",null,'The above would mean, "move the columns that are found in ',(0,o.kt)("inlineCode",{parentName:"p"},"X")," from cursor ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," to cursor ",(0,o.kt)("inlineCode",{parentName:"p"},"C"),'", presuming ',(0,o.kt)("inlineCode",{parentName:"p"},"X")," has columns common to both."),(0,o.kt)("h3",{id:"fetch-statement-specifics"},"Fetch Statement Specifics"),(0,o.kt)("p",null,"Many of the examples used the ",(0,o.kt)("inlineCode",{parentName:"p"},"FETCH")," statement in a sort of demonstrative way that is\nhopefully self-evident but the statement has many forms and so it's worth going over\nthem specifically.  Below we'll use the letters ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," for the names of cursors.  Usually ",(0,o.kt)("inlineCode",{parentName:"p"},"C"),";"),(0,o.kt)("h4",{id:"fetch-with-statement-or-result-set-cursors"},"Fetch with Statement or Result Set Cursors"),(0,o.kt)("p",null,"A cursor declared in one of these forms:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"declare C cursor for select * from foo;")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"declare C cursor for call foo();"),"  (foo might end with a ",(0,o.kt)("inlineCode",{parentName:"li"},"select")," or use ",(0,o.kt)("inlineCode",{parentName:"li"},"out union"),")")),(0,o.kt)("p",null,"is either a statement cursor or a result set cursor.  In either case the cursor moves\nthrough the results.  You load the next row with:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"FETCH C"),", or"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"FETCH C into x, y, z;"))),(0,o.kt)("p",null,"In the first form ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," is said to be ",(0,o.kt)("em",{parentName:"p"},"automatic")," in that it automatically declares the storage needed to hold all its columns.  As mentioned above, automatic cursors have\nstorage for their row."),(0,o.kt)("p",null,"Having done this fetch you can use C as a scalar variable to see if it holds a row, e.g."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from foo limit 1;\nfetch C;\nif C then\n  -- bingo we have a row\n  call printf("%s\\n", C.whatever);\nend if\n')),(0,o.kt)("p",null,"You can easily iterate, e.g."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from foo;\nloop fetch C\nbegin\n  -- one time for every row\n  call printf("%s\\n", C.whatever);\nend;\n')),(0,o.kt)("p",null,"Automatic cursors are so much easier to use than explicit storage that explicit storage\nis rarely seen.  Storing to ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," parameters is one case where explicit storage actually\nis the right choice, as the ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," parameters have to be declared anyway."),(0,o.kt)("h4",{id:"fetch-with-value-cursors"},"Fetch with Value Cursors"),(0,o.kt)("p",null," A value cursor is declared in one of these ways:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"declare C cursor fetch from call foo(args)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"foo")," must be a procedure that returns one row with ",(0,o.kt)("inlineCode",{parentName:"li"},"OUT")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},'declare C cursor like select 1 id, "x" name;'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"declare C cursor like X;")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"where X is the name of a table, a view, another cursor, or a procedure that returns a structured result")),(0,o.kt)("p",{parentName:"li"},"A value cursor is ",(0,o.kt)("em",{parentName:"p"},"always")," automatic; it's purpose is to hold a row.  It doesn't iterate over anything but it can be re-loaded in a loop.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch C into ...")," is not valid on such a cursor, because it doesn't have a source to step through."),(0,o.kt)("p",{parentName:"li"},"The canonical way to load such a cursor is:")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C from call foo(args);")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"foo")," must be a procedure that returns one row with ",(0,o.kt)("inlineCode",{parentName:"li"},"OUT")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C(a,b,c...) from values(x, y, z);")))),(0,o.kt)("p",null,"The first form is in some sense the origin of the value cursor.  Value cursors were added to the language initially to provide a way to capture the single row ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," statement results, much like result set cursors were added to capture procedure results from ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION"),".  In the first form, the cursor storage (a C struct) is provided by reference as a hidden out parameter to the procedure and the procedure fills it in.  The procedure may or may not use the ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," statement in its control flow, as the cursor might not hold a row.  You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"if C then ...")," as before to test for a row."),(0,o.kt)("p",null,"The second form is more interesting as it allows the cursor to be loaded from arbitrary expressions subject to some rules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"you should think of the cursor as a logical row: it's either fully loaded or it's not, therefore you must specify enough columns in the column list to ensure that all ",(0,o.kt)("inlineCode",{parentName:"li"},"NOT NULL")," columns will get a value"),(0,o.kt)("li",{parentName:"ul"},"if not mentioned in the list, NULL will be loaded where possible"),(0,o.kt)("li",{parentName:"ul"},"if insufficient columns are named, an error is generated"),(0,o.kt)("li",{parentName:"ul"},"if the value types specified are not compatible with the column types mentioned, an error is generated"),(0,o.kt)("li",{parentName:"ul"},"later in this chapter, we'll show that columns can also be filled with dummy data using a seed value")),(0,o.kt)("p",null,"With this form, any possible valid cursor values could be set, but many forms of updates\nthat are common would be awkward. So there are various forms of syntactic sugar that are\nautomatically rewritten into the canonical form.  See the examples below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C from values(x, y, z)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"if no columns are specified this is the same as naming all the columns, in declared order"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C from arguments")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the arguments to the procedure in which this statement appears are used as the values, in order"),(0,o.kt)("li",{parentName:"ul"},"in this case ",(0,o.kt)("inlineCode",{parentName:"li"},"C")," was also rewritten into ",(0,o.kt)("inlineCode",{parentName:"li"},"C(a,b,c,..)")," etc."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C from arguments like C")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the arguments to the procedure in which this statement appears are used, by name, as the values, using the names of of the indicated shape"),(0,o.kt)("li",{parentName:"ul"},"the order in which the arguments appeared no longer matters, the names that match the columns of C are used if present"),(0,o.kt)("li",{parentName:"ul"},"the formal parameter name may have a single trailing underscore (this is what ",(0,o.kt)("inlineCode",{parentName:"li"},"like C")," would generate)"),(0,o.kt)("li",{parentName:"ul"},"e.g. if ",(0,o.kt)("inlineCode",{parentName:"li"},"C")," has columns ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"b")," then there must exist formals named ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"a_")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"b")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"b_"),", in any position"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C(a,b) from cursor D(a,b)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the named columns of D are used as the values"),(0,o.kt)("li",{parentName:"ul"},"in this case the statement becomes: ",(0,o.kt)("inlineCode",{parentName:"li"},"fetch C(a,b) from values(D.a, D.b);"))))),(0,o.kt)("p",null,"That most recent form doesn't seem like it saves much, but recall the first rewrite:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C from cursor D")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"both cursors are expanded into all their columns, creating a copy from one to the other"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"fetch C from D")," can be used if the cursors have the exact same column names and types; it also generates slightly better code and is a common case")),(0,o.kt)("p",{parentName:"li"},"It is very normal to want to use only some of the columns of a cursor; these ",(0,o.kt)("inlineCode",{parentName:"p"},"like")," forms do that job.  We saw some of these forms in an earlier example.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C from cursor D(like C)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"here ",(0,o.kt)("inlineCode",{parentName:"li"},"D"),' is presumed to be "bigger" than ',(0,o.kt)("inlineCode",{parentName:"li"},"C"),", in that it has all of the ",(0,o.kt)("inlineCode",{parentName:"li"},"C")," columns and maybe more.  The ",(0,o.kt)("inlineCode",{parentName:"li"},"like C")," expands into the names of the ",(0,o.kt)("inlineCode",{parentName:"li"},"C")," columns so ",(0,o.kt)("inlineCode",{parentName:"li"},"C")," is loaded from the ",(0,o.kt)("inlineCode",{parentName:"li"},"C")," part of ",(0,o.kt)("inlineCode",{parentName:"li"},"D")),(0,o.kt)("li",{parentName:"ul"},"the expansion might be ",(0,o.kt)("inlineCode",{parentName:"li"},"fetch C(a, b, g) from values (D.a, D.b, D.g)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"D")," might have had fields ",(0,o.kt)("inlineCode",{parentName:"li"},"c, d, e, f")," which were not used because they are not in ",(0,o.kt)("inlineCode",{parentName:"li"},"C"),".")),(0,o.kt)("p",{parentName:"li"},"The symmetric operation, loading some of the columns of a wider cursor can be expressed neatly:")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C(like D) from cursor D")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"like D")," expands into the columns of ",(0,o.kt)("inlineCode",{parentName:"li"},"D")," causing the cursor to be loaded with what's in ",(0,o.kt)("inlineCode",{parentName:"li"},"D")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"NULL")," (if needed)"),(0,o.kt)("li",{parentName:"ul"},"when expanded, this might look like ",(0,o.kt)("inlineCode",{parentName:"li"},"fetch C(x, y) from values(D.x, D.y)"))))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," can be used in both places, for instance suppose ",(0,o.kt)("inlineCode",{parentName:"p"},"E")," is a shape that has a subset of the rows of both ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"D"),".  You can write a form like this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"fetch C(like E) from cursor D(like E)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"this means take the column names found in ",(0,o.kt)("inlineCode",{parentName:"li"},"E")," and copy them from D to C."),(0,o.kt)("li",{parentName:"ul"},"the usual type checking is done")),(0,o.kt)("p",{parentName:"li"},"As is mentioned above, the ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch"),' form means "load an entire row into the cursor". This\nis important because "half loaded" cursors would be semantically problematic.  However\nthere are many cases where you might like to amend the values of an already loaded\ncursor.  You can do this with the ',(0,o.kt)("inlineCode",{parentName:"p"},"update")," form.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"update cursor C(a,b,..) from values(1,2,..);")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the update form is a no-op if the cursor is not already loaded with values (!!)"),(0,o.kt)("li",{parentName:"ul"},"the columns and values are type checked so a valid row is ensured (or no row)"),(0,o.kt)("li",{parentName:"ul"},"all the re-writes above are legal so ",(0,o.kt)("inlineCode",{parentName:"li"},"update cursor C(like D) from D")," is possible; it is in fact the use-case for which this was designed.")))),(0,o.kt)("h3",{id:"calling-procedures-with-argument-bundles"},"Calling Procedures with Argument Bundles"),(0,o.kt)("p",null,"It's often desirable to treat bundles of arguments as a unit, or cursors as a unit, especially when calling other procedures.  The shape patterns above are very helpful\nfor moving data between cursors, and the database.  These can be rounded out with\nsimilar constructs for procedure definitions and procedure calls as follows."),(0,o.kt)("p",null,"First we'll define some shapes to use in the examples.  Note that we made ",(0,o.kt)("inlineCode",{parentName:"p"},"U")," using ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create table T(x integer not null, y integer not null,  z integer not null);\ncreate table U(like T, a integer not null, b integer not null);\n")),(0,o.kt)("p",null,"We haven't mentioned this before but the implication of the above is that you can\nuse the ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," construct inside a table definition to add columns from a shape."),(0,o.kt)("p",null,"We can also use the ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," construct to create procedure arguments.  To avoid conflicts\nwith column names, when used this way the procedure arguments all get a trailing\nunderscore appended to them.  The arguments will be ",(0,o.kt)("inlineCode",{parentName:"p"},"x_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"y_"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"z_")," as we can\nsee if the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'create proc p1(like T)\nbegin\n  call printf("%d %d %d\\n", x_, y_, z_);\nend;\n')),(0,o.kt)("p",null,"Shapes can also be used in a procedure call, as showed below. This next example is\nobviously contrived, but of course it generalizes. It is exactly equivalent to the above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'create proc p2(like T)\nbegin\n  call printf("%d %d %d\\n", from arguments);\nend;\n')),(0,o.kt)("p",null,"Now we might want to chain these things together.  This next example uses a cursor to\ncall ",(0,o.kt)("inlineCode",{parentName:"p"},"p1"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc q1()\nbegin\n declare C cursor for select * from T;\n loop fetch C\n begin\n   /* this is the same as call p(C.x, C.y, C.z) */\n   call p1(from C);\n end;\nend;\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"like")," construct allows you to select some of the arguments, or\nsome of a cursor to use as arguments.  This next procedure has more arguments\nthan just ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),". The arguments will be ",(0,o.kt)("inlineCode",{parentName:"p"},"x_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"y_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"z_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"a_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"b_"),".  But the\ncall will still have the ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," arguments ",(0,o.kt)("inlineCode",{parentName:"p"},"x_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"y_"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"z_"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc q2(like U)\nbegin\n  /* just the args that match T: so this is still call p(x_, y_, z_) */\n  call p1(from arguments like T);\nend;\n")),(0,o.kt)("p",null,"Or similarly, using a cursor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc q3(like U)\nbegin\n declare C cursor for select * from U;\n loop fetch C\n begin\n  /* just the columns that match T so this is still call p(C.x, C.y, C.z) */\n  call p1(from C like T);\n end;\nend;\n")),(0,o.kt)("p",null,"Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," argument forms do not have to be all the arguments.  For instance\nyou can get columns from two cursors like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"  call something(from C, from D)\n")),(0,o.kt)("p",null,"All the varieties can be combined but of course the procedure signature must match.  And\nall these forms work in function expressions as well as procedure calls."),(0,o.kt)("p",null,"e.g."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"  set x := a_function(from C);\n")),(0,o.kt)("p",null,"Since these forms are simply syntatic sugar, they can also appear inside of function calls\nthat are in SQL statements. The variables mentioned will be expanded and become bound\nvariables just like any other variable that appears in a SQL statement."),(0,o.kt)("p",null,"Note the form ",(0,o.kt)("inlineCode",{parentName:"p"},"x IN (from arguments)")," is not supported at this time, though this would be\na relatively easy addition."),(0,o.kt)("h3",{id:"using-named-argument-bundles"},"Using Named Argument Bundles"),(0,o.kt)("p",null,"There are many cases where stored procedures require complex arguments using data shapes\nthat come from the schema, or from other procedures.  As we have seen the ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," construct\nfor arguments can help with this, but it has some limitations. Let's consider a specific\nexample to study:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create table Person (\n  id text primary key,\n  name text not null,\n  address text not null,\n  birthday real\n);\n")),(0,o.kt)("p",null,"To manage this table we might need something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc insert_person(like Person)\nbegin\n  insert into Person from arguments;\nend;\n")),(0,o.kt)("p",null,"As we have seen, the above expands into:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc insert_person(\n  id_ text not null,\n  name_ text not null,\n  address_ text not null,\n  birthday_ real)\nbegin\n  insert into Person(id, name, address, birthday)\n    values(id_, name_, address_, birthday_);\nend;\n")),(0,o.kt)("p",null,"It's clear that the sugared version is a lot easier to reason about than the\nfully expanded version, and much less prone to errors as well."),(0,o.kt)("p",null,"This much is already helpful, but just those forms aren't general enough to handle\nthe usual mix of situations.  For instance, what if we need a procedure that works\nwith two people? A hypothetical ",(0,o.kt)("inlineCode",{parentName:"p"},"insert_two_people")," procedure cannot be written with\nthe forms we have so far."),(0,o.kt)("p",null,"To generalize this the language adds the notion of named argument bundles. The idea here\nis to name the bundles which provides a useful scoping.  Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc insert_two_people(p1 like Person, p2 like Person)\nbegin\n  -- using a procedure that takes a Person args\n  call insert_person(from p1);\n  call insert_person(from p2);\nend;\n")),(0,o.kt)("p",null,"or alternatively"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc insert_two_people(p1 like Person, p2 like Person)\nbegin\n  -- inserting a Person directly\n  insert into Person from p1;\n  insert into Person from p2;\nend;\n")),(0,o.kt)("p",null,"The above expands into:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create proc insert_two_people(\n  p1_id text not null,\n  p1_name text not null,\n  p1_address text not null,\n  p1_birthday real,\n  p2_id text not null,\n  p2_name text not null,\n  p2_address text not null,\n  p2_birthday real)\nbegin\n  insert into Person(id, name, address, birthday)\n    values(p1_id, p1_name, p1_address, p1_birthday);\n  insert into Person(id, name, address, birthday)\n    values(p2_id, p2_name, p2_address, p2_birthday);\nend;\n")),(0,o.kt)("p",null,"Or course different named bundles can have different types -- you can create and name\nshapes of your choice.  The language allows you to use an argument bundle name in all\nthe places that a cursor was previously a valid source.  That includes ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"fetch"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"update cursor"),", and procedure calls.  You can refer to the arguments by\ntheir expanded name such as ",(0,o.kt)("inlineCode",{parentName:"p"},"p1_address")," or alternatively ",(0,o.kt)("inlineCode",{parentName:"p"},"p1.address")," -- they mean\nthe same thing."),(0,o.kt)("p",null,"Here's another example showing a silly but illustrative thing you could do:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'create proc insert_lotsa_people(P like Person)\nbegin\n  -- make a cursor to hold the arguments\n  declare C cursor like P;\n\n  -- convert arguments to a cursor\n  fetch C from P;\n\n  -- set up to patch the cursor and use it 20 times\n  let i := 0;\n  while i < 20\n  begin\n    update cursor C(id) from values(printf("id_%d", i));\n    insert into Person from C;\n    set i := i + 1;\n  end;\nend;\n')),(0,o.kt)("p",null,"The above shows that you can use a bundle as the source of a shape, and you can\nuse a bundle as a source of data to load a cursor.  After which you can do all the\nusual value cursor things.  Of course in this case the value cursor was redundant,\nwe could just as easily have done something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'  set P_id := printf("id_%d", i);\n  insert into Person from P;\n  set i := i + 1;\n')),(0,o.kt)("p",null,"Note: the CQL JSON output includes extra information about procedure arguments\nif they originated as part of a shape bundle do identify the shape source\nfor tools that might need that information."),(0,o.kt)("h3",{id:"the-columnslike-construct-in-the-select-statement"},"The COLUMNS/LIKE construct in the SELECT statement"),(0,o.kt)("p",null,"The select list of a ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," statement already has complex syntax and functionality,\nbut it is a very interesting place to use shapes.  To make it possible to use\nshape notations and not confuse them with standard SQL the ",(0,o.kt)("inlineCode",{parentName:"p"},"COLUMNS")," construct was\nadded to the language.  This allows for a sugared syntax for extracting columns in bulk."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"COLUMNS")," clause is like of a generalization of the ",(0,o.kt)("inlineCode",{parentName:"p"},"select T.*")," with shape slicing and type-checking.  The forms are discussed below:"),(0,o.kt)("h4",{id:"columns-from-a-join-table-or-tables"},"Columns from a join table or tables"),(0,o.kt)("p",null,"This is the simplest form, it's just like ",(0,o.kt)("inlineCode",{parentName:"p"},"T.*"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- same as A.*\nselect columns(A) from ...;\n\n-- same as A.*, B.*\nselect columns(A, B) from ...;\n")),(0,o.kt)("h4",{id:"columns-from-a-particular-joined-table-that-match-a-shape"},"Columns from a particular joined table that match a shape"),(0,o.kt)("p",null,"This allows you to choose some of the columns of one table of the FROM clause."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- the columns of A that match the shape Foo\nselect columns(A like Foo) from ...;\n\n-- get the Foo shape from A and the Far shape from B\nselect columns(A like Foo, B like Bar) from ...;\n")),(0,o.kt)("h4",{id:"columns-from-any-that-match-a-shape-from-anywhere-in-the-from"},"Columns from any that match a shape, from anywhere in the FROM"),(0,o.kt)("p",null,"Here we do not specify a particular table that contains the columns,\nthe could come from any of the tables in the FROM clause."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"--- get the Foo shape from anywhere in the join\nselect columns(like Foo) from ...;\n\n-- get the Foo and Bar shapes, from anywhere in the join\nselect columns(like Foo, like Bar) from ...;\n")),(0,o.kt)("h4",{id:"specific-columns"},"Specific columns"),(0,o.kt)("p",null,"This form allows you to slice out a few columns without defining a shape, you\nsimply list the exact columns you want."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- T1.x and T2.y plus the Foo shape\nselect columns(T1.x, T2.y, like Foo) from ...;\n")),(0,o.kt)("h4",{id:"distinct-columns"},"Distinct columns"),(0,o.kt)("p",null,"Its often the case that there are duplicate column names in the ",(0,o.kt)("inlineCode",{parentName:"p"},"FROM")," clause.\nFor instance, you could join ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," with both having a column ",(0,o.kt)("inlineCode",{parentName:"p"},"pk"),". The\nfinal result set can only have one column named ",(0,o.kt)("inlineCode",{parentName:"p"},"pk"),", the distinct clause\nhelps you to get distinct column names.  In this context ",(0,o.kt)("inlineCode",{parentName:"p"},"distinct")," is about\ncolumn names, not values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- removes duplicate column names\n-- e.g. there will be one copy of 'pk'\nselect columns(distinct A, B) from A join B using(pk);\n\n-- if both Foo and Bar have an (e.g.) 'id' field you only get one copy\nselect columns(distinct like Foo, like Bar) from ...;\n")),(0,o.kt)("p",null,"If a specific column is mentioned it is always included, but later expressions\nthat are not a specific column will avoid that column name."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- if F or B has an x it won't appear again, just T.x\nselect columns(distinct T.x, F like Foo, B like Bar) from F, B ..;\n")),(0,o.kt)("p",null,"Of course this is all just sugar, so it all compiles to a column list with table\nqualifications -- but the syntax is very powerful.  You can easily narrowin a\nwide table, or fusing joins that share common keys."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- just the Foo columns\nselect columns(like Foo) from Superset_Of_Foo_From_Many_Joins_Even;\n\n-- only one copy of 'pk'\nselect columns(distinct A,B,C) from\n  A join B using (pk) join C using (pk);\n")),(0,o.kt)("p",null,'And of course you can define shapes however you like and then use them\nto slice off column chucks of your choice.  There are many ways to build\nup shapes from other shapes.  For instance, you can declare procedures\nthat return the shape you want and never actually create the procedure --\na pattern is very much like a shape "typedef".  E.g.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"declare proc shape1() (x integer, y real, z text);\ndeclare proc shape2() (like shape1, u bool, v bool);\n")),(0,o.kt)("p",null,"With this combination you can easily define common column shapes and slice them\nout of complex queries without having to type the columns names over and over."),(0,o.kt)("h3",{id:"missing-data-columns-nulls-and-dummy-data"},"Missing Data Columns, Nulls and Dummy Data"),(0,o.kt)("p",null,"What follows are the rules for columns that are missing in an ",(0,o.kt)("inlineCode",{parentName:"p"},"INSERT"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"FETCH")," statement. As with many of the other things discussed here, the forms result in\nautomatic rewriting of the code to include the specified dummy data.  So SQLite\nwill never see these forms."),(0,o.kt)("p",null,"Two things to note: First, the dummy data options described below are really only interesting in test code, it's hard to imagine them being useful in production code.\nSecond, none of what follows applies to the ",(0,o.kt)("inlineCode",{parentName:"p"},"update cursor")," statement because its\npurpose is to do partial updates on exactly the specified columns and we're about to\ntalk about what happens with the columns that were not specified."),(0,o.kt)("p",null,"When fetching a row all the columns must come from somewhere; if the column is\nmentioned or mentioned by rewrite then it must have a value mentioned, or a value\nmentioned by rewrite. For columns that are not mentioned, a NULL value is used if\nit is legal to do so.  For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch C(a) from values(1)")," might turn into ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch C(a,b,c,d) from values (1, NULL, NULL, NULL)")),(0,o.kt)("p",null,"In addition to the automatic NULL you may add the annotation ",(0,o.kt)("inlineCode",{parentName:"p"},"@dummy_seed([long integer expression])"),". If this annotion is present then:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the expression is evaluated and stored in the hidden variable ",(0,o.kt)("em",{parentName:"li"},"seed")),(0,o.kt)("li",{parentName:"ul"},"all integers, and long integers get ",(0,o.kt)("em",{parentName:"li"},"seed")," as their value (possibly truncated)"),(0,o.kt)("li",{parentName:"ul"},"booleans get 1 if and only if ",(0,o.kt)("em",{parentName:"li"},"seed")," is non-zero"),(0,o.kt)("li",{parentName:"ul"},'strings get the name of the string column an underscore and the value as text (e.g.   "myText',(0,o.kt)("em",{parentName:"li"},'7" if _seed')," is 7)"),(0,o.kt)("li",{parentName:"ul"},"blobs are not currently supported for dummy data (CQL is missing blob conversions which are needed first)")),(0,o.kt)("p",null,"This construct is hugely powerful in a loop to create many complete rows with very little effort, even if the schema change over time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare i integer not null;\ndeclare C like my_table;\nset i := 0;\nwhile (i < 20)\nbegin\n   fetch C(id) from values(i+10000) @dummy_seed(i);\n   insert into my_table from cursor C;\nend;\n")),(0,o.kt)("p",null,"Now in this example we don't need to know anything about ",(0,o.kt)("inlineCode",{parentName:"p"},"my_table")," other than that it has a column named ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),". This example shows several things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"we got the shape of the cursor from the table we were inserting into"),(0,o.kt)("li",{parentName:"ul"},"you can do your own computation for some of the columns (those named) and leave the unnamed values to be defaulted"),(0,o.kt)("li",{parentName:"ul"},"the rewrites mentioned above work for the ",(0,o.kt)("inlineCode",{parentName:"li"},"insert")," statement as well as ",(0,o.kt)("inlineCode",{parentName:"li"},"fetch")),(0,o.kt)("li",{parentName:"ul"},"in fact ",(0,o.kt)("inlineCode",{parentName:"li"},"insert into my_table(id) values(i+10000) @dummy_seed(i)")," would have worked too with no cursor at all",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"bonus, dummy blob data does work in insert statements because SQLite can do the string conversion easily"),(0,o.kt)("li",{parentName:"ul"},"the dummy value for a blob is a blob that holds the text of the column name and the text of the seed just like a string column")))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@dummy_seed")," form can be modified with ",(0,o.kt)("inlineCode",{parentName:"p"},"@dummy_nullables"),", this indicates that rather than using NULL for any nullable value that is missing, CQL should use the seed value.  This overrides the default behavior of using NULL where columns are needed.  Note the NULL filling works a little differently on insert statements.  Since SQLite will provide a NULL if one is legal the column doesn't have to be added to the list with a NULL value during rewriting, it can simply be omitted, making the statement smaller."),(0,o.kt)("p",null,"Finally for ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," statement only, SQLite will normally use the default value of a column if it has one, so there is no need to add missing columns with default values to the insert statement.  However if you specify ",(0,o.kt)("inlineCode",{parentName:"p"},"@dummy_defaults")," then columns with a default value will instead be rewritten and they will get ",(0,o.kt)("inlineCode",{parentName:"p"},"_seed_")," as their value."),(0,o.kt)("p",null,"Some examples.  Suppose columns a, b, c are not null;  m, n are nullable; and x, y have defaults."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- as written\ninsert into my_table(a) values(7) @dummy_seed(1000)\n-- rewrites to\ninsert into my_table(a, b, c) values(7, 1000, 1000);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- as written\ninsert into my_table(a) values(7) @dummy_seed(1000) @dummy_nullables\n-- rewrites to\ninsert into my_table(a, b, c, m, n) values(7, 1000, 1000, 1000, 1000);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-- as written\ninsert into my_table(a) values(7) @dummy_seed(1000) @dummy_nullables @dummy_defaults\n-- rewrites to\ninsert into my_table(a, b, c, m, n, x, y) values(7, 1000, 1000, 1000, 1000, 1000, 1000);\n")),(0,o.kt)("p",null,"The sugar features on ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"update cursor")," are as symmetric as possible, but again, dummy data is generally only interesting in test code. Dummy  data will continue to give you valid test rows even if columns are added or removed from the tables in question."),(0,o.kt)("h3",{id:"generalized-cursor-lifetimes-aka-cursor-boxing"},'Generalized Cursor Lifetimes aka Cursor "Boxing"'),(0,o.kt)("p",null,'Generalized Cursor Lifetime refers to capturing a Statement Cursor in an object so that it can used more flexibly.  Wrapping something\nin an object is often called "boxing".  Since Generalized Cursor Lifetime is a mouthful we\'ll refer to it as "boxing"\nfrom here forward. The symmetric operation "unboxing" refers to converting the boxed object back into a cursor.'),(0,o.kt)("p",null,"The normal cursor usage pattern is by far the most common, a cursor is created directly with something like\nthese forms:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare C cursor for select * from shape_source;\n\ndeclare D cursor for call proc_that_returns_a_shape();\n")),(0,o.kt)("p",null,"At this point the cursor can be used normally as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"loop fetch C\nbegin\n  -- do stuff with C\nend;\n")),(0,o.kt)("p",null,'Those are the usual patterns and they allow statement cursors to be consumed sort of "up" the call chain from where the cursor was created.\nBut what if you want some worker procedures that consume a cursor? There is no way to pass your cursor down again with these normal patterns alone.'),(0,o.kt)("p",null,"To generalize the patterns, allowing, for instance, a cursor to be returned as an out parameter or accepted as\nan in parameter you first need to declare an object variable that can hold the cursor and has a type indicating\nthe shape of the cursor."),(0,o.kt)("p",null,"To make an object that can hold a cursor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare obj object<T cursor>;\n")),(0,o.kt)("p",null,"Where ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," is the name of a shape. It can be a table name, or a view name, or it can be the name of the canonical procedure that returns the result.\nT should be some kind of global name, something that could be accessed with ",(0,o.kt)("inlineCode",{parentName:"p"},"#include")," in various places.\nReferring to the examples above, choices for ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," might be ",(0,o.kt)("inlineCode",{parentName:"p"},"shape_source")," the table or ",(0,o.kt)("inlineCode",{parentName:"p"},"proc_that_returns_a_shape")," the procedure."),(0,o.kt)("p",null,'Note: it\'s always possible make a fake procedure that returns a result to sort of "typedef" a shape name.  e.g.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"declare proc my_shape() (id integer not null, name text);\n")),(0,o.kt)("p",null,"The procedure here ",(0,o.kt)("inlineCode",{parentName:"p"},"my_shape")," doesn\u2019t have to actually ever be created, in fact it\u2019s better if it isn't.  It won\u2019t ever be called;\nits hypothetical result is just being as a shape.  This can be useful if you have several procedures like ",(0,o.kt)("inlineCode",{parentName:"p"},"proc_that_returns_a_shape"),"\nthat all return results with the columns of ",(0,o.kt)("inlineCode",{parentName:"p"},"my_shape"),"."),(0,o.kt)("p",null,"To create the boxed cursor, first declare the object variable that will hold it and then set object from the cursor.\nNote that in the following example the cursor ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," must have the shape defined by ",(0,o.kt)("inlineCode",{parentName:"p"},"my_shape")," or an error is produced.\nThe type of the object is crucial because, as we'll see, during unboxing that type defines the shape\nof the unboxed cursor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"-- recap: declare the box that holds the cursor (T changed to my_shape for this example)\ndeclare box_obj object<my_shape cursor>;\n\n-- box the cursor into the object (the cursor shape must match the box shape)\nset box_obj from cursor C;\n")),(0,o.kt)("p",null,"The variable ",(0,o.kt)("inlineCode",{parentName:"p"},"box_obj")," can now be passed around as usual.  It could be stored in a suitable ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," variable\nor it could be passed to a procedure as an ",(0,o.kt)("inlineCode",{parentName:"p"},"in"),' parameter.  Then, later, you can "unbox" ',(0,o.kt)("inlineCode",{parentName:"p"},"box_obj")," to get a\ncursor back. Like so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"-- unboxing a cursor from an object, the type of box_obj defines the type of the created cursor\ndeclare D cursor for box_obj;\n")),(0,o.kt)("p",null,"These primitives will allow cursors to be passed around with general purpose lifetime."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"-- consumes a cursor\ncreate proc cursor_user(box_obj object<my_shape cursor>)\nbegin\n   declare C cursor for box_obj;  -- the cursors shape will be my_shape matching box\n   loop fetch C\n   begin\n      -- do something with C\n   end;\nend;\n\n-- captures a cursor and passes it on\ncreate proc cursor_boxer()\nbegin\n   declare C cursor for select * from something_like_my_shape;\n   declare box_obj object<my_shape cursor>\n   set box from cursor C; -- produces error if shape doesn't match\n   call cursor_user(box_obj);\nend;\n")),(0,o.kt)("p",null,"Importantly, once you box a cursor the underlying SQLite statement\u2019s lifetime is managed by the box object with normal\nretain/release semantics.  The box and underlying statement can be released simply by setting all references to it to null\nas usual."),(0,o.kt)("p",null,"With this pattern it's possible to, for instance, create a cursor, box it, consume some of the rows in one procedure, do some other stuff,\nand then consume the rest of the rows in another different procedure."),(0,o.kt)("p",null,"Important Notes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the underlying SQLite statement is shared by all references to it.  Unboxing does not reset the cursor's position.  It is possible, even desirable, to have different procedures advancing the same cursor"),(0,o.kt)("li",{parentName:"ul"},'there is no operation for "peeking" at a cursor without advancing it; if your code requires that you inspect the row and then delegate it, you can do this simply by passing the cursor data as a value rather than the cursor statement.  Boxing and unboxing are for cases where you need to stream data out of the cursor in helper procedures'),(0,o.kt)("li",{parentName:"ul"},"durably storing a boxed cursor (e.g. in a global) could lead to all manner of problems -- it is ",(0,o.kt)("em",{parentName:"li"},"exactly")," like holding on to a ",(0,o.kt)("inlineCode",{parentName:"li"},"sqlite3_stmt *")," for a long time with all the same problems because that is exactly is happening")),(0,o.kt)("p",null,"Summarizing, the main reason for using the boxing patterns is to allow for standard helper procedures that can get a cursor from a variety of places and process it.\nBoxing isn\u2019t the usual pattern at all and returning cursors in a box, while possible, should be avoided in favor of the simpler patterns, if only because then then lifetime management is very simple in all those cases."))}d.isMDXComponent=!0}}]);