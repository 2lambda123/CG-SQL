"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2713],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),h=r,u=d["".concat(s,".").concat(h)]||d[h]||m[h]||i;return a?n.createElement(u,l(l({ref:t},p),{},{components:a})):n.createElement(u,l({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var c=2;c<i;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},554:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return m}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),l=["components"],o={id:"int06",title:"Part 6: Schema Management",sidebar_label:"Part 6: Schema Management"},s=void 0,c={unversionedId:"int06",id:"int06",title:"Part 6: Schema Management",description:"\x3c!---",source:"@site/../CQL_Guide/int06.md",sourceDirName:".",slug:"/int06",permalink:"/cql-guide/int06",draft:!1,tags:[],version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1658875789,formattedLastUpdatedAt:"7/26/2022",frontMatter:{id:"int06",title:"Part 6: Schema Management",sidebar_label:"Part 6: Schema Management"},sidebar:"someSidebar",previous:{title:"Part 5: CQL Runtime",permalink:"/cql-guide/int05"},next:{title:"Part 7: JSON Generation",permalink:"/cql-guide/int07"}},p={},m=[{value:"Preface",id:"preface",level:3},{value:"Schema Management",id:"schema-management",level:2},{value:"Check for errors, check for <code>--global_proc</code>",id:"check-for-errors-check-for---global_proc",level:3},{value:"Preparing the Attributes",id:"preparing-the-attributes",level:3},{value:"Creating the Global CRC",id:"creating-the-global-crc",level:3},{value:"Output Fragments",id:"output-fragments",level:3},{value:"Declarations Section",id:"declarations-section",level:3},{value:"Schema Region Arguments",id:"schema-region-arguments",level:4},{value:"Schema Output Modes",id:"schema-output-modes",level:4},{value:"The Schema Helpers",id:"the-schema-helpers",level:3},{value:"Declared Upgrade Procedures",id:"declared-upgrade-procedures",level:3},{value:"The Upgrading Workers",id:"the-upgrading-workers",level:3},{value:"Reading the Facets into Memory",id:"reading-the-facets-into-memory",level:4},{value:"Process Standard Annotations",id:"process-standard-annotations",level:4},{value:"Finalization Steps",id:"finalization-steps",level:4},{value:"The &quot;Main&quot; Steps",id:"the-main-steps",level:4},{value:"Writing the Buffer",id:"writing-the-buffer",level:4},{value:"Recap",id:"recap",level:3}],d={toc:m};function h(e){var t=e.components,a=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"preface"},"Preface"),(0,i.kt)("p",null,"Part 6 continues with a discussion of the essentials of schema management in the CQL compiler.\nAs in the previous parts, the goal here is not to go over every detail of the system but rather to give\na sense of how schema management happens in general -- the core strategies and implementation choices --\nso that when reading the management code you will have an idea how it all hangs together. To accomplish\nthis, various key data structures will be explained in detail and accompanied by examples of their use."),(0,i.kt)("h2",{id:"schema-management"},"Schema Management"),(0,i.kt)("p",null,'The primary goal of the schema management features of the CQL compiler is to provide the ability\nto create a "schema upgrader" that can move a given user\'s database from a previous version\nof the schema to the current version.  Because of the limitations of SQL in general, and\nSQLite in particular, not all transforms are possible; so additionally the system must correctly\ndetect and prevent upgrades that cannot be safely performed.'),(0,i.kt)("p",null,"The full set of schema attributes and their meaning is described in ",(0,i.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch10"},"Chapter 10"),"\nand the full set of validations is described in ",(0,i.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch11"},"Chapter 11"),".  Briefly the\ndirectives are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@create(n)"),": indicates a table/column is to be created at version ",(0,i.kt)("inlineCode",{parentName:"li"},"n"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@delete(n)"),": indicates a table/column is to be deleted at version ",(0,i.kt)("inlineCode",{parentName:"li"},"n"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@recreate"),": indicates the table contents are not precious",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the table can be dropped and created when its schema changes"),(0,i.kt)("li",{parentName:"ul"},"this does not combine with ",(0,i.kt)("inlineCode",{parentName:"li"},"@create")),(0,i.kt)("li",{parentName:"ul"},"it applies only to tables"),(0,i.kt)("li",{parentName:"ul"},"views, triggers, and indices are always on the ",(0,i.kt)("inlineCode",{parentName:"li"},"@recreate")," plan and do not have to be marked so")))),(0,i.kt)("p",null,"Now the various annotations can occur substantially in any order as there are no rules that require that\ntables that are created later in time appear later in the input.  This means the appearance order\nof tables is in general very inconvenient for any upgrading logic.  However, the semantic validation\npass gathers all the annotations into two large ",(0,i.kt)("inlineCode",{parentName:"p"},"bytebuf")," objects which can be readily sorted --\none for things on the ",(0,i.kt)("inlineCode",{parentName:"p"},"@create")," plan and one for the ",(0,i.kt)("inlineCode",{parentName:"p"},"@recreate")," plan.  These will be discussed below."),(0,i.kt)("p",null,"At this point it's probably best to start looking at some of the code fragments. We're going to be looking\nat all the steps in the top level function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Main entry point for schema upgrade code-gen.\ncql_noexport void cg_schema_upgrade_main(ast_node *head) {\n  Contract(options.file_names_count == 1);\n  ...\n}\n")),(0,i.kt)("p",null,"Note that the schema upgrader code generator in CQL does not produce ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," but rather it produces\nmore ",(0,i.kt)("inlineCode",{parentName:"p"},"CQL")," which then has to be compiled down to ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),".  This choice means that the codegen is a\nlot more readable and gets the benefit of the usual CQL error checking and exception management."),(0,i.kt)("h3",{id:"check-for-errors-check-for---global_proc"},"Check for errors, check for ",(0,i.kt)("inlineCode",{parentName:"h3"},"--global_proc")),(0,i.kt)("p",null,"We start with some simple error checks:  Any semantic errors abort the code-generation.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"--global_proc")," names the procedure that will do the upgrade. It is also used\nas a prefix on all of the tables that the upgrader requires. This makes it possible,\nif desired, to have separate upgraders for different parts of your schema, or to\ncombine upgraders from two different unrelated subsystems in the same database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  cql_exit_on_semantic_errors(head);\n  exit_on_no_global_proc();\n")),(0,i.kt)("h3",{id:"preparing-the-attributes"},"Preparing the Attributes"),(0,i.kt)("p",null,"The two arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"schema_annotations")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"recreate_annotations")," are sorted.\nThe item count can be easily computed using the allocated size of these items,\nboth of which are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"bytebuf"),".  The comparators provided to ",(0,i.kt)("inlineCode",{parentName:"p"},"qsort"),"\nput these arrays in exactly the order needed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  // first sort the schema annotations according to version, type etc.\n  // we want to process these in an orderly fashion and the upgrade rules\n  // are nothing like the declared order.\n  void *base = schema_annotations->ptr;\n  size_t schema_items_size = sizeof(schema_annotation);\n  size_t schema_items_count = schema_annotations->used / schema_items_size;\n  schema_annotation *notes = (schema_annotation*)base;\n  int32_t max_schema_version = 0;\n  if (schema_items_count) {\n     qsort(base, schema_items_count, schema_items_size, annotation_comparator);\n     max_schema_version = notes[schema_items_count - 1].version;\n  }\n\n  // likewise, @recreate annotations, in the correct upgrade order (see comparator)\n  base = recreate_annotations->ptr;\n  size_t recreate_items_size = sizeof(recreate_annotation);\n  size_t recreate_items_count = recreate_annotations->used / recreate_items_size;\n  if (recreate_items_count) {\n    qsort(base, recreate_items_count, recreate_items_size, recreate_comparator);\n  }\n  recreate_annotation *recreates = (recreate_annotation *)base;\n")),(0,i.kt)("h3",{id:"creating-the-global-crc"},"Creating the Global CRC"),(0,i.kt)("p",null,"Schema upgrade is expensive, so we want to be able to quickly detect if the schema\ninstalled is already the latest version. To do this we compute a single global\n64-bit CRC for the current version of the schema.  This can be compared against a\nstored schema CRC from the last run. If the CRCs match, no work needs to be done."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  CHARBUF_OPEN(all_schema);\n  // emit canonicalized schema for everything we will upgrade\n  // this will include the schema declarations for the ad hoc migrations, too;\n  cg_generate_schema_by_mode(&all_schema, SCHEMA_TO_UPGRADE);\n\n  // compute the master CRC using schema and migration scripts\n  llint_t schema_crc = (llint_t)crc_charbuf(&all_schema);\n\n  CHARBUF_CLOSE(all_schema);\n")),(0,i.kt)("p",null,'The schema generator is used to emit the full schema, including annotations, into\na buffer. A raw CRC of the buffer gives us the "global" or "overall" CRC for the\nwhole schema.'),(0,i.kt)("h3",{id:"output-fragments"},"Output Fragments"),(0,i.kt)("p",null,"A number of buffers will hold the various pieces of output."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  CHARBUF_OPEN(preamble);\n  CHARBUF_OPEN(main);\n  CHARBUF_OPEN(decls);\n  CHARBUF_OPEN(pending);\n  CHARBUF_OPEN(upgrade);\n  CHARBUF_OPEN(baseline);\n")),(0,i.kt)("p",null,"These will be assembled as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  CHARBUF_OPEN(output_file);\n  bprintf(&output_file, "%s\\n", decls.ptr);\n  bprintf(&output_file, "%s", preamble.ptr);\n  bprintf(&output_file, "%s", main.ptr);\n\n  cql_write_file(options.file_names[0], output_file.ptr);\n\n  CHARBUF_CLOSE(output_file);\n')),(0,i.kt)("p",null,"In short:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"first ",(0,i.kt)("inlineCode",{parentName:"li"},"decls"),", this declares the schema among other things"),(0,i.kt)("li",{parentName:"ul"},"then, ",(0,i.kt)("inlineCode",{parentName:"li"},"preamble"),", this contains helper procedures"),(0,i.kt)("li",{parentName:"ul"},"then, ",(0,i.kt)("inlineCode",{parentName:"li"},"main"),", the primary upgrader steps go here")),(0,i.kt)("p",null,"We'll go over all of these in subsequent sections."),(0,i.kt)("h3",{id:"declarations-section"},"Declarations Section"),(0,i.kt)("p",null,"The result type includes a customizable prefix string.  This is the first thing to go out.\nTypically this is the appropriate copyright notice.  ",(0,i.kt)("inlineCode",{parentName:"p"},"rt.c")," has this information and that\nfile is replaceable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  bprintf(&decls, "%s", rt->source_prefix);\n')),(0,i.kt)("p",null,"The schema upgrade script is in the business of creating tables from old versions and then altering them.\nThe table declarations will be for the final shape.  We need to emit ",(0,i.kt)("inlineCode",{parentName:"p"},"@SCHEMA_UPGRADE_SCRIPT")," so that\nthe CQL compiler knows that there will be multiple declarations of the same table and they might not\nbe identical. The upgrade script is in the business of getting things to the end state.  Likewise\nit is normal for the schema upgrade script to refer to columns that have been deleted, this is because\na column might be created in say version 5 and then deleted in version 10.  The upgrade code goes\nthrough the columns lifecycle, so even though the declarations already say the column is doomed\nto die in version 10, the creation code in version 5 is legal -- and necessary.  Schema migration steps\nthat run in version 6, 7, 8, or 9 might use the contents of the column as part of essential data migration.\nWe can never know what version we might find in a database that is being upgraded, it could be very far in\nthe past, at a time where a deleted column still existed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  bprintf(&decls, "-- no columns will be considered hidden in this script\\n");\n  bprintf(&decls, "-- DDL in procs will not count as declarations\\n");\n  bprintf(&decls, "@SCHEMA_UPGRADE_SCRIPT;\\n\\n");\n')),(0,i.kt)("p",null,"A convenience comment goes in the ",(0,i.kt)("inlineCode",{parentName:"p"},"decls")," section with the CRC."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  bprintf(&decls, "-- schema crc %lld\\n\\n", schema_crc);\n')),(0,i.kt)("p",null,"There are a set of functions that allow the creation of, and access to, an in-memory\ncache of the facet state.  These functions are all defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"cqlrt_common.c"),".  But\nthey have to be declared to CQL to use them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  cg_schema_emit_facet_functions(&decls);\n")),(0,i.kt)("p",null,"The table ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite_master")," is used to read schema state.  That table has to be declared."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  cg_schema_emit_sqlite_master(&decls);\n")),(0,i.kt)("p",null,"The full schema may be used by the upgraders, we need a declaration of all of that."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  bprintf(&decls, "-- declare full schema of tables and views to be upgraded and their dependencies -- \\n");\n  cg_generate_schema_by_mode(&decls, SCHEMA_TO_DECLARE);\n')),(0,i.kt)("p",null,"At this point a quick side-step to the output modes and region arguments is appropriate."),(0,i.kt)("h4",{id:"schema-region-arguments"},"Schema Region Arguments"),(0,i.kt)("p",null,"The upgrader honors the arguments ",(0,i.kt)("inlineCode",{parentName:"p"},"--include_regions")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"--exclude_regions"),'.  If they are absent\nthat is the same as "include everything" and "exclude nothing".  Recall that schema regions allow\nyou to group schema as you wish.  A typical use might be to define some "core" schema in a set\nof regions (maybe just one) and then a set of "optional" schema in some additional regions.'),(0,i.kt)("p",null,'An upgrader for just "core" could be created by adding ',(0,i.kt)("inlineCode",{parentName:"p"},"--include_regions core"),".  When creating\nupgraders for the optional parts, there are two choices:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--include-regions optional1")," : makes an upgrader for ",(0,i.kt)("inlineCode",{parentName:"li"},"optional1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"core")," (the assumption being that ",(0,i.kt)("inlineCode",{parentName:"li"},"optional1")," was declared to depend on ",(0,i.kt)("inlineCode",{parentName:"li"},"core"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--include-regions optional1")," ",(0,i.kt)("inlineCode",{parentName:"li"},"--exclude-regions core")," : makes an upgrader for ",(0,i.kt)("inlineCode",{parentName:"li"},"optional1")," which should run after the standalone ",(0,i.kt)("inlineCode",{parentName:"li"},"core")," upgrader has already run",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'this allows you to share the "core" parts between any number of "optional" parts'),(0,i.kt)("li",{parentName:"ul"},'and of course this can nest; there can be several "core" parts; and so forth')))),(0,i.kt)("h4",{id:"schema-output-modes"},"Schema Output Modes"),(0,i.kt)("p",null,"The flag bits are these:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// We declare all schema we might depend on in this upgrade (this is the include list)\n// e.g. we need all our dependent tables so that we can legally use them in an FK\n#define SCHEMA_TO_DECLARE 1\n\n// We only emit schema that we are actually updating (this is include - exclude)\n// e.g. a table on the exclude list is assumed to be upgraded by its own script\n// in a different run.\n#define SCHEMA_TO_UPGRADE 2\n\n// We get TEMP items IF and ONLY IF this bit is set\n#define SCHEMA_TEMP_ITEMS 4\n")),(0,i.kt)("p",null,"As we saw before, the schema we CRC is ",(0,i.kt)("inlineCode",{parentName:"p"},"SCHEMA_TO_UPGRADE"),'.  This is all the regions that were selected\nbut not their dependencies.  The point of this is that you might make an upgrader for say a "core"\npart of your schema which can be shared and then make additional upgraders for various parts that\nuse the "core" but are otherwise "optional".  Each of those "optional" upgraders needs its own CRC that\nincludes its schema but not the "core" schema.  However the "optional" schema can refer to "core"\nschema (e.g. in foreign keys) so all of the tables are declared.  This is ',(0,i.kt)("inlineCode",{parentName:"p"},"SCHEMA_TO_DECLARE")," mode."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"declare all schema you are allowed to refer to"),(0,i.kt)("li",{parentName:"ul"},"CRC, and upgrade, only the parts selected by the region arguments")),(0,i.kt)("h3",{id:"the-schema-helpers"},"The Schema Helpers"),(0,i.kt)("p",null,"This bit generates the ",(0,i.kt)("inlineCode",{parentName:"p"},"facets")," table, the full name is ",(0,i.kt)("inlineCode",{parentName:"p"},"your_global_proc_cql_schema_facets")," where\n",(0,i.kt)("inlineCode",{parentName:"p"},"your_global_proc")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"--global_proc")," argument. This is referred to simply as the ",(0,i.kt)("inlineCode",{parentName:"p"},"facets")," table.\nThere is an identical temporary table that is used to store the contents of the ",(0,i.kt)("inlineCode",{parentName:"p"},"facets")," table\nupon startup.  This allows the upgrader to produce a complete difference.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"facets")," table\nis nothing more than a mapping between the name of some facet of the schema (like a table, a view,\na column) and its last known verison info -- usually its CRC."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NOTE: this temp table predates the in-memory facets data structure so it could probably be removed",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the diff would have to work against the in-memory datastructure which is immutable hence just as good as a temp table"),(0,i.kt)("li",{parentName:"ul"},"look for a change like this soon")))),(0,i.kt)("p",null,"The remaining procedures are for testing facet state or ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite_master")," state.  All of them get the\nusual global prefix.  For ease of discussion I will elide the prefix for the rest of this document."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"check_column_exists")," : checks if the indicated column is present in ",(0,i.kt)("inlineCode",{parentName:"li"},"sqlite_master"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"necessary because there is no ",(0,i.kt)("inlineCode",{parentName:"li"},"ALTER TABLE ADD COLUMN IF NOT EXISTS")," command"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"create_cql_schema_facets_if_needed")," : actually creates the ",(0,i.kt)("inlineCode",{parentName:"li"},"facets")," table if it does not exist"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"save_cql_schema_facets")," : creates the ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_schema_facets_saved")," temp table and populates it"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_set_facet_version")," : sets one facet to the indicated value",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this writes to the database, not the in-memory version of the table"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_get_facet_version")," : reads a facet value from the facet table",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this is only used to check the master schema value, after that the in-memory version is used"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_get_version_crc")," : gets the CRC for a given schema version",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"each schema version has its own CRC in addition to the global CRC"),(0,i.kt)("li",{parentName:"ul"},"this information is stored in the facets table with a simple naming convention for the facet name"),(0,i.kt)("li",{parentName:"ul"},"the in memory version of the table is always used here"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_set_version_crc")," : sets the CRC for a given schema version in the facet table",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this writes to the database, not the in-memory version of the table"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_drop_legacy_triggers")," : drops any triggers of the from ",(0,i.kt)("inlineCode",{parentName:"li"},"tr__*"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"for historical reasons the original triggers did not include tombstones when deleted"),(0,i.kt)("li",{parentName:"ul"},"this kludge is here to clean up legacy triggers and its peculiar to Messenger only"),(0,i.kt)("li",{parentName:"ul"},"this should really be removed from the OSS version but it's never been a priority"),(0,i.kt)("li",{parentName:"ul"},"sorry...")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  cg_schema_helpers(&decls);\n")),(0,i.kt)("h3",{id:"declared-upgrade-procedures"},"Declared Upgrade Procedures"),(0,i.kt)("p",null,'The annotations can include an upgrade procedure. The term "migration" procedure is sometimes used\nas well and is synonymous.  This is some code that should run after the schema alteration has\nbeen made to create/delete/move some data around in the new schema.  Each of these must be\ndeclared before it is used and the declarations will be here, at the end of the ',(0,i.kt)("inlineCode",{parentName:"p"},"decls")," section\nafter this introductory comment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  bprintf(&decls, "-- declared upgrade procedures if any\\n");\n')),(0,i.kt)("h3",{id:"the-upgrading-workers"},"The Upgrading Workers"),(0,i.kt)("p",null,"The main upgrader will invoke these key workers to do its job.  This is where the ",(0,i.kt)("inlineCode",{parentName:"p"},"preamble"),"\nsection starts. It contains the meat of the upgrade steps wrapped in procedures that do\nthe job."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  cg_schema_emit_baseline_tables_proc(&preamble, &baseline);\n\n  int32_t view_creates = 0, view_drops = 0;\n  cg_schema_manage_views(&preamble, &view_drops, &view_creates);\n\n  int32_t index_creates = 0, index_drops = 0;\n  cg_schema_manage_indices(&preamble, &index_drops, &index_creates);\n\n  int32_t trigger_creates = 0, trigger_drops = 0;\n  cg_schema_manage_triggers(&preamble, &trigger_drops, &trigger_creates);\n\n  if (recreate_items_count) {\n    cg_schema_manage_recreate_tables(&preamble, recreates, recreate_items_count);\n  }\n\n  bool_t has_temp_schema = cg_schema_emit_temp_schema_proc(&preamble);\n  bool_t one_time_drop_needed = false;\n")),(0,i.kt)("p",null,"These are the last of the worker methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_emit_baseline_tables_proc")," : emits a procedure that will create the schema at its baseline version",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'this means whatever "v0" of the schema was, no creates or deletes have yet happened'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_manage_views")," : creates the view management procedures",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_drop_all_views")," : drops all views"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_create_all_views")," : creates all views"),(0,i.kt)("li",{parentName:"ul"},"both of these run unless the global CRC matches"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_manage_indices")," : creates the index management procedures",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_drop_all_indices")," : drops any index that exists and whose CRC changed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_create_all_indices")," : creates any index whose CRC changed"),(0,i.kt)("li",{parentName:"ul"},"recreating indices can be costly so it is only done if the index actually changed"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_manage_triggers")," : creates the trigger management procedures",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_drop_all_triggers")," : drops all triggers"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_create_all_triggers")," : creates all triggers"),(0,i.kt)("li",{parentName:"ul"},"both of these run unless the global CRC matches"),(0,i.kt)("li",{parentName:"ul"},"additionally any legacy triggers will be deleted (see ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_drop_legacy_triggers"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_manage_recreate_tables")," : creates the ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_recreate_tables")," worker",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"recreate_annotations")," array is used to find all the recreate tables"),(0,i.kt)("li",{parentName:"ul"},"the entries are sorted by group, then name, so that annotations within a group are together"),(0,i.kt)("li",{parentName:"ul"},"the procedure contains code to delete the procedure or group and recreate it if the CRC does not match"),(0,i.kt)("li",{parentName:"ul"},"the CRC is computed using the code for create instructions and is stored in a facet with a suitable name"),(0,i.kt)("li",{parentName:"ul"},"the easiest way to think of this code is that it always emits a chunk of recreates for a group",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"ungrouped tables are a group of 1"),(0,i.kt)("li",{parentName:"ul"},"group delete/create instructions accumulate until the next entry is in a different group"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_emit_temp_schema_proc")," : emits a procedure to create any temporary schema",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"temp tables are always created in full at the latest version"),(0,i.kt)("li",{parentName:"ul"},"this code is run regardless of whether the global CRC matches or not")))),(0,i.kt)("p",null,"All of these functions semantic outputs like ",(0,i.kt)("inlineCode",{parentName:"p"},"all_indices_list"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"all_views_list"),", etc. to do their job (except\n",(0,i.kt)("inlineCode",{parentName:"p"},"cg_schema_manage_recreate_tables")," as noted). Generally they have all the data they need handed to them\non a silver platter by the semantic pass. This is not an accident."),(0,i.kt)("h4",{id:"reading-the-facets-into-memory"},"Reading the Facets into Memory"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"setup_facets")," procedure simply selects out the entire ",(0,i.kt)("inlineCode",{parentName:"p"},"facets")," table with a cursor\nand uses ",(0,i.kt)("inlineCode",{parentName:"p"},"cql_facet_add")," to get them into a hash table.  This is the primary source of\nfacets information during the run.  This is a good example of what the codegen looks like\nso we'll include this one in full."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  // code to read the facets into the hash table\n\n  bprintf(&preamble, "@attribute(cql:private)\\n");\n  bprintf(&preamble, "CREATE PROCEDURE %s_setup_facets()\\n", global_proc_name);\n  bprintf(&preamble, "BEGIN\\n");\n  bprintf(&preamble, "  BEGIN TRY\\n");\n  bprintf(&preamble, "    SET %s_facets := cql_facets_new();\\n", global_proc_name);\n  bprintf(&preamble, "    DECLARE C CURSOR FOR SELECT * from %s_cql_schema_facets;\\n", global_proc_name);\n  bprintf(&preamble, "    LOOP FETCH C\\n");\n  bprintf(&preamble, "    BEGIN\\n");\n  bprintf(&preamble, "      LET added := cql_facet_add(%s_facets, C.facet, C.version);\\n", global_proc_name);\n  bprintf(&preamble, "    END;\\n");\n  bprintf(&preamble, "  END TRY;\\n");\n  bprintf(&preamble, "  BEGIN CATCH\\n");\n  bprintf(&preamble, "   -- if table doesn\'t exist we just have empty facets, that\'s ok\\n");\n  bprintf(&preamble, "  END CATCH;\\n");\n  bprintf(&preamble, "END;\\n\\n");\n\n### The Main Upgrader\n\nAnd now we come to the main upgrading procedure `perform_upgrade_steps`.\n\nWe\'ll go over this section by section.\n\n#### Standard Steps\n\n```c\n  // the main upgrade worker\n\n  bprintf(&main, "\\n@attribute(cql:private)\\n");\n  bprintf(&main, "CREATE PROCEDURE %s_perform_upgrade_steps()\\n", global_proc_name);\n  bprintf(&main, "BEGIN\\n");\n  bprintf(&main, "  DECLARE schema_version LONG INTEGER NOT NULL;\\n");\n\n  if (view_drops) {\n    bprintf(&main, "    -- dropping all views --\\n");\n    bprintf(&main, "    CALL %s_cql_drop_all_views();\\n\\n", global_proc_name);\n  }\n\n  if (index_drops) {\n    bprintf(&main, "    -- dropping condemned or changing indices --\\n");\n    bprintf(&main, "    CALL %s_cql_drop_all_indices();\\n\\n", global_proc_name);\n  }\n\n  if (trigger_drops) {\n    bprintf(&main, "    -- dropping condemned or changing triggers --\\n");\n    bprintf(&main, "    CALL %s_cql_drop_all_triggers();\\n\\n", global_proc_name);\n  }\n\n  if (baseline.used > 1) {\n    llint_t baseline_crc = (llint_t)crc_charbuf(&baseline);\n    bprintf(&main, "    ---- install baseline schema if needed ----\\n\\n");\n    bprintf(&main, "    CALL %s_cql_get_version_crc(0, schema_version);\\n", global_proc_name);\n    bprintf(&main, "    IF schema_version != %lld THEN\\n", baseline_crc);\n    bprintf(&main, "      CALL %s_cql_install_baseline_schema();\\n", global_proc_name);\n    bprintf(&main, "      CALL %s_cql_set_version_crc(0, %lld);\\n", global_proc_name, baseline_crc);\n    bprintf(&main, "    END IF;\\n\\n");\n  }\n')),(0,i.kt)("p",null,"First we deal with the preliminaries:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"drop the views if there are any"),(0,i.kt)("li",{parentName:"ul"},"drop the indices that need dropping"),(0,i.kt)("li",{parentName:"ul"},"drop the triggers if there are any"),(0,i.kt)("li",{parentName:"ul"},"install the baseline schema if there is any")),(0,i.kt)("h4",{id:"process-standard-annotations"},"Process Standard Annotations"),(0,i.kt)("p",null,"In this phase we walk the annotations from ",(0,i.kt)("inlineCode",{parentName:"p"},"schema_annotations")," which are now stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"notes"),"."),(0,i.kt)("p",null,"They have been sorted in exactly the right order to process them (by version, then type, then target).\nWe'll create one set of instructions per version number as we simply accumulate instructions for any\nversion while we're still on the same version then spit them all out.  Adding ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," to the sort\norder ensures that the results have a total ordering (there are no ties that might yield an ambiguous order)."),(0,i.kt)("p",null,"We set up a loop to walk over the annotations and we flush if we ever encounter an annotation for\na different version number.  We'll have to force a flush at the end as well.  ",(0,i.kt)("inlineCode",{parentName:"p"},"cg_schema_end_version"),"\ndoes the flush."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"  int32_t prev_version = 0;\n\n  for (int32_t i = 0; i < schema_items_count; i++) {\n    schema_annotation *note = &notes[i];\n\n    ast_node *version_annotation = note->annotation_ast;\n\n    uint32_t type = note->annotation_type;\n    Contract(type >= SCHEMA_ANNOTATION_FIRST && type <= SCHEMA_ANNOTATION_LAST);\n\n    Contract(is_ast_version_annotation(version_annotation));\n    EXTRACT_OPTION(vers, version_annotation->left);\n\n    Invariant(note->version == vers);\n    Invariant(vers > 0);\n\n    if (prev_version != vers) {\n      cg_schema_end_version(&main, &upgrade, &pending, prev_version);\n      prev_version = vers;\n    }\n")),(0,i.kt)("p",null,"If we find any item that is in a region we are not upgrading, we skip it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    CSTR target_name = note->target_name;\n\n    Invariant(type >= SCHEMA_ANNOTATION_FIRST && type <= SCHEMA_ANNOTATION_LAST);\n\n    if (!include_from_region(note->target_ast->sem->region, SCHEMA_TO_UPGRADE)) {\n      continue;\n    }\n")),(0,i.kt)("p",null,"There are several annotation types.  Each one requires appropriate commands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'    switch (type) {\n      case SCHEMA_ANNOTATION_CREATE_COLUMN: {\n        ... emit ALTER TABLE ADD COLUMN if the column does not already exist\n        break;\n      }\n\n      case SCHEMA_ANNOTATION_DELETE_COLUMN: {\n        ... it\'s not possible to delete columns in SQLite (this is changing)\n        ... we simply emit a comment and move on\n        break;\n      }\n\n      case SCHEMA_ANNOTATION_CREATE_TABLE: {\n        ... if the table is moving from @recreate to @create we have to drop any stale version\n        ... of it one time.  We emit a call to `cql_one_time_drop` and record that we need\n        ... to generate that procedure in `one_time_drop_needed`.\n        ...in all cases emit a CREATE TABLE IF NOT EXISTS\n        break;\n      }\n\n      case SCHEMA_ANNOTATION_DELETE_TABLE: {\n        ... emit DROP TABLE IF EXISTS for the target\n        break;\n      }\n\n      case SCHEMA_ANNOTATION_DELETE_INDEX:\n      case SCHEMA_ANNOTATION_DELETE_VIEW:\n      case SCHEMA_ANNOTATION_DELETE_TRIGGER:\n        ... this annotation indicates there is a tombstone on the item\n        ... this was handled in the appropriate `manage` worker above, nothing needs\n        ... to be done here except run any migration procs (see below)\n        break;\n\n      case SCHEMA_ANNOTATION_AD_HOC:\n        ... ad hoc migration procs allow for code to be run one time when we hit\n        ... a particular schema version, this just allows the migration proc to run\n        // no annotation based actions other than migration proc (handled below)\n        Contract(version_annotation->right);\n        bprintf(&upgrade, "      -- ad hoc migration proc %s will run\\n\\n", target_name);\n        break;\n    }\n')),(0,i.kt)("p",null,"The above constitutes the bulk of the upgrading logic which, as you can see, isn't that complicated."),(0,i.kt)("p",null,"Any of the above might have a migration proc.  If there is one in the node, then generate:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"emit a call to ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_facet_find")," to see if the migration proc has already run"),(0,i.kt)("li",{parentName:"ul"},"emit a declaration for the migration proc into the ",(0,i.kt)("inlineCode",{parentName:"li"},"decls")," section"),(0,i.kt)("li",{parentName:"ul"},"emit a call to the procedure (it accept no arguments)"),(0,i.kt)("li",{parentName:"ul"},"emit a call to ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_set_facet_version")," to record that the migrator ran")),(0,i.kt)("p",null,"When the loop is done, any pending migration code is flushed using ",(0,i.kt)("inlineCode",{parentName:"p"},"cg_schema_end_version")," again."),(0,i.kt)("p",null,"At this point we can move on to the finalization steps."),(0,i.kt)("h4",{id:"finalization-steps"},"Finalization Steps"),(0,i.kt)("p",null,"With the standard upgrade finished, there is just some house keeping left:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  if (recreate_items_count) {\n    bprintf(&main, "    CALL %s_cql_recreate_tables();\\n", global_proc_name);\n  }\n\n  if (view_creates) {\n    bprintf(&main, "    CALL %s_cql_create_all_views();\\n", global_proc_name);\n  }\n\n  if (index_creates) {\n    bprintf(&main, "    CALL %s_cql_create_all_indices();\\n", global_proc_name);\n  }\n\n  if (trigger_creates) {\n    bprintf(&main, "    CALL %s_cql_create_all_triggers();\\n", global_proc_name);\n  }\n\n  bprintf(&main, "    CALL %s_cql_set_facet_version(\'cql_schema_version\', %d);\\n", global_proc_name, prev_version);\n  bprintf(&main, "    CALL %s_cql_set_facet_version(\'cql_schema_crc\', %lld);\\n", global_proc_name, schema_crc);\n  bprintf(&main, "END;\\n\\n");\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_recreate_tables")," : must run if there are any tables marked recreate",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this procedure will have code to drop and recreate any changed tables"),(0,i.kt)("li",{parentName:"ul"},"this procedure was created by ",(0,i.kt)("inlineCode",{parentName:"li"},"cg_schema_manage_recreate_tables")," and that process is described above",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"basically, it uses ",(0,i.kt)("inlineCode",{parentName:"li"},"recreate_annotations")," to do the job"))),(0,i.kt)("li",{parentName:"ul"},"any that were condemned by marking with ",(0,i.kt)("inlineCode",{parentName:"li"},"@delete")," will not be created again here"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_create_all_views")," : must run if there are any views, they need to be put back",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"any that were condemned by marking with ",(0,i.kt)("inlineCode",{parentName:"li"},"@delete")," are not created again here"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_create_all_indices")," : must run if there are any indices, this will create any that are missing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"any that were changing were previously deleted, this is where they come back"),(0,i.kt)("li",{parentName:"ul"},"any that were condemned by marking with ",(0,i.kt)("inlineCode",{parentName:"li"},"@delete")," are not created again here"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_create_all_triggers")," : must run if there are any triggers, they need to be put back",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"any that were condemned by marking with ",(0,i.kt)("inlineCode",{parentName:"li"},"@delete")," are not created again here"),(0,i.kt)("li",{parentName:"ul"},"triggers might cause weird side-effects during upgrade hence they are always dropped"),(0,i.kt)("li",{parentName:"ul"},"stale triggers especially could be problematic"),(0,i.kt)("li",{parentName:"ul"},"any triggers that refer to views couldn't possibly run as the views are gone"),(0,i.kt)("li",{parentName:"ul"},"hence, triggers are always dropped and recreated")))),(0,i.kt)("h4",{id:"the-main-steps"},'The "Main" Steps'),(0,i.kt)("p",null,"We're getting very close to the top level now"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"perform_needed_upgrades")," : this orchestrates the upgrade, if it is called there is one"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_facet_find"),' : is used to check for a schema "downgrade"',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"abort with an error if that happens"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"save_cql_schema_facets")," : saves the facets as they exist so we can diff them"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"perform_upgrade_steps")," : does the upgrade"),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("inlineCode",{parentName:"li"},"LEFT OUTER JOIN")," between ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_schema_facets")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_schema_facets_saved")," reports differences"),(0,i.kt)("li",{parentName:"ul"},"any errors will cause the normal CQL error flow"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the main entry point is named by ",(0,i.kt)("inlineCode",{parentName:"p"},"global_proc_name")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"create_cql_schema_facets_if_needed")," is used to create the ",(0,i.kt)("inlineCode",{parentName:"li"},"facets")," table if it doesn't already exist"),(0,i.kt)("li",{parentName:"ul"},"the special facet ",(0,i.kt)("inlineCode",{parentName:"li"},"cql_schema_crc")," is read from the ",(0,i.kt)("inlineCode",{parentName:"li"},"facets")," table"),(0,i.kt)("li",{parentName:"ul"},'if the CRC stored there matches our target then we return "no differences", otherwise'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"setup_facets")," : loads the in-memory version of the facets table"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"perform_needed_upgrades")," : does the work and creates the diff"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cql_facets_delete")," is used to free the in-memory storage, even if there were errors in ",(0,i.kt)("inlineCode",{parentName:"li"},"perform_needed_upgrades")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"cql_install_temp_schema")," : installs temporary schema if there is any, regardless of the CRC")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the ",(0,i.kt)("inlineCode",{parentName:"p"},"one_time_drop")," code is emitted if it was needed"))),(0,i.kt)("h4",{id:"writing-the-buffer"},"Writing the Buffer"),(0,i.kt)("p",null,"At this point the main buffers ",(0,i.kt)("inlineCode",{parentName:"p"},"decls"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"preamble"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," are ready to go.  We're back to where we started\nbut we can quickly recap the overall flow."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'  CHARBUF_OPEN(output_file);\n  bprintf(&output_file, "%s\\n", decls.ptr);\n  bprintf(&output_file, "%s", preamble.ptr);\n  bprintf(&output_file, "%s", main.ptr);\n\n  cql_write_file(options.file_names[0], output_file.ptr);\n\n  CHARBUF_CLOSE(output_file);\n')),(0,i.kt)("p",null,"There is nothing left but to ",(0,i.kt)("inlineCode",{parentName:"p"},"CHARBUF_CLOSE")," the interim buffers we created."),(0,i.kt)("h3",{id:"recap"},"Recap"),(0,i.kt)("p",null,"At present ",(0,i.kt)("inlineCode",{parentName:"p"},"cg_schema.c")," accomplishes a lot and is fairly light at only 1313 lines (at present).\nIt is able to do so because it can leverage heavy lifting done in the semantic analysis phase\nand schema generation that can be done like all other SQL generation by the echoing code\ndiscussed in ",(0,i.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),"."),(0,i.kt)("p",null,"Topics covered included:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the essential sources of schema information from the semantic pass"),(0,i.kt)("li",{parentName:"ul"},"the state tables used in the database and helpers for read/write of the same"),(0,i.kt)("li",{parentName:"ul"},"the interaction with schema regions"),(0,i.kt)("li",{parentName:"ul"},"the prosecution steps for tables, columns, views, triggers, indices"),(0,i.kt)("li",{parentName:"ul"},"the key annotation types and what code they create"),(0,i.kt)("li",{parentName:"ul"},"the handling of recreate tables, temp tables, and the base schema"),(0,i.kt)("li",{parentName:"ul"},'how all of these are wired together starting from the upgrader\'s "main"')),(0,i.kt)("p",null,"As with the other parts, no attempt was made to cover every function in detail.  That is\nbest done by reading the source code. But there is overall structure here and an understanding\nof the basic principles is helpful before diving into the source code."))}h.isMDXComponent=!0}}]);