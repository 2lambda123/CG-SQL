"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6830],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||o;return n?r.createElement(h,l(l({ref:t},p),{},{components:n})):r.createElement(h,l({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var u=2;u<o;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},464:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return c}});var r=n(3117),a=n(102),o=(n(7294),n(3905)),l=["components"],i={slug:"arg-bungle-intro",title:"Introducing  Argument Bundles",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},s=void 0,u={permalink:"/blog/arg-bungle-intro",editUrl:"https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2020-12-08-arg-bundle-intro.md",source:"@site/blog/2020-12-08-arg-bundle-intro.md",title:"Introducing  Argument Bundles",description:"There are many cases where stored procedures require complex arguments using data shapes well known",date:"2020-12-08T00:00:00.000Z",formattedDate:"December 8, 2020",tags:[{label:"facebook",permalink:"/blog/tags/facebook"},{label:"cg-sql",permalink:"/blog/tags/cg-sql"},{label:"errors",permalink:"/blog/tags/errors"}],readingTime:5.565,hasTruncateMarker:!1,authors:[{name:"CG/SQL Team",title:"Maintainer of CG/SQL",url:"https://github.com/facebookincubator",imageURL:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4"}],frontMatter:{slug:"arg-bungle-intro",title:"Introducing  Argument Bundles",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},prevItem:{title:"Introducing Virtual Tables",permalink:"/blog/virtual-table-into"},nextItem:{title:"Introducing Declare Enum",permalink:"/blog/declare-enum-intro"}},p={authorsImageUrls:[void 0]},c=[],d={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,l);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"There are many cases where stored procedures require complex arguments using data shapes well known\nto higher level languages or that come from the schema.  There is already some affordance for this\nsort of thing in the form of this kind of pattern:"),(0,o.kt)("p",null,"(I'll continue to use this simple example as I discuss the generalization below)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"create table Person (\n   id text primary key,\n   name text not null,\n   address text not null,\n   birthday real\n);\n")),(0,o.kt)("p",null,"Then maybe something like this"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"create proc insert_person(like Person)\nbegin\n    insert into Person from arguments;\nend;\n")),(0,o.kt)("p",null,"The above expands into:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"create proc insert_person(\n    id_ text not null,\n    name_ text not null,\n    address_ text not null,\n    birthday_ real)\nbegin\n    insert into Person(id, name, address, birthday)\n        values(id_, name_, address_, birthday_);\nend;\n")),(0,o.kt)("p",null,"And I think we can all agree the sugared version is a lot easier to reason about\nand much less prone to errors as well."),(0,o.kt)("p",null,"Those features have been in the language for a long time and that's all fine and well\nbut it isn't general enough to handle the usual mix of situations.  For instance what\nif you need a procedure that works with two people?  A hypothetical ",(0,o.kt)("inlineCode",{parentName:"p"},"insert_two_people"),"\nprocedure cannot be written with the old form.  This is where argument bundles come in.\nThe idea here is to name the bundle which provides useful reference.  To wit:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"create proc insert_two_people(p1 like Person, p2 like Person)\nbegin\n    call insert_person(from p1);\n    call insert_person(from p2);\nend;\n")),(0,o.kt)("p",null,"or alternatively"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"create proc insert_two_people(p1 like Person, p2 like Person)\nbegin\n    insert into Person from p1;\n    insert into Person from p2;\nend;\n")),(0,o.kt)("p",null,"So what's going on here?  Well, there are lots of reasons to keep the API to procedures simple\nand adding general purpose structured types would be at odds with that.  It would require lots\nof knowledge about C structure layout and whatnot.  And trying to call from java would require\nvery complex JNI for any such procedure.  So we avoid all that.  We keep simple arguments.\nThe above expands into:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"create proc insert_person(\n    p1_id text not null,\n    p1_name text not null,\n    p1_address text not null,\n    p1_birthday real,\n    p2_id text not null,\n    p2_name text not null,\n    p2_address text not null,\n    p2_birthday real)\nbegin\n    insert into Person(id, name, address, birthday)\n        values(p1_id, p1_name, p1_address, p1_birthday);\n    insert into Person(id, name, address, birthday)\n        values(p2_id, p2_name, p2_address, p2_birthday);\nend;\n")),(0,o.kt)("p",null,"Or course the types don't have to be the same, you can create and name shapes of your choice.  The language allow\nyou to use an argument bundle in all the places that a cursor was previously a valid source.  That includes ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"fetch"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"update cursor"),", and procedure calls.  You can refer to the arguments by their expanded name ",(0,o.kt)("inlineCode",{parentName:"p"},"p1_address"),"\nor alternatively ",(0,o.kt)("inlineCode",{parentName:"p"},"p1.address")," means the same thing."),(0,o.kt)("p",null,"Here's another example showing a silly but illustrative thing you could do:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'create proc insert_lotsa_people(P like Person)\nbegin\n    declare C cursor like P;\n    fetch C from P;\n    declare i integer not null;\n    set i := 0;\n    while (i < 20)\n    begin\n        update cursor C using\n            printf("id_%d", i) id;\n        insert into Person from C;\n    end;\nend;\n')),(0,o.kt)("p",null,"The above shows that you can use a bundle as the source of a shape elsewhere, and you can\nuse a bundle as a source of data to load a cursor.  After which you can do all the usual value cursor things\nlike ",(0,o.kt)("inlineCode",{parentName:"p"},"out")," statements and so forth."),(0,o.kt)("p",null,'In order to call procedures with argument bundles more readily from other languages, the JSON output now includes additional\ninformation about where procedure arguments originated; The field with this information is creatively called "argOrigin:"\nand it has 3 forms.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'"arg_name" -> the argument is not an expansion of anything'),(0,o.kt)("li",{parentName:"ul"},'"T arg_name" -> the argument came from ',(0,o.kt)("inlineCode",{parentName:"li"},"like T"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"there will be one arg for each member of T"),(0,o.kt)("li",{parentName:"ul"},"the formal argument name for this arg will be arg",(0,o.kt)("em",{parentName:"li"},"name")),(0,o.kt)("li",{parentName:"ul"},"if T is procedure arguments ",(0,o.kt)("inlineCode",{parentName:"li"},"like p1 arguments")," then you'll get  \"p1","[arguments]",' arg_name"'))),(0,o.kt)("li",{parentName:"ul"},'"name T arg_name" -> the argument came from ',(0,o.kt)("inlineCode",{parentName:"li"},"name like T")," (a named bundle)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"there will be one arg for each member of T"),(0,o.kt)("li",{parentName:"ul"},"the formal argument name for this arg will be T_arg_name"),(0,o.kt)("li",{parentName:"ul"},"T could be procedure arguments as above"))),(0,o.kt)("li",{parentName:"ul"},"If the source of an argument was a cursor or argument bundle name you get instead that thing's shape source name",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"this is always better because cursor names and bundle names are not globally unique."))),(0,o.kt)("li",{parentName:"ul"},"If the cursor had an anonymous source (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"like select 1 x"),') then you get the useless shape name "select"',(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"this is an indicator that you should make some ad hoc struct for this procedure because there is no useful name for the arg bundle's type")))),(0,o.kt)("p",null,"None of this matters unless you're trying to make wrappers for a CQL procedure for some other language\nand you'd like to have your wrapper deal with structs rather than all loose arguments.  the JSON\nbasically tells you the structs."),(0,o.kt)("p",null,"Interestingly, argument bundles resulted in a significant reduction of code in the compiler.  The argument bundle\nname has to be usable in the contexts where a cursor was previously usable.  It is another source of shaped data.\nGetting that to work  proved to be super simple as the two forms look almost identical to the compiler -- no coincidence there.\nSo very little code was required to make ",(0,o.kt)("inlineCode",{parentName:"p"},"from [cursor_name]")," work with ",(0,o.kt)("inlineCode",{parentName:"p"},"from [any_shape_name]")," in the half dozen or so places\nthat this construct is allowed (e.g. procedure call arguments, insert statements, etc.).  However, there was as\nmuch code associated with ",(0,o.kt)("inlineCode",{parentName:"p"},"from arguments")," as there was ",(0,o.kt)("inlineCode",{parentName:"p"},"from cursor_name"),".  And the code was nearly identical.."),(0,o.kt)("p",null,'When argument bundles were introduced the natural thing to do was to create an artifical bundle called "arguments" which\nrepresents the bundle that is ALL the arguments.  With that done, all the code for ',(0,o.kt)("inlineCode",{parentName:"p"},"from arguments")," could be deleted\nbecause ",(0,o.kt)("inlineCode",{parentName:"p"},"arguments")," itself was a valid shape name.  Hence ",(0,o.kt)("inlineCode",{parentName:"p"},"insert into T from arguments"),' "just works".  And so half\nthe rewrites were deleted.  The only cost was that the form ',(0,o.kt)("inlineCode",{parentName:"p"},"from arguments like shape")," became the cursor form\n",(0,o.kt)("inlineCode",{parentName:"p"},"from arguments(like shape)")," which only adds mandatory parens to a form that was largely unused anyway (there were two\ncases in our entire codebase).  The cursor form is more general as you can do ",(0,o.kt)("inlineCode",{parentName:"p"},"from C(like A, like B)")," to get the\nfields that match ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," then those that match ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),".  Arguments get this for free as well (well, at the cost of parens)."),(0,o.kt)("p",null,"So overall, this feature was added, and the compiler got smaller and cleaner.  Only the test suite had to grow."),(0,o.kt)("p",null,"Stay safe out there."))}m.isMDXComponent=!0}}]);