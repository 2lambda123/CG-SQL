"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1195],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return c},MDXProvider:function(){return m},mdx:function(){return d},useMDXComponents:function(){return p},withMDXComponents:function(){return u}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},a.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),u=function(e){return function(t){var n=p(t.components);return r.createElement(e,a({},t,{components:n}))}},p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,h=u["".concat(i,".").concat(m)]||u[m]||f[m]||a;return n?r.createElement(h,s(s({ref:t},c),{},{components:n})):r.createElement(h,s({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},38462:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var r=n(83117),o=n(80102),a=(n(67294),n(3905)),i=["components"],s={slug:"from-general",title:"Using the FROM construct in more places",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql"]},l=void 0,c={permalink:"/blog/from-general",editUrl:"https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2022-02-21-from-general.md",source:"@site/blog/2022-02-21-from-general.md",title:"Using the FROM construct in more places",description:"This new feature is a pretty simple generalization of the FROM construct as applied to expression lists.",date:"2022-02-21T00:00:00.000Z",formattedDate:"February 21, 2022",tags:[{label:"facebook",permalink:"/blog/tags/facebook"},{label:"cg-sql",permalink:"/blog/tags/cg-sql"}],readingTime:2.97,hasTruncateMarker:!1,authors:[{name:"CG/SQL Team",title:"Maintainer of CG/SQL",url:"https://github.com/facebookincubator",imageURL:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4"}],frontMatter:{slug:"from-general",title:"Using the FROM construct in more places",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql"]},prevItem:{title:"Introducing Blob Storage",permalink:"/blog/blob-storage"},nextItem:{title:"Introducing Expression Fragments",permalink:"/blog/expression-frags"}},u={authorsImageUrls:[void 0]},p=[],m={toc:p};function f(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.mdx)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"This new feature is a pretty simple generalization of the ",(0,a.mdx)("inlineCode",{parentName:"p"},"FROM")," construct as applied to expression lists.\nNote this isn't the same as using ",(0,a.mdx)("inlineCode",{parentName:"p"},"FROM")," the usual way in a ",(0,a.mdx)("inlineCode",{parentName:"p"},"select")," statement.   An example will clear\nthis right up."),(0,a.mdx)("p",null,"Suppose you wanted to create a procedure that inserts a row into a table.  You could write this:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-sql"},"create table Shape_xy (x int, y int);\n\ncreate proc insert_xy(like Shape_xy)\nbegin\n  insert into Shape_xy from arguments;\nend;\n")),(0,a.mdx)("p",null,"Here we're using ",(0,a.mdx)("inlineCode",{parentName:"p"},"from")," to introduce some shape of values.  It can appear in a lot of places."),(0,a.mdx)("p",null,"Suppose now I want to insert two of those shapes. I could write this slightly more complicated procedure:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc insert_two_xy(xy1 like Shape_xy, xy2 like Shape_xy)\nbegin\n   call insert_xy(from xy1);\n   call insert_xy(from xy2);\nend;\n")),(0,a.mdx)("p",null,"This also composes with cursors, so maybe you need to get two ",(0,a.mdx)("inlineCode",{parentName:"p"},"xy")," values from diverse\nlocations.  You can mix and match."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc write_xy()\nbegin\n   declare C cursor for select T.x, T.y from somewhere T;\n   fetch C;\n   declare D cursor for select T.x, T.y from somewhere_else T;\n   fetch D;\n   if C and D then\n     -- strange combos for illustration only\n     call insert_two_xy(from C, from D);\n     call insert_two_xy(from D, 5, 3);\n     call insert_two_xy(4, 2, from C);\n     call insert_two_xy(4, from C, 8);\n   end if;\nend;\n")),(0,a.mdx)("p",null,"So, as you can see, we can start from data in one or more cursors and we can turn that data,\nplus other expressions, into arguments, composing them as we like. This gives you the ability\nto call procedures and functions using shapes from a mixed set of sources.  None of this is new."),(0,a.mdx)("p",null,"However, the other places where expression lists happen -- ",(0,a.mdx)("inlineCode",{parentName:"p"},"fetch"),", ",(0,a.mdx)("inlineCode",{parentName:"p"},"update cursor"),", and ",(0,a.mdx)("inlineCode",{parentName:"p"},"insert")," -- only\nallowed you specify a single object as the input source such as ",(0,a.mdx)("inlineCode",{parentName:"p"},"insert into Shape_xy from C"),"."),(0,a.mdx)("p",null,"With a little work, this is trivially generalized so that all value lists can use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"from")," construct."),(0,a.mdx)("p",null,"Here's a complete example showing all the new forms."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-sql"},"create table Shape_xy (x int, y int);\ncreate table Shape_uv (u text, v text);\ncreate table Shape_uvxy (like Shape_xy, like Shape_uv);\n\ncreate proc ShapeTrix()\nbegin\n  declare C cursor for select Shape_xy.*, '1' u, '2' v from Shape_xy;\n  fetch C;\n\n  -- This new form is equivalent to the old form:\n  --    insert into Shape_xy from C(like Shape_xy)\n  -- but the values(...) form generalizes, see below.\n  insert into Shape_xy values(from C like Shape_xy);\n\n  declare D cursor for select * from Shape_uv;\n  fetch D;\n\n  declare R cursor like Shape_uvxy;\n\n  -- This form works just like the function call case\n  -- that was previously supported (it uses the same code even).\n  -- This form lets you load R from any combination of sources\n  -- as long as you make a suitable row.\n  fetch R from values (from C like Shape_xy, from D);\n\n  -- Same thing is supported in update cursor\n  -- the x, y come from C and the u,v come from D.x, D.y.\n  -- Note that C.u and C.v would not even be type compatible.\n  update cursor R from values (from C like Shape_xy, from D);\n\n  -- And in a select-values clause\n  declare S cursor for\n    with cte(l,m,n,o) as (values (from C like Shape_xy, from D))\n     select * from cte;\n  fetch S;\n  insert into Shape_uvxy from S;\nend;\n")),(0,a.mdx)("p",null,"As you can see, you can choose a subset of the ",(0,a.mdx)("inlineCode",{parentName:"p"},"from")," shape using ",(0,a.mdx)("inlineCode",{parentName:"p"},"like"),"."),(0,a.mdx)("p",null,"These combinations let you flexibily assemble rows of data for\ncursors, calls, and insertions, using any combination of data sources\nyou might want, without resorting to listing every column by hand."))}f.isMDXComponent=!0}}]);