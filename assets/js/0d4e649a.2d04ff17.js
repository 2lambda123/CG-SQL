"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4627],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),h=d(n),c=i,m=h["".concat(s,".").concat(c)]||h[c]||u[c]||o;return n?a.createElement(m,l(l({ref:t},p),{},{components:n})):a.createElement(m,l({ref:t},p))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=h;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var d=2;d<o;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7366:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return r},metadata:function(){return d},toc:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),l=["components"],r={id:"x8",title:"Appendix 8: CQL Best Practices",sidebar_label:"Appendix 8: CQL Best Practices"},s=void 0,d={unversionedId:"x8",id:"x8",title:"Appendix 8: CQL Best Practices",description:"\x3c!---",source:"@site/../CQL_Guide/x8.md",sourceDirName:".",slug:"/x8",permalink:"/cql-guide/x8",draft:!1,tags:[],version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1664404098,formattedLastUpdatedAt:"9/28/2022",frontMatter:{id:"x8",title:"Appendix 8: CQL Best Practices",sidebar_label:"Appendix 8: CQL Best Practices"},sidebar:"someSidebar",previous:{title:"Appendix 7: CQL Anti-patterns",permalink:"/cql-guide/x7"},next:{title:"Appendix 9: Using the CQL Amalgam",permalink:"/cql-guide/x9"}},p={},u=[{value:"Data Definition Language (DDL)",id:"data-definition-language-ddl",level:3},{value:"Ad Hoc Migrations",id:"ad-hoc-migrations",level:3},{value:"Transactions",id:"transactions",level:3},{value:"Savepoints",id:"savepoints",level:3},{value:"Compilation options",id:"compilation-options",level:3},{value:"Previous Schema",id:"previous-schema",level:3},{value:"Schema Regions",id:"schema-regions",level:3},{value:"Schema Version",id:"schema-version",level:3},{value:"C Text Echo",id:"c-text-echo",level:3},{value:"Enumerations",id:"enumerations",level:3},{value:"Cursor Lifetime",id:"cursor-lifetime",level:3},{value:"Procedure Calls and Exceptions",id:"procedure-calls-and-exceptions",level:3},{value:"Control Flow with &quot;Big Moves&quot;",id:"control-flow-with-big-moves",level:3},{value:"Getting access to external code",id:"getting-access-to-external-code",level:3},{value:"Regular Data Manipulation Language (DML)",id:"regular-data-manipulation-language-dml",level:3},{value:"Variable and Cursor declarations",id:"variable-and-cursor-declarations",level:3},{value:"Query Plans",id:"query-plans",level:3},{value:"Fetching Data from a Cursor or from Loose Data",id:"fetching-data-from-a-cursor-or-from-loose-data",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"Manual Control of Results",id:"manual-control-of-results",level:3},{value:"CTEs and Shared Fragments",id:"ctes-and-shared-fragments",level:3}],h={toc:u};function c(e){var t=e.components,n=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This is a brief discussion of every statement type and some general best practices for that statement.\nThe statements are in mostly alphabetical order except related statements were moved up in the order\nto make logical groups."),(0,o.kt)("p",null,"Refer also to Appendix 7: CQL Anti-patterns."),(0,o.kt)("h3",{id:"data-definition-language-ddl"},"Data Definition Language (DDL)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ALTER TABLE ADD COLUMN")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CREATE INDEX")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CREATE PROC")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CREATE TABLE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CREATE TRIGGER")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CREATE VIEW")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CREATE VIRTUAL TABLE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DROP INDEX")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DROP TABLE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DROP TRIGGER")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DROP VIEW"))),(0,o.kt)("p",null,"These statements almost never appear in normal procedures and generally should be avoided.  The normal way of handling schema in CQL\nis to have one or more files declare all the schema you need and then let CQL create a schema upgrader for you.  This means you'll\nnever manually drop tables or indices etc.  The ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," declarations with their annotations will totally drive the schema."),(0,o.kt)("p",null,"Any ad hoc DDL is usually a very bad sign.  Test code is an obvious exception to this as it often does setup and teardown\nof schema to set up things for the test."),(0,o.kt)("h3",{id:"ad-hoc-migrations"},"Ad Hoc Migrations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@SCHEMA_AD_HOC_MIGRATION"))),(0,o.kt)("p",null,"This is a special upgrade step that should be taken at the version indicated in the statement.  These can be quite complex and even super important\nbut should not be used lightly.  Any migration procedure has to be highly tolerant of a variety of incoming schema versions and previous partial successes.\nIn any case this directive should not appear in normal code.  It should be part of the schema DDL declarations."),(0,o.kt)("h3",{id:"transactions"},"Transactions"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"BEGIN TRANSACTION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"COMMIT TRANSACTION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ROLLBACK TRANSACTION"))),(0,o.kt)("p",null,'Transactions do not nest and most procedures do not know the context in which they will be called, so the vast majority of\nprocedures will not and should not actually start transactions.  You can only do this if you know, somehow, for sure, that\nthe procedure in question is somehow a "top level" procedure.  So generally, don\'t use these statements.'),(0,o.kt)("h3",{id:"savepoints"},"Savepoints"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SAVEPOINT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ROLLBACK TO SAVEPOINT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RELEASE SAVEPOINT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PROC SAVEPOINT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"COMMIT RETURN")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ROLLBACK RETURN"))),(0,o.kt)("p",null,"Savepoints are the preferred tool for having interim state that can be rolled back if needed.  You can use ad hoc\nsavepoints, just give your save point and name then use ",(0,o.kt)("inlineCode",{parentName:"p"},"RELEASE SAVEPOINT")," to commit it, or else ",(0,o.kt)("inlineCode",{parentName:"p"},"ROLLBACK TO SAVEPOINT"),"\nfollowed by a ",(0,o.kt)("inlineCode",{parentName:"p"},"RELEASE")," to abort it.  Note that you always ",(0,o.kt)("inlineCode",{parentName:"p"},"RELEASE")," savepoints in both the rollback and the commit case."),(0,o.kt)("p",null,"Managing savepoints can be tricky, especially given the various error cases.  They combine nicely with ",(0,o.kt)("inlineCode",{parentName:"p"},"TRY CATCH")," to do\nthis job.  However, even that is a lot of boilerplate.  The best way to use savepoints is with ",(0,o.kt)("inlineCode",{parentName:"p"},"PROC SAVEPOINT BEGIN")," .. ",(0,o.kt)("inlineCode",{parentName:"p"},"END"),";"),(0,o.kt)("p",null,"When you use ",(0,o.kt)("inlineCode",{parentName:"p"},"PROC SAVEPOINT"),", a savepoint is created for you with the name of your procedure.  When the block exits\nthe savepoint is released (committed).  However you also get an automatically generated try/catch block which will\nrollback the savepoint if anything inside the block were to invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"THROW"),".  Also, you may not use a regular ",(0,o.kt)("inlineCode",{parentName:"p"},"RETURN"),"\ninside this block, you must use either ",(0,o.kt)("inlineCode",{parentName:"p"},"ROLLBACK RETURN")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"COMMIT RETURN"),".  Both of these directly indicate the fate\nof the automatically generated statement when they run.  This gives you useful options to early-out (with no error)\nwhile keeping or abandoning any work in progress.  Of course you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"THROW")," to return an error and\nabandon the work in progress."),(0,o.kt)("h3",{id:"compilation-options"},"Compilation options"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@ENFORCE_NORMAL")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@ENFORCE_POP")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@ENFORCE_PUSH")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@ENFORCE_RESET")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@ENFORCE_STRICT"))),(0,o.kt)("p",null,'CQL allows you to specify a number of useful options such as "do not allow Window Functions" or "all foreign keys must choose some update or delete strategy".\nThese additional enforcements are designed to prevent errors.  Because of this they should be established once, somewhere central and they should be rarely\nif ever overridden.  For instance ',(0,o.kt)("inlineCode",{parentName:"p"},"@ENFORCE_NORMAL WINDOW FUNCTION")," would allow you to use window functions again, but this is probably a bad idea. If\nstrict mode is on, disallowing them, that probably means your project is expected to target versions of SQLite that do not have window functions.  Overriding\nthat setting is likely to lead to runtime errors."),(0,o.kt)("p",null,"In general you don't want to see these options in most code."),(0,o.kt)("h3",{id:"previous-schema"},"Previous Schema"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@PREVIOUS_SCHEMA"))),(0,o.kt)("p",null,"CQL can ensure that the current schema is compatible with the previous schema, meaning that an upgrade script could reasonably be generated to go from the\nprevious to the current.  This directive demarks the start of the previous schema section when that validation happens.  This directive is useless except\nfor creating that schema validation so it should never appear in normal procedures."),(0,o.kt)("h3",{id:"schema-regions"},"Schema Regions"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@BEGIN_SCHEMA_REGION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@DECLARE_DEPLOYABLE_REGION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@DECLARE_SCHEMA_REGION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@END_SCHEMA_REGION"))),(0,o.kt)("p",null,"CQL allows you to declare arbitrary schema regions and limit what parts of the schema any given region may consume.  This helps you to prevent schema from getting\nentangled.  There is never a reason to use this directives inside normal procedures;  They should appear only in your schema declaration files."),(0,o.kt)("h3",{id:"schema-version"},"Schema Version"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@SCHEMA_UPGRADE_SCRIPT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@SCHEMA_UPGRADE_VERSION"))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@SCHEMA_UPGRADE_SCRIPT")," directive is only used by CQL itself to declare that the incoming file is an autogenerated schema upgrade script.\nThese scripts have slightly different rules for schema declaration that are not useful outside of such scripts.  So you should never use this."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@SCHEMA_UPGRADE_VERSION")," on the other hand is used if you are creating a manual migration script.  You need this script to run in the context\nof the schema version that it affects.  Use this directive at the start of the file to do so.  Generally manual migration scripts are to be\navoided so hopefully this directive is rarely if ever used."),(0,o.kt)("h3",{id:"c-text-echo"},"C Text Echo"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@ECHO"))),(0,o.kt)("p",null,"This directive emits plain text directly into the compiler's output stream.  It can be invaluable for adding new runtime features and for ensuring that\n(e.g.) additional ",(0,o.kt)("inlineCode",{parentName:"p"},"#include")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"#define")," directives are present in the output but you can really break things by over-using this feature.  Most parts\nof the CQL output are subject to change so any use of this should be super clean.  The intended use was, as mentioned, to allow an extra ",(0,o.kt)("inlineCode",{parentName:"p"},"#include")," in your code\nso that CQL could call into some library.  Most uses of this combine with ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE FUNCTION")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE PROCEDURE")," to declare an external entity."),(0,o.kt)("h3",{id:"enumerations"},"Enumerations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DECLARE ENUM")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@EMIT_ENUMS"))),(0,o.kt)("p",null,"Avoid embedded constants whenever possible.  Instead declare a suitable enumeration.   Use ",(0,o.kt)("inlineCode",{parentName:"p"},"@EMIT_ENUMS Some_Enum")," to get the enumeration\nconstants into the generated .h file for C. But be sure to do this only from one compiland.  You do not want the enumerations in every .h file.\nChoose a single .sql file (not included by lots of other things) to place the ",(0,o.kt)("inlineCode",{parentName:"p"},"@EMIT_ENUMS")," directive. You can make a file specifically for this\npurpose if nothing else is serviceable."),(0,o.kt)("h3",{id:"cursor-lifetime"},"Cursor Lifetime"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CLOSE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"OPEN"))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"OPEN")," statement is a no-op, SQLite has no such notion.  It was included because it is present in ",(0,o.kt)("inlineCode",{parentName:"p"},"MYSQL")," and other variants and its inclusion can\nease readability sometimes.  But it does nothing.   The ",(0,o.kt)("inlineCode",{parentName:"p"},"CLOSE")," statement is normally not necessary because all cursors are closed at the end of the\nprocedure they are declared in (unless they are boxed, see below).  You only need ",(0,o.kt)("inlineCode",{parentName:"p"},"CLOSE"),' if you want to close a global cursor (which has no scope)\nor if you want to close a local cursor "sooner" because waiting to the end of the procedure might be a very long time.  Using close more than once\nis safe, the second and later close operations do nothing.'),(0,o.kt)("h3",{id:"procedure-calls-and-exceptions"},"Procedure Calls and Exceptions"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CALL")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"THROW")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"TRY CATCH"))),(0,o.kt)("p",null,"Remember that if you call a procedure and it uses ",(0,o.kt)("inlineCode",{parentName:"p"},"THROW")," or else uses some SQL that failed, this return code will cause your\ncode to ",(0,o.kt)("inlineCode",{parentName:"p"},"THROW")," when the procedure returns.  Normally that's exactly what you want, the error will ripple out and some top-level\n",(0,o.kt)("inlineCode",{parentName:"p"},"CATCH")," will cause a ",(0,o.kt)("inlineCode",{parentName:"p"},"ROLLBACK")," and the top level callers sees the error.  If you have your own rollback needs be sure to install\nyour own ",(0,o.kt)("inlineCode",{parentName:"p"},"TRY"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"CATCH")," block or else use ",(0,o.kt)("inlineCode",{parentName:"p"},"PROC SAVEPOINT")," as above to do it for you."),(0,o.kt)("p",null,"Inside of a ",(0,o.kt)("inlineCode",{parentName:"p"},"CATCH")," block you can use the special variable ",(0,o.kt)("inlineCode",{parentName:"p"},"@RC")," to see the most recent return code from SQLite."),(0,o.kt)("h3",{id:"control-flow-with-big-moves"},'Control Flow with "Big Moves"'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CONTINUE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"LEAVE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RETURN"))),(0,o.kt)("p",null,"These work as usual but beware, you can easily use any of these to accidentally leave a block with a savepoint or transaction\nand you might skip over the ",(0,o.kt)("inlineCode",{parentName:"p"},"ROLLBACK")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"COMMIT")," portions of the logic.  Avoid this problem by using ",(0,o.kt)("inlineCode",{parentName:"p"},"PROC SAVEPOINT"),"."),(0,o.kt)("h3",{id:"getting-access-to-external-code"},"Getting access to external code"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DECLARE FUNCTION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DECLARE SELECT FUNCTION")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DECLARE PROCEDURE"))),(0,o.kt)("p",null,"The best practice is to put any declarations into a shared header file which you can ",(0,o.kt)("inlineCode",{parentName:"p"},"#include")," in all the places it is needed.\nThis is especially important should you have to forward declare a procedure.  CQL normally provides exports for all procedures\nso you basically get an automatically generated and certain-to-be-correct ",(0,o.kt)("inlineCode",{parentName:"p"},"#include")," file.  But, if the procedures are being compiled\ntogether then an export file won't have been generated yet at the time you need it;  To work around this you use the ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE PROCEDURE"),"\nform.  However, procedure declarations are tricky;  they include not just the type of the arguments but the types of any/all of the\ncolumns in any result set the procedure might have.  This must not be wrong or callers will get unpredictable failures."),(0,o.kt)("p",null,"The easiest way to ensure it is correct is to use the same trick as you would in C -- make sure that you ",(0,o.kt)("inlineCode",{parentName:"p"},"#include")," the declaration\nthe in the translation unit with the definition.  If they don't match there will be an error."),(0,o.kt)("p",null,"A very useful trick: the error will include the exact text of the correct declaration.  So if you don't know it, or are too lazy to\nfigure it out; simply put ",(0,o.kt)("inlineCode",{parentName:"p"},"ANY")," declaration in the shared header file and then paste in the correct declaration from the error.  should\nthe definition ever change you will get a compilation error which you can again harvest to get the correct declaration."),(0,o.kt)("p",null,"In this way you can be sure the declarations are correct."),(0,o.kt)("p",null,"Functions have no CQL equivalent, but they generally don't change very often.  Use ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE FUNCTION")," to allow access to some C code\nthat returns a result of some kind.   Be sure to add the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE")," option if the function returns a reference that the caller owns."),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE SELECT FUNCTION")," to tell CQL about any User Defined Functions you have added to SQLite so that it knows how to call them.\nNote that CQL does not register those UDFs, it couldn't make that call lacking the essential C information required to do so.  If you\nfind that you are getting errors when calling a UDF the most likely reason for the failure is that the UDF was declared but never\nregistered with SQLite at runtime.  This happens in test code a lot -- product code tends to have some central place to register the\nUDFs and it normally runs at startup, e.g. right after the schema is upgraded."),(0,o.kt)("h3",{id:"regular-data-manipulation-language-dml"},"Regular Data Manipulation Language (DML)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DELETE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"INSERT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SELECT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UPDATE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UPSERT"))),(0,o.kt)("p",null,"These statements are the most essential and they'll appear in almost every procedure. There are a few general best practices we can go over."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Try to do as much as you can in one batch rather than iterating;  e.g."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"don't write a loop with a ",(0,o.kt)("inlineCode",{parentName:"li"},"DELETE")," statement that deletes one row if you can avoid it, write a delete statement that deletes all you need to delete"),(0,o.kt)("li",{parentName:"ul"},"don't write a loop with of ",(0,o.kt)("inlineCode",{parentName:"li"},"SELECT")," statement that fetches one row, try to fetch all the rows you need with one select"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Make sure ",(0,o.kt)("inlineCode",{parentName:"p"},"UPSERT")," is supported on the SQLite system you are using, older versions do not support it")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Don't put unnecessary casts in your ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," statements, they just add fat")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"CASE"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"WHEN")," to compute a boolean, the boolean operations are more economical (e.g. use ",(0,o.kt)("inlineCode",{parentName:"p"},"IS"),")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"COUNT")," if all you need to know is whether a row exists or not, use ",(0,o.kt)("inlineCode",{parentName:"p"},"EXISTS"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"GROUP BY"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ORDER BY"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"DISTINCT")," on large rowsets, the sort is expensive and it will make your ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," statements write to disk rather than just read")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Always use the ",(0,o.kt)("inlineCode",{parentName:"p"},"INSERT INTO FOO USING")," form of the ",(0,o.kt)("inlineCode",{parentName:"p"},"INSERT")," statement, it's much easier to read than the standard form and compiles to the same thing"))),(0,o.kt)("h3",{id:"variable-and-cursor-declarations"},"Variable and Cursor declarations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DECLARE OUT CALL")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DECLARE")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"LET")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SET"))),(0,o.kt)("p",null,"These are likely to appear all over as well.  If you can avoid a variable declaration by using ",(0,o.kt)("inlineCode",{parentName:"p"},"LET")," then do so;  The code will be more concise and you'll\nget the exact variable type you need.  This is the same as ",(0,o.kt)("inlineCode",{parentName:"p"},"var x = foo();")," in other languages.  Once the variable is declared use ",(0,o.kt)("inlineCode",{parentName:"p"},"SET"),"."),(0,o.kt)("p",null,"You can save yourself a lot of declarations of ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," variables with ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE OUT CALL"),".  That declaration form automatically declares the ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," variables used\nin the call you are about to make with the correct type.  If the number of arguments changes you just have to add the args you don't have to also add\nnew declarations."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE")," construct can be used to let you declare things whose type is the same as another thing.  Patterns like ",(0,o.kt)("inlineCode",{parentName:"p"},"DECLARE ARGS CURSOR LIKE FOO ARGUMENTS"),'\nsave you a lot of typing and also enhance correctness.  There\'s a whole chapter dedicated to "shapes" defined by ',(0,o.kt)("inlineCode",{parentName:"p"},"LIKE"),"."),(0,o.kt)("h3",{id:"query-plans"},"Query Plans"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"EXPLAIN"))),(0,o.kt)("p",null,"Explain can be used in front of other queries to generate a plan.  The way SQLite handles this is that you fetch the rows of the plan as usual.  So basically\n",(0,o.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," is kind of like ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT QUERY PLAN OF"),".  This hardly ever comes up in normal coding.  CQL has an output option where it will generate code that gives you\nthe query plan for a procedures queries rather than the normal body of the procedure."),(0,o.kt)("h3",{id:"fetching-data-from-a-cursor-or-from-loose-data"},"Fetching Data from a Cursor or from Loose Data"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"FETCH")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UPDATE CURSOR"))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FETCH")," statement has many variations, all are useful at some time or another. There are a few helpful guidelines."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If fetching from loose values into a cursor use the ",(0,o.kt)("inlineCode",{parentName:"li"},"FETCH USING")," form (as you would with ",(0,o.kt)("inlineCode",{parentName:"li"},"INSERT INTO USING"),") because it is less error prone"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"FETCH INTO")," is generally a bad idea, you'll have to declare a lot of variables, instead just rely on automatic storage in the cursor e.g.\n",(0,o.kt)("inlineCode",{parentName:"li"},"fetch my_cursor")," rather than ",(0,o.kt)("inlineCode",{parentName:"li"},"fetch my_cursor into a, b, c")),(0,o.kt)("li",{parentName:"ul"},"If you have data already in a cursor you can mutate some of the columns using ",(0,o.kt)("inlineCode",{parentName:"li"},"UPDATE CURSOR"),", this can let you adjust values or apply defaults")),(0,o.kt)("h3",{id:"control-flow"},"Control Flow"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IF")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"LOOP")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SWITCH")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"WHILE"))),(0,o.kt)("p",null,"These are your bread and butter and they will appear all over.  One tip: Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ALL VALUES")," variant of switch whenever possible to ensure that you haven't missed any cases."),(0,o.kt)("h3",{id:"manual-control-of-results"},"Manual Control of Results"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"OUT"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If you know you are producing exactly one row ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT")," is more economical than ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If you need complete flexibility on what rows to produce (e.g. skip some, add extras, mutate some) then ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT UNION")," will give you that, use it only when needed, it's more expensive than just ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")))),(0,o.kt)("h3",{id:"ctes-and-shared-fragments"},"CTEs and Shared Fragments"),(0,o.kt)("p",null,"To understand what kinds of things you can reasonably do with fragments, really you\njust have to understand the things that you can do with common table expressions or\nCTEs.  For those who don't know, CTEs are the things you declare\nin the WITH clause of a SELECT statement.  They're kind of like local views.  Well,\nactually, they are exactly like local views."),(0,o.kt)("p",null,"Query fragments help you to define useful CTEs so basically what you can do\neconomically in a CTE directly determines what you can do economically in a fragment."),(0,o.kt)("p",null,"To demonstrate some things that happen with CTEs we're going to use these three\nboring tables."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"create table A\n(\n   id integer primary key,\n   this text not null\n);\n\ncreate table B\n(\n   id integer primary key,\n   that text not null\n);\n\ncreate table C\n(\n   id integer primary key,\n   other text not null\n);\n")),(0,o.kt)("p",null,"Let's start with a very simple example, the first few examples are like control cases."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nselect * from A\ninner join B on B.id = A.id;\n\nQUERY PLAN\n|--SCAN TABLE A\n\\--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"OK as we can see ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," is not constrained so it has to be scanned but ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," isn't scanned,\nwe use its primary key for the join.  This is the most common kind of join: a search\nbased on a key of the table you are joining to."),(0,o.kt)("p",null,"Let's make it a bit more realistic."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nselect * from A\ninner join B on B.id = A.id\nwhere A.id = 5;\n\nQUERY PLAN\n|--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n\\--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"Now ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," is constrained by the ",(0,o.kt)("inlineCode",{parentName:"p"},"WHERE")," clause so we can use its index and then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," index.\nSo we get a nice economical join from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," and no scans at all."),(0,o.kt)("p",null,"Now suppose we try this with some CTE replacements for ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),".  Does this make it worse?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nwith\n  AA(id, this) as (select * from A),\n  BB(id, that) as (select * from B)\nselect * from AA\nleft join BB on BB.id = AA.id\nwhere AA.id = 5;\n\nQUERY PLAN\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n\\--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"The answer is a resounding no.  The CTE ",(0,o.kt)("inlineCode",{parentName:"p"},"AA")," was not materialized it was expanded in place,\nas was the CTE ",(0,o.kt)("inlineCode",{parentName:"p"},"BB"),".  We get ",(0,o.kt)("em",{parentName:"p"},"exactly")," the same query plan.  Now this means that the\ninner expressions like ",(0,o.kt)("inlineCode",{parentName:"p"},"select * from A")," could have been fragments such as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\ncreate proc A_()\nbegin\n  select * from A;\nend;\n\n@attribute(cql:shared_fragment)\ncreate proc B_()\nbegin\n  select * from B;\nend;\n\nexplain query plan\nwith\n  (call A_()),    -- short for A_(*) AS (call A_())\n  (call B_())     -- short for B_(*) AS (call B_())\nselect * from A_\nleft join B_ on B_.id = A_.id\nwhere A_.id = 5;\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note:")," I'll use the convention that ",(0,o.kt)("inlineCode",{parentName:"p"},"A_")," is the fragment proc that could have generated the CTE ",(0,o.kt)("inlineCode",{parentName:"p"},"AA"),",\nlikewise with ",(0,o.kt)("inlineCode",{parentName:"p"},"B_")," and so forth."),(0,o.kt)("p",null,"The above will expand into exactly what we had before and hence will have the exactly\nsame good query plan.  Of course this is totally goofy, why make a fragment like that --\nit's just more typing.  Well now lets generalize the fragments just a bit."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'@attribute(cql:shared_fragment)\ncreate proc A_(experiment bool not null)\nbegin\n  -- data source might come from somewhere else due to an experiment\n  if not experiment then\n    select * from A;\n  else\n    select id, this from somewhere_else;\n  end if;\nend;\n\n@attribute(cql:shared_fragment)\ncreate proc B_()\nbegin\n  -- we don\'t actually refer to "B" if the filter is null\n  if b_filter is not null then\n    -- applies b_filter if specified\n    select * from B where B.other like b_filter;\n  else\n    -- generates the correct shape but zero rows of it\n    select null as id, null as that where false;\n  end if;\nend;\n\ncreate proc getAB(\n    id_ integer not null,\n    experiment bool not null,\n    b_filter text)\nbegin\n  with\n    (call A_(experiment)),\n    (call B_(b_filter))\n  select * from A_\n  left join B_ on B_.id = A_.id\n  where A_.id = id_;\nend;\n')),(0,o.kt)("p",null,"The above now has 4 combos economically encoded and all of them have a good plan.\nImportantly though, if ",(0,o.kt)("inlineCode",{parentName:"p"},"b_filter")," is not specified then we don't actually join to ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),".\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"B_")," CTE will have no reference to ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", it just has zero rows."),(0,o.kt)("p",null,"Now lets look at some things you don't want to do."),(0,o.kt)("p",null,"Consider this form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nwith\n  AA(id, this) as (select * from A),\n  BB(id, that) as (select A.id, B.that from A left join B on B.id = A.id)\nselect * from AA\nleft join BB on BB.id = AA.id\nwhere AA.id = 5;\n\nQUERY PLAN\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n\\--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"Note that here we get 3 joins.  Now a pretty cool thing happened here -- even though the expression\nfor ",(0,o.kt)("inlineCode",{parentName:"p"},"BB")," does not include a ",(0,o.kt)("inlineCode",{parentName:"p"},"WHERE")," clause SQLite has figured out the ",(0,o.kt)("inlineCode",{parentName:"p"},"AA.id")," being 5 forces ",(0,o.kt)("inlineCode",{parentName:"p"},"A.id")," to be 5\nwhich in turn gives a constraint on ",(0,o.kt)("inlineCode",{parentName:"p"},"BB"),". Nice job SQLite.  If it hadn't been able to figure that out\nthen the expansion of ",(0,o.kt)("inlineCode",{parentName:"p"},"BB")," would have resulted in a table scan."),(0,o.kt)("p",null,"Still, 3 joins is bad when we only need 2 joins to do the job.  What happened?  Well, when we did\nthe original fragments with extensions and stuff we saw this same pattern in fragment code.\nBasically the fragment for ",(0,o.kt)("inlineCode",{parentName:"p"},"BB")," isn't just doing the ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," things it's restarting from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and doing its\nown join to get ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),". This results in a wasted join.  And it might result in a lot of work on the ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," table\nas well if the filtering was more complex and couldn't be perfectly inferred."),(0,o.kt)("p",null,"You might think, \"oh, no problem, I can save this, I'll just refer to ",(0,o.kt)("inlineCode",{parentName:"p"},"AA")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),' in the second query."'),(0,o.kt)("p",null,"This does not help (but it's going in the right direction):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nwith\n  AA(id, this) as (select * from A),\n  BB(id, that) as (select AA.id, B.that from AA left join B on B.id = AA.id)\nselect * from AA\nleft join BB on BB.id = AA.id\nwhere AA.id = 5;\n\nQUERY PLAN\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n\\--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"In terms of fragments the anti-pattern is this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\ncreate proc B_()\nbegin\n  select B.* from A left join B on B.id = A.id;\nend;\n")),(0,o.kt)("p",null,"The above starts the query for ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," again from the root.  You can save this, the trick is to not\ntry to generate just the ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," columns and then join them later.  You can get a nice data\nflow going with chain of CTEs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nwith\n  AA(id, this) as (select * from A),\n  AB(id, this, that) as (select AA.*, B.that from AA left join B on B.id = AA.id)\nselect * from AB\nwhere AB.id = 5;\n\nQUERY PLAN\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n\\--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"And we're right back to the perfect plan.  The good form creates a CTE chain\nwhere we only need the result of the final CTE.  A straight line of CTEs\neach depending on the previous one results in a excellent data flow."),(0,o.kt)("p",null,"In terms of fragments this is now:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\ncreate proc A_()\nbegin\n  select * from A;\nend;\n\n@attribute(cql:shared_fragment)\ncreate proc AB_()\nbegin\n  with\n  (call A_)\n  select A_.*, B.that from A_ left join B on B.id = A_.id\nend;\n\nwith (call AB_())\nselect * from AB_ where AB_.id = 5;\n")),(0,o.kt)("p",null,"For brevity I didn't include the possibility of using IF and such.  Another option\nthat makes the same good query plan.  We can generalize ",(0,o.kt)("inlineCode",{parentName:"p"},"AB_")," so that it doesn't know\nwhere the base data is coming from and can be used in more cases."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\ncreate proc A_()\nbegin\n  select * from A;\nend;\n\n@attribute(cql:shared_fragment)\ncreate proc AB_()\nbegin\n  with\n  source(*) like A -- you must provide some source that is the same shape as A\n  select source.*, B.that from source left join B on B.id = source.id\nend;\n\nwith\n(call A_())\n(call AB_() using A_ as source)\nselect * from AB_ where AB_.id = 5;\n")),(0,o.kt)("p",null,"Again this results in a nice straight chain of CTEs and even though the where\nclause is last the A table is constrained properly."),(0,o.kt)("p",null,"It's important not to fork the chain... if you do that then whatever\ncame before the fork must be materialized for use in both branches.\nThat can be quite bad because then the filtering might come after the\nmaterialization.  This is an example that is quite bad."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nwith\n  AA(id, this) as (select * from A),\n  BB(id, that) as (select AA.id, B.that from AA left join B on B.id = AA.id),\n  CC(id, other) as (select AA.id, C.other from AA left join C on C.id = AA.id)\nselect * from AA\nleft join BB on BB.id = AA.id\nleft join CC on CC.id = AA.id\nwhere AA.id = 5;\n\nQUERY PLAN\n|--MATERIALIZE 2\n|  |--SCAN TABLE A\n|  \\--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n|--MATERIALIZE 3\n|  |--SCAN TABLE A\n|  \\--SEARCH TABLE C USING INTEGER PRIMARY KEY (rowid=?)\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n|--SCAN SUBQUERY 2\n\\--SEARCH SUBQUERY 3 USING AUTOMATIC COVERING INDEX (id=?)\n")),(0,o.kt)("p",null,"Things have gone way of the rails here. As you can see ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," is now\nscanned twice. and there are many more joins.  We could make this\na lot better by moving the A condition all the way up into the first\nCTE.  With fragments that would just mean creating something like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\ncreate proc A_(id_)\nbegin\n  select * from A where A.id = id_;\nend;\n")),(0,o.kt)("p",null,"At least then if we have to materialize we'll get only one row.  This could be\na good thing to do universally, but it's especially important if you know that\nforking in the query shape is mandatory for some reason."),(0,o.kt)("p",null,"A better pattern might be this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"explain query plan\nwith\n  AA(id, this) as (select * from A),\n  AB(id, this, that) as (select AA.*, B.that from AA left join B on B.id = AA.id),\n  ABC(id, this, that, other) as (select AB.*, C.other from AB left join C on C.id = AB.id)\nselect * from ABC\nwhere ABC.id = 5;\n\nQUERY PLAN\n|--SEARCH TABLE A USING INTEGER PRIMARY KEY (rowid=?)\n|--SEARCH TABLE B USING INTEGER PRIMARY KEY (rowid=?)\n\\--SEARCH TABLE C USING INTEGER PRIMARY KEY (rowid=?)\n")),(0,o.kt)("p",null,"Here we've just extended the chain.  With shared fragments you could easily build an\n",(0,o.kt)("inlineCode",{parentName:"p"},"AB_")," proc as before and then build an ",(0,o.kt)("inlineCode",{parentName:"p"},"ABC_")," proc either by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"AB_")," directly or by\nhaving a table parameter that is ",(0,o.kt)("inlineCode",{parentName:"p"},"LIKE AB_"),"."),(0,o.kt)("p",null,"Both cases will give you a great plan."),(0,o.kt)("p",null,"So the most important things are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Avoid forking the chain of CTEs/fragments, a straight chain works great."),(0,o.kt)("li",{parentName:"ul"},"Avoid re-joining to tables, even unconstrained CTEs result in great plans if they don't have to be materialized."),(0,o.kt)("li",{parentName:"ul"},"If you do need to fork in your CTE chain, because of your desired shape, be sure to move as many filters as you can further upstream so that by the time you materialize only a very small number of rows need to be materialiized.")),(0,o.kt)("p",null,"These few rules will go far in helping you to create shapes."),(0,o.kt)("p",null,"One last thing, without shared fragments, if you wanted to create a large 10 way join or something you had to type that\njoin into your file and it would be very much in your face.  Now that join might be hidden from you in a nice easy-to-use\nfragment.  Which you might then decide you want to use 3 times... And now with a tiny amount of code you have 30 joins."),(0,o.kt)("p",null,"The thing is shared fragments make it easy to generate a lot of SQL.  It's not bad that shared fragments make things easy,\nbut with great power comes great responsibility, so give a care as to what it is you are assembling.  Understanding\nyour fragments, especially any big ones, will help you to create great code."))}c.isMDXComponent=!0}}]);