"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4642],{3905:function(e,n,a){a.r(n),a.d(n,{MDXContext:function(){return d},MDXProvider:function(){return u},mdx:function(){return x},useMDXComponents:function(){return p},withMDXComponents:function(){return m}});var t=a(67294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},o.apply(this,arguments)}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,o({},n,{components:a}))}},p=function(e){var n=t.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(d.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},N=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=p(a),u=r,N=m["".concat(l,".").concat(u)]||m[u]||c[u]||o;return a?t.createElement(N,s(s({ref:n},d),{},{components:a})):t.createElement(N,s({ref:n},d))}));function x(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=N;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var d=2;d<o;d++)l[d]=a[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}N.displayName="MDXCreateElement"},66833:function(e,n,a){a.r(n),a.d(n,{assets:function(){return m},contentTitle:function(){return i},default:function(){return c},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return p}});var t=a(83117),r=a(80102),o=(a(67294),a(3905)),l=["components"],s={id:"x7",title:"Appendix 7: CQL Anti-patterns",sidebar_label:"Appendix 7: CQL Anti-patterns"},i=void 0,d={unversionedId:"x7",id:"x7",title:"Appendix 7: CQL Anti-patterns",description:"\x3c!---",source:"@site/../CQL_Guide/x7.md",sourceDirName:".",slug:"/x7",permalink:"/cql-guide/x7",draft:!1,tags:[],version:"current",lastUpdatedBy:"timch326",lastUpdatedAt:1682983565,formattedLastUpdatedAt:"May 1, 2023",frontMatter:{id:"x7",title:"Appendix 7: CQL Anti-patterns",sidebar_label:"Appendix 7: CQL Anti-patterns"},sidebar:"someSidebar",previous:{title:"Appendix 6: CQL In 20 Minutes",permalink:"/cql-guide/x6"},next:{title:"Appendix 8: CQL Best Practices",permalink:"/cql-guide/x8"}},m={},p=[{value:"Common Schema",id:"common-schema",level:3},{value:"Declarations",id:"declarations",level:3},{value:"Casts",id:"casts",level:3},{value:"Booleans",id:"booleans",level:4},{value:"Boolean expressions and CASE/WHEN",id:"boolean-expressions-and-casewhen",level:3},{value:"CASE and CAST and NULL",id:"case-and-cast-and-null",level:3},{value:"Filtering out NULLs",id:"filtering-out-nulls",level:3},{value:"Not null boolean expressions",id:"not-null-boolean-expressions",level:3},{value:"Using <code>IS</code> when it makes sense to do so",id:"using-is-when-it-makes-sense-to-do-so",level:3},{value:"Left joins that are not left joins",id:"left-joins-that-are-not-left-joins",level:3}],u={toc:p};function c(e){var n=e.components,a=(0,r.Z)(e,l);return(0,o.mdx)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"These are a few of the antipatterns I've seen while travelling through various CQL source files.  They are in various categories."),(0,o.mdx)("p",null,"Refer also to Appendix 8: CQL Best Practices."),(0,o.mdx)("h3",{id:"common-schema"},"Common Schema"),(0,o.mdx)("p",null,"For these examples let's create a couple of tables we might need for examples"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE foo (\n    id integer primary key,\n    name text\n);\n\nCREATE TABLE bar (\n    id integer primary key,\n    rate real\n);\n")),(0,o.mdx)("h3",{id:"declarations"},"Declarations"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"DECLARE v LONG NOT NULL;\nSET v := 1;\n")),(0,o.mdx)("p",null,"better"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"LET v := 1L;  -- long literals have the L suffix like in C\n")),(0,o.mdx)("p",null,"Similarly"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"DECLARE v REAL NOT NULL;\nSET v := 1;\n")),(0,o.mdx)("p",null,"better"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"LET v := 1.0; -- use scientific notation or add .0 to make a real literal\n")),(0,o.mdx)("h3",{id:"casts"},"Casts"),(0,o.mdx)("p",null,"Redundant casts fatten the code and don't really add anything to readability.  Sometimems it's necessary to cast NULL to\na  particular type so that you can be sure that generated result set has the right data type, but most of the casts\nbelow are not necessary."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  SELECT\n    CAST(foo.id as INTEGER) as id,\n    CAST(foo.name as TEXT) as name,\n    CAST(NULL as REAL) as rate\n  FROM foo\nUNION ALL\n  SELECT\n    CAST(bar.id as INTEGER) as id,\n    CAST(NULL as TEXT) as name,\n    CAST(bar.rate as REAL) as rate\n  FROM bar\n")),(0,o.mdx)("p",null,"Better"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  SELECT\n    foo.id,\n    foo.name,\n    CAST(NULL as REAL) as rate\n  FROM foo\nUNION ALL\n  SELECT\n    bar.id,\n    CAST(NULL as TEXT) as name,\n    bar.rate\n  FROM bar\n")),(0,o.mdx)("p",null,"It's possible to do the following to make this even cleaner:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"-- somewhere central\n#define NULL_TEXT CAST(NULL as TEXT)\n#define NULL_REAL CAST(NULL as REAL)\n#define NULL_INT CAST(NULL as INTEGER)\n#define NULL_LONG CAST(NULL as LONG)\n")),(0,o.mdx)("p",null,"Then you can write"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  SELECT\n    foo.id,\n    foo.name,\n    NULL_REAL as rate\n  FROM foo\nUNION ALL\n  SELECT\n    bar.id,\n    NULL_TEXT as name,\n    bar.rate\n  FROM bar\n")),(0,o.mdx)("h4",{id:"booleans"},"Booleans"),(0,o.mdx)("p",null,"TRUE and FALSE can be used as boolean literals."),(0,o.mdx)("p",null,"SQLite doesn't care about the type but CQL will get the type information it needs to make the columns of type BOOL"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  SELECT\n    foo.id,\n    foo.name,\n    NULL_REAL as rate,\n    TRUE as has_name,  -- this is a bit artificial but you get the idea\n    FALSE as has_rate\n  FROM foo\nUNION ALL\n  SELECT\n    bar.id,\n    NULL_TEXT as name,\n    bar.rate,\n    FALSE as has_name,\n    TRUE as has_rate\n  FROM bar\n")),(0,o.mdx)("h3",{id:"boolean-expressions-and-casewhen"},"Boolean expressions and CASE/WHEN"),(0,o.mdx)("p",null,"It's easy to get carried away with the power of ",(0,o.mdx)("inlineCode",{parentName:"p"},"CASE")," expressions, I've seen this kind of thing:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"CAST(CASE WHEN foo.name IS NULL THEN 0 ELSE 1 END AS BOOL)\n")),(0,o.mdx)("p",null,"But this is simply"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"foo.name IS NOT NULL\n")),(0,o.mdx)("p",null,"In general, if your case alternates are booleans a direct boolean expression would have served you better."),(0,o.mdx)("h3",{id:"case-and-cast-and-null"},"CASE and CAST and NULL"),(0,o.mdx)("p",null,"Somtimes there's clamping or filtering going on in a case statement"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"CAST(CASE WHEN foo.name > 'm' THEN foo.name ELSE NULL END AS TEXT)\n")),(0,o.mdx)("p",null,"Here the ",(0,o.mdx)("inlineCode",{parentName:"p"},"CAST")," is not needed at all so we could go to"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"CASE WHEN foo.name > 'm' THEN foo.name ELSE NULL END\n")),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"NULL")," is already the default value for the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ELSE")," clause so you never need ",(0,o.mdx)("inlineCode",{parentName:"p"},"ELSE NULL")),(0,o.mdx)("p",null,"So better:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"CASE WHEN foo.name > 'm' THEN foo.name END\n")),(0,o.mdx)("h3",{id:"filtering-out-nulls"},"Filtering out NULLs"),(0,o.mdx)("p",null,"Consider"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"SELECT *\n    FROM foo\n    WHERE foo.name IS NOT NULL AND foo.name > 'm';\n")),(0,o.mdx)("p",null,"There's no need to test for ",(0,o.mdx)("inlineCode",{parentName:"p"},"NOT NULL")," here, the boolean will result in ",(0,o.mdx)("inlineCode",{parentName:"p"},"NULL")," if ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo.name")," is null\nwhich is not true so the ",(0,o.mdx)("inlineCode",{parentName:"p"},"WHERE")," test will fail."),(0,o.mdx)("p",null,"Better:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"SELECT *\n    FROM foo\n    WHERE foo.name > 'm';\n")),(0,o.mdx)("h3",{id:"not-null-boolean-expressions"},"Not null boolean expressions"),(0,o.mdx)("p",null,"In this statement we do not want to have a null result for the boolean expression"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"SELECT\n    id,\n    name,\n    CAST(IFNULL(name > 'm', 0) AS BOOL) AS name_bigger_than_m\n    FROM FOO;\n")),(0,o.mdx)("p",null,"So now we've made several mistakes.  We could have used the usual ",(0,o.mdx)("inlineCode",{parentName:"p"},"FALSE")," defintion to avoid the cast.\nBut even that would have left us with an IFNULL that's harder to read.  Here's a much simpler formulation:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"SELECT\n    id,\n    name,\n    name > 'm' IS TRUE AS name_bigger_than_m\n    FROM FOO;\n")),(0,o.mdx)("p",null,"Even without the ",(0,o.mdx)("inlineCode",{parentName:"p"},"TRUE")," macro you could do ",(0,o.mdx)("inlineCode",{parentName:"p"},"IS 1")," above and still get a result of type ",(0,o.mdx)("inlineCode",{parentName:"p"},"BOOL NOT NULL")),(0,o.mdx)("h3",{id:"using-is-when-it-makes-sense-to-do-so"},"Using ",(0,o.mdx)("inlineCode",{parentName:"h3"},"IS")," when it makes sense to do so"),(0,o.mdx)("p",null,"This kind of boolean expression is also verbose for no reason"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"    rate IS NOT NULL AND rate = 20\n")),(0,o.mdx)("p",null,"In a ",(0,o.mdx)("inlineCode",{parentName:"p"},"WHERE")," clause probably ",(0,o.mdx)("inlineCode",{parentName:"p"},"rate = 20")," suffices but even if you really need a ",(0,o.mdx)("inlineCode",{parentName:"p"},"NOT NULL BOOL"),"\nresult the expression above is exactly what the ",(0,o.mdx)("inlineCode",{parentName:"p"},"IS")," operator is for.  e.g."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"    rate IS 20\n")),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"IS")," operator is frequently avoided except for ",(0,o.mdx)("inlineCode",{parentName:"p"},"IS NULL")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"IS NOT NULL")," but it's a general equality operator\nwith the added semantic that it never returns ",(0,o.mdx)("inlineCode",{parentName:"p"},"NULL"),".   ",(0,o.mdx)("inlineCode",{parentName:"p"},"NULL IS NULL")," is true.  ",(0,o.mdx)("inlineCode",{parentName:"p"},"NULL IS [anything not null]")," is false."),(0,o.mdx)("h3",{id:"left-joins-that-are-not-left-joins"},"Left joins that are not left joins"),(0,o.mdx)("p",null,"Consider"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  SELECT foo.id,\n         foo.name,\n         bar.rate\n  FROM foo\n  LEFT JOIN bar ON foo.id = bar.id\n  WHERE bar.rate > 5;\n")),(0,o.mdx)("p",null,"This is no longer a left join because the ",(0,o.mdx)("inlineCode",{parentName:"p"},"WHERE")," clause demands a value for at least one column from ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar"),"."),(0,o.mdx)("p",null,"Better:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-sql"},"  SELECT foo.id,\n         foo.name,\n         bar.rate\n  FROM foo\n  INNER JOIN bar ON foo.id = bar.id\n  WHERE bar.rate > 5;\n")))}c.isMDXComponent=!0}}]);