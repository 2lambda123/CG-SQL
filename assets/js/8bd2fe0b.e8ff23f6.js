"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6769],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return c},MDXProvider:function(){return m},mdx:function(){return f},useMDXComponents:function(){return d},withMDXComponents:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),u=function(e){return function(t){var n=d(t.components);return a.createElement(e,i({},t,{components:n}))}},d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=r,h=u["".concat(o,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},37012:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return p},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return d}});var a=n(83117),r=n(80102),i=(n(67294),n(3905)),o=["components"],l={id:"ch08",title:"Chapter 8: Functions",sidebar_label:"Chapter 8: Functions"},s=void 0,c={unversionedId:"ch08",id:"ch08",title:"Chapter 8: Functions",description:"\x3c!---",source:"@site/../CQL_Guide/ch08.md",sourceDirName:".",slug:"/ch08",permalink:"/cql-guide/ch08",draft:!1,tags:[],version:"current",lastUpdatedBy:"timch326",lastUpdatedAt:1682983565,formattedLastUpdatedAt:"May 1, 2023",frontMatter:{id:"ch08",title:"Chapter 8: Functions",sidebar_label:"Chapter 8: Functions"},sidebar:"someSidebar",previous:{title:"Chapter 7: CQL Result Sets",permalink:"/cql-guide/ch07"},next:{title:"Chapter 9: Statements Summary and Error Checking",permalink:"/cql-guide/ch09"}},u={},d=[{value:"Function Types",id:"function-types",level:3},{value:"Ordinary Scalar Functions",id:"ordinary-scalar-functions",level:4},{value:"SQL Scalar Functions",id:"sql-scalar-functions",level:4},{value:"SQL Table Valued Functions",id:"sql-table-valued-functions",level:4},{value:"SQL Functions with Unchecked Parameter Types",id:"sql-functions-with-unchecked-parameter-types",level:3},{value:"Notes on Builtin Functions",id:"notes-on-builtin-functions",level:3}],m={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.mdx)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"CQL stored procs have a very simple contract so it is easy to declare procedures and then implement them in regular C; the C functions just have to conform to the contract.  However, CQL procedures have their own calling conventions and this makes it very inconvenient to use external code that is not doing database things and wants to return values.  Even a random number generator or something would be difficult to use because it could not be called in the context of an expression.  To allow for this CQL adds declared functions"),(0,i.mdx)("p",null,"In another example of the two-headed nature of CQL, there are two ways to declare functions.  As we have already\nseen you can make function-like procedures and call them like functions simply by making a procedure with an ",(0,i.mdx)("inlineCode",{parentName:"p"},"out")," parameter. However, there are also cases where it is reasonable to make function calls to external functions of other kinds.  There are three major types of functions you might wish to call."),(0,i.mdx)("h3",{id:"function-types"},"Function Types"),(0,i.mdx)("h4",{id:"ordinary-scalar-functions"},"Ordinary Scalar Functions"),(0,i.mdx)("p",null,"These functions are written in regular C and provide for the ability to do operations on in-memory objects.  For instance,\nyou could create functions that allow you to read and write from a dictionary.  You can declare these functions like so:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare function dict_get_value(dict object, key_ text not null) text;\n")),(0,i.mdx)("p",null,"Such a function is not known to SQLite and therefore cannot appear in SQL statements.  CQL will enforce this."),(0,i.mdx)("p",null,"The above function returns a text reference, and, importantly, this is a borrowed reference.  The dictionary\nis presumably holding on to the reference and as long as it is not mutated the reference is valid.  CQL will\nretain this reference as soon as it is stored and release it automatically when it is out of scope.  So, in\nthis case, the dictionary continues to own the object."),(0,i.mdx)("p",null,"It is also possible to declare functions that create objects.  Such as this example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare function dict_create() create object;\n")),(0,i.mdx)("p",null,"This declaration tells CQL that the function will create a new object for our use.  CQL does not retain the\nprovided object, rather assuming ownership of the presumably one reference count the object already has.\nWhen the object goes out of scope it is released as usual."),(0,i.mdx)("p",null,"If we also declare this procedure:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare procedure dict_add(\n    dict object not null,\n    key_ text not null,\n    value text not null);\n")),(0,i.mdx)("p",null,"then with this family of declarations we could write something like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},'create proc create_and_init(out dict object not null)\nbegin\n  set dict := dict_create();\n  call dict_add(dict, "k1", "v1");\n  call dict_add(dict, "k2", "v2");\n  if (dict_get_value(dict, "k1") == dict__get_value(dict, "k2")) then\n    call printf("insanity has ensued\\n");\n  end if;\nend;\n')),(0,i.mdx)("p",null,"Note: Ordinary scalar functions may not use the database in any way. When they are invoked they will not\nbe provided with the database pointer and so they will be unable to do any database operations.  To do\ndatabase operations, use regular procedures.  You can create a function-like-procedure using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"out")," convention\ndiscussed previously."),(0,i.mdx)("h4",{id:"sql-scalar-functions"},"SQL Scalar Functions"),(0,i.mdx)("p",null,"SQLite includes the ability to add new functions to its expressions using ",(0,i.mdx)("inlineCode",{parentName:"p"},"sqlite3_create_function"),".  In\norder to use this function in CQL, you must also provide its prototype definition to the compiler.  You\ncan do so following this example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare select function strencode(t text not null) text not null;\n")),(0,i.mdx)("p",null,"This introduces the function ",(0,i.mdx)("inlineCode",{parentName:"p"},"strencode")," to the compiler for use in SQL constructs.  With this done you\ncould write a procedure something like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"create table foo(id integer, t text);\n\ncreate procedure bar(id_ integer)\nbegin\n   select strencode(T1.t) from foo T1 where T1.id = id_;\nend;\n")),(0,i.mdx)("p",null,'This presumably returns the "encoded" text, whatever that might be.  Note that if ',(0,i.mdx)("inlineCode",{parentName:"p"},"sqlite3_create_function"),"\nis not called before this code runs, a run-time error will ensue.  Just as CQL must assume that declared\ntables really are created, it also assumes that declared function really are created.  This is another case\nof telling the compiler in advance what the situation will be at runtime."),(0,i.mdx)("p",null,"SQLite allows for many flexible kinds of user defined functions.  CQL doesn't concern itself with the details of the implementation of the function, it only needs the signature so that it can validate calls."),(0,i.mdx)("p",null,"Note that SQL Scalar Functions cannot contain ",(0,i.mdx)("inlineCode",{parentName:"p"},"object")," parameters. To pass an ",(0,i.mdx)("inlineCode",{parentName:"p"},"object"),", you should instead pass\nthe memory address of this object using a ",(0,i.mdx)("inlineCode",{parentName:"p"},"LONG INT")," parameter. To access the address of an ",(0,i.mdx)("inlineCode",{parentName:"p"},"object")," at runtime, you should use\nthe ",(0,i.mdx)("inlineCode",{parentName:"p"},"ptr()")," function. See ",(0,i.mdx)("a",{parentName:"p",href:"#notes-on-builtin-functions"},"the notes section below")," for more information."),(0,i.mdx)("p",null,"See also: ",(0,i.mdx)("a",{parentName:"p",href:"https://www.sqlite.org/c3ref/create_function.html"},"Create Or Redefine SQL Functions"),"."),(0,i.mdx)("h4",{id:"sql-table-valued-functions"},"SQL Table Valued Functions"),(0,i.mdx)("p",null,'More recent versions of SQLite also include the ability to add table-valued functions to statements in place of actual tables. These functions can use their arguments to create a "virtual table" value for use in place of a table.  For this\nto work, again SQLite must be told of the existence of the table.  There are a series of steps to make this happen\nbeginning with ',(0,i.mdx)("inlineCode",{parentName:"p"},"sqlite3_create_module"),' which are described in the SQLite documents under "The Virtual Table Mechanism Of SQLite."'),(0,i.mdx)("p",null,"Once that has been done, a table-valued function can be defined for most object types.  For instance it is possible to\ncreate a table-valued function like so:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare select function dict_contents(dict object not null)\n   (k text not null, v text not null);\n")),(0,i.mdx)("p",null,"This is just like the previous type of select function but the return type is a table shape.  Once the above has been done you can legally write something like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"create proc read_dict(dict object not null, pattern text)\nbegin\n  if pattern is not null then\n    select k, v from dict_contents(dict) T1 where T1.k LIKE pattern;\n  else\n    select k, v from dict_contents(dict);\n  end if;\nend;\n")),(0,i.mdx)("p",null,"This construct is very general indeed but the runtime set up for it is much more complicated than scalar functions\nand only more modern versions of SQLite even support it."),(0,i.mdx)("h3",{id:"sql-functions-with-unchecked-parameter-types"},"SQL Functions with Unchecked Parameter Types"),(0,i.mdx)("p",null,"Certain SQL functions like ",(0,i.mdx)("a",{parentName:"p",href:"https://www.sqlite.org/json1.html#jex"},(0,i.mdx)("inlineCode",{parentName:"a"},"json_extract"))," are variadic (they accept variable number of arguments). To use such functions within CQL, you can declare a SQL function to have untyped parameters by including the ",(0,i.mdx)("inlineCode",{parentName:"p"},"NO CHECK")," clause instead of parameter types."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare select function json_extract no check text;\n")),(0,i.mdx)("p",null,"This is also supported for SQL table-valued functions:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sql"},"declare select function table_valued_function no check (t text, i int);\n")),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},"Note: currently the ",(0,i.mdx)("inlineCode",{parentName:"p"},"NO CHECK")," clause is not supported for non SQL ",(0,i.mdx)("a",{parentName:"p",href:"#Ordinary-Scalar-Functions"},"Ordinary Scalar Functions"),".")),(0,i.mdx)("h3",{id:"notes-on-builtin-functions"},"Notes on Builtin Functions"),(0,i.mdx)("p",null,"Some of the SQLite builtin functions are hard-coded;  these are the functions that have semantics that are not readily captured with a simple prototype.  Other SQLite functions can be declared with ",(0,i.mdx)("inlineCode",{parentName:"p"},"declare select function ...")," and then used."),(0,i.mdx)("p",null,"CQL's hard-coded builtin list includes:"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Aggregate Functions")),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"count"),(0,i.mdx)("li",{parentName:"ul"},"max"),(0,i.mdx)("li",{parentName:"ul"},"min"),(0,i.mdx)("li",{parentName:"ul"},"sum"),(0,i.mdx)("li",{parentName:"ul"},"total"),(0,i.mdx)("li",{parentName:"ul"},"avg"),(0,i.mdx)("li",{parentName:"ul"},"group_concat")),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Scalar Functions")),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"ifnull"),(0,i.mdx)("li",{parentName:"ul"},"nullif"),(0,i.mdx)("li",{parentName:"ul"},"upper"),(0,i.mdx)("li",{parentName:"ul"},"char"),(0,i.mdx)("li",{parentName:"ul"},"abs"),(0,i.mdx)("li",{parentName:"ul"},"instr"),(0,i.mdx)("li",{parentName:"ul"},"coalesce"),(0,i.mdx)("li",{parentName:"ul"},"last_insert_rowid"),(0,i.mdx)("li",{parentName:"ul"},"printf"),(0,i.mdx)("li",{parentName:"ul"},"strftime"),(0,i.mdx)("li",{parentName:"ul"},"date"),(0,i.mdx)("li",{parentName:"ul"},"time"),(0,i.mdx)("li",{parentName:"ul"},"datetime"),(0,i.mdx)("li",{parentName:"ul"},"julianday"),(0,i.mdx)("li",{parentName:"ul"},"substr"),(0,i.mdx)("li",{parentName:"ul"},"replace"),(0,i.mdx)("li",{parentName:"ul"},"round"),(0,i.mdx)("li",{parentName:"ul"},"trim"),(0,i.mdx)("li",{parentName:"ul"},"ltrim"),(0,i.mdx)("li",{parentName:"ul"},"rtrim")),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Window Functions")),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"row_number"),(0,i.mdx)("li",{parentName:"ul"},"rank"),(0,i.mdx)("li",{parentName:"ul"},"dense_rank"),(0,i.mdx)("li",{parentName:"ul"},"percent_rank"),(0,i.mdx)("li",{parentName:"ul"},"cume_dist"),(0,i.mdx)("li",{parentName:"ul"},"ntile"),(0,i.mdx)("li",{parentName:"ul"},"lag"),(0,i.mdx)("li",{parentName:"ul"},"lead"),(0,i.mdx)("li",{parentName:"ul"},"first_value"),(0,i.mdx)("li",{parentName:"ul"},"last_value"),(0,i.mdx)("li",{parentName:"ul"},"nth_value")),(0,i.mdx)("p",null,"Special Functions"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"nullable"),(0,i.mdx)("li",{parentName:"ul"},"sensitive"),(0,i.mdx)("li",{parentName:"ul"},"ptr")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"Nullable")," casts an operand to the nullable version of its type and otherwise does nothing.  This cast might be useful if you need an exact type match in a situation.  It is stripped from any generated SQL and generated C so it has no runtime effect at all other than the indirect consequences of changing the storage class of its operand."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"Sensitive")," casts an operand to the sensitive version of its type and otherwise does nothing.  This cast might be useful if you need an exact type match in a situation.  It is stripped from any generated SQL and generated C so it has no runtime effect at all other than the indirect consequences of changing the storage class of its operand."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"Ptr")," is used to cause a reference type variable to be bound as a long integer to SQLite. This is a way of giving object pointers to SQLite UDFs. Not all versions of Sqlite support\nbinding object variables, so passing memory addresses is the best we can do on all versions."))}p.isMDXComponent=!0}}]);