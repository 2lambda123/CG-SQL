"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9080],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),c=i,h=p["".concat(o,".").concat(c)]||p[c]||m[c]||l;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=p;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4040:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return m}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),r=["components"],s={id:"int08",title:"Part 8: Test Helpers",sidebar_label:"Part 8: Test Helpers"},o=void 0,d={unversionedId:"int08",id:"int08",title:"Part 8: Test Helpers",description:"\x3c!---",source:"@site/../CQL_Guide/int08.md",sourceDirName:".",slug:"/int08",permalink:"/cql-guide/int08",draft:!1,tags:[],version:"current",lastUpdatedBy:"Elena Luo",lastUpdatedAt:1663203441,formattedLastUpdatedAt:"9/15/2022",frontMatter:{id:"int08",title:"Part 8: Test Helpers",sidebar_label:"Part 8: Test Helpers"},sidebar:"someSidebar",previous:{title:"Part 7: JSON Generation",permalink:"/cql-guide/int07"}},u={},m=[{value:"Preface",id:"preface",level:3},{value:"Test Helpers",id:"test-helpers",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set",id:"dummy-table-dummy-insert-dummy-select-dummy-result-set",level:3},{value:"Dummy Test",id:"dummy-test",level:3},{value:"Building the Trigger and Index mappings",id:"building-the-trigger-and-index-mappings",level:4},{value:"Computing The Dependencies of a Procedure",id:"computing-the-dependencies-of-a-procedure",level:4},{value:"Emitting Indices and Triggers",id:"emitting-indices-and-triggers",level:4},{value:"Emitting Tables and Views",id:"emitting-tables-and-views",level:4},{value:"Gathering Ad Hoc Data To Be Inserted",id:"gathering-ad-hoc-data-to-be-inserted",level:4},{value:"Emitting the Table Population Fragments",id:"emitting-the-table-population-fragments",level:4},{value:"Recap",id:"recap",level:3}],p={toc:m};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h3",{id:"preface"},"Preface"),(0,l.kt)("p",null,"Part 8 continues with a discussion of the Test Helper  generation code.\nAs in the previous sections, the goal here is not to go over every detail but rather to give\na sense of how helpers are created in general -- the core strategies and implementation choices --\nso that when reading the source you will have an idea how it all hangs together."),(0,l.kt)("h2",{id:"test-helpers"},"Test Helpers"),(0,l.kt)("p",null,"The testability features are described in ",(0,l.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch12"},"Chapter 12")," of the Guide\nSo, we won't be discussing all the details of what can be created.  Instead we're going to go over\nthe theory of how the generator works. This generator is somewhat different than others in that\nit only concerns itself with procedures and only those that have been suitably annotated --\nthere are large parts of the tree that are of no interest to the test helper logic, including,\nimportantly the body of procedures.  Only the signature matters.  As we'll see there is a fairly\nlarge family of generators that are like this."),(0,l.kt)("p",null,"We'll have one section for every kind of output, but really only the ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_test")," helper is\nworthy of detailed discussion the others, as we'll see, are very simple."),(0,l.kt)("h3",{id:"initialization"},"Initialization"),(0,l.kt)("p",null,"The generator is wired like the others with a suitable main, this one is pretty simple:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'// Main entry point for test_helpers\ncql_noexport void cg_test_helpers_main(ast_node *head) {\n  Contract(options.file_names_count == 1);\n  cql_exit_on_semantic_errors(head);\n  exit_on_validating_schema();\n  cg_test_helpers_reset_globals();\n\n  CHARBUF_OPEN(output_buf);\n\n  cg_th_output = &output_buf;\n\n  bprintf(cg_th_output, "%s", rt->source_prefix);\n  cg_test_helpers_stmt_list(head);\n  cql_write_file(options.file_names[0], cg_th_output->ptr);\n\n  CHARBUF_CLOSE(output_buf);\n  cg_test_helpers_reset_globals();\n}\n')),(0,l.kt)("p",null,"The text output will be ultimately put into ",(0,l.kt)("inlineCode",{parentName:"p"},"output_buf")," defined here and ",(0,l.kt)("inlineCode",{parentName:"p"},"helper_flags")," will track which kinds of helpers\nwe saw.  This helps us to emit the right sections of output as we'll see."),(0,l.kt)("p",null,"The code iterates the AST looking at the top level statement list only and in particular looking for ",(0,l.kt)("inlineCode",{parentName:"p"},"CREATE PROC"),"\nstatements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'// Iterate through statement list\nstatic void cg_test_helpers_stmt_list(ast_node *head) {\n  Contract(is_ast_stmt_list(head));\n  init_all_trigger_per_table();\n  init_all_indexes_per_table();\n  CHARBUF_OPEN(procs_buf);\n  CHARBUF_OPEN(decls_buf);\n  cg_th_procs = &procs_buf;\n  cg_th_decls = &decls_buf;\n\n  for (ast_node *ast = head; ast; ast = ast->right) {\n    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);\n\n    if (is_ast_create_proc_stmt(stmt)) {\n      EXTRACT_STRING(proc_name, stmt->left);\n      cg_test_helpers_create_proc_stmt(stmt, misc_attrs);\n    }\n  }\n\n  bprintf(cg_th_output, "%s", decls_buf.ptr);\n  bprintf(cg_th_output, "\\n");\n  bprintf(cg_th_output, "%s", procs_buf.ptr);\n\n  CHARBUF_CLOSE(decls_buf);\n  CHARBUF_CLOSE(procs_buf);\n  symtab_delete(all_tables_with_triggers);\n  all_tables_with_triggers = NULL;\n  symtab_delete(all_tables_with_indexes);\n  all_tables_with_indexes = NULL;\n}\n')),(0,l.kt)("p",null,"There are some preliminaries:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we make a symbol table that maps from tables names to the list of triggers on that table by walking all the triggers"),(0,l.kt)("li",{parentName:"ul"},"we make a symbol table that maps from tables names to the list of indices on that table by walking all the indices"),(0,l.kt)("li",{parentName:"ul"},"we'll need two buffers one for declarations (that must go first) and one for procedure bodies"),(0,l.kt)("li",{parentName:"ul"},"each ",(0,l.kt)("inlineCode",{parentName:"li"},"CREATE PROC")," statement potentially contributes to both sections"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cg_test_helpers_create_proc_stmt")," checks for the helper attributes and sets up the dispatch to emit the test helpers")),(0,l.kt)("p",null,"To do this we have to walk any misc attributes on the procedure we're looking for things of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"@attribute(cql:autotest=xxx)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"static void cg_test_helpers_create_proc_stmt(ast_node *stmt, ast_node *misc_attrs) {\n  Contract(is_ast_create_proc_stmt(stmt));\n\n  if (misc_attrs) {\n    helper_flags = 0;\n    dummy_test_infos = symtab_new();\n\n    find_misc_attrs(misc_attrs, test_helpers_find_ast_misc_attr_callback, stmt);\n\n    symtab_delete(dummy_test_infos);\n    dummy_test_infos = NULL;\n  }\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"find_misc_attrs")," calls ",(0,l.kt)("inlineCode",{parentName:"p"},"test_helpers_find_ast_misc_attr_callback"),".  We're going to keep track of\nwhich kinds of helpers we have found to help us with the output.  This is where ",(0,l.kt)("inlineCode",{parentName:"p"},"helper_flags"),"\ncomes in. The flags are:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"#define DUMMY_TABLE           1 // dummy_table attribute flag\n#define DUMMY_INSERT          2 // dummy_insert attribute flag\n#define DUMMY_SELECT          4 // dummy_select attribute flag\n#define DUMMY_RESULT_SET      8 // dummy_result_set attribute flag\n#define DUMMY_TEST         0x10 // dummy_test attribute flag\n")),(0,l.kt)("p",null,"And now we're ready for actual dispatch:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'// This is invoked for every misc attribute on every create proc statement\n// in this translation unit.  We\'re looking for attributes of the form cql:autotest=(...)\n// and we ignore anything else.\nstatic void test_helpers_find_ast_misc_attr_callback(\n  CSTR _Nullable misc_attr_prefix,\n  CSTR _Nonnull misc_attr_name,\n  ast_node *_Nullable ast_misc_attr_value_list,\n  void *_Nullable context)\n{\n  ast_node *stmt = (ast_node *)context;\n  Contract(is_ast_create_proc_stmt(stmt));\n\n  if (misc_attr_prefix &&\n      misc_attr_name &&\n      !Strcasecmp(misc_attr_prefix, "cql") &&\n      !Strcasecmp(misc_attr_name, "autotest")) {\n    ...\n  }\n}\n')),(0,l.kt)("p",null,"The main dispatch looks like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// In principle, any option can be combined with any other but some only make sense for procs with\n// a result.\n\nEXTRACT_STRING(autotest_attr_name, misc_attr_value);\nif (is_autotest_dummy_test(autotest_attr_name)) {\n  cg_test_helpers_dummy_test(stmt);\n}\n\n// these options are only for procs that return a result set\nif (has_result_set(stmt) || has_out_stmt_result(stmt) || has_out_union_stmt_result(stmt)) {\n  if (is_autotest_dummy_table(autotest_attr_name)) {\n    helper_flags |= DUMMY_TABLE;\n    cg_test_helpers_dummy_table(proc_name);\n  }\n  else if (is_autotest_dummy_insert(autotest_attr_name)) {\n    helper_flags |= DUMMY_INSERT;\n    cg_test_helpers_dummy_insert(proc_name);\n  }\n  else if (is_autotest_dummy_select(autotest_attr_name)) {\n    helper_flags |= DUMMY_SELECT;\n    cg_test_helpers_dummy_select(proc_name);\n  }\n  else if (is_autotest_dummy_result_set(autotest_attr_name)) {\n    helper_flags |= DUMMY_RESULT_SET;\n    cg_test_helpers_dummy_result_set(proc_name);\n  }\n}\n")),(0,l.kt)("p",null,"Most of these options are very simple indeed.   ",(0,l.kt)("inlineCode",{parentName:"p"},"cg_test_helpers_dummy_test")," is the trickiest\nby far and we'll save it for last, let's dispense with the easy stuff."),(0,l.kt)("h3",{id:"dummy-table-dummy-insert-dummy-select-dummy-result-set"},"Dummy Table, Dummy Insert, Dummy Select, Dummy Result Set"),(0,l.kt)("p",null,"All of these are a very simple template.  The language includes just the right features\nto emit these procedures as nearly constant strings. The ",(0,l.kt)("inlineCode",{parentName:"p"},"LIKE")," construct was literally\ndesigned to make these patterns super simple.  You can see all the patterns\nin ",(0,l.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch12"},"Chapter 12"),' but let\'s look at the code for\nthe first one.  This is "dummy table".'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'// Emit an open proc which creates a temp table in the form of the original proc\n// Emit a close proc which drops the temp table\nstatic void cg_test_helpers_dummy_table(CSTR name) {\n  bprintf(cg_th_procs, "\\n");\n  bprintf(cg_th_procs, "CREATE PROC open_%s()\\n", name);\n  bprintf(cg_th_procs, "BEGIN\\n");\n  bprintf(cg_th_procs, "  CREATE TEMP TABLE test_%s(LIKE %s);\\n", name, name);\n  bprintf(cg_th_procs, "END;\\n");\n\n  bprintf(cg_th_procs, "\\n");\n  bprintf(cg_th_procs, "CREATE PROC close_%s()\\n", name);\n  bprintf(cg_th_procs, "BEGIN\\n");\n  bprintf(cg_th_procs, "  DROP TABLE test_%s;\\n", name);\n  bprintf(cg_th_procs, "END;\\n");\n}\n')),(0,l.kt)("p",null,"The purpose of this is to create helper functions that can create a temporary\ntable with the same columns in it as the procedure you are trying to mock.\nYou can then select rows out of that table (with ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_select"),") or insert\nrows into the table (with ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_insert"),").  Or you can make a single\nrow result set (often enough) with ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_result_set"),"."),(0,l.kt)("p",null,"As we can see we simply prepend ",(0,l.kt)("inlineCode",{parentName:"p"},"open_")," to the procedure name and use\nthat to create a test helper that make the temporary table.  The table's\ncolumns are defined to be ",(0,l.kt)("inlineCode",{parentName:"p"},"LIKE")," the result shape of the procedure under\ntest.  Recall this helper is only available to procedures that return a result set.\nThe temporary table gets a ",(0,l.kt)("inlineCode",{parentName:"p"},"test_")," prefix.  Assuming the procedure with the\nannotation is ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," then this code is universal:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TEMP TABLE test_foo(LIKE foo);\n")),(0,l.kt)("p",null,"Is universal, no matter the result shape of ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," you get a table with those columns."),(0,l.kt)("p",null,"For this to work we need to emit a declaration of ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," before this code.  However,\nsince we have the full definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," handy that is no problem.  We remember\nthat we'll need it by setting a flag in ",(0,l.kt)("inlineCode",{parentName:"p"},"helper_flags"),"."),(0,l.kt)("p",null,"The code for ",(0,l.kt)("inlineCode",{parentName:"p"},"close_foo")," is even simpler if that's possible.  The great thing is\nall need to know the columns of ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," has been removed from the test helper.  The\nCQL compiler handles this as a matter of course and it is generally useful.\nSee ",(0,l.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms"},"Chapter 5"),"\nfor more examples."),(0,l.kt)("p",null,"All the others are equally simple and use similar tricks.  These were the first\ntest helpers.  They're actually not that popular because they are so easy to create\nyourself anyway."),(0,l.kt)("h3",{id:"dummy-test"},"Dummy Test"),(0,l.kt)("p",null,"The dummy test code emitter is non-trivial.  Let's quickly review the things it has to\ndo and then we can go over how each of these is accomplished.  Assuming we have an procedure\n",(0,l.kt)("inlineCode",{parentName:"p"},"your_proc")," that has been annotated like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-SQL"},"@attribute(cql:autotest=(dummy_test))\ncreate proc your_proc(..args...)\nbegin\n  -- assorted references to tables and views\nend;\n")),(0,l.kt)("p",null,"Dummy test will produce the following:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_create_tables"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure that creates all the tables and views that ",(0,l.kt)("inlineCode",{parentName:"li"},"your_proc")," needs"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_drop_tables"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure that drops those same tables and views"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_create_indexes"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure that creates your indices, in a test you may or may not want to create the indices"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_drop_indexes"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure the drops those same indices"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_create_triggers"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure that creates your trigger, in a test you may or may not want to create the triggers"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_drop_triggers"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure the drops those same triggers"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_read_table1"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"for each table or view in the ",(0,l.kt)("inlineCode",{parentName:"li"},"create_tables")," a procedure that selects all the data out of that object is created in case you need it"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_populate_tables"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a procedure that loads all the tables from ",(0,l.kt)("inlineCode",{parentName:"li"},"create_tables")," with sample data"),(0,l.kt)("li",{parentName:"ul"},"FK relationships are obeyed"),(0,l.kt)("li",{parentName:"ul"},"user data may be specified in an attribute and that data will be used in preference to auto-generated data")))),(0,l.kt)("p",null,"These are more fully discussed in ",(0,l.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern"},"Chapter 12"),"."),(0,l.kt)("h4",{id:"building-the-trigger-and-index-mappings"},"Building the Trigger and Index mappings"),(0,l.kt)("p",null,"In order to know which indices and triggers we might need we have to be able to map from the tables/views in ",(0,l.kt)("inlineCode",{parentName:"p"},"your_proc")," to the indices.\nTo set up for this a general purpose reverse mapping is created.  We'll look at the triggers version. The indices version is nearly identical."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// Walk through all triggers and create a dictionnary of triggers per tables.\nstatic void init_all_trigger_per_table() {\n  Contract(all_tables_with_triggers == NULL);\n  all_tables_with_triggers = symtab_new();\n\n  for (list_item *item = all_triggers_list; item; item = item->next) {\n    EXTRACT_NOTNULL(create_trigger_stmt, item->ast);\n    EXTRACT_NOTNULL(trigger_body_vers, create_trigger_stmt->right);\n    EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);\n    EXTRACT_NOTNULL(trigger_condition, trigger_def->right);\n    EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);\n    EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);\n    EXTRACT_ANY_NOTNULL(table_name_ast, trigger_target_action->left);\n    EXTRACT_STRING(table_name, table_name_ast);\n\n    if (create_trigger_stmt->sem->delete_version > 0) {\n      // dummy_test should not emit deleted trigger\n      continue;\n    }\n\n    symtab_append_bytes(all_tables_with_triggers, table_name, &create_trigger_stmt, sizeof(create_trigger_stmt));\n  }\n}\n")),(0,l.kt)("p",null,"The steps are pretty simple:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we make a symbol table that will map from the table name to an array of statements"),(0,l.kt)("li",{parentName:"ul"},"there is a convenient ",(0,l.kt)("inlineCode",{parentName:"li"},"all_triggers")," list that has all the triggers"),(0,l.kt)("li",{parentName:"ul"},"from each trigger we ",(0,l.kt)("inlineCode",{parentName:"li"},"EXTRACT")," the table or view name (named ",(0,l.kt)("inlineCode",{parentName:"li"},"table_name")," even if it's a view)"),(0,l.kt)("li",{parentName:"ul"},"we append the trigger statement pointer to the end of such statements for the table"),(0,l.kt)("li",{parentName:"ul"},"any triggers marked with ",(0,l.kt)("inlineCode",{parentName:"li"},"@delete")," are not included for obvious reasons")),(0,l.kt)("p",null,"At the end of this looking up the table name will give you a list of trigger statement AST pointers.  From there\nof course you can get everything you need."),(0,l.kt)("p",null,"The index version is basically the same, the details of the ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTRACT")," ops to go from index to table name are different\nand of course we start from the ",(0,l.kt)("inlineCode",{parentName:"p"},"all_indices_list")),(0,l.kt)("h4",{id:"computing-the-dependencies-of-a-procedure"},"Computing The Dependencies of a Procedure"),(0,l.kt)("p",null,"Sticking with our particular example, in order to determine that tables/views that ",(0,l.kt)("inlineCode",{parentName:"p"},"your_proc")," might need,\nthe generator has to walk its entire body looking for things that are tables.  This is handled by the\n",(0,l.kt)("inlineCode",{parentName:"p"},"find_all_table_nodes")," function."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"static void find_all_table_nodes(dummy_test_info *info, ast_node *node) {\n  table_callbacks callbacks = {\n    .callback_any_table = found_table_or_view,\n    .callback_any_view = found_table_or_view,\n    .callback_context = info,\n    .notify_table_or_view_drops = true,\n    .notify_fk = true,\n    .notify_triggers = true,\n  };\n\n  info->callbacks  = &callbacks;\n  find_table_refs(&callbacks, node);\n\n  // stitch the views to the tables to make one list, views first\n  for (list_item *item = info->found_views; item; item = item->next) {\n     if (!item->next) {\n       item->next = info->found_tables;\n       info->found_tables = info->found_views;\n       break;\n     }\n  }\n  // this shouldn't be used after it's been linked in\n  info->found_views = NULL;\n}\n")),(0,l.kt)("p",null,"This code uses the general dependency walker in ",(0,l.kt)("inlineCode",{parentName:"p"},"cg_common.c")," to visit all tables and views. It is a recursive\nwalk and the general steps for prosecution go something like this:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"starting from ",(0,l.kt)("inlineCode",{parentName:"li"},"your_proc")," the entire body of the procedure is visited"),(0,l.kt)("li",{parentName:"ul"},"references to tables or views in update, delete, insert, select etc. statements are identified"),(0,l.kt)("li",{parentName:"ul"},"each such table/view is added to the found tables list (at most once)"),(0,l.kt)("li",{parentName:"ul"},"for views, the recursion proceeds to the body of the view as though the body had been inline in the procedure"),(0,l.kt)("li",{parentName:"ul"},"for tables, the recursion proceeds to the body of the table to discover any FK relationships that need to be followed"),(0,l.kt)("li",{parentName:"ul"},"if any found item has triggers, the trigger body is walked, any tables/views mentioned there become additional found items"),(0,l.kt)("li",{parentName:"ul"},"any given table/view and hence trigger is only visited once")),(0,l.kt)("p",null,'The net of all this, the "found items", is a list of all the tables and views that the procedure uses, directly\nor indirectly.  As discussed in ',(0,l.kt)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern"},"Chapter 12"),"\nthis walk does not include tables and views used by procedures that ",(0,l.kt)("inlineCode",{parentName:"p"},"your_proc")," calls."),(0,l.kt)("p",null,"To get the dependencies in the correct order, the tables have been walked following the foreign key chain and all\nviews go after all tables.  The views are stitched together.  The business of diving into views/tables/triggers and\nmaintainence of the found items is done by the callback function ",(0,l.kt)("inlineCode",{parentName:"p"},"found_table_or_view"),".  The actual source\nis more descriptive comments than code but the code is included here as it is brief."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// comments elided for brevity, the why of all this is described in the code\nstatic void found_table_or_view(\n  CSTR _Nonnull table_or_view_name,\n  ast_node *_Nonnull table_or_view,\n  void *_Nullable context)\n{\n  Contract(table_or_view);\n\n  dummy_test_info *info = (dummy_test_info *)context;\n\n  bool deleted = table_or_view->sem->delete_version > 0;\n  if (!deleted) {\n    continue_find_table_node(info->callbacks, table_or_view);\n\n    if (is_ast_create_view_stmt(table_or_view)) {\n      add_item_to_list(&info->found_views, table_or_view);\n    }\n    else {\n      add_item_to_list(&info->found_tables, table_or_view);\n    }\n\n    find_all_triggers_node(info, table_or_view_name);\n  }\n}\n")),(0,l.kt)("p",null,"The general purpose walker notifies exactly once on each visited table/view and ",(0,l.kt)("inlineCode",{parentName:"p"},"continue_find_table_node")," is used to\ndive into the bodies of views/tables that would otherwise not be searched.  Likewise ",(0,l.kt)("inlineCode",{parentName:"p"},"find_all_triggers_node"),"\ndives into the body of any triggers that are on the found item."),(0,l.kt)("h4",{id:"emitting-indices-and-triggers"},"Emitting Indices and Triggers"),(0,l.kt)("p",null,'With the "found tables" computed (creatively stored in a field called ',(0,l.kt)("inlineCode",{parentName:"p"},"found_tables"),') it\'s very easy to loop over these\nand generate the necessary indices for each found table (keeping in mind the "found table" can be a view).'),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"create index statement")," is emitted by the usual ",(0,l.kt)("inlineCode",{parentName:"p"},"gen_statement_with_callbacks")," form that echos the AST."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"drop index")," can be trivially created by name."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'// Emit create and drop index statement for all indexes on a table.\nstatic void cg_emit_index_stmt(\n  CSTR table_name,\n  charbuf *gen_create_indexes,\n  charbuf *gen_drop_indexes,\n  gen_sql_callbacks *callback)\n{\n  symtab_entry *indexes_entry = symtab_find(all_tables_with_indexes, table_name);\n  bytebuf *buf = indexes_entry ? (bytebuf *)indexes_entry->val : NULL;\n  ast_node **indexes_ast = buf ? (ast_node **)buf->ptr : NULL;\n  int32_t count = buf ? buf->used / sizeof(*indexes_ast) : 0;\n  gen_set_output_buffer(gen_create_indexes);\n\n  for (int32_t i = 0; i < count; i++) {\n    ast_node *index_ast = indexes_ast[i];\n    EXTRACT_NOTNULL(create_index_stmt, index_ast);\n    EXTRACT_NOTNULL(create_index_on_list, create_index_stmt->left);\n    EXTRACT_ANY_NOTNULL(index_name_ast, create_index_on_list->left);\n    EXTRACT_STRING(index_name, index_name_ast);\n\n    gen_statement_with_callbacks(index_ast, callback);\n    bprintf(gen_create_indexes, ";\\n");\n    bprintf(gen_drop_indexes, "DROP INDEX IF EXISTS %s;\\n", index_name);\n  }\n}\n')),(0,l.kt)("p",null,"Triggers are done in exactly the same way except that instead of looping over found tables we can\nactually generate them as they are discovered inside of ",(0,l.kt)("inlineCode",{parentName:"p"},"find_all_triggers_node"),".  Recal that we\nhad to visit the triggers when computing the found tables anyway.  We did not have to visit the indices\nhence the difference."),(0,l.kt)("p",null,"These walks allow us to produce: ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_create_indexes"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_drop_indexes"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_create_triggers"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_drop_triggers")),(0,l.kt)("h4",{id:"emitting-tables-and-views"},"Emitting Tables and Views"),(0,l.kt)("p",null,"Starting from the found tables, again it is very easy to generate the code to create and drop the tables and views.  The only trick here is that the\ntables depend on one another so order is important.  The tables are discovered with the deepest dependency first, new found items are added to the head\nof the found tables but it's a post-order walk so that means that the deepest tables/views are at the front of the list.  This means the list\nis naturally in the order that it needs to be to delete the tables (parent tables at the end).  So the algorithm goes like this:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"emit the drop tables/views in the found order"),(0,l.kt)("li",{parentName:"ul"},"reverse the list"),(0,l.kt)("li",{parentName:"ul"},"emit the create tables/views in the reverse order"),(0,l.kt)("li",{parentName:"ul"},"for each table/view emit the reader `test",(0,l.kt)("em",{parentName:"li"},"your_proc_read"),"[item]"),(0,l.kt)("li",{parentName:"ul"},"for tables we emit an insertion fragment into ",(0,l.kt)("inlineCode",{parentName:"li"},"test_your_proc_populate_tables")," using ",(0,l.kt)("inlineCode",{parentName:"li"},"cg_dummy_test_populate"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"population is discussed in the following sections")))),(0,l.kt)("p",null,"As in the other cases ",(0,l.kt)("inlineCode",{parentName:"p"},"gen_statement_with_callbacks")," is used to create the DDL statements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CREATE TABLE")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CREATE VIEW")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CREATE VIRTUAL TABLE"))),(0,l.kt)("p",null,"The delete side is easily created with ad hoc ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP TABLE")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP VIEW")," statements."),(0,l.kt)("p",null,"The reading procedure is always of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT * FROM foo"),' so that too is trivial to generate with a fixed template.  The "echoing" system\nonce again is doing a lot of the heavy lifting.'),(0,l.kt)("p",null,"These walks give us ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_create_tables"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_drop_tables"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_read_[item]")," and drive the population process"),(0,l.kt)("h4",{id:"gathering-ad-hoc-data-to-be-inserted"},"Gathering Ad Hoc Data To Be Inserted"),(0,l.kt)("p",null,"Before we get into the mechanics of the population code, we have to visit one more area.  It's possible to include data in the the\n",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_test")," annotaiton itself.  This is data that you want to have populated.  This data will be included in the overall data populator.\nIf there is enough of it (at least 2 rows per candidate table) then it might be all the data you get.  Now the data format here is\nnot designed to be fully general, after all it's not that hard to just write ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT ... VALUES")," for all your tables anyway.  The goal\nis to provide something that will help you not have to remember all the FK relationships and maybe let you economically specify some leaf\ndata you need and get the rest for free.  It's also possible to manually create dummy data that just won't work, again, scrubbing all\nthis is way beyond the ability of a simple test helper.  When the code runs you'll get SQLite errors which can be readily addressed."),(0,l.kt)("p",null,'So keeping in mind this sort of "entry level data support" as the goal, we can take a look at how the system works -- it\'s all\nin the function ',(0,l.kt)("inlineCode",{parentName:"p"},"collect_dummy_test_info")," which includes this helpful comment on structure."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// the data attribute looks kind of like this:\n// @attribute(cql:autotest = (\n//   .. other auto test attributes\n//   (dummy_test,\n//     (table_name1, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),\n//     (table_name2, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),\n//     ...\n//   )\n//   .. other auto test attributes\n// ))\n//\n// we're concerned with the dummy_test entries here, they have a very specific format\n// i.e. first the table then the column names, and then a list of matching columns and values\n")),(0,l.kt)("p",null,"So we're going to walk a list of attributes each one begins with a table name, then a list of columns, and then a list of values."),(0,l.kt)("p",null,"All of the data is in the symbol table ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_test_infos")," which is indexed by table name.  For each table name we find\nwe ensure there is a symbol table at that slot.  So ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_test_infos")," is a symbol table of symbol tables.  It's actually\ngoing to be something like ",(0,l.kt)("inlineCode",{parentName:"p"},"value_list = dummy_test_infos['table']['column']")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"  // collect table name from dummy_test info\n  ast_node *table_list = dummy_attr->left;\n  EXTRACT_STRING(table_name, table_list->left);\n  symtab *col_syms = symtab_ensure_symtab(dummy_test_infos, table_name);\n")),(0,l.kt)("p",null,"Next we're going to find the column names, they are the next entry in the list so we go ",(0,l.kt)("inlineCode",{parentName:"p"},"right")," to get the ",(0,l.kt)("inlineCode",{parentName:"p"},"column_name_list")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// collect column names from dummy_test info\nast_node *column_name_list = table_list->right;\nfor (ast_node *list = column_name_list->left; list; list = list->right) {\n  EXTRACT_STRING(column_name, list->left);\n  sem_t col_type = find_column_type(table_name, column_name);\n\n  bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);\n\n  // store the column meta data, create space to hold values in databuf\n  bytebuf_append_var(&col_data_buf, column_values);\n  bytebuf_append_var(&col_type_buf, col_type);\n  bytebuf_append_var(&col_name_buf, column_name);\n}\n")),(0,l.kt)("p",null,"The primary purpose of this part of the loop is then to add the column names to ",(0,l.kt)("inlineCode",{parentName:"p"},"col_syms")," so that they are linked to the dummy info for this table.\nThe line ",(0,l.kt)("inlineCode",{parentName:"p"},"bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);")," does this.  And this also creates the byte buffer that will hold\nthe eventual values."),(0,l.kt)("p",null,"We also keep a side set of buffers that has the column name, type, and the values in the ",(0,l.kt)("inlineCode",{parentName:"p"},"col_name"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"col_type"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"col_data")," buffers respectively.\nThese are used to handle the foreign key work shortly and they allow us to not have to look up all the names over and over."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// collect column value from dummy_test info. We can have multiple rows of column value\nfor (ast_node *values_ast = column_name_list->right;\n     values_ast;\n     values_ast = values_ast->right) {\n\n  int32_t column_index = 0;\n\n  // collect one row of column value\n  for (ast_node *list = values_ast->left; list; list = list->right) {\n    ast_node *misc_attr_value = list->left;\n    Contract(col_data_buf.used);\n    bytebuf *column_values = ((bytebuf **) col_data_buf.ptr)[column_index];\n    sem_t column_type = ((sem_t *) col_type_buf.ptr)[column_index];\n    CSTR column_name = ((CSTR *) col_name_buf.ptr)[column_index];\n\n    bytebuf_append_var(column_values, misc_attr_value);\n    column_index++;\n\n    ...foreign key stuff goes here...\n  }\n  .. some cleanup\n}\n")),(0,l.kt)("p",null,"The most important part is ",(0,l.kt)("inlineCode",{parentName:"p"},"bytebuf_append_var(column_values, misc_attr_value);")," this is where the\nattribute value is added to the list of values that are on the column."),(0,l.kt)("p",null,"Finally, the \"foreign key stuff\".  What we need to do here is check the column name in the table to see if it's part of a foreign\nkey and if it is we recursively add the current data value to the referenced column in the reference table.  That way\nif you add an initalizer to a leaf table you don't also have to add it to all the parent tables.  If it wasn't for this\nfeature the manual data wouldn't be very useful at all, hand written ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," statements would be just as good."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// If a column value is added to dummy_test info for a foreign key column then\n// we need to make sure that same column value is also added as a value in the\n// the referenced table's dummy_test info.\n// e.g.\n//   create table A(id integer primary key);\n//   create table B(id integer primary key references A(id));\n//\n// If there is sample data provided for B.id then we must also ensure that\n// the value provided for B.id is also add as a sample row in A with the same\n// value for id.\nif (is_foreign_key(column_type)) {\n  add_value_to_referenced_table(table_name, column_name, column_type, misc_attr_value);\n}\n")),(0,l.kt)("p",null,"When this is a done all of the initializers will have been added to the appropriate column of the appropriate table.\nAgain the overall structure is something like: ",(0,l.kt)("inlineCode",{parentName:"p"},"value_list = dummy_test_infos['table']['column']")),(0,l.kt)("h4",{id:"emitting-the-table-population-fragments"},"Emitting the Table Population Fragments"),(0,l.kt)("p",null,"With any custom initalizers in the ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_test_infos")," structure we can do the population fragment for any given table."),(0,l.kt)("p",null,"The general algorithm here goes like this:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the total number of rows we will generate will be the number of column values in the initializers or else ",(0,l.kt)("inlineCode",{parentName:"li"},"DUMMY_TEST_INSERT_ROWS"),", whichever is larger"),(0,l.kt)("li",{parentName:"ul"},"the insert statement generated will include ",(0,l.kt)("inlineCode",{parentName:"li"},"dummy_seed([value_seed])")," where value_seed starts at 123 and goes up 1 for every row generated",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"dummy_seed will create values for any missing columns using the seed so any combination of included columns is ok, we'll always get a complete insert"))),(0,l.kt)("li",{parentName:"ul"},"foreign key columns use a provided intializer from the parent table if there is one, or else they use 1, 2, 3 etc.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"likewise if a column is referenceable by some other table it uses the known sequence 1, 2, 3 etc. for its value rather than the varying seed"),(0,l.kt)("li",{parentName:"ul"},"in this way child tables can know that partent tables will have a value they can use since both tables will have at least ",(0,l.kt)("inlineCode",{parentName:"li"},"DUMMY_TEST_INSERT_ROWS")," and any rows that were not manually initialized will match"),(0,l.kt)("li",{parentName:"ul"},"note that foreign key columns always get this treatment, whether they were mentioned or not"))),(0,l.kt)("li",{parentName:"ul"},"to mix things up the ",(0,l.kt)("inlineCode",{parentName:"li"},"dummy_nullables")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"dummy_defaults")," are added on every other row which makes missing values be NULL and/or the default value if one is present")),(0,l.kt)("p",null,"This is enough to generate a set of insert statements for the table in question and since the fragments are generated in the table creation order the resulting insert statements will have the parent tables first so the foreign keys of later tables will be correct."),(0,l.kt)("p",null,"This can go wrong if the manual initializations use keys that conflict with the default generation or if the manual intializations have PK conflicts or other such things.  No attempt is made to sort that out.  The run time errors should be clear and these are, after all, only test helpers.  It's very easy to avoid these hazards\nand you get a pretty clear error message if you don't so that seems good enough."),(0,l.kt)("p",null,"These fragments are ultimately combined to make the body of the procedure ",(0,l.kt)("inlineCode",{parentName:"p"},"test_your_proc_populate_tables"),"."),(0,l.kt)("h3",{id:"recap"},"Recap"),(0,l.kt)("p",null,"The test helpers in ",(0,l.kt)("inlineCode",{parentName:"p"},"cg_test_helpers.c")," are very simple nearly-constant templates with the exception of ",(0,l.kt)("inlineCode",{parentName:"p"},"dummy_test")," which includes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"table and view creation"),(0,l.kt)("li",{parentName:"ul"},"index creation"),(0,l.kt)("li",{parentName:"ul"},"trigger creation"),(0,l.kt)("li",{parentName:"ul"},"data population")),(0,l.kt)("p",null,"Topics covered included:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"how the candidate procedures are discovered"),(0,l.kt)("li",{parentName:"ul"},"how the attributes are scanned for test directives"),(0,l.kt)("li",{parentName:"ul"},"how each dummy test type is dispatched"),(0,l.kt)("li",{parentName:"ul"},"how ",(0,l.kt)("inlineCode",{parentName:"li"},"dummy_test")," handles data initialization"),(0,l.kt)("li",{parentName:"ul"},"how ",(0,l.kt)("inlineCode",{parentName:"li"},"dummy_test")," does its dependency analysis")),(0,l.kt)("p",null,"As with the other parts, no attempt was made to cover every function in detail.  That is\nbest done by reading the source code. But there is overall structure here and an understanding\nof the basic principles is helpful before diving into the source code."))}c.isMDXComponent=!0}}]);