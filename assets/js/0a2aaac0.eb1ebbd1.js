"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5317],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return d},MDXProvider:function(){return p},mdx:function(){return h},useMDXComponents:function(){return m},withMDXComponents:function(){return u}});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},a.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=o.createContext({}),u=function(e){return function(t){var n=m(t.components);return o.createElement(e,a({},t,{components:n}))}},m=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=m(e.components);return o.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=m(n),p=r,f=u["".concat(i,".").concat(p)]||u[p]||c[p]||a;return n?o.createElement(f,l(l({ref:t},d),{},{components:n})):o.createElement(f,l({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var d=2;d<a;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},31701:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return m}});var o=n(83117),r=n(80102),a=(n(67294),n(3905)),i=["components"],l={id:"dev-notes",title:"Developer Notes on CQL Development",sidebar_label:"Developer Notes"},s=void 0,d={unversionedId:"dev-notes",id:"dev-notes",title:"Developer Notes on CQL Development",description:"0. We have extensive documentation at CQL Internals.",source:"@site/../docs/dev_notes.md",sourceDirName:".",slug:"/dev-notes",permalink:"/docs/dev-notes",draft:!1,tags:[],version:"current",frontMatter:{id:"dev-notes",title:"Developer Notes on CQL Development",sidebar_label:"Developer Notes"},sidebar:"someSidebar",previous:{title:"Playground",permalink:"/docs/playground"},next:{title:"Code Coverage CG/SQL",permalink:"/docs/code-coverage"}},u={},m=[],p={toc:m};function c(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.mdx)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("ol",{start:0},(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("p",{parentName:"li"},"We have extensive documentation at ",(0,a.mdx)("a",{parentName:"p",href:"/cql-guide/int01"},"CQL Internals"),".")),(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("p",{parentName:"li"},"If you aren't good with ",(0,a.mdx)("inlineCode",{parentName:"p"},"yacc"),"/",(0,a.mdx)("inlineCode",{parentName:"p"},"lex")," you probably should do some homework before you start. CQL development is all about building and walking a syntax tree.  It's possible to make local changes without knowing the details but it can be hard to figure out where to make changes without context.")),(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("p",{parentName:"li"},"CQL development is basically test driven, to create a new feature:"),(0,a.mdx)("ol",{parentName:"li"},(0,a.mdx)("li",{parentName:"ol"},"Add the language feature to ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sql")),(0,a.mdx)("li",{parentName:"ol"},"run ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh"),"; it will fail due to parse error"),(0,a.mdx)("li",{parentName:"ol"},"Add the syntax to ",(0,a.mdx)("inlineCode",{parentName:"li"},"cql.y")," and create the necessary tree pieces in ",(0,a.mdx)("inlineCode",{parentName:"li"},"ast.h")),(0,a.mdx)("li",{parentName:"ol"},"run ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh"),"; accept any file differences to install this as the new reference baseline."),(0,a.mdx)("li",{parentName:"ol"},"Add a test case to ",(0,a.mdx)("inlineCode",{parentName:"li"},"sem_test.sql")," that uses your new feature. ",(0,a.mdx)("inlineCode",{parentName:"li"},"sem_test.sql")," can contain pattern matching for the semantic output."),(0,a.mdx)("li",{parentName:"ol"},"run ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh"),"; it will fail because it will find an AST node it doesn't understand"),(0,a.mdx)("li",{parentName:"ol"},"edit ",(0,a.mdx)("inlineCode",{parentName:"li"},"sem.c")," to do the analysis for your new node type"),(0,a.mdx)("li",{parentName:"ol"},"adjust the verification in ",(0,a.mdx)("inlineCode",{parentName:"li"},"sem_test.sql")," accordingly"),(0,a.mdx)("li",{parentName:"ol"},"run ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh")," until it passes making fixes as needed"),(0,a.mdx)("li",{parentName:"ol"},"there will be new diff output and it will be spitting out the diffs; if you are happy with the new output, accept the diffs to update the reference outputs; note the pattern matching validations will still fail if the output goes bad even if the reference comparison is good, the reference output is a double check"),(0,a.mdx)("li",{parentName:"ol"},"add code that uses your new feature to ",(0,a.mdx)("inlineCode",{parentName:"li"},"cg_test.sql"),", this is the code gen test, verifications using pattern matching are also allowed there"),(0,a.mdx)("li",{parentName:"ol"},"run ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh")),(0,a.mdx)("li",{parentName:"ol"},"it will fail because codegen doesn't know about your new feature"),(0,a.mdx)("li",{parentName:"ol"},"edit ",(0,a.mdx)("inlineCode",{parentName:"li"},"cg_c.c")," (or a different code gen if you're doing test helpers or some such) to support your new code"),(0,a.mdx)("li",{parentName:"ol"},"cycle running ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh")," until it passes"),(0,a.mdx)("li",{parentName:"ol"},"accept each diff when you're happy with the new output"),(0,a.mdx)("li",{parentName:"ol"},"Add code that runs your new feature using run_test.sql"),(0,a.mdx)("li",{parentName:"ol"},"Run ",(0,a.mdx)("inlineCode",{parentName:"li"},"test.sh"),", if your codegen was perfect it could pass; it probably won't at first"),(0,a.mdx)("li",{parentName:"ol"},"fix your code until it's done; you shouldn't need to accept any more diffs at this point"),(0,a.mdx)("li",{parentName:"ol"},"run ",(0,a.mdx)("inlineCode",{parentName:"li"},"cov.sh")," to confirm 100% coverage"),(0,a.mdx)("li",{parentName:"ol"},"sanity check the GCC build (I use a linux box for this)"))),(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("p",{parentName:"li"},"Get a solid code review and land as usual."))),(0,a.mdx)("p",null,"By the time you have done this you will have passed the tests dozens of times and you will know exactly what your code is doing to the entire battery of cql combinations.  Missing tests can be painful and cause downstream regressions so be ruthless about adding enough combinations and validating the essential parts.  The snapshot diffing is helpful but the real gating is done by the pattern matching logic."),(0,a.mdx)("p",null,"Note: none of this works unless you are standing the main source directory"),(0,a.mdx)("p",null,"Note: the test scripts make a lot of turds, at this point almost everything should be going into the ",(0,a.mdx)("inlineCode",{parentName:"p"},"out"),"\ndirectory but it wasn't always so.  You can use ",(0,a.mdx)("inlineCode",{parentName:"p"},"make clean")," to get rid of the build stuff wherever it may be.\nAlternatively use source control to get rid of any junk."))}c.isMDXComponent=!0}}]);