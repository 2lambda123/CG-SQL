"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6855],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return u}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=c(a),u=i,h=m["".concat(s,".").concat(u)]||m[u]||p[u]||r;return a?n.createElement(h,l(l({ref:t},d),{},{components:a})):n.createElement(h,l({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},148:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var n=a(7462),i=a(3366),r=(a(7294),a(3905)),l=["components"],o={id:"ch10",title:"Chapter 10: Schema Management Features",sidebar_label:"Chapter 10: Schema Management Features"},s=void 0,c={unversionedId:"ch10",id:"ch10",title:"Chapter 10: Schema Management Features",description:"\x3c!---",source:"@site/../CQL_Guide/ch10.md",sourceDirName:".",slug:"/ch10",permalink:"/cql-guide/ch10",draft:!1,tags:[],version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1666799051,formattedLastUpdatedAt:"10/26/2022",frontMatter:{id:"ch10",title:"Chapter 10: Schema Management Features",sidebar_label:"Chapter 10: Schema Management Features"},sidebar:"someSidebar",previous:{title:"Chapter 9: Statements Summary and Error Checking",permalink:"/cql-guide/ch09"},next:{title:"Chapter 11: Previous Schema Validation",permalink:"/cql-guide/ch11"}},d={},p=[{value:"Annotations",id:"annotations",level:3},{value:"Semantics",id:"semantics",level:3},{value:"Allowable changes",id:"allowable-changes",level:3},{value:"Prosecution",id:"prosecution",level:3},{value:"Example Migration",id:"example-migration",level:3},{value:"Sample Upgrade Script",id:"sample-upgrade-script",level:3},{value:"Preamble",id:"preamble",level:4},{value:"Facet Helpers",id:"facet-helpers",level:4},{value:"Declaration Section",id:"declaration-section",level:4},{value:"Helper Procedures",id:"helper-procedures",level:4},{value:"Baseline Schema",id:"baseline-schema",level:4},{value:"Migration Procedures",id:"migration-procedures",level:4},{value:"Views",id:"views",level:4},{value:"Indices",id:"indices",level:4},{value:"Triggers",id:"triggers",level:4},{value:"Caching the state of the facets",id:"caching-the-state-of-the-facets",level:4},{value:"Main Migration Script",id:"main-migration-script",level:4},{value:"Temp Tables",id:"temp-tables",level:4},{value:"Schema Regions",id:"schema-regions",level:3},{value:"Details",id:"details",level:4},{value:"E.g. Your Application has an on-disk and an in-memory database",id:"eg-your-application-has-an-on-disk-and-an-in-memory-database",level:5},{value:"Your Application Needs To Upgrade Each of the Above",id:"your-application-needs-to-upgrade-each-of-the-above",level:5},{value:"Your Customer Doesn&#39;t Want The Kitchen Sink of Schema",id:"your-customer-doesnt-want-the-kitchen-sink-of-schema",level:5},{value:"Declaring Regions and Dependencies",id:"declaring-regions-and-dependencies",level:4},{value:"Using Regions",id:"using-regions",level:4},{value:"Region Visibility",id:"region-visibility",level:4},{value:"Exception for <code>&quot;... LIKE &lt;table&gt;&quot;</code> statement",id:"exception-for--like-table-statement",level:5},{value:"Maintaining Schema in Pieces",id:"maintaining-schema-in-pieces",level:4},{value:"Schema Not In Any Region",id:"schema-not-in-any-region",level:5},{value:"Deployable Regions",id:"deployable-regions",level:4},{value:"Motivation and Examples",id:"motivation-and-examples",level:5},{value:"Private Regions",id:"private-regions",level:4},{value:"Unsubscription and Resubscription Features",id:"unsubscription-and-resubscription-features",level:3},{value:"Unsubscription and Resubscription",id:"unsubscription-and-resubscription",level:4},{value:"Validations for @unsub(<em>version</em>, <em>table</em>):",id:"validations-for-unsubversion-table",level:4},{value:"Validations for @resub(<em>version</em>, <em>table</em>):",id:"validations-for-resubversion-table",level:4},{value:"Previous Schema validations for @unsub/@resub",id:"previous-schema-validations-for-unsubresub",level:4}],m={toc:p};function u(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"CQL has a lot of schema knowledge already and so it's well positioned to think about schema upgrades and versioning."),(0,r.kt)("p",null,"It seemed essential to be able to record changes to the schema over time so CQL got an understanding of versioning.  This lets you do things like:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ensure columns are only added where they should be"),(0,r.kt)("li",{parentName:"ul"},"generate compiler errors if you try to access columns that are deprecated"),(0,r.kt)("li",{parentName:"ul"},"move from one version to another tracking schema facets that have to be added")),(0,r.kt)("p",null,"To use cql in this fashion, the sequence will be something like the below.  See Appendix 1 for command line details."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cql --in input.sql --rt schema_upgrade --cg schema_upgrader.sql \\\n                   --global_proc desired_upgrade_proc_name\n")),(0,r.kt)("h3",{id:"annotations"},"Annotations"),(0,r.kt)("p",null,"There are three basic flavors of annotation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@create(version [, migration proc])")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@delete(version [, migration proc])")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@recreate"))),(0,r.kt)("p",null,"They have various constraints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@create")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete")," can only be applied to tables and columns"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@recreate")," can only be applied to tables (nothing else needs it anyway)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@recreate")," cannot mix with ",(0,r.kt)("inlineCode",{parentName:"li"},"@create")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@recreate")," can include a group name as in ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate(musketeers)"),"; if a group name is specified then all the tables in that group are recreated if any of them change")),(0,r.kt)("p",null,'Indices, Views, and Triggers are always "recreated" (just like tables can be) and so neither the ',(0,r.kt)("inlineCode",{parentName:"p"},"@recreate")," nor the ",(0,r.kt)("inlineCode",{parentName:"p"},"@create")," annotations are needed (or allowed).  However when an Index, View, or Trigger is retired it must be marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," so that it isn't totally forgotten but can be deleted anywhere it might still exist.  Note that when one of these items is deleted, the definition is not used as it will only be dropped anyway. The simplest creation of the object with the correct name will do the job as a tombstone."),(0,r.kt)("p",null,"e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"create view used_to_be_fabulous as select 1 x @delete(12);"),"  suffices to drop the ",(0,r.kt)("inlineCode",{parentName:"p"},"used_to_be_fabulous")," view in version 12 no matter how complicated it used to be.  Its ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE VIEW")," will not be emitted into the upgrade procedure in any case.  Similarly, trivial indices and triggers of the correct name can be used for the tombstone."),(0,r.kt)("p",null,"In addition, if there is some data migration that needs to happen at a particular schema version that isn't associated with any particular change in schema, you can run an ",(0,r.kt)("em",{parentName:"p"},"ad hoc")," migrator at any time.  The syntax for that is ",(0,r.kt)("inlineCode",{parentName:"p"},"@schema_ad_hoc_migration(version, migration proc);"),".  Ad hoc migrations are the last to run in any given schema version; they happen after table drop migrations."),(0,r.kt)("h3",{id:"semantics"},"Semantics"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@create")," declares that the annotated object first appeared in the indicated version, and at that time the migration proc needs to be executed to fill in default values, denormalize values, or whatever the case may be."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," declares that the annotated object disappeared in the indicated version, and at that time the migration proc needs to be executed to clean up the contents, or potentially move them elsewhere."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@recreate")," declares that the annotated object can be dropped and recreated when it changes because there is no need to preserve its contents during an upgrade. Such objects may be changed arbitrarily from version to version."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"no columns in a ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate")," table may have ",(0,r.kt)("inlineCode",{parentName:"li"},"@create")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete")," (these aren't needed anyway)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"therefore tables with ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate")," never have deprecated columns (since ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete")," isn't allowed on their columns)")))),(0,r.kt)("p",null,"NOTE: all annotations are suppressed from generated SQL.  SQLite never sees them."),(0,r.kt)("p",null,"NOTE: looking at the annotations it is possible to compute the logical schema at any version, especially the original schema -- it's what you get if you disregard all ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," entirely (don't delete) and then remove anything marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@create")," directives."),(0,r.kt)("h3",{id:"allowable-changes"},"Allowable changes"),(0,r.kt)("p",null,"Not all migrations are possible in a sensible fashion, therefore CQL enforces certain limitations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'the "original" schema has no annotations or just delete annotations'),(0,r.kt)("li",{parentName:"ul"},"new tables may be added (with ",(0,r.kt)("inlineCode",{parentName:"li"},"@create"),")"),(0,r.kt)("li",{parentName:"ul"},"tables may be deleted (with ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete"),")"),(0,r.kt)("li",{parentName:"ul"},"columns may be added to a table, but only at the end of the table"),(0,r.kt)("li",{parentName:"ul"},"added columns must be nullable or have a default value (otherwise all existing insert statements would break for sure)"),(0,r.kt)("li",{parentName:"ul"},"columns may not be renamed"),(0,r.kt)("li",{parentName:"ul"},"columns may be deleted but this is only a logical delete, SQLite has no primitive to remove columns; once deleted you may no longer refer to that column in queries"),(0,r.kt)("li",{parentName:"ul"},"deleted columns must be nullable or have a default value (otherwise all existing and future insert statements would break for sure, the column isn't really gone)"),(0,r.kt)("li",{parentName:"ul"},"views, indices, and triggers may be added (no annotation required) and removed (with ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete"),") like tables"),(0,r.kt)("li",{parentName:"ul"},"views, indices, and triggers may be altered completely from version to version"),(0,r.kt)("li",{parentName:"ul"},"no normal code is allowed to refer to deleted columns, tables, etc.  This includes views, indices, and triggers"),(0,r.kt)("li",{parentName:"ul"},"schema migration stored procs see the schema as it existed in their annotation (so an older version). They are also forbidden from using views (see below)"),(0,r.kt)("li",{parentName:"ul"},"recreated objects (tables marked with @recreate, views, tables, and indices) have no change restrictions")),(0,r.kt)("h3",{id:"prosecution"},"Prosecution"),(0,r.kt)("p",null,"Moving from one schema version to another is done in an orderly fashion with the migration proc taking these essential steps in this order:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_schema_facets")," table is created if needed -- this records the current state of the schema")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the last known schema hash is read from the ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_schema_facets")," tables (it is zero by default)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"if the overall schema hash code matches what is stored, processing stops; otherwise an upgrade ensues")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"all known views are dropped (hence migration procs won't see them!)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"any index that needs to change is dropped (this includes items marked ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," or indices that are different than before)"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"change is detected by hash (crc64) of the previous index definition vs. the current"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"all known triggers are dropped (hence they will not fire during migration!)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the current schema version is extracted from ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_schema_facets")," (it is zero by default)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"if the current schema version is zero, then the original versions of all the tables are created")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"if the current schema version is <= 1 then"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"any tables that need to be created at schema version 1 are created as they exist at schema version 1"),(0,r.kt)("li",{parentName:"ul"},"any columns that need to be created at schema version 1 are created as they exist at schema version 1"),(0,r.kt)("li",{parentName:"ul"},"migration procedures schema version 1 are run in this order:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"create table migration"),(0,r.kt)("li",{parentName:"ul"},"create column migration"),(0,r.kt)("li",{parentName:"ul"},"delete trigger migration (these are super rare and supported for uniformity)"),(0,r.kt)("li",{parentName:"ul"},"delete index migration (these are super rare and supported for uniformity)"),(0,r.kt)("li",{parentName:"ul"},"delete view migration  (these are super rare and supported for uniformity)"),(0,r.kt)("li",{parentName:"ul"},"delete column migration"),(0,r.kt)("li",{parentName:"ul"},"delete table migration"),(0,r.kt)("li",{parentName:"ul"},"ad hoc migration"),(0,r.kt)("li",{parentName:"ul"},"each proc is run exactly one time"))),(0,r.kt)("li",{parentName:"ul"},"any tables that need to be dropped at schema version 1 are dropped"),(0,r.kt)("li",{parentName:"ul"},"the schema version is marked as 1 in ",(0,r.kt)("inlineCode",{parentName:"li"},"cql_schema_facets")),(0,r.kt)("li",{parentName:"ul"},"each sub-step in the above is recorded in ",(0,r.kt)("inlineCode",{parentName:"li"},"cql_schema_facets")," as it happens so it is not repeated",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"all that checking not shown for brevity"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the above process is repeated for all schema versions up to the current version")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"all tables that are marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@recreate")," are re-created if necessary"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"i.e. if the checksum of the table definition has changed for any  table (or group) then ",(0,r.kt)("inlineCode",{parentName:"li"},"drop")," it and create the new version."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"all indices that changed and were not marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," are re-created")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"all views not marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," are re-created")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"all triggers not marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete")," are re-installed")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the current schema hash is written to the ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_schema_facets")," table"))),(0,r.kt)("h3",{id:"example-migration"},"Example Migration"),(0,r.kt)("p",null,"Here's an example of a schema directly from the test cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-- crazy amount of versioning here\ncreate table foo(\n  id integer not null,\n  rate long integer @delete(5),\n  rate_2 long integer @delete(4, DeleteRate2Proc),\n  id2 integer default 12345 @create(4, CreateId2Proc),\n  name text @create(5),\n  name_2 text @create(6)\n);\n\n-- much simpler table, lots of stuff added in v2.\n-- note v1 is the first new version and v0 is base version\ncreate table table2(\n  id integer not null,\n  name1 text @create(2, CreateName1Proc),\n  name2 text @create(2, CreateName2Proc),\n  name3 text @create(2), -- no proc\n  name4 text @create(2) -- no proc\n);\n\ncreate table added_table(\n  id integer not null,\n  name1 text,\n  name2 text @create(4)\n) @create(3) @delete(5);\n\n-- this view is present in the output\ncreate view live_view as select * from foo;\n\n-- this view is also present in the output\ncreate view another_live_view as select * from foo;\n\n-- this view is not present in the output\ncreate view dead_view as select * from foo @delete(2);\n\n-- this index is present\ncreate index index_still_present on table2(name1, name2);\n\n-- this index is going away\ncreate index index_going_away on table2(name3) @delete(3);\n\n-- this is a simple trigger, and it's a bit silly but that doesn't matter\ncreate trigger trigger_one\n  after insert on foo\nbegin\n  delete from table2 where table2.id = new.id;\nend;\n")),(0,r.kt)("p",null,"This schema has a LOT of versioning... you can see tables and columns appearing in versions 2 through 6.  There is a lot of error checking happening."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"things with no create annotation were present in the base schema"),(0,r.kt)("li",{parentName:"ul"},"only things with no delete annotation are visible to normal code"),(0,r.kt)("li",{parentName:"ul"},"created columns have to be at the end of their table (required by SQLite)"),(0,r.kt)("li",{parentName:"ul"},"they have to be in ascending schema version order (but you can add several columns in one version)"),(0,r.kt)("li",{parentName:"ul"},"there may or may not be a proc to run to populate data in that column when it's added or to remove data when it's deleted",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"proc names must be unique"))),(0,r.kt)("li",{parentName:"ul"},"you can't delete a table or column in a version before it was created"),(0,r.kt)("li",{parentName:"ul"},"you can't delete a column in a table in a version before the table was created"),(0,r.kt)("li",{parentName:"ul"},"you can't create a column in a table in a version after the table was deleted"),(0,r.kt)("li",{parentName:"ul"},"there may be additional checks not listed here")),(0,r.kt)("h3",{id:"sample-upgrade-script"},"Sample Upgrade Script"),(0,r.kt)("p",null,"With just those annotations you can automatically create the following upgrade script which is itself CQL (and hence has to be compiled). Notice that this code is totally readable!"),(0,r.kt)("p",null,"The script has been split into logical pieces to make it easier to explain what's going on."),(0,r.kt)("h4",{id:"preamble"},"Preamble"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- ...copyright notice... possibly generated source tag... elided to avoid confusion\n\n-- no columns will be considered hidden in this script\n-- DDL in procs will not count as declarations\n@SCHEMA_UPGRADE_SCRIPT;\n")),(0,r.kt)("p",null,"Schema upgrade scripts need to see all the columns even the ones that would be logically deleted in normal mode.  This is so that things like ",(0,r.kt)("inlineCode",{parentName:"p"},"alter table add column")," can refer to real columns and ",(0,r.kt)("inlineCode",{parentName:"p"},"drop table")," can refer to a table that shouldn't even be visible.  Remember in CQL the declarations tell you the logical state of the universe and DLL mutations are expected to create that condition, so you should be dropping tables that are marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@delete"),"\nCQL stores the current state of the universe in this table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- schema crc -7714030317354747478\n")),(0,r.kt)("p",null,"The schema crc is computed by hashing all the schema declarations in canonical form.  That's everything in this next section."),(0,r.kt)("h4",{id:"facet-helpers"},"Facet Helpers"),(0,r.kt)("p",null,"CQL uses a set of four functions to manage a dictionary.  The implementation is in ",(0,r.kt)("inlineCode",{parentName:"p"},"cqlrt_common.c")," but it's really\njust a simple hash table that maps from a string key to a number.  This functionality was added because over time\nthe facets table can get pretty big and running a SQL query every time to read a single integer is not economical."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- declare facet helpers--\nDECLARE facet_data TYPE LONG<facet_data> not null;\nDECLARE test_facets facet_data;\nDECLARE FUNCTION cql_facets_new() facet_data;\nDECLARE PROCEDURE cql_facets_delete(facets facet_data);\nDECLARE FUNCTION cql_facet_add(facets facet_data, facet TEXT NOT NULL, crc LONG NOT NULL) BOOL NOT NULL;\nDECLARE FUNCTION cql_facet_find(facets facet_data, facet TEXT NOT NULL) LONG NOT NULL;\n")),(0,r.kt)("h4",{id:"declaration-section"},"Declaration Section"),(0,r.kt)("p",null,"Wherein all the necessary objects are declared..."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- declare sqlite_master --\nCREATE TABLE sqlite_master (\n  type TEXT NOT NULL,\n  name TEXT NOT NULL,\n  tbl_name TEXT NOT NULL,\n  rootpage INTEGER NOT NULL,\n  sql TEXT NOT NULL\n);\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlite_master")," table is built-in but it has to be introduced to CQL so that we can query it. Like all the other loose DDL declarations here there is no code generated for this.  We are simply declaring tables.  To create code you have to put the DDL in a proc.  Normally DDL in procs also declares the table but since we may need the original version of a table created and the final version declared we have ",(0,r.kt)("inlineCode",{parentName:"p"},"@schema_upgrade_script")," to help avoid name conflicts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- declare full schema of tables and views to be upgraded --\nCREATE TABLE foo(\n  id INTEGER NOT NULL,\n  rate LONG INT @DELETE(5),\n  rate_2 LONG INT @DELETE(4, DeleteRate2Proc),\n  id2 INTEGER DEFAULT 12345 @CREATE(4, CreateId2Proc),\n  name TEXT @CREATE(5),\n  name_2 TEXT @CREATE(6)\n);\n\nCREATE TABLE table2(\n  id INTEGER NOT NULL,\n  name1 TEXT @CREATE(2, CreateName1Proc),\n  name2 TEXT @CREATE(2, CreateName2Proc),\n  name3 TEXT @CREATE(2),\n  name4 TEXT @CREATE(2)\n);\n\nCREATE TABLE added_table(\n  id INTEGER NOT NULL,\n  name1 TEXT,\n  name2 TEXT @CREATE(4)\n) @CREATE(3) @DELETE(5);\n")),(0,r.kt)("p",null,"NOTE: all the tables are emitted including all the annotations.  This lets us do the maximum validation when we compile this script."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE VIEW live_view AS\nSELECT *\n  FROM foo;\n\nCREATE VIEW another_live_view AS\nSELECT *\n  FROM foo;\n\nCREATE VIEW dead_view AS\nSELECT *\n  FROM foo @DELETE(2);\n")),(0,r.kt)("p",null,"These view declarations do very little.  We only need the view names so we can legally drop the views.  We create the views elsewhere."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX index_still_present ON table2 (name1, name2);\nCREATE INDEX index_going_away ON table2 (name3) @DELETE(3);\n")),(0,r.kt)("p",null,"Just like views, these declarations introduce the index names and nothing else."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TRIGGER trigger_one\n  AFTER INSERT ON foo\nBEGIN\nDELETE FROM table2 WHERE table2.id = new.id;\nEND;\n")),(0,r.kt)("p",null,"We have only the one trigger; we declare it here."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- facets table declaration --\nCREATE TABLE IF NOT EXISTS test_cql_schema_facets(\n  facet TEXT NOT NULL PRIMARY KEY,\n  version LONG INTEGER NOT NULL\n);\n")),(0,r.kt)("p",null,"This is where we will store everything we know about the current state of the schema.  Below we define a few helper procs for reading and writing that table and reading ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlite_master")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- saved facets table declaration --\nCREATE TEMP TABLE test_cql_schema_facets_saved(\n  facet TEXT NOT NULL PRIMARY KEY,\n  version LONG INTEGER NOT NULL\n);\n")),(0,r.kt)("p",null,"We will snapshot the facets table at the start of the run so that we can produce a summary of the changes\nat the end of the run.  This table will hold that snapshot."),(0,r.kt)("p",null,'NOTE: the prefix "test" was specified when this file was built so all the methods and tables begin with ',(0,r.kt)("inlineCode",{parentName:"p"},"test_"),"."),(0,r.kt)("h4",{id:"helper-procedures"},"Helper Procedures"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc for testing for the presence of a column/type\nCREATE PROCEDURE test_check_column_exists(table_name TEXT NOT NULL,\n                                          decl TEXT NOT NULL,\n                                          OUT present BOOL NOT NULL)\nBEGIN\n  SET present := (SELECT EXISTS(SELECT * FROM sqlite_master\n                  WHERE tbl_name = table_name AND sql GLOB decl));\nEND;\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"check_column_exists")," inspects ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlite_master")," and returns true if a column matching ",(0,r.kt)("inlineCode",{parentName:"p"},"decl")," exists."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc for creating the schema version table\nCREATE PROCEDURE test_create_cql_schema_facets_if_needed()\nBEGIN\n  CREATE TABLE IF NOT EXISTS test_cql_schema_facets(\n    facet TEXT NOT NULL PRIMARY KEY,\n    version LONG INTEGER NOT NULL\n  );\nEND;\n")),(0,r.kt)("p",null,"Here we actually create the ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_schema_facets")," table with DDL inside a proc.  In a non-schema-upgrade script the above would give a name conflict."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc for saving the schema version table\nCREATE PROCEDURE test_save_cql_schema_facets()\nBEGIN\n  DROP TABLE IF EXISTS test_cql_schema_facets_saved;\n  CREATE TEMP TABLE test_cql_schema_facets_saved(\n    facet TEXT NOT NULL PRIMARY KEY,\n    version LONG INTEGER NOT NULL\n  );\n  INSERT INTO test_cql_schema_facets_saved\n    SELECT * FROM test_cql_schema_facets;\nEND;\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"save_sql_schema_facets")," procedure simply makes a snapshot of the current facets table.  Later we use\nthis snapshot to report the differences by joining these tables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc for setting the schema version of a facet\nCREATE PROCEDURE test_cql_set_facet_version(_facet TEXT NOT NULL,\n                                            _version LONG INTEGER NOT NULL)\nBEGIN\n  INSERT OR REPLACE INTO test_cql_schema_facets (facet, version)\n       VALUES(_facet, _version);\nEND;\n\n-- helper proc for getting the schema version of a facet\nCREATE PROCEDURE test_cql_get_facet_version(_facet TEXT NOT NULL,\n                                            out _version LONG INTEGER NOT NULL)\nBEGIN\n  BEGIN TRY\n    SET _version := (SELECT version FROM test_cql_schema_facets\n                       WHERE facet = _facet LIMIT 1 IF NOTHING -1);\n  END TRY;\n  BEGIN CATCH\n    SET _version := -1;\n  END CATCH;\nEND;\n")),(0,r.kt)("p",null,"The two procedures ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_get_facet_version")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_set_facet_version")," do just what you would expect.  Note the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"try")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," to return a default value if the select fails."),(0,r.kt)("p",null,"There are two additional helper procedures that do essentially the same thing using a schema version index.  These two methods exist only to avoid unnecessary repeated string literals in the output file which cause bloat."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc for getting the schema version CRC for a version index\nCREATE PROCEDURE test_cql_get_version_crc(_v INTEGER NOT NULL, out _crc LONG INTEGER NOT NULL)\nBEGIN\n  SET _crc := cql_facet_find(test_facets, printf('cql_schema_v%d', _v));\nEND;\n\n-- helper proc for setting the schema version CRC for a version index\nCREATE PROCEDURE test_cql_set_version_crc(_v INTEGER NOT NULL,\n                                          _crc LONG INTEGER NOT NULL)\nBEGIN\n  INSERT OR REPLACE INTO test_cql_schema_facets (facet, version)\n       VALUES('cql_schema_v'||_v, _crc);\nEND;\n")),(0,r.kt)("p",null,"As you can see, these procedures are effectively specializations of ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_get_facet_version")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_set_facet_version")," where the facet name is computed from the integer."),(0,r.kt)("p",null,'Triggers require some special processing.  There are so-called "legacy" triggers that crept into the system.  These\nbegin with ',(0,r.kt)("inlineCode",{parentName:"p"},"tr__")," and they do not have proper tombstones.  In fact some are from early versions of CQL before\nthey were properly tracked.  To fix any old databases that have these in them, we delete all triggers that start with ",(0,r.kt)("inlineCode",{parentName:"p"},"tr__"),".\nNote we have to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"GLOB")," operator to do this, because ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," is the ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," wildcard."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc to reset any triggers that are on the old plan --\nDECLARE PROCEDURE cql_exec_internal(sql TEXT NOT NULL) USING TRANSACTION;\nCREATE PROCEDURE test_cql_drop_legacy_triggers()\nBEGIN\n  DECLARE C CURSOR FOR SELECT name from sqlite_master\n     WHERE type = 'trigger' AND name GLOB 'tr__*';\n  LOOP FETCH C\n  BEGIN\n    call cql_exec_internal(printf('DROP TRIGGER %s;', C.name));\n  END;\nEND;\n")),(0,r.kt)("h4",{id:"baseline-schema"},"Baseline Schema"),(0,r.kt)("p",null,"The 'baseline' or 'v0' schema is unannotated (no ",(0,r.kt)("inlineCode",{parentName:"p"},"@create")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"@recreate"),").    The first real schema\nmanagement procedures are for creating and dropping these tables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROCEDURE test_cql_install_baseline_schema()\nBEGIN\n  CREATE TABLE foo(\n    id INTEGER NOT NULL,\n    rate LONG_INT,\n    rate_2 LONG_INT\n  );\n\n  CREATE TABLE table2(\n    id INTEGER NOT NULL\n  );\n\nEND;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- helper proc for dropping baseline tables before installing the baseline schema\nCREATE PROCEDURE test_cql_drop_baseline_tables()\nBEGIN\n  DROP TABLE IF EXISTS foo;\n  DROP TABLE IF EXISTS table2;\nEND;\n")),(0,r.kt)("h4",{id:"migration-procedures"},"Migration Procedures"),(0,r.kt)("p",null,"The next section declares the migration procedures that were in the schema.  These are expected to be\ndefined elsewhere."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- declared upgrade procedures if any\nDECLARE proc CreateName1Proc() USING TRANSACTION;\nDECLARE proc CreateName2Proc() USING TRANSACTION;\nDECLARE proc CreateId2Proc() USING TRANSACTION;\nDECLARE proc DeleteRate2Proc() USING TRANSACTION;\n")),(0,r.kt)("p",null,"The code below will refer to these migration procedures.  We emit a declaration so that we can use the names in context.\nNOTE: ",(0,r.kt)("inlineCode",{parentName:"p"},"USING TRANSACTION")," when applied to a proc declaration simply means the proc will access the database so it needs to be provided with a ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlite3 *db")," parameter."),(0,r.kt)("h4",{id:"views"},"Views"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- drop all the views we know\nCREATE PROCEDURE test_cql_drop_all_views()\nBEGIN\n  DROP VIEW IF EXISTS live_view;\n  DROP VIEW IF EXISTS another_live_view;\n  DROP VIEW IF EXISTS dead_view;\nEND;\n\n-- create all the views we know\nCREATE PROCEDURE test_cql_create_all_views()\nBEGIN\n  CREATE VIEW live_view AS\n  SELECT *\n    FROM foo;\n  CREATE VIEW another_live_view AS\n  SELECT *\n    FROM foo;\nEND;\n")),(0,r.kt)("p",null,"View migration is done by dropping all views and putting all views back."),(0,r.kt)("p",null,"NOTE: ",(0,r.kt)("inlineCode",{parentName:"p"},"dead_view")," was not created, but we did try to drop it if it existed."),(0,r.kt)("h4",{id:"indices"},"Indices"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- drop all the indices that are deleted or changing\nCREATE PROCEDURE test_cql_drop_all_indices()\nBEGIN\n  IF cql_facet_find(test_facets, 'index_still_present_index_crc') != -6823087563145941851 THEN\n    DROP INDEX IF EXISTS index_still_present;\n  END IF;\n  DROP INDEX IF EXISTS index_going_away;\nEND;\n\n-- create all the indices we need\nCREATE PROCEDURE test_cql_create_indices()\nBEGIN\n  IF cql_facet_find(test_facets, 'index_still_present_index_crc') != -6823087563145941851 THEN\n    CREATE INDEX index_still_present ON table2 (name1, name2);\n    CALL test_cql_set_facet_version('index_still_present_index_crc', -6823087563145941851);\n  END IF;\nEND;\n\n")),(0,r.kt)("p",null,"Indices are processed similarly to views, however we do not want to drop indices that are not changing.  Therefore we compute the CRC of the index definition.  At the start of the script any indices that are condemned (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"index_going_away"),") are dropped as well as any that have a new CRC. At the end of migration, changed or new indices are (re)created using ",(0,r.kt)("inlineCode",{parentName:"p"},"cql_create_indices"),"."),(0,r.kt)("h4",{id:"triggers"},"Triggers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"- drop all the triggers we know\nCREATE PROCEDURE test_cql_drop_all_triggers()\nBEGIN\n  CALL test_cql_drop_legacy_triggers();\n  DROP TRIGGER IF EXISTS trigger_one;\nEND;\n\n-- create all the triggers we know\nCREATE PROCEDURE test_cql_create_all_triggers()\nBEGIN\n  CREATE TRIGGER trigger_one\n    AFTER INSERT ON foo\n  BEGIN\n  DELETE FROM table2 WHERE table2.id = new.id;\n  END;\nEND;\n")),(0,r.kt)("p",null,"Triggers are always dropped before migration begins and are re-instated quite late in the processing\nas we will see below."),(0,r.kt)("h4",{id:"caching-the-state-of-the-facets"},"Caching the state of the facets"),(0,r.kt)("p",null,"To avoid selecting single rows out of the facets table repeatedly we introduce this procedure\nwhose job is to harvest the facets table and store it in a dictionary.  The helpers that do this\nwere declared above.  You've already seen usage of the facets in the\ncode above."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROCEDURE test_setup_facets()\nBEGIN\n  BEGIN TRY\n    SET test_facets := cql_facets_new();\n    DECLARE C CURSOR FOR SELECT * from test_cql_schema_facets;\n    LOOP FETCH C\n    BEGIN\n      LET added := cql_facet_add(test_facets, C.facet, C.version);\n    END;\n  END TRY;\n  BEGIN CATCH\n   -- if table doesn't exist we just have empty facets, that's ok\n  END CATCH;\nEND;\n")),(0,r.kt)("h4",{id:"main-migration-script"},"Main Migration Script"),(0,r.kt)("p",null,"The main script orchestrates everything.  There are inline comments for all of it.  The general order of events is:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"create schema facets table if needed"),(0,r.kt)("li",{parentName:"ul"},"check main schema crc; if it matches we're done here, otherwise continue...")),(0,r.kt)("p",null,"These operations are done in ",(0,r.kt)("inlineCode",{parentName:"p"},"test_perform_needed_upgrades")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"drop all views"),(0,r.kt)("li",{parentName:"ul"},"drop condemned indices"),(0,r.kt)("li",{parentName:"ul"},"fetch the current schema version"),(0,r.kt)("li",{parentName:"ul"},"if version 0 then install the baseline schema (see below)"),(0,r.kt)("li",{parentName:"ul"},"for each schema version with changes do the following:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"create any tables that need to be created in this version"),(0,r.kt)("li",{parentName:"ul"},"add any columns that need to be added in this version"),(0,r.kt)("li",{parentName:"ul"},"run migration procs in this order:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"create table"),(0,r.kt)("li",{parentName:"ul"},"create column"),(0,r.kt)("li",{parentName:"ul"},"delete trigger"),(0,r.kt)("li",{parentName:"ul"},"delete view"),(0,r.kt)("li",{parentName:"ul"},"delete index"),(0,r.kt)("li",{parentName:"ul"},"delete column"),(0,r.kt)("li",{parentName:"ul"},"delete table"))),(0,r.kt)("li",{parentName:"ul"},"drop any tables that need to be dropped in this version"),(0,r.kt)("li",{parentName:"ul"},"mark schema upgraded to the current version so far, and proceed to the next version"),(0,r.kt)("li",{parentName:"ul"},"each partial step is also marked as completed so that it can be skipped if the script is run again"))),(0,r.kt)("li",{parentName:"ul"},"create all the views"),(0,r.kt)("li",{parentName:"ul"},"(re)create any indices that changed and are not dead"),(0,r.kt)("li",{parentName:"ul"},"set the schema CRC to the current CRC")),(0,r.kt)("p",null,"That's it... the details are below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROCEDURE test_perform_upgrade_steps()\nBEGIN\n  DECLARE column_exists BOOL NOT NULL;\n  DECLARE schema_version LONG INTEGER NOT NULL;\n    -- dropping all views --\n    CALL test_cql_drop_all_views();\n\n    -- dropping condemned or changing indices --\n    CALL test_cql_drop_all_indices();\n\n    -- dropping condemned or changing triggers --\n    CALL test_cql_drop_all_triggers();\n\n    ---- install baseline schema if needed ----\n\n    CALL test_cql_get_version_crc(0, schema_version);\n    IF schema_version != -9177754326374570163 THEN\n      CALL test_cql_install_baseline_schema();\n      CALL test_cql_set_version_crc(0, -9177754326374570163);\n    END IF;\n\n    ---- upgrade to schema version 2 ----\n\n    CALL test_cql_get_version_crc(2, schema_version);\n    IF schema_version != -6840158498294659234 THEN\n      -- altering table table2 to add column name1 TEXT;\n\n      CALL test_check_column_exists('table2', '*[( ]name1 TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE table2 ADD COLUMN name1 TEXT;\n      END IF;\n\n      -- altering table table2 to add column name2 TEXT;\n\n      CALL test_check_column_exists('table2', '*[( ]name2 TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE table2 ADD COLUMN name2 TEXT;\n      END IF;\n\n      -- altering table table2 to add column name3 TEXT;\n\n      CALL test_check_column_exists('table2', '*[( ]name3 TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE table2 ADD COLUMN name3 TEXT;\n      END IF;\n\n      -- altering table table2 to add column name4 TEXT;\n\n      CALL test_check_column_exists('table2', '*[( ]name4 TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE table2 ADD COLUMN name4 TEXT;\n      END IF;\n\n      -- data migration procedures\n      IF cql_facet_find(test_facets, 'CreateName1Proc') = -1 THEN\n        CALL CreateName1Proc();\n        CALL test_cql_set_facet_version('CreateName1Proc', 2);\n      END IF;\n      IF cql_facet_find(test_facets, 'CreateName2Proc') = -1 THEN\n        CALL CreateName2Proc();\n        CALL test_cql_set_facet_version('CreateName2Proc', 2);\n      END IF;\n\n      CALL test_cql_set_version_crc(2, -6840158498294659234);\n    END IF;\n\n    ---- upgrade to schema version 3 ----\n\n    CALL test_cql_get_version_crc(3, schema_version);\n    IF schema_version != -4851321700834943637 THEN\n      -- creating table added_table\n\n      CREATE TABLE IF NOT EXISTS added_table(\n        id INTEGER NOT NULL,\n        name1 TEXT\n      );\n\n      CALL test_cql_set_version_crc(3, -4851321700834943637);\n    END IF;\n\n    ---- upgrade to schema version 4 ----\n\n    CALL test_cql_get_version_crc(4, schema_version);\n    IF schema_version != -6096284368832554520 THEN\n      -- altering table added_table to add column name2 TEXT;\n\n      CALL test_check_column_exists('added_table', '*[( ]name2 TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE added_table ADD COLUMN name2 TEXT;\n      END IF;\n\n      -- altering table foo to add column id2 INTEGER;\n\n      CALL test_check_column_exists('foo', '*[( ]id2 INTEGER*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE foo ADD COLUMN id2 INTEGER DEFAULT 12345;\n      END IF;\n\n      -- logical delete of column rate_2 from foo; -- no ddl\n\n      -- data migration procedures\n      IF cql_facet_find(test_facets, 'CreateId2Proc') = -1 THEN\n        CALL CreateId2Proc();\n        CALL test_cql_set_facet_version('CreateId2Proc', 4);\n      END IF;\n      IF cql_facet_find(test_facets, 'DeleteRate2Proc') = -1 THEN\n        CALL DeleteRate2Proc();\n        CALL test_cql_set_facet_version('DeleteRate2Proc', 4);\n      END IF;\n\n      CALL test_cql_set_version_crc(4, -6096284368832554520);\n    END IF;\n\n    ---- upgrade to schema version 5 ----\n\n    CALL test_cql_get_version_crc(5, schema_version);\n    IF schema_version != 5720357430811880771 THEN\n      -- altering table foo to add column name TEXT;\n\n      CALL test_check_column_exists('foo', '*[( ]name TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE foo ADD COLUMN name TEXT;\n      END IF;\n\n      -- logical delete of column rate from foo; -- no ddl\n\n      -- dropping table added_table\n\n      DROP TABLE IF EXISTS added_table;\n\n      CALL test_cql_set_version_crc(5, 5720357430811880771);\n    END IF;\n\n    ---- upgrade to schema version 6 ----\n\n    CALL test_cql_get_version_crc(6, schema_version);\n    IF schema_version != 3572608284749506390 THEN\n      -- altering table foo to add column name_2 TEXT;\n\n      CALL test_check_column_exists('foo', '*[( ]name_2 TEXT*', column_exists);\n      IF NOT column_exists THEN\n        ALTER TABLE foo ADD COLUMN name_2 TEXT;\n      END IF;\n\n      CALL test_cql_set_version_crc(6, 3572608284749506390);\n    END IF;\n\n    CALL test_cql_create_all_views();\n    CALL test_cql_create_all_indices();\n    CALL test_cql_create_all_triggers();\n    CALL test_cql_set_facet_version('cql_schema_version', 6);\n    CALL test_cql_set_facet_version('cql_schema_crc', -7714030317354747478);\nEND;\n")),(0,r.kt)("p",null,"We have one more helper that will look for evidence that we're trying\nto move backwards to a previous schema version.  This is not supported.\nThis procedure also arranges for the original facet versions to be saved\nand it proceduces a difference in facets after the upgrade is done."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROCEDURE test_perform_needed_upgrades()\nBEGIN\n  -- check for downgrade --\n  IF cql_facet_find(test_facets, 'cql_schema_version') > 6 THEN\n    SELECT 'downgrade detected' facet;\n  ELSE\n    -- save the current facets so we can diff them later --\n    CALL test_save_cql_schema_facets();\n    CALL test_perform_upgrade_steps();\n\n    -- finally produce the list of differences\n    SELECT T1.facet FROM\n      test_cql_schema_facets T1\n      LEFT OUTER JOIN test_cql_schema_facets_saved T2\n        ON T1.facet = T2.facet\n      WHERE T1.version is not T2.version;\n  END IF;\nEND;\n")),(0,r.kt)("p",null,"This is the main function for upgrades, it checks only the master schema version.\nThis function is separate so that the normal startup path doesn't have to have\nthe code for the full upgrade case in it.  This lets linker order files do a superior job\n(since full upgrade is the rare case)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROCEDURE test()\nBEGIN\n  DECLARE schema_crc LONG INTEGER NOT NULL;\n\n  -- create schema facets information table --\n  CALL test_create_cql_schema_facets_if_needed();\n\n  -- fetch the last known schema crc, if it's different do the upgrade --\n  CALL test_cql_get_facet_version('cql_schema_crc', schema_crc);\n\n  IF schema_crc <> -7714030317354747478 THEN\n    BEGIN TRY\n      CALL test_setup_facets();\n      CALL test_perform_needed_upgrades();\n    END TRY;\n    BEGIN CATCH\n      CALL cql_facets_delete(test_facets);\n      SET test_facets := 0;\n      THROW;\n    END CATCH;\n    CALL cql_facets_delete(test_facets);\n    SET test_facets := 0;\n  ELSE\n    -- some canonical result for no differences --\n    SELECT 'no differences' facet;\n  END IF;\nEND;\n")),(0,r.kt)("h4",{id:"temp-tables"},"Temp Tables"),(0,r.kt)("p",null,"We had no temporary tables in this schema, but if there were some they get added\nto the schema after the upgrade check."),(0,r.kt)("p",null,"A procedure like this one is generated:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PROCEDURE test_cql_install_temp_schema()\nBEGIN\n  CREATE TEMP TABLE tempy(\n    id INTEGER\n  );\nEND;\n")),(0,r.kt)("p",null,"This entry point can be used any time you need the temp tables.  But normally it is\nautomatically invoked."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"  ---- install temp schema after upgrade is complete ----\n  CALL test_cql_install_temp_schema();\n")),(0,r.kt)("p",null,"That logic is emitted at the end of the test procedure."),(0,r.kt)("h3",{id:"schema-regions"},"Schema Regions"),(0,r.kt)("p",null,"Schema Regions are designed to let you declare your schema in logical regions whose dependencies are specified.  It enforces the dependencies you specify creating errors if you attempt to break the declared rules.  Schema regions allow you to generate upgrade scripts for parts of your schema that can compose and be guaranteed to remain self-consistent."),(0,r.kt)("h4",{id:"details"},"Details"),(0,r.kt)("p",null,"In many cases schema can be factored into logical and independent islands.  This is desireable for a number of reasons:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"so that the schema can go into different databases"),(0,r.kt)("li",{parentName:"ul"},"so that the schema can be upgraded on a different schedule"),(0,r.kt)("li",{parentName:"ul"},'so that "not relevant" schema can be omitted from distributions'),(0,r.kt)("li",{parentName:"ul"},"so that parts of your schema that have no business knowing about each other can be prevented from taking dependencies on each other")),(0,r.kt)("p",null,"These all have very real applications:"),(0,r.kt)("h5",{id:"eg-your-application-has-an-on-disk-and-an-in-memory-database"},"E.g. Your Application has an on-disk and an in-memory database"),(0,r.kt)("p",null,"This creates basically three schema regions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"on disk: which cannot refer to the in-memory at all"),(0,r.kt)("li",{parentName:"ol"},"in-memory: which cannot refer to the on-disk schema at all"),(0,r.kt)("li",{parentName:"ol"},"cross-db: which refers to both, also in memory (optional)")),(0,r.kt)("h5",{id:"your-application-needs-to-upgrade-each-of-the-above"},"Your Application Needs To Upgrade Each of the Above"),(0,r.kt)("p",null,'There must be a separate upgrade script for both the island databases and yet a different one for the "cross-db" database'),(0,r.kt)("h5",{id:"your-customer-doesnt-want-the-kitchen-sink-of-schema"},"Your Customer Doesn't Want The Kitchen Sink of Schema"),(0,r.kt)("p",null,"If you're making a library with database support, your customers likely want to be able to create databases that have only features they want; you will want logical parts within your schema that can be separated for cleanliness and distribution."),(0,r.kt)("h4",{id:"declaring-regions-and-dependencies"},"Declaring Regions and Dependencies"),(0,r.kt)("p",null,"Schema Regions let you create logical groupings, you simply declare the regions you want and then start putting things into those regions.  The regions form a directed acyclic graph -- just like C++ base classes.  You create regions like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@declare_schema_region root;\n\n@declare_schema_region extra using root;\n")),(0,r.kt)("p",null,"The above simply declares the regions -- it doesn't put anything into them.  In this case we now have a ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," region and an ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," region.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," schema items will not be allowed to refer to anything in ",(0,r.kt)("inlineCode",{parentName:"p"},"extra"),"."),(0,r.kt)("p",null,"Without regions, you could also ensure that the above is true by putting all the ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," items afer the ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," in the input file but things can get more complicated than that in general, and the schema might also be in several files, complicating ordering as the option.  Also, relying on order could be problematic as it is quite easy to put things in the wrong place (e.g. add a new ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," item after the ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," items).  Making this a bit more complicated, we could have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@declare_schema_region feature1 using extra;\n@declare_schema_region feature2 using extra;\n@declare_schema_region everything using feature1, feature2;\n")),(0,r.kt)("p",null,"And now there are many paths to ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"everything")," region;  that's ok but certainly it will be tricky to do all that with ordering."),(0,r.kt)("h4",{id:"using-regions"},"Using Regions"),(0,r.kt)("p",null,"An illustrative example, using the regions defined above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@begin_schema_region root;\n\ncreate table main(\n  id integer,\n  name text\n);\n\ncreate view names as select name from main order by name;\n\n@end_schema_region;\n\n@begin_schema_region extra;\n\ncreate table details(\n   id integer references main(id),\n   details text\n);\n\ncreate proc get_detail(integer id_)\nbegin\n  select T1.id, T1.details, T2.name from details T1\n  inner join main T2 on T1.id = T2.id\n  where T1.id = id_;\nend;\n\n@end_schema_region;\n\n@begin_schema_region feature1;\n\ncreate table f1(\n   id integer references details(id),\n   f1_info text\n);\n\ncreate proc get_detail(integer id_)\nbegin\n  select T1.id, T1.details, T2.name, f1_info from details T1\n  inner join f T2 on T1.id = T2.id\n  inner join f1 on f1.id = T1.id\n  where T1.id = id_;\nend;\n\n@end_schema_region;\n\n@begin_schema_region feature2;\n  -- you can use details, and main but not f1\n@end_schema_region;\n")),(0,r.kt)("p",null,"With the structure above specified, even if a new contribution to the ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," schema appears later, the rules enforce that this region cannot refer to anything other than things in ",(0,r.kt)("inlineCode",{parentName:"p"},"root"),".  This can be very important if schema is being included via ",(0,r.kt)("inlineCode",{parentName:"p"},"#include")," and might get pulled into the compilation in various orders.  A feature area might also have a named public region that others things can depend on (e.g. some views) and private regions (e.g. some tables, or whatever)."),(0,r.kt)("h4",{id:"region-visibility"},"Region Visibility"),(0,r.kt)("p",null,"Schema regions do not provide additional name spaces -- the names of objects should be unique across all regions. In other words, regions do not hide or scope entity names; rather they create errors if inappropriate names are used."),(0,r.kt)("p",null,"Case 1: The second line will fail semantic validation because table ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," already exists"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- obvious standard name conflict\ncreate table A (id integer);\ncreate table A (id integer, name text);\n")),(0,r.kt)("p",null,"Case 2: This fails for the same reason as case #1. Table ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," already exists"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@declare_region root;\n-- table A is in no region\ncreate table A (id integer);\n@begin_region root:\n-- this table A is in the root region, still an error\ncreate table A (id integer, name text);\n@end_region;\n")),(0,r.kt)("p",null,"Case 3: Again fails for the same reason as case #1. Table ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," already exist in region ",(0,r.kt)("inlineCode",{parentName:"p"},"extra"),", and you cannot define another table with the same name in another region."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@declare_region root;\n@declare_region extra;\n\n@begin_region extra;\n-- so far so good\ncreate table A (id integer);\n@end_region;\n\n@begin_region root;\n-- no joy, this A conflicts with the previous A\ncreate table A (id integer, name text);\n@end_region;\n")),(0,r.kt)("p",null,"Really the visibility rules couldn't be anything other than the above, as SQLite has no knowledge of regions at all and so any exotic name resolution would just doom SQLite statements to fail when they finally run."),(0,r.kt)("h5",{id:"exception-for--like-table-statement"},"Exception for ",(0,r.kt)("inlineCode",{parentName:"h5"},'"... LIKE <table>"')," statement"),(0,r.kt)("p",null,"The rules above are enforced for all constructs except for where the syntactic sugar ",(0,r.kt)("inlineCode",{parentName:"p"},"... LIKE <table>")," forms, which can happen in a variety of statements. This form doesn't create a dependence on the table (but does create a dependence on its shape). When CQL generates output, the ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," construct is replaced with the actual names of the columns it refers to.  But these are independent columns, so this is simply a keystroke saver.  The table (or view, cursor, etc.) reference will be gone."),(0,r.kt)("p",null,"These cases below will succeed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@declare_region root;\ncreate table A (...);\ncreate view B (....);\ncreate procedure C {...}\n\n@begin_region root;\ncreate table AA(LIKE A);\ncreate table BB(LIKE B);\ncreate table CC(LIKE C);\n@end_region;\n")),(0,r.kt)("p",null,"Note: this exception may end up causing maintenance problems and so it might be revisited in the future."),(0,r.kt)("h4",{id:"maintaining-schema-in-pieces"},"Maintaining Schema in Pieces"),(0,r.kt)("p",null,"When creating upgrade scripts, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"--rt schema_upgrade")," flags you can add region options ",(0,r.kt)("inlineCode",{parentName:"p"},"--include_regions a b c")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"--exclude_regions d e f")," per the following:"),(0,r.kt)("p",null,"Included regions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'must be valid region names -- the base types are walked to compute all the regions that are "in"'),(0,r.kt)("li",{parentName:"ul"},'declarations are emitted in the upgrade for all of the "in" objects -- "exclude" does not affect the declarations')),(0,r.kt)("p",null,"Excluded regions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"must be valid region names and indicate parts of schema that are upgraded elsewhere, perhaps with a seperate CQL run, a different automatic upgrade, or even a manual mechanism"),(0,r.kt)("li",{parentName:"ul"},"upgrade code will be generated for all the included schema, but not for the excluded regions and their contents")),(0,r.kt)("p",null,"Example: Referring to the regions above you might do something like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"\n# All of these also need a --global_proc param for the entry point but that's not relevant here\ncql --in schema.sql --cg shared.sql --rt schema_upgrade  --include_regions extra\ncql --in schema.sql --cg f1.cql --rt schema_upgrade --include_regions feature1 --exclude_regions extra\ncql --in schema.sql --cg f2.cql --rt schema_upgrade --include_regions feature2 --exclude_regions extra\n")),(0,r.kt)("p",null,"The first command generates all the shared schema for regions ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," contains ",(0,r.kt)("inlineCode",{parentName:"p"},"root")),(0,r.kt)("p",null,"The second command declares all of ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," so that the ",(0,r.kt)("inlineCode",{parentName:"p"},"feature1")," things can refer to them, however the upgrade code for these shared regions is not emitted.  Only the upgrade for schema in ",(0,r.kt)("inlineCode",{parentName:"p"},"feature1")," is emitted.  ",(0,r.kt)("inlineCode",{parentName:"p"},"feature2")," is completely absent.  This will be ok because we know ",(0,r.kt)("inlineCode",{parentName:"p"},"feature1")," cannot depend on ",(0,r.kt)("inlineCode",{parentName:"p"},"feature2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," is assumed to be upgraded elsewhere (such as in the previous line)."),(0,r.kt)("p",null,"The third command declares all of ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"extra")," so that the ",(0,r.kt)("inlineCode",{parentName:"p"},"feature2")," things can refer to them, however the upgrade code for these shared regions is not emitted.  Only the upgrade for schema in ",(0,r.kt)("inlineCode",{parentName:"p"},"feature2")," is emitted.  ",(0,r.kt)("inlineCode",{parentName:"p"},"feature1")," is completely absent."),(0,r.kt)("p",null,"Note that in the above examples, CQL is generating more CQL to be compiled again (a common pattern).  The CQL upgrade scripts need to be compiled as usual to produce executable code.  Thus the output of this form includes the schema declarations and executable DDL."),(0,r.kt)("h5",{id:"schema-not-in-any-region"},"Schema Not In Any Region"),(0,r.kt)("p",null,"For schema that is not in any region you might imagine that it is a special region ",(0,r.kt)("inlineCode",{parentName:"p"},"<none>")," that depends on everything.  So basically you can put anything there.  Schema that is in any region cannot ever refer to schema that is in ",(0,r.kt)("inlineCode",{parentName:"p"},"<none>"),"."),(0,r.kt)("p",null,"When upgrading, if any include regions are specified then ",(0,r.kt)("inlineCode",{parentName:"p"},"<none>")," will not be emitted at all.  If you want an upgrader for just ",(0,r.kt)("inlineCode",{parentName:"p"},"<none>")," this is possible with an assortment of exclusions.  You can always create arbitrary grouping regions to make this easier. A region named ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," that uses all other regions would make this simple."),(0,r.kt)("p",null,"In general, best practice is that there is no schema in ",(0,r.kt)("inlineCode",{parentName:"p"},"<none>"),", but since most SQL code has no regions some sensible meaning has to be given to DDL before it gets region encodings."),(0,r.kt)("h4",{id:"deployable-regions"},"Deployable Regions"),(0,r.kt)("p",null,"Given the above we note that some schema regions correspond to the way that we will deploy the schema.  We want those bundles to be safe to deploy but to in order to be so we need a new notion -- a deployable region.  To make this possible CQL includes the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can declare a region as deployable using ",(0,r.kt)("inlineCode",{parentName:"li"},"@declare_deployable_region")),(0,r.kt)("li",{parentName:"ul"},"CQL computes the covering of a deployable region: its transitive closure up to but not including any deployable regions it references"),(0,r.kt)("li",{parentName:"ul"},"No region is allowed to depend on a region that is within the interior of a different deployable region, but you can depend on the deployable region itself")),(0,r.kt)("p",null,"Because of the above, each deployable region is in fact a well defined root for the regions it contains.  The deployable region becomes the canonical way in which a bundle of regions (and their content) is deployed and any given schema item can be in only one deployable region."),(0,r.kt)("h5",{id:"motivation-and-examples"},"Motivation and Examples"),(0,r.kt)("p",null,"As we saw above, regions are logical groupings of tables/views/etc such that if an entity is in some region ",(0,r.kt)("inlineCode",{parentName:"p"},"R")," then it is allowed to only refer to the things that ",(0,r.kt)("inlineCode",{parentName:"p"},"R")," declared as dependencies ",(0,r.kt)("inlineCode",{parentName:"p"},"D1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"D2"),", etc. and their transitive closures.  You can make as many logical regions as you like and you can make them as razor thin as you like; they have no physical reality but they let you make as many logical groups of things as you might want."),(0,r.kt)("p",null,"Additionally, when we\u2019re deploying schema you generally need to do it in several pieces. E.g. if we have tables that go in an in-memory database then defining a region that holds all the in-memory tables makes it easy to, say, put all those in-memory tables into a particular deployment script."),(0,r.kt)("p",null,"Now we come to the reason for deployable regions. From CQL\u2019s perspective, all regions are simply logical groups; some grouping is then meaningful to programmers but has no physical reality. This means you\u2019re free to reorganize tables etc. as you see fit into new or different regions when things should move. Only, that\u2019s not quite true. The fact that we deploy our schema in certain ways means while most logical moves are totally fine, if you were to move a table from, say, the main database region to the in-memory region you would be causing a major problem.  Some installations may already have the table in the main area and there would be nothing left in the schema to tell CQL to drop the table from the main database -- the best you can hope for is the new location gets a copy of the table the old location keeps it and now there are name conflicts forever."),(0,r.kt)("p",null,"So, the crux of the problem is this: We want to let you move schema freely between logical regions in whatever way makes sense to you, but once you pick the region you are going to deploy in, you cannot change that."),(0,r.kt)("p",null,"To accomplish this, CQL needs to know that some of the regions are deployable regions and there have to be rules to make it all makes sense.  Importantly, every region has to be contained in at most one deployable region."),(0,r.kt)("p",null,"Since the regions form a DAG we must create an error if any region could ever roll up to two different deployable regions. The easiest way to describe this rule is \u201cno peeking\u201d \u2013 the contents of a deployable region are \u201cprivate\u201d they can refer to each other in any DAG shape but outside of the deployable region you can only refer to its root. So you can still compose them but each deployable region owns a well-defined covering. Note that you can make as many fine-grained deployable regions as you want; you don\u2019t actually have to deploy them separately, but you get stronger rules about the sharing when you do."),(0,r.kt)("p",null,"Here\u2019s an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Master Deployment 1\n  Feature 1 (Deployable)\n    logical regions for feature 1\n    Core (Deployable)\n      logical regions for core\n  Feature 2 (Deployable)\n    logical regions for feature 2\n    Core\n      ...\n\nMaster Deployment 2\n  Feature 1 (Deployable)\n    ...\n\n  Feature 3 (Deployable)\n    logical regions for feature 3\n")),(0,r.kt)("p",null,"In the above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"none of the logical regions for feature 1, 2, 3 are allowed to refer to logical regions in any other feature, though any of them could refer to Core (but not directly to what is inside Core)"),(0,r.kt)("li",{parentName:"ul"},"within those regions you can make any set of groupings that makes sense and you can change them over time as you see fit, with some restrictions"),(0,r.kt)("li",{parentName:"ul"},"any such regions are not allowed to move to a different Feature group (because those are deployment regions)"),(0,r.kt)("li",{parentName:"ul"},"the Master Deployment regions just group features in ways we\u2019d like to deploy them; in this case there are two deployments: one that includes Feature 1 & 2 and another that includes Feature 1 & 3"),(0,r.kt)("li",{parentName:"ul"},"the deployable region boundaries are preventing Feature 1 regions from using Feature 2 regions in an ad hoc way (i.e. you can't cheat by taking a direct dependency on something inside a different feature), but both Features can use Core"),(0,r.kt)("li",{parentName:"ul"},"Feature 3 doesn\u2019t use Core but Core will still be in Master Deployment 2 due to Feature 1")),(0,r.kt)("p",null,"Note that the deployable regions for Feature 1, 2, and 3 aren't actually deployed alone, but they are adding enforcement that makes the features cleaner"),(0,r.kt)("p",null,'Because of how upgrades work, \u201cCore\u201d could have its own upgrader. Then when you create the upgrader for Master Deployment 1 and 2, you can specify \u201cexclude Core\u201d in which case those tables are assumed to be updated independently. You could create as many or as few independently upgrade-able things with this pattern. Because regions are not allowed to "peek" inside of a deployable region, you can reorganize your logical regions without breaking other parts of the schema.'),(0,r.kt)("h4",{id:"private-regions"},"Private Regions"),(0,r.kt)("p",null,"The above constructs create a good basis for creating and composing regions, but a key missing aspect is the ability to hide internal details in the logical groups.  This becomes increasingly important as your desire to modularize schema grows; you will want to have certain parts that can change without worrying about breaking others and without fear that there are foreign keys and so forth referring to them."),(0,r.kt)("p",null,"To accomplish this, CQL provides the ability to compose schema regions with the optional ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," keyword.  In the following example there will be three regions creatively named ",(0,r.kt)("inlineCode",{parentName:"p"},"r1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"r2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"r3"),".  Region ",(0,r.kt)("inlineCode",{parentName:"p"},"r2")," consumes ",(0,r.kt)("inlineCode",{parentName:"p"},"r1")," privately and therefore ",(0,r.kt)("inlineCode",{parentName:"p"},"r3")," is not allowed to use things in ",(0,r.kt)("inlineCode",{parentName:"p"},"r1")," even though it consumes ",(0,r.kt)("inlineCode",{parentName:"p"},"r2"),".  When creating an upgrade script for ",(0,r.kt)("inlineCode",{parentName:"p"},"r3")," you will still need (and will get) all of ",(0,r.kt)("inlineCode",{parentName:"p"},"r2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r1"),", but from a visibility perspective ",(0,r.kt)("inlineCode",{parentName:"p"},"r3")," can only directly depend on ",(0,r.kt)("inlineCode",{parentName:"p"},"r2"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@declare_schema_region r1;\n@declare_schema_region r2 using r1 private;\n@declare_schema_region r3 using r2;\n\n@begin_schema_region r1;\ncreate table r1_table(id integer primary key);\n@end_schema_region;\n\n@begin_schema_region r2;\ncreate table r2_table(id integer primary key references r1_table(id));\n@end_schema_region;\n\n@begin_schema_region r3;\n\n-- this is OK\ncreate table r3_table_2(id integer primary key references r2_table(id));\n\n-- this is an error, no peeking into r1\ncreate table r3_table_1(id integer primary key references r1_table(id));\n\n@end_schema_region;\n")),(0,r.kt)("p",null,"As expected ",(0,r.kt)("inlineCode",{parentName:"p"},"r2")," is still allowed to use ",(0,r.kt)("inlineCode",{parentName:"p"},"r1")," because your private regions are not private from yourself.  So you may think it\u2019s easy to work around this privacy by simply declaring a direct dependency on r1 wherever you need it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"@declare_schema_region my_sneaky_region using r1, other_stuff_I_need;\n")),(0,r.kt)("p",null,"That would seem to make it all moot.  However, this is where deployable regions come in.  Once you bundle your logical regions in a deployable region there\u2019s no more peeking inside the the deployable region.  So we could strengthen the above to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"@declare_deployable_region r2 using r1 private;\n")),(0,r.kt)("p",null,"Once this is done it becomes an error to try to make new regions that peek into ",(0,r.kt)("inlineCode",{parentName:"p"},"r2"),"; you have to take all of ",(0,r.kt)("inlineCode",{parentName:"p"},"r2"),' or none of it -- and you can\u2019t see the private parts.  Of course you can do region wrapping at any level so you can have as many subgroups as you like, whatever is useful. You can even add additional deployable regions that aren\u2019t actually deployed to get the "hardened" grouping at no cost.'),(0,r.kt)("p",null,"So, in summary, to get true privacy, first make whatever logical regions you like that are helpful.  Put privacy where you need/want it.  Import logical regions as much as you want in your own bundle of regions.  Then wrap that bundle up in a deployable region (they nest) and then your private regions are safe from unwanted usage."),(0,r.kt)("h3",{id:"unsubscription-and-resubscription-features"},"Unsubscription and Resubscription Features"),(0,r.kt)("p",null,"Any significant library that is centered around a database is likely to accrue significant amounts of schema to support its features.\nOften users of the library don\u2019t want all its features and therefore don\u2019t want all of its schema.  CQL\u2019s primary strategy is to allow\nthe library author to divide the schema into regions and then the consumer of the library  may generate a suitable schema deployer\nthat deploys only the desired regions.  You simply subscribe to the regions you want."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@unsub"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"@resub")," constructs  deal with the unfortunate situation of over-subscription.  In the event that a customer has subscribed to regions\nthat it turns out they don\u2019t need, or if indeed the regions are not fine-grained enough, they may wish to (possibly much later) unsubscribe\nfrom particular tables or entire regions that they previously had included."),(0,r.kt)("p",null,"Unfortunately it\u2019s not so trivial as to simply remove the regions after the fact. The problem is that there might be billions\nof devices that already have the undesired tables and are paying the initialization costs for them.  Affirmatively removing the tables\nis highly desirable and that means a forward-looking annotation is necessary to tell the upgrader to generate ",(0,r.kt)("inlineCode",{parentName:"p"},"DROP")," statements at some point.\nFurthermore, a customer  might decide at some point later that now is the time they need the schema in question, so resubcription also\nhas to be possible."),(0,r.kt)("h4",{id:"unsubscription-and-resubscription"},"Unsubscription and Resubscription"),(0,r.kt)("p",null,"To accomplish this we add the following constructs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@unsub(version_number, table_name);\n")),(0,r.kt)("p",null,"And its twin"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"@resub(version_number, table_name);\n")),(0,r.kt)("p",null,"The effects of a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"@unsub")," are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The table is no longer accessible by statements"),(0,r.kt)("li",{parentName:"ul"},"If the table is marked ",(0,r.kt)("inlineCode",{parentName:"li"},"@create"),", then \u201cDROP IF EXISTS table",(0,r.kt)("em",{parentName:"li"},"name\u201d is emitted into the upgrade steps for _version_number")),(0,r.kt)("li",{parentName:"ul"},"If the table is ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate")," the table is unconditionally dropped as though it had been deleted"),(0,r.kt)("li",{parentName:"ul"},"The JSON includes the unsub details in a new subscriptions section")),(0,r.kt)("p",null,"The effects of a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"@resub")," are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The table is once again accessible by statements"),(0,r.kt)("li",{parentName:"ul"},"If the table is ",(0,r.kt)("inlineCode",{parentName:"li"},"@create")," then ",(0,r.kt)("inlineCode",{parentName:"li"},"CREATE TABLE table_name ...")," is emitted into the upgrade steps for ",(0,r.kt)("em",{parentName:"li"},"version_number"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the emitted create is for the table as it would have existed at ",(0,r.kt)("em",{parentName:"li"},"version_number"),"."))),(0,r.kt)("li",{parentName:"ul"},"If the table is ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate"),", the table is recreated as usual"),(0,r.kt)("li",{parentName:"ul"},"The JSON includes the resub details in a new subscriptions section")),(0,r.kt)("p",null,"The compiler ensures that the directives are valid and stay valid."),(0,r.kt)("h4",{id:"validations-for-unsubversion-table"},"Validations for @unsub(",(0,r.kt)("em",{parentName:"h4"},"version"),", ",(0,r.kt)("em",{parentName:"h4"},"table"),"):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"version")," must be an integer greater or equal to 1"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"version")," must be greater or equal to any unsub or resub version previously seen"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," must be a valid table name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," may have no previous unsub/resub at ",(0,r.kt)("em",{parentName:"li"},"version")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," must be marked with an ",(0,r.kt)("inlineCode",{parentName:"li"},"@create")," version < ",(0,r.kt)("em",{parentName:"li"},"version")," or else be marked ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"recall that unmarked (baseline) tables are the same as ",(0,r.kt)("inlineCode",{parentName:"li"},"@create(0)")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," must not be already unsubscribed"),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("em",{parentName:"li"},"table")," is marked with ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete"),", its delete version must be > ",(0,r.kt)("em",{parentName:"li"},"version"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"unsubscribing from a table after it\u2019s been outright deleted is clearly a mistake"),(0,r.kt)("li",{parentName:"ul"},"deleting a table in the same version that it is unsubscribed makes the ",(0,r.kt)("inlineCode",{parentName:"li"},"@unsub")," redundant"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," might be later outright deleted, the ",(0,r.kt)("inlineCode",{parentName:"li"},"@unsub")," at an earlier version stands"))),(0,r.kt)("li",{parentName:"ul"},"For every child table -- those that mention this table using ",(0,r.kt)("inlineCode",{parentName:"li"},"REFERENCES"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The child must be already deleted or unsubscribed"),(0,r.kt)("li",{parentName:"ul"},"The deletion or unsubscription must have happened at a version <= ",(0,r.kt)("em",{parentName:"li"},"version")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," is marked unsubscribed for purposes of further analysis")),(0,r.kt)("h4",{id:"validations-for-resubversion-table"},"Validations for @resub(",(0,r.kt)("em",{parentName:"h4"},"version"),", ",(0,r.kt)("em",{parentName:"h4"},"table"),"):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"version")," must be an integer greater or equal to 1"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"version")," must be greater or equal to any unsub or resub version previously seen"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," must be a valid table name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," may have no previous unsub/resub at ",(0,r.kt)("em",{parentName:"li"},"version")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," must be marked with an ",(0,r.kt)("inlineCode",{parentName:"li"},"@create")," version < ",(0,r.kt)("em",{parentName:"li"},"version")," or else be marked ",(0,r.kt)("inlineCode",{parentName:"li"},"@recreate"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"recall that unmarked (baseline) tables are the same as ",(0,r.kt)("inlineCode",{parentName:"li"},"@create(0)")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," must currently be unsubscribed"),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("em",{parentName:"li"},"table")," is marked with ",(0,r.kt)("inlineCode",{parentName:"li"},"@delete"),", its delete version must be > ",(0,r.kt)("em",{parentName:"li"},"version"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"resubscribing from a table after it\u2019s been outright deleted is clearly a mistake"),(0,r.kt)("li",{parentName:"ul"},"deleting a table in the same version that it is resubscribed makes the ",(0,r.kt)("inlineCode",{parentName:"li"},"@resub")," redundant"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," might be later outright deleted, the ",(0,r.kt)("inlineCode",{parentName:"li"},"@resub")," at an earlier version stands"))),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("em",{parentName:"li"},"table")," is not currently deleted then",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For every parent table (i.e. the tables it REFERENCES)"),(0,r.kt)("li",{parentName:"ul"},"The parent table must not be deleted or unsubscribed"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"table")," has its unsubscribed status removed for further analysis")),(0,r.kt)("h4",{id:"previous-schema-validations-for-unsubresub"},"Previous Schema validations for @unsub/@resub"),(0,r.kt)("p",null,"In the presence of ",(0,r.kt)("inlineCode",{parentName:"p"},"@previous_schema;")," the following additional validations must be made:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Every ",(0,r.kt)("inlineCode",{parentName:"li"},"@unsub")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@resub")," in the previous schema must exist in the current schema in the exact same order with the exact same parameters",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"i.e. these operations are never revoked, they undo each other creating a linear history like every other annotation"))),(0,r.kt)("li",{parentName:"ul"},"Any ",(0,r.kt)("inlineCode",{parentName:"li"},"@unsub")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"@resub")," not present in the previous schema version happens at a version number that is greater or equal to the largest version number that was present anywhere in the previous schema",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"i.e. you cannot unsubscribe or subscribe in the past.")))),(0,r.kt)("p",null,"These validations are sufficient to guarantee a constistent logical history for unsubscriptions."))}u.isMDXComponent=!0}}]);