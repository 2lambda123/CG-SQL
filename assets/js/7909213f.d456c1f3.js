"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3608],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return u},MDXProvider:function(){return p},mdx:function(){return f},useMDXComponents:function(){return d},withMDXComponents:function(){return m}});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=a.createContext({}),m=function(e){return function(n){var t=d(n.components);return a.createElement(e,r({},n,{components:t}))}},d=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(u.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=d(t),p=o,h=m["".concat(i,".").concat(p)]||m[p]||c[p]||r;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},72087:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return d}});var a=t(83117),o=t(80102),r=(t(67294),t(3905)),i=["components"],l={slug:"declare-enum-intro",title:"Introducing Declare Enum",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},s=void 0,u={permalink:"/blog/declare-enum-intro",editUrl:"https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2020-12-03-declare-enum-intro.md",source:"@site/blog/2020-12-03-declare-enum-intro.md",title:"Introducing Declare Enum",description:"There is an unfortunate pattern of hard coding constants in SQL which I think comes from the",date:"2020-12-03T00:00:00.000Z",formattedDate:"December 3, 2020",tags:[{label:"facebook",permalink:"/blog/tags/facebook"},{label:"cg-sql",permalink:"/blog/tags/cg-sql"},{label:"errors",permalink:"/blog/tags/errors"}],readingTime:4.765,hasTruncateMarker:!1,authors:[{name:"CG/SQL Team",title:"Maintainer of CG/SQL",url:"https://github.com/facebookincubator",imageURL:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4"}],frontMatter:{slug:"declare-enum-intro",title:"Introducing Declare Enum",author:"CG/SQL Team",author_title:"Maintainer of CG/SQL",author_url:"https://github.com/facebookincubator",author_image_url:"https://avatars2.githubusercontent.com/u/69631?s=200&v=4",tags:["facebook","cg-sql","errors"]},prevItem:{title:"Introducing  Argument Bundles",permalink:"/blog/arg-bungle-intro"},nextItem:{title:"A quick tutorial on LIKE forms",permalink:"/blog/like-forms-tutorial"}},m={authorsImageUrls:[void 0]},d=[],p={toc:d};function c(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.mdx)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"There is an unfortunate pattern of hard coding constants in SQL which I think comes from the\nfact that there's not an especially good way to encode constants in SQL.  Things are a little\nbetter In CG/SQL's CQL language because it's normal to run things through the pre-processor first\nso you can do things like:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"#define BUSINESS_TYPE_RESTAURANT 1\n#define BUSINESS_TYPE_LAUNDROMAT 2\n")),(0,r.mdx)("p",null,"Having done so, you could write:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"insert into Business using\n   \"Rico's Laundry\"  name,\n   BUSINESS_TYPE_LAUNDROMAT type;\n\n-- by the time SQL sees this it becomes\ninsert into Business(name, type) values('Rico''s Laundry', 2);\n")),(0,r.mdx)("p",null,"And at least you don't have to see these loose '2' values all over. An especially unfortunate\nform is the below, in which the auther is clearly crying for a symbol to use:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'insert into Business using\n   "Rico\'s Laundry"  name,\n   2 type; /* laundromat */\n')),(0,r.mdx)("p",null,"But if we use ",(0,r.mdx)("inlineCode",{parentName:"p"},"#define")," the language knows nothing of the names and it can't help you manage them\nor export them consistently or anything like that.  I guess ",(0,r.mdx)("inlineCode",{parentName:"p"},"#define")," is pretty useful in several\nlangauges (C and C++) so you could maybe ",(0,r.mdx)("inlineCode",{parentName:"p"},"#include")," the macros somehow but that doesn't seem\nespecially great.  And if you need them in Java you're getting no help at all."),(0,r.mdx)("p",null,"So to this world we add enumerated constants.  This is a bit short of enumerated types as we'll\nsee later.  You can now write something like this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"declare enum business_type integer (\n  restuarant,\n  laundromat,\n  corner_store = 11+3  /* math added for demo purposes only */\n);\n")),(0,r.mdx)("p",null,"After this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"select business_type.corner_store;\n")),(0,r.mdx)("p",null,"is the same as"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"select 14;\n")),(0,r.mdx)("p",null,"And that is exactly what SQLite will see, the literal 14."),(0,r.mdx)("p",null,"What's going on here?  There's just a few rules:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"the enumeration can be any numeric type (bool, integer, long integer, real)"),(0,r.mdx)("li",{parentName:"ul"},"the values of the enumeration start at 1 (i.e. if there is no ",(0,r.mdx)("inlineCode",{parentName:"li"},"= expression")," the first item will be 1, not 0)"),(0,r.mdx)("li",{parentName:"ul"},"if you don't specify a value, the next value is the previous value + 1"),(0,r.mdx)("li",{parentName:"ul"},"if you do specify a value it can be any constant expression and it will be cast to the type of the enumeration (even if thatis lossy)"),(0,r.mdx)("li",{parentName:"ul"},"the enumeration can refer to previous values in itself with no qualification ",(0,r.mdx)("inlineCode",{parentName:"li"},"(big = 100.0, medium = big/2, small = medium/2)")),(0,r.mdx)("li",{parentName:"ul"},"the enumeration can refer to previously defined enumerations as usual ",(0,r.mdx)("inlineCode",{parentName:"li"},"(code = business_type.restaurant)")),(0,r.mdx)("li",{parentName:"ul"},"Once the enumeration is defined you refer to its members in a fully qualified fashion ",(0,r.mdx)("inlineCode",{parentName:"li"},"enum_name.member_name")," elsewhere")),(0,r.mdx)("p",null,"Why is this better than macros?  Well for one thing the enum values can be checked at their declaration site, so if you\nhave errors you will hear about them in a more reasonable place.  But additionally since the structure is known to the\ncompiler it can give you useful information in the outputs."),(0,r.mdx)("p",null,"In the ",(0,r.mdx)("inlineCode",{parentName:"p"},".h")," files you get:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"enum business_type {\n  business_type__restaurant = 1,\n  business_type__laundromat = 2,\n  business_type__corner_store = 14\n};\n")),(0,r.mdx)("p",null,"In case of floating point values such as:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"declare enum floating real (\n  one = 1.0,\n  two = 2.0,\n  e = 2.71828,\n  pi = 3.14159\n);\n")),(0,r.mdx)("p",null,"You get:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"// enum floating (floating point values)\n#define floating__one 1.000000e+00\n#define floating__two 2.000000e+00\n#define floating__e 2.718280e+00\n#define floating__pi 3.141590e+00\n")),(0,r.mdx)("p",null,"Which is unfortunately the best you can do since C has no floating point enums."),(0,r.mdx)("p",null,"But in both cases the ",(0,r.mdx)("inlineCode",{parentName:"p"},"enums")," section of the JSON has the name of the enums and their members and values ready to go.\nWith these values you can readily generate (with moustache or something) the language interfaces of your choice.  This\nis a real help if you're trying to make helpers to call your CQL from say Java or something."),(0,r.mdx)("p",null,"To do all this we needed to add some constant folding and general evaluation to the compiler.  It's not much,\njust the normal numeric types and null.  The supported operations include:"),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"+"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"-"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"*"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"/"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"%"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"|"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"&"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"<<"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},">>"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"~"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"and"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"or"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"not"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"=="),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"<="),", ",(0,r.mdx)("inlineCode",{parentName:"p"},">="),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"!="),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"<"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},">"),", the ",(0,r.mdx)("inlineCode",{parentName:"p"},"cast")," operator\nand the ",(0,r.mdx)("inlineCode",{parentName:"p"},"case")," forms.  These are enough to make a lot of very interesting expressions, all of which are envaluated at\ncompile time."),(0,r.mdx)("p",null,"While the constant folding was added to allow for rich ",(0,r.mdx)("inlineCode",{parentName:"p"},"enum")," expressions, there is also the ",(0,r.mdx)("inlineCode",{parentName:"p"},"const()")," primitive in the\nlanguage now which can appear anywhere a literal could appear.  This allows you do things that were previously not\nallowed such as:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"create table something(\n  x integer default const((1<<16)|0xf) /*  again the math is just for illustration */\n);\n")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"const")," form is also very useful in macros:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"#define SOMETHING const(12+3)\n")),(0,r.mdx)("p",null,"This form ensures that the constant will be evaluated at compile time. Const can also also nest so you can build these\nkinds of macros from other macros or you can build enums this way. Anywhere you might need literals, you can use ",(0,r.mdx)("inlineCode",{parentName:"p"},"const"),"."),(0,r.mdx)("p",null,"Importantly, no enumerated data types were added to the language to do any of this.  The values can help you to\nachieve some correctness by avoiding transcription mistakes but there is no additional type-safety provided here.\nIndeed given the rich mix between these types in SQLite, and with SQLite having no knowledge of enumerations at\nall it would be tricky to do a complete job.  Still, this might happen in the future."),(0,r.mdx)("p",null,"But for now, declaring constants that are really an intimate part of your schema is now possible and the addition\nof the constants to the ",(0,r.mdx)("inlineCode",{parentName:"p"},".h")," files and the ",(0,r.mdx)("inlineCode",{parentName:"p"},".json")," output should hopefully make these generally useful.  At least\nwe might see less of the hard-coded constant business with good values baked right into the schema declarations."),(0,r.mdx)("p",null,"Happy Holidays."))}c.isMDXComponent=!0}}]);