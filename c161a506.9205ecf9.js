(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{130:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return u}));var a=n(2),i=n(6),r=(n(0),n(162)),l=["components"],o={id:"ch13",title:"Chapter 13: JSON Output",sidebar_label:"Chapter 13: JSON Output"},s={unversionedId:"ch13",id:"ch13",isDocsHomePage:!1,title:"Chapter 13: JSON Output",description:"\x3c!---",source:"@site/../CQL_Guide/ch13.md",slug:"/ch13",permalink:"/cql-guide/ch13",version:"current",lastUpdatedBy:"Artur Kotyrba",lastUpdatedAt:1652725956,sidebar_label:"Chapter 13: JSON Output",sidebar:"someSidebar",previous:{title:"Chapter 12: Testability Features",permalink:"/cql-guide/ch12"},next:{title:"Chapter 14: CQL Query Fragments",permalink:"/cql-guide/ch14"}},b=[],c={rightToc:b};function u(e){var t=e.components,n=Object(i.a)(e,l);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,'To help facilitate additional tools that might want to depend on CQL input files further down the toolchain, CQL includes a JSON output format for SQL DDL as well as stored procedure information, including special information for a single-statement DML.  "Single-statement DML" refers to those stored procedures that consist of a single ',Object(r.b)("inlineCode",{parentName:"p"},"insert"),", ",Object(r.b)("inlineCode",{parentName:"p"},"select"),", ",Object(r.b)("inlineCode",{parentName:"p"},"update"),", or ",Object(r.b)("inlineCode",{parentName:"p"},"delete"),".   Even though such procedures comprise just one statement, good argument binding can create very powerful DML fragments that are re-usable.  Many CQL stored procedures are of this form (in practice maybe 95% are just one statement.)"),Object(r.b)("p",null,"To use CQL in this fashion, the sequence will be something like the below.  See Appendix 1 for command line details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"cql --in input.sql --rt json_schema --cg out.json\n")),Object(r.b)("p",null,"The output contains many different sections for the various types of entities that CQL can process.  There is a full description of\nthe possible outputs available at ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/json-diagram"},"https://cgsql.dev/json-diagram"),"."),Object(r.b)("p",null,"In the balance of this chapter we'll deal with the contents of the sections and their meaning rather than the specifics of the format,\nwhich are better described with the grammar above."),Object(r.b)("h4",{id:"tables"},"Tables"),Object(r.b)("p",null,'The "tables" section has zero or more tables, each table is comprised of these fields:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the table name"),Object(r.b)("li",{parentName:"ul"},"crc : the schema CRC for the entire table definition, including columns and constraints"),Object(r.b)("li",{parentName:"ul"},"isTemp : true if this is a temporary table"),Object(r.b)("li",{parentName:"ul"},'ifNotExists : true if the table was created with "if not exists"'),Object(r.b)("li",{parentName:"ul"},'withoutRowid : true if the table was created using "without rowid"'),Object(r.b)("li",{parentName:"ul"},"isAdded : true if the table has an @create directive",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"addedVersion : optional, the schema version number in the @create directive"))),Object(r.b)("li",{parentName:"ul"},"isDeleted : true if the table was marked with @delete or is currently ",Object(r.b)("em",{parentName:"li"},"unsubscribed"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"deletedVersion : optional, the schema version number in the @delete directive"))),Object(r.b)("li",{parentName:"ul"},"isRecreated : true if the table is marked with @recreate",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"recreateGroupName : optional, if the @recreate attribute specifies a group name, it is present here"))),Object(r.b)("li",{parentName:"ul"},"unsubscribedVersion : optional, if the table was last unsubscribed, the version number when this happened"),Object(r.b)("li",{parentName:"ul"},"resubscribedVersion : optional, if the table was last resubscribed, the version number when this happened"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},"indices : optional, a list of the names of the indices on this table, see the indices section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"columns")," : an array of column definitions, see the section on columns"),Object(r.b)("li",{parentName:"ul"},"primaryKey : a list of column names, possibly empty if no primary key"),Object(r.b)("li",{parentName:"ul"},"primaryKeySortOrders : a list of corresponding sort orders, possibly empty, for each column of the primary key if specified"),Object(r.b)("li",{parentName:"ul"},"primaryKeyName : optional, the name of the primary key, if it has one"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"foreignKeys")," : a list of foreign keys for this table, possibly empty, see the foreign keys section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"uniqueKeys")," : a list of unique keys for this table, possibly empty, see the unique keys section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"checkExpressions")," : a list of check expressions for this table, possibly empty, see the check expression section")),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"@attribute(an_attribute=(1,('foo', 'bar')))\nCREATE TABLE foo(\n  id INTEGER,\n  name TEXT\n);\n")),Object(r.b)("p",null,"generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "foo",\n      "CRC" : "-1869326768060696459",\n      "isTemp" : 0,\n      "ifNotExists" : 0,\n      "withoutRowid" : 0,\n      "isAdded" : 0,\n      "isDeleted" : 0,\n      "isRecreated": 0,\n      "indices" : [ "foo_name" ],\n      "attributes" : [\n        {\n          "name" : "an_attribute",\n          "value" : [1, ["foo", "bar"]]\n        }\n      ],\n      "columns" : [\n        {\n          "name" : "id",\n          "type" : "integer",\n          "isNotNull" : 0,\n          "isAdded" : 0,\n          "isDeleted" : 0,\n          "isPrimaryKey" : 0,\n          "isUniqueKey" : 0,\n          "isAutoIncrement" : 0\n        },\n        {\n          "name" : "name",\n          "type" : "text",\n          "isNotNull" : 0,\n          "isAdded" : 0,\n          "isDeleted" : 0,\n          "isPrimaryKey" : 0,\n          "isUniqueKey" : 0,\n          "isAutoIncrement" : 0\n        }\n      ],\n      "primaryKey" : [  ],\n      "primaryKeySortOrders" : [  ],\n      "foreignKeys" : [\n      ],\n      "uniqueKeys" : [\n      ],\n      "checkExpressions" : [\n      ]\n    }\n')),Object(r.b)("h4",{id:"region-information"},"Region Information"),Object(r.b)("p",null,"Region Information can appear on many entities, it consists of two optional elements:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"region : optional, the name of the region in which the entity was defined"),Object(r.b)("li",{parentName:"ul"},"deployedInRegion : optional, the deployment region in which that region is located")),Object(r.b)("h4",{id:"attributes"},"Attributes"),Object(r.b)("p",null,"Miscelleaneous attributes can be present on virtual every kind of entity.  They are optional.  The root node\nintroduces the attributes:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"attributes : a list at least one attribute")),Object(r.b)("p",null,"Each attribute is a name and value pair:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : any string",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},'attribute names are often compound like "cql:shared_fragment"'),Object(r.b)("li",{parentName:"ul"},"they are otherwise simple identifiers"))),Object(r.b)("li",{parentName:"ul"},"value : any ",Object(r.b)("em",{parentName:"li"},"attribute value"))),Object(r.b)("p",null,"Each ",Object(r.b)("em",{parentName:"p"},"attribute value")," can be:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"any literal"),Object(r.b)("li",{parentName:"ul"},"an array of ",Object(r.b)("em",{parentName:"li"},"attribute values"))),Object(r.b)("p",null,"Since the ",Object(r.b)("em",{parentName:"p"},"attribute values")," can nest its possible to represent arbitrarily complex data types in an attribute.  You can even represent a LISP program."),Object(r.b)("h4",{id:"foreign-keys"},"Foreign Keys"),Object(r.b)("p",null,"Foreign keys appear only in tables, the list of keys contains zero or more entries of this form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : optional, the name of the foreign key if specified"),Object(r.b)("li",{parentName:"ul"},'columns : the names of the constrained columns in the current table (the "child" table)'),Object(r.b)("li",{parentName:"ul"},"referenceTable : the name of the table that came after REFERENCES in the foreign key"),Object(r.b)("li",{parentName:"ul"},"referenceColumns : the constraining columns in the referenced table"),Object(r.b)("li",{parentName:"ul"},'onUpdate : the ON UPDATE action (e.g. "CASCADE", "NO ACTION", etc.)'),Object(r.b)("li",{parentName:"ul"},'onDelete : the ON DELETE action (e.g. "CASCADE", "NO ACTION", etc.)'),Object(r.b)("li",{parentName:"ul"},"isDeferred : boolean, indicating the deferred or not deferred setting for this foreign key")),Object(r.b)("h4",{id:"unique-keys"},"Unique Keys"),Object(r.b)("p",null,"Unique keys appear only in tables, the list of keys contains zero or more entries of this form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : optional, the name of the unique key if specified"),Object(r.b)("li",{parentName:"ul"},"columns: a list of 1 or more contrained column names"),Object(r.b)("li",{parentName:"ul"},"sortOrders: a list of corresponding sort orders for the columns")),Object(r.b)("h4",{id:"check-expressions"},"Check Expressions"),Object(r.b)("p",null,"Check Expressions appear only in tables, the list of keys contains zero or more entries of this form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : optional, the name of the unique key if specified"),Object(r.b)("li",{parentName:"ul"},"checkExpr : the check expression in plain text"),Object(r.b)("li",{parentName:"ul"},"checkExprArgs: an array of zero or more local variables that should be bound to the ",Object(r.b)("inlineCode",{parentName:"li"},"?")," items in the check expression")),Object(r.b)("p",null,"The checkExprArgs will almost certainly be the empty list ",Object(r.b)("inlineCode",{parentName:"p"},"[]"),".  In the exceedingly rare situation that the table\nin question was defined in a procedure and some of parts of the check expression were arguments to that procedure\nthen the check expression is not fully known until that procedure runs and some of its literals will be decided\nat run time.  This is an extraordinary choice but technically possible."),Object(r.b)("h4",{id:"columns"},"Columns"),Object(r.b)("p",null,"Columns are themselves rather complex, there are 1 or more of them in each table.  The table will have\na list of records of this form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the columns"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},"type : the column type (e.g. bool, real, text, etc.)"),Object(r.b)("li",{parentName:"ul"},"kind : optional, if the type is qualified by a discriminator such as int<task_id> it appears here"),Object(r.b)("li",{parentName:"ul"},"isSensitive : optional, indicates a column that holds sensitive information such as PII"),Object(r.b)("li",{parentName:"ul"},"isNotNull : true if the column is not null"),Object(r.b)("li",{parentName:"ul"},"isAdded : true if the column has an @create directive",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"addedVersion : optional, the schema version number in the @create directive"))),Object(r.b)("li",{parentName:"ul"},"isDeleted : true if the column was marked with @delete",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"deletedVersion : optional, the schema version number in the @delete directive"))),Object(r.b)("li",{parentName:"ul"},"defaultValue : optional, can be any literal, the default value of the column"),Object(r.b)("li",{parentName:"ul"},"collate : optional, the collation string (e.g. nocase)"),Object(r.b)("li",{parentName:"ul"},"checkExpr : optional, the ",Object(r.b)("em",{parentName:"li"},"check expression")," for this column (see the related section)"),Object(r.b)("li",{parentName:"ul"},"isPrimaryKey : true if the column was marked with PRIMARY KEY"),Object(r.b)("li",{parentName:"ul"},"isUniqueKey : true if the column was marked with UNIQUE"),Object(r.b)("li",{parentName:"ul"},"isAutoIncrement : true if the column was marked with AUTOINCREMENT")),Object(r.b)("h4",{id:"virtual-tables"},"Virtual Tables"),Object(r.b)("p",null,'The "virtualTables" section is very similar to the "tables" section with zero or more virtual table entries.\nVirtual table entries are the same as table entries with the following additions:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"module : the name of the module that manages this virtual table"),Object(r.b)("li",{parentName:"ul"},"isEponymous : true if the virtual table was declared eponymous"),Object(r.b)("li",{parentName:"ul"},"isVirtual : always true for virtual tables")),Object(r.b)("p",null,"The JSON schema for these items was designed to be as similar as possible so that typically the same code can handle both\nwith possibly a few extra tests of the isVirtual field."),Object(r.b)("h4",{id:"views"},"Views"),Object(r.b)("p",null,"The views section contains the list of all views in the schema, it is zero or more view entires of this form."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the view name"),Object(r.b)("li",{parentName:"ul"},"crc : the schema CRC for the entire view definition"),Object(r.b)("li",{parentName:"ul"},"isTemp : true if this is a temporary view"),Object(r.b)("li",{parentName:"ul"},"isDeleted : true if the view was marked with @delete",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"deletedVersion : optional, the schema version number in the @delete directive"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"columns")," : an array of column definitions, see the section on columns"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"projection")," : an array of projected columns from the view, the view result if you will, see the section on projections"),Object(r.b)("li",{parentName:"ul"},"select : the text of the select statement that defined the view"),Object(r.b)("li",{parentName:"ul"},'selectArgs : the names of arguments any unbound expressions ("?") in the view'),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"dependencies")," : several lists of tables and how they are used in the view, see the section on dependencies")),Object(r.b)("p",null,"Note that the use of unbound expressions in a view truly extraordinary so selectArgs is essentially always going to be an empty list."),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"CREATE VIEW MyView AS\nSELECT *\n  FROM foo\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "MyView",\n      "CRC" : "5545408966671198580",\n      "isTemp" : 0,\n      "isDeleted" : 0,\n      "projection" : [\n        {\n          "name" : "id",\n          "type" : "integer",\n          "isNotNull" : 0\n        },\n        {\n          "name" : "name",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "select" : "SELECT id, name FROM foo",\n      "selectArgs" : [  ],\n      "fromTables" : [ "foo" ],\n      "usesTables" : [ "foo" ]\n    }\n')),Object(r.b)("h4",{id:"projections"},"Projections"),Object(r.b)("p",null,"A projection defines the output shape of something that can return a table-like value such as a view or a procedure."),Object(r.b)("p",null,"The projection consists of a list of one or more ",Object(r.b)("em",{parentName:"p"},"projected columns"),", each of which is:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'name : the name of the result column  (e.g. in select 2 as foo) the name is "foo"'),Object(r.b)("li",{parentName:"ul"},"type : the type of the column (e.g. text, real, etc.)"),Object(r.b)("li",{parentName:"ul"},"kind : optional, the discriminator of the type if it has one (e.g. if the result is an ",Object(r.b)("inlineCode",{parentName:"li"},"int<job_id>"),' the kind is "job_id")'),Object(r.b)("li",{parentName:"ul"},"isSensitive : optional, true if the result is sensitive (e.g. PII or something like that)"),Object(r.b)("li",{parentName:"ul"},"isNotNull : true if the result is known to be not null")),Object(r.b)("h4",{id:"dependencies"},"Dependencies"),Object(r.b)("p",null,"The dependencies section appears in many entities, it indicates things that were used by the object and how they were used.\nMost of the fields are optional, some fields are impossible in some contexts (e.g. inserts can happen inside of views)."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"insertTables : optional, a list of tables into which values were inserted"),Object(r.b)("li",{parentName:"ul"},"updateTables : optional, a list of tables whose values were updated"),Object(r.b)("li",{parentName:"ul"},"deleteTables : optional, a list of tables which had rows deleted"),Object(r.b)("li",{parentName:"ul"},"fromTables : optional, a list of tables that appeared in a FROM clause (maybe indirectly inside a VIEW or CTE)"),Object(r.b)("li",{parentName:"ul"},"usesProcedures : optional, a list of procedures that were accessed via CALL (not shared fragments, those are inlined)"),Object(r.b)("li",{parentName:"ul"},"usesViews : optional, a list of views which were accessed (these are recursively visited to get to tables)"),Object(r.b)("li",{parentName:"ul"},"usesTables : the list of tables that were used in any way at all by the current entity (i.e. the union of the previous table sections)")),Object(r.b)("h4",{id:"indices"},"Indices"),Object(r.b)("p",null,"The indices section contains the list of all indices in the schema, it is zero or more view entires of this form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the index name"),Object(r.b)("li",{parentName:"ul"},"crc : the schema CRC for the entire index definition"),Object(r.b)("li",{parentName:"ul"},"table : the name of the table with this index"),Object(r.b)("li",{parentName:"ul"},"isUnique : true if this is a unique index"),Object(r.b)("li",{parentName:"ul"},"ifNotExists : true if this index was created with IF NOT EXISTS"),Object(r.b)("li",{parentName:"ul"},"isDeleted : true if the view was marked with @delete",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"deletedVersion : optional, the schema version number in the @delete directive"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},"where : optional, if this is partial index then this has the partial index where expression"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},"columns : the list of column names in the index"),Object(r.b)("li",{parentName:"ul"},"sortOrders : the list of corresponding sort orders")),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"create index foo_name on foo(name);\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "foo_name",\n      "CRC" : "6055860615770061843",\n      "table" : "foo",\n      "isUnique" : 0,\n      "ifNotExists" : 0,\n      "isDeleted" : 0,\n      "columns" : [ "name" ],\n      "sortOrders" : [ "" ]\n    }\n\n')),Object(r.b)("h4",{id:"procedures"},"Procedures"),Object(r.b)("p",null,"The next several sections:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Queries"),Object(r.b)("li",{parentName:"ul"},"Inserts"),Object(r.b)("li",{parentName:"ul"},"General Inserts"),Object(r.b)("li",{parentName:"ul"},"Updates"),Object(r.b)("li",{parentName:"ul"},"Deletes"),Object(r.b)("li",{parentName:"ul"},"General")),Object(r.b)("p",null,'All provide information about various types of procedures.  Some "simple" procedures that consist only of the type of statement\ncorresond to their section (and some other rules) present additional information about their contents.  This can sometimes\nbe useful.  All the sections define certain common things about procedures so that basic information is available about\nall procedures.  This is is basically the contents of the "general" section which deals with procedures that have a complex\nbody of which little can be said.'),Object(r.b)("h4",{id:"queries"},"Queries"),Object(r.b)("p",null,"The queries section corresponds to the stored procedures that are a single SELECT statement with no fragments."),Object(r.b)("p",null,"The fields of a query record are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the procedure"),Object(r.b)("li",{parentName:"ul"},"definedInFile : the file that contains the procedure (the path is as it was specified to CQL so it might be relative or absolute)"),Object(r.b)("li",{parentName:"ul"},"args : ",Object(r.b)("em",{parentName:"li"},"procedure arguments")," see the relevant section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"dependencies")," : several lists of tables and how they are used in the view, see the section on dependencies"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"projection")," : an array of projected columns from the procedure, the view if you will, see the section on projections"),Object(r.b)("li",{parentName:"ul"},"statement : the text of the select statement that is the body of the procedure"),Object(r.b)("li",{parentName:"ul"},'statementArgs : a list of procedure arguments (possibly empty) that should be used to replace the corresonding "?" parameters in the statement')),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"create proc p(name_ text)\nbegin\n  select * from foo where name = name_;\nend;\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "p",\n      "definedInFile" : "x",\n      "args" : [\n        {\n          "name" : "name_",\n          "argOrigin" : "name_",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "fromTables" : [ "foo" ],\n      "usesTables" : [ "foo" ],\n      "projection" : [\n        {\n          "name" : "id",\n          "type" : "integer",\n          "isNotNull" : 0\n        },\n        {\n          "name" : "name",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "statement" : "SELECT id, name FROM foo WHERE name = ?",\n      "statementArgs" : [ "name_" ]\n    }\n')),Object(r.b)("h4",{id:"procedure-arguments"},"Procedure Arguments"),Object(r.b)("p",null,"Procedure arguments have several generalities that don't come up very often but are important to describe.  The argument list\nof a procedure is 0 or more arguments of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the argument name, any valid identifier"),Object(r.b)("li",{parentName:"ul"},"argOrigin : either the name repeated if it's just a name or a 3 part string if it came from a bundle, see below"),Object(r.b)("li",{parentName:"ul"},"type : the type of the argument (e.g. text, real, etc.)"),Object(r.b)("li",{parentName:"ul"},"kind : optional, the descriminated type if any e.g. in ",Object(r.b)("inlineCode",{parentName:"li"},"int<job_id>"),' it\'s "job_id"'),Object(r.b)("li",{parentName:"ul"},"isSensitive : optional, true if the argument is marked with @sensitive (e.g. it has PII etc.)"),Object(r.b)("li",{parentName:"ul"},"isNotNull : true if the argument is declared not null")),Object(r.b)("p",null,"An example of a simple argumenmt was shown above, if we change the example a little bit to use the argument bundle syntax\n(even though it's overkill) we can see the general form of argOrigin."),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"create proc p(a_foo like foo)\nbegin\n  select * from foo where name = a_foo.name or id = a_foo.id;\nend;\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "p",\n      "definedInFile" : "x",\n      "args" : [\n        {\n          "name" : "a_foo_id",\n          "argOrigin" : "a_foo foo id",\n          "type" : "integer",\n          "isNotNull" : 0\n        },\n        {\n          "name" : "a_foo_name",\n          "argOrigin" : "a_foo foo name",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "fromTables" : [ "foo" ],\n      "usesTables" : [ "foo" ],\n      "projection" : [\n        {\n          "name" : "id",\n          "type" : "integer",\n          "isNotNull" : 0\n        },\n        {\n          "name" : "name",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "statement" : "SELECT id, name FROM foo WHERE name = ? OR id = ?",\n      "statementArgs" : [ "a_foo_name", "a_foo_id" ]\n    }\n')),Object(r.b)("p",null,"Note the synthetic names ",Object(r.b)("inlineCode",{parentName:"p"},"a_foo_id")," and ",Object(r.b)("inlineCode",{parentName:"p"},"a_foo_name")," the argOrigin indicates that the bundle name is ",Object(r.b)("inlineCode",{parentName:"p"},"a_foo"),"\nwhich could have been anything, the shape was ",Object(r.b)("inlineCode",{parentName:"p"},"foo")," and the column in ",Object(r.b)("inlineCode",{parentName:"p"},"foo")," was ",Object(r.b)("inlineCode",{parentName:"p"},"id")," or ",Object(r.b)("inlineCode",{parentName:"p"},"name")," as appropriate."),Object(r.b)("p",null,"The JSON is often used to generate glue code to call procedures from different languages.  The argOrigin can be useful if\nyou want to codegen something other normal arguments in your code."),Object(r.b)("h4",{id:"general-inserts"},"General Inserts"),Object(r.b)("p",null,"The general insert section corresponds to the stored procedures that are a single INSERT statement with no fragments.\nThe fields of a general insert record are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the procedure"),Object(r.b)("li",{parentName:"ul"},"definedInFile : the file that contains the procedure (the path is as it was specified to CQL so it might be relative or absolute)"),Object(r.b)("li",{parentName:"ul"},"args : ",Object(r.b)("em",{parentName:"li"},"procedure arguments")," see the relevant section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"dependencies")," : several lists of tables and how they are used in the view, see the section on dependencies"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},"table : the name of the table the procedure inserts into"),Object(r.b)("li",{parentName:"ul"},"statement : the text of the select statement that is the body of the procedure"),Object(r.b)("li",{parentName:"ul"},'statementArgs : a list of procedure arguments (possibly empty) that should be used to replace the corresonding "?" parameters in the statement'),Object(r.b)("li",{parentName:"ul"},'statementType : there are several insert forms such as "INSERT", "INSERT OR REPLACE", "REPLACE", etc.  the type is encoded here')),Object(r.b)("p",null,"General inserts does not include the inserted values because they are not directly extractable in general.  This form is used if one of\nthese is true:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"insert from multiple value rows"),Object(r.b)("li",{parentName:"ul"},"insert from a select statement"),Object(r.b)("li",{parentName:"ul"},"insert using a ",Object(r.b)("inlineCode",{parentName:"li"},"WITH")," clause"),Object(r.b)("li",{parentName:"ul"},"insert using the upsert clause")),Object(r.b)("p",null,'If fragments are in use then even "generalInsert" cannot capture everything and "general" must be used (see below).'),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},'create proc p()\nbegin\n  insert into foo values (1, "foo"), (2, "bar");\nend;\n')),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "p",\n      "definedInFile" : "x",\n      "args" : [\n      ],\n      "insertTables" : [ "foo" ],\n      "usesTables" : [ "foo" ],\n      "table" : "foo",\n      "statement" : "INSERT INTO foo(id, name) VALUES(1, \'foo\'), (2, \'bar\')",\n      "statementArgs" : [  ],\n      "statementType" : "INSERT",\n      "columns" : [ "id", "name" ]\n    }\n')),Object(r.b)("h4",{id:"simple-inserts"},"Simple Inserts"),Object(r.b)("p",null,'The vanilla inserts section can be used for procedures that just insert a single row.  This is a\nvery common case and if the JSON is being used to drive custom code generation it is useful\nto provide the extra information.  The data in this section is exactly the same as the General Inserts\nsection except that includes the inserted values.  The "values" property has this extra information.'),Object(r.b)("p",null,"Each value in the values list corresponds 1:1 with a column and has this form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"value : the expression for this value"),Object(r.b)("li",{parentName:"ul"},'valueArgs: the array of procedure arguments that should replace the "?" entries in the value')),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"create proc p(like foo)\nbegin\n  insert into foo from arguments;\nend;\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "p",\n      "definedInFile" : "x",\n      "args" : [\n        {\n          "name" : "id_",\n          "argOrigin" : "foo id",\n          "type" : "integer",\n          "isNotNull" : 0\n        },\n        {\n          "name" : "name_",\n          "argOrigin" : "foo name",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "insertTables" : [ "foo" ],\n      "usesTables" : [ "foo" ],\n      "table" : "foo",\n      "statement" : "INSERT INTO foo(id, name) VALUES(?, ?)",\n      "statementArgs" : [ "id_", "name_" ],\n      "statementType" : "INSERT",\n      "columns" : [ "id", "name" ],\n      "values" : [\n        {\n          "value" : "?",\n          "valueArgs" : [ "id_" ]\n        },\n        {\n          "value" : "?",\n          "valueArgs" : [ "name_" ]\n        }\n      ]\n    }\n')),Object(r.b)("h4",{id:"updates"},"Updates"),Object(r.b)("p",null,"The updates section corresponds to the stored procedures that are a single UPDATE statement with no fragments. The\nfields of an update record are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the procedure"),Object(r.b)("li",{parentName:"ul"},"definedInFile : the file that contains the procedure (the path is as it was specified to CQL so it might be relative or absolute)"),Object(r.b)("li",{parentName:"ul"},"args : ",Object(r.b)("em",{parentName:"li"},"procedure arguments")," see the relevant section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"dependencies")," : several lists of tables and how they are used in the view, see the section on dependencies"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},"table : the name of the table the procedure inserts into"),Object(r.b)("li",{parentName:"ul"},"statement : the text of the update statement that is the body of the procedure"),Object(r.b)("li",{parentName:"ul"},'statementArgs : a list of procedure arguments (possibly empty) that should be used to replace the corresonding "?" parameters in the statement')),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"create proc p(like foo)\nbegin\n  update foo set name = name_ where id = id_;\nend;\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "p",\n      "definedInFile" : "x",\n      "args" : [\n        {\n          "name" : "id_",\n          "argOrigin" : "foo id",\n          "type" : "integer",\n          "isNotNull" : 0\n        },\n        {\n          "name" : "name_",\n          "argOrigin" : "foo name",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "updateTables" : [ "foo" ],\n      "usesTables" : [ "foo" ],\n      "table" : "foo",\n      "statement" : "UPDATE foo SET name = ? WHERE id = ?",\n      "statementArgs" : [ "name_", "id_" ]\n    }\n')),Object(r.b)("h4",{id:"deletes"},"Deletes"),Object(r.b)("p",null,"The deletes section corresponds to the stored procedures that are a single DELETE statement with no fragments. The\nfields of a delete record are exactly the same as those of update.  Those are the basic fields needed to bind any\nstatement."),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"create proc delete_proc (name_ text)\nbegin\n  delete from foo where name like name_;\nend;\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "delete_proc",\n      "definedInFile" : "x",\n      "args" : [\n        {\n          "name" : "name_",\n          "argOrigin" : "name_",\n          "type" : "text",\n          "isNotNull" : 0\n        }\n      ],\n      "deleteTables" : [ "foo" ],\n      "usesTables" : [ "foo" ],\n      "table" : "foo",\n      "statement" : "DELETE FROM foo WHERE name LIKE ?",\n      "statementArgs" : [ "name_" ]\n    }\n')),Object(r.b)("h4",{id:"general"},"General"),Object(r.b)("p",null,"And finally the section for procedures that were encountered that are not one of the simple prepared statement forms.  The principle reasons for being in this category are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"the procedure has out arguments"),Object(r.b)("li",{parentName:"ul"},"the procedure uses something other than a single DML statement"),Object(r.b)("li",{parentName:"ul"},"the procedure has no projection (no result of any type)"),Object(r.b)("li",{parentName:"ul"},"the procedure uses shared fragments and hence has complex argument binding")),Object(r.b)("p",null,"The fields of a general procedure are something like a union of update and delete and query but with no statement info.  The are\nas follows:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the procedure"),Object(r.b)("li",{parentName:"ul"},"definedInFile : the file that contains the procedure (the path is as it was specified to CQL so it might be relative or absolute)"),Object(r.b)("li",{parentName:"ul"},"args : ",Object(r.b)("em",{parentName:"li"},"complex procedure arguments")," see the relevant section"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"dependencies")," : several lists of tables and how they are used in the view, see the section on dependencies"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"region information")," : optional, see the section on Region Info"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"projection")," : optional, an array of projected columns from the procedure, the view if you will, see the section on projections"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"result_contract")," : optional,"),Object(r.b)("li",{parentName:"ul"},"table : the name of the table the procedure inserts into"),Object(r.b)("li",{parentName:"ul"},"statement : the text of the update statement that is the body of the procedure"),Object(r.b)("li",{parentName:"ul"},'statementArgs : a list of procedure arguments (possibly empty) that should be used to replace the corresonding "?" parameters in the statement'),Object(r.b)("li",{parentName:"ul"},"usesDatabase : true if the procedure requires you to pass in a sqlite connection to call it")),Object(r.b)("p",null,"The result contract is at most one of these:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"hasSelectResult : true if the procedure generates its projection using SELECT"),Object(r.b)("li",{parentName:"ul"},"hasOutResult: true if the procedure generates its projection using OUT"),Object(r.b)("li",{parentName:"ul"},"hasOutUnionResult: true if the procedure generates its projection using OUT UNION")),Object(r.b)("p",null,"A procedure that does not produce a result set in any way will set none of these and have no projection entry."),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'create proc with_complex_args (inout arg real)\nbegin\n  set arg := (select arg+1 as a);\n  select "foo" bar;\nend;\n')),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'      "name" : "with_complex_args",\n      "definedInFile" : "x",\n      "args" : [\n        {\n          "binding" : "inout",\n          "name" : "arg",\n          "argOrigin" : "arg",\n          "type" : "real",\n          "isNotNull" : 0\n        }\n      ],\n      "usesTables" : [  ],\n      "projection" : [\n        {\n          "name" : "bar",\n          "type" : "text",\n          "isNotNull" : 1\n        }\n      ],\n      "hasSelectResult" : 1,\n      "usesDatabase" : 1\n    }\n')),Object(r.b)("h4",{id:"complex-procedure-arguments"},"Complex Procedure Arguments"),Object(r.b)("p",null,'The complex form of the arguments allows for an optional "binding"'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'binding : optional, if present it can take the value "out" or "inout"'),Object(r.b)("li",{parentName:"ul"},'if absent then binding is the usual "in"')),Object(r.b)("p",null,'Note that atypical binding forces procedures into the "general" section.'),Object(r.b)("h4",{id:"regions"},"Regions"),Object(r.b)("p",null,"The regions section contains a list of all the region definitions.  Each region is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the region"),Object(r.b)("li",{parentName:"ul"},"isDeployableRoot : is this region itself a deployment region (declared with @declare_deployable_region)"),Object(r.b)("li",{parentName:"ul"},'deployedInRegion : name, the deployment region that contains this region or "(orphan)" if none',Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"note that deploymentRegions form a forest"))),Object(r.b)("li",{parentName:"ul"},"using : a list of zero or more parent regions"),Object(r.b)("li",{parentName:"ul"},"usingPrivately: a list of zero more more booleans, one corresponding to each region",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the boolean is true if the inheritance is private, meaning that sub-regions cannot see the contents of the inherited region")))),Object(r.b)("p",null,"There are more details on regions and the meaning of these terms in Chapter 10."),Object(r.b)("h4",{id:"ad-hoc-migrations"},"Ad Hoc Migrations"),Object(r.b)("p",null,"This section lists all of the declared ad hoc migrations.  Each entry is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the procedure to be called for the migration step"),Object(r.b)("li",{parentName:"ul"},"crc : the CRC of this migration step, a hash of the call"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"attributes")," : optional, see the section on attributes, they appear in many places")),Object(r.b)("p",null,"Exactly one of:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"version: optional, any positive integer, the version at which the migration runs, OR"),Object(r.b)("li",{parentName:"ul"},"onRecreateOf: optional, if present indicates that the migration runs when the indicated group is recreated")),Object(r.b)("p",null,"There are more details on ad hoc migrations in Chapter 10."),Object(r.b)("h4",{id:"enums"},"Enums"),Object(r.b)("p",null,"This section list all the enumeration types and values.  Each entry is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the enumeration"),Object(r.b)("li",{parentName:"ul"},"type : the base type of the enumeration (e.g. INT, LONG)"),Object(r.b)("li",{parentName:"ul"},'isNotNull: always true, all enum values are not null (here for symmetry with other uses of "type")'),Object(r.b)("li",{parentName:"ul"},"values: a list of legal enumeration values")),Object(r.b)("p",null,"Each enumeration value is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the value"),Object(r.b)("li",{parentName:"ul"},"value : a numeric literal")),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"declare enum an_enumeration integer ( x = 5, y = 12 );\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "an_enumeration",\n      "type" : "integer",\n      "isNotNull" : 1,\n      "values" : [\n        {\n          "name" : "x",\n          "value" : 5\n        },\n        {\n          "name" : "y",\n          "value" : 12\n        }\n      ]\n    }\n')),Object(r.b)("h4",{id:"constant-groups"},"Constant Groups"),Object(r.b)("p",null,"This section list all the constant groups and values.  Each entry is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the constant group"),Object(r.b)("li",{parentName:"ul"},"values: a list of declared constant values, this can be of mixed type")),Object(r.b)("p",null,"Each constant value is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name : the name of the constant"),Object(r.b)("li",{parentName:"ul"},"type : the base type of the constant (e.g. LONG, REAL, etc.)"),Object(r.b)("li",{parentName:"ul"},"kind : optional, the type kind of the constant (this can be set with a CAST on a literal, e.g. CAST(1 as int<job_id>))"),Object(r.b)("li",{parentName:"ul"},"isNotNull : true if the constant type is not null (which is anything but the NULL literal)"),Object(r.b)("li",{parentName:"ul"},"value : the numeric or string literal value of the constant")),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"declare const group some_constants (\n  x = cast(5 as integer<job_id>),\n  y = 12.0,\n  z = 'foo'\n);\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "name" : "some_constants",\n      "values" : [\n        {\n          "name" : "x",\n          "type" : "integer",\n          "kind" : "job_id",\n          "isNotNull" : 1,\n          "value" : 5\n        },\n        {\n          "name" : "y",\n          "type" : "real",\n          "isNotNull" : 1,\n          "value" : 1.200000e+01\n        },\n        {\n          "name" : "z",\n          "type" : "text",\n          "isNotNull" : 1,\n          "value" : "foo"\n        }\n      ]\n    }\n')),Object(r.b)("h4",{id:"subscriptions"},"Subscriptions"),Object(r.b)("p",null,"This section list all the schema subscriptions in non-decreasing order by version.  Each entry is of the form:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'type : either "unsub" or "resub"'),Object(r.b)("li",{parentName:"ul"},"table : the target of the subscription directive"),Object(r.b)("li",{parentName:"ul"},"version : the version at which this operation is to happen")),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"@unsub(10, foo);\n@resub(15, foo);\n")),Object(r.b)("p",null,"Generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'    {\n      "type" : "unsub",\n      "table" : "foo",\n      "version" : 10\n    },\n    {\n      "type" : "resub",\n      "table" : "foo",\n      "version" : 15\n    }\n')),Object(r.b)("h4",{id:"summary"},"Summary"),Object(r.b)("p",null,"These sections general provide all the information about everything that was declared in a translation unit.  Typically\nnot the full body of what was declared but its interface.  The schema information provide the core type and context\nwhile the procedure information illuminates the code that was generated and how you might call it."))}u.isMDXComponent=!0},162:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),c=function(e){var t=i.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,b=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return n?i.a.createElement(h,o(o({ref:t},b),{},{components:n})):i.a.createElement(h,o({ref:t},b))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var b=2;b<r;b++)l[b]=n[b];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);