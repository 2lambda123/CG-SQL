<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="CG/SQL RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="CG/SQL Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-44373548-49","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>


<link rel="search" type="application/opensearchdescription+xml" title="CG/SQL" href="/opensearch.xml"><title data-rh="true">Introducing Parent/Child Result Sets | CG/SQL</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://cgsql.dev/blog/parent-child"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Introducing Parent/Child Result Sets | CG/SQL"><meta data-rh="true" name="description" content="Introduction and Context"><meta data-rh="true" property="og:description" content="Introduction and Context"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-10-06T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/facebookincubator"><meta data-rh="true" property="article:tag" content="facebook,cg-sql"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://cgsql.dev/blog/parent-child"><link data-rh="true" rel="alternate" href="https://cgsql.dev/blog/parent-child" hreflang="en"><link data-rh="true" rel="alternate" href="https://cgsql.dev/blog/parent-child" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://1HF376U378-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.46cfcd93.css">
<link rel="preload" href="/assets/js/runtime~main.5025e161.js" as="script">
<link rel="preload" href="/assets/js/main.a9e34648.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><div class="announcementBar_mb4j" style="background-color:#20232a;color:#fff" role="banner"><div class="announcementBarContent_xLdY">Support Ukraine ðŸ‡ºðŸ‡¦ <a target="_blank" rel="noopener noreferrer" href="https://opensource.fb.com/support-ukraine"> Help Provide Humanitarian Aid to Ukraine</a>.</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">CG/SQL</b></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/cql-guide/int01">CQL Internals</a><a class="navbar__item navbar__link" href="/program-diagram">Railroad Diagram</a><a class="navbar__item navbar__link" href="/json-diagram">Railroad Diagram: JSON</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/schema-notes-2022">Some updates on the CQL schema upgrade system</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/parent-child">Introducing Parent/Child Result Sets</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/backed-tables">Introducing Backed Tables</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/blob-storage">Introducing Blob Storage</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/from-general">Using the FROM construct in more places</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_Ikge" itemprop="headline">Introducing Parent/Child Result Sets</h1><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2022-10-06T00:00:00.000Z" itemprop="datePublished">October 6, 2022</time> Â· <!-- -->15 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_sTYa"><div class="avatar margin-bottom--sm"><a href="https://github.com/facebookincubator" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars2.githubusercontent.com/u/69631?s=200&amp;v=4" alt="CG/SQL Team"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/facebookincubator" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">CG/SQL Team</span></a></div><small class="avatar__subtitle" itemprop="description">Maintainer of CG/SQL</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction-and-context">Introduction and Context<a class="hash-link" href="#introduction-and-context" title="Direct link to heading">â€‹</a></h2><p>There are many cases where you might want to nest one result set inside of another one.  In order to
do this ecomomically there was a great desire to be able to run a parent query and a child query and
then link the child rows to the parent rows.  One way to do this is of course to run one query for
each &quot;child&quot; but then you end up with <code>O(n)</code> child queries and if there are sub-children it would be
<code>O(n*m)</code> and so forth. What you really want to do here is something more like a join, only without
the cross-product part of the join.  Many systems have such features, sometimes they are called
&quot;chaptered rowsets&quot; but in any case there is a general need for such a thing.</p><p>We did a bunch of work in the name of Parent/Child results sets but like many goals of this kind it
caused us to ripen the CQL language in a variety of ways and its interesting to talk about those
changes.  Importantly, we wanted to be able to do work of this kind in the language while adding
the fewest new notions and basically enabling the language to express a concept like a child rowset
in the first place.</p><p>Here are some things that happened along the way that are interesting.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cursor-types-and-result-types">Cursor Types and Result Types<a class="hash-link" href="#cursor-types-and-result-types" title="Direct link to heading">â€‹</a></h2><p>One of the first problems we run into thinking about how a CQL program might express pieces of a rowset
and turn them into child results is that you need to be able to hash a row, append row data, and
extract a result set from a key.</p><p>Let&#x27;s think about that for just a second: in order to do anything at all with a child rowset,
no matter how we got such a thing, we have to be able to describe it in a type-safe way.
These objects already exist at runtime but they do not appear anywhere in the language explicitly
and that was going to have to change.</p><p>To address this we added a new object type, kind of like we did with boxed statements.  A result set
has a type that looks like this <code>object &lt;proc_name set&gt;</code>.  Here <code>proc_name</code> must the the name of a
procedure that returns a result set and the object will represent a result set with the
corresponding columns in it.</p><p>That step may seem like it&#x27;s super important but actually it&#x27;s kind of optional, it provides type-safety
but the initial versions of the feature just used the type <code>object</code> which works fine provided you make
no mistakes... it turns out there are even more fundamental needs that aren&#x27;t optional.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="creating-new-cursor-types-from-existing-cursor-types">Creating New Cursor Types From Existing Cursor Types<a class="hash-link" href="#creating-new-cursor-types-from-existing-cursor-types" title="Direct link to heading">â€‹</a></h2><p>The first thing you need to be able to to is take the type of the parent query and add to it one
more columns to whole the child result set or sets (note that you can have more than one child
result set per parent).  So for instance you might have a list of people, and one child result might
be the names of the schools they attended and another is the names of the jobs they worked.</p><p>So while adding columns to existing rows might sound like a bizarre thing to do but actually it&#x27;s
actually fundamental to the job here.  We must be able to create a new output row is that is the
sames as the parent but includes columns for the the child results too.  There was no good syntax for this.
The cursor declaration forms were:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/* option 1 */ declare C cursor like shape_name;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/* option 2 */ declare C cursor like select 1 x, &quot;2&quot; y, false z;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The first option implies that you already have a shape from (e.g.) a procedure or table and you want
to make an identical cursor.  That doesn&#x27;t work here because we&#x27;re trying to modify an existing shape,
not use it as is.</p><p>The second form was supposed to be able to create any kind of cursor shape by simply declaring a <code>select</code>
statement that is an example of what you want to capture.  In principle this can define almost anything.
However, there&#x27;s a catch -- you can&#x27;t get object types to come out of a <code>select</code> so it&#x27;s hopeless for result set types.
And, maybe just as important, you can&#x27;t just add a few columns to an existing type with any kind of ease,
you have to list all columns.</p><p>Fortunately there was a pretty simple solution to this problem.  There were already lots of cases where
a typed name list happens in the language -- for example in the return type of a function you can
specify something like <code>(id integer, name text)</code>.  That construction also defines a shape just like a
select statement and there was already code to handle all the correctness analysis.  Additionally,
the <code>LIKE</code> construct can be used in such a list to refer to existing types.  So for instance a function that
returns all the columns of tables A and B could be defined like so</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare function foo() (LIKE A, LIKE B);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>So we could solve all the cursor type problems by allowing a typed name list to be used to define a cursor shape.
Probably the approach that should have been taken in the first place. The select option seems weird by comparison.</p><p>With the already existing support for shapes in a type list we could make the result shape for this parent/child case
with ease, like so:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare result cursor like (like parent, child_result object&lt;child_proc set&gt;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>So, all the parent columns plus a child result set.  Or more than one child result set if needed.</p><p>Lastly there were going to be cases where we needed to make a new cursor using only some of the field of an existing cursor.
The case in particular I&#x27;m thinking of is that we might have a big row from the parent and it might
have only one or two columns that we need that form the key columns for the child.  We didn&#x27;t have a good way to do that
either, but solving this turns out to be simple enough.  We already had this form:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare D cursor like C;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>we just added:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare D cursor like C(a, b, c);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Which chooses just the 3 named fields from <code>C</code> and makes a cursor with only those.  Recently we added
the form:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare D cursor like C(-x);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To mean take all the columns of <code>C</code> except <code>x</code></p><p>With the a shape for the key fields defined, we can use existing syntax to load the fields
economically:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">fetch D from C(like D);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Which says we want to load <code>D</code> from the fields of <code>C</code>, but using only the columns of <code>D</code>.  That operation
is of course going to be an exact type match by construction.  So now we could describe the key columns from
child rows, and the key columns from parent rows.  And we could add columns to the parent type to create space
to hold child result sets.  All of our type problems are solved.  Almost.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cursor-arguments">Cursor Arguments<a class="hash-link" href="#cursor-arguments" title="Direct link to heading">â€‹</a></h3><p>It was clear that we would need to be able to do things like &quot;hash a cursor&quot; (any cursor) or &quot;store this row
into the appropriate partition&quot; and this requirement meant that we had to be able to write functions that
could take any cursor and dynamically do things to it based on its type information.  There is no good way
to write these generic helper things in CQL, but:</p><ul><li>we don&#x27;t need very many of them,</li><li>it&#x27;s pretty easy to do that job in C</li></ul><p>The main thing we need is to create a way to declare such functions and call them a with cursor and the necessary shape info.</p><p>So we added this notion of being able to call an external function with any cursor.  Like so:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare function cursor_hash(C cursor) long not null;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>you can call it like so:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let hash := cursor_hash(C);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>where <code>C</code> is any cursor.</p><p>When such a call is made the C function <code>cursor_hash</code> gets passed what we call a &quot;dynamic cursor&quot;.
This includes:</p><ul><li>a pointer to the data for the cursor</li><li>the count of fields</li><li>the names of the fields</li><li>the type/offset of every field in the cursor</li></ul><p>So you can (e.g.) generically do the hash by applying a hash to each field and then combining all of those.
This kind of function works on any cursor and all the extra data about the shape that&#x27;s needed to make the
call is static, so really the cost of the call stays modest.  Details of the dynamic cursor type are in
<code>cqlrt_common.h</code> and there are many example functions now in the <code>cqlrt_common.c</code> file.</p><p>Again, creating this facility was a pretty minor matter, the compiler already has all this data and uses it
to create result sets in the first place.  We just allowed other functions to use that same data and
made a public type for it.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-specific-parentchild-functions">The Specific Parent/Child Functions<a class="hash-link" href="#the-specific-parentchild-functions" title="Direct link to heading">â€‹</a></h2><p>To do the parent/child operations we needed three helper functions:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE FUNC cql_partition_create ()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   CREATE OBJECT&lt;partitioning&gt; NOT NULL;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE FUNC cql_partition_cursor (</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  part OBJECT&lt;partitioning&gt; NOT NULL,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  key CURSOR,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  value CURSOR)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    BOOL NOT NULL;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE FUNC cql_extract_partition (</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  part OBJECT&lt;partitioning&gt; NOT NULL,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  key CURSOR)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CREATE OBJECT NOT NULL;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The first function makes a new partitioning.</p><p>The second function hashes the key columns of a cursor (specified by the key argument) and appends
the values provided into a bucket for that key.  By making a pass over the child rows you can easily
create a partitioning with each unique key combo having a buffer of all the matching rows.</p><p>The third function is used once the partitioning is done.  Given a key again, which you now presumably
get from the parent rows, you get the buffer you had accumulated and then make a result set out of it
and return that.  Note that this function returns the vanilla object type because it could be returning
any shape.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="result-set-sugar">Result Set Sugar<a class="hash-link" href="#result-set-sugar" title="Direct link to heading">â€‹</a></h2><p>With the type system mentioned above you could now join together any kind of complex parent and
child combo you needed, but it might be a lot of code, and it&#x27;s error prone.  This is a good job
for a little sugar.  So we added some simple syntax to specify the usual partitioning.</p><p>It looks like this:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">-- parent and child defined elsewhere</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare proc parent(x integer not null) (id integer not null, a integer, b integer);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare proc child(y integer not null) (id integer not null, u text, v text);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-- join together parent and child using &#x27;id&#x27;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">create proc parent_child(x_ integer not null, y_ integer not null)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  out union call parent(x_) join call child(y_) using (id);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The generated code is simple enough, even though there&#x27;s a good bit of it.
But it&#x27;s a useful exercise to look at it once.  Comments added for clarity.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC parent_child (x_ INTEGER NOT NULL, y_ INTEGER NOT NULL)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE __result__0 BOOL NOT NULL;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- we need a cursor to hold just the key of the child row</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE __key__0 CURSOR LIKE child(id);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- we need our partitioning object (there could be more than one per function</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- so it gets a number, likewise everything else gets a number</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  LET __partition__0 := cql_partition_create();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- we invoke the child and then iterate its rows</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE __child_cursor__0 CURSOR FOR CALL child(y_);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH __child_cursor__0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    -- we extract just the key fields (id in this case)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH __key__0(id) FROM VALUES(__child_cursor__0.id);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    -- we add this child to the partition using its key</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    SET __result__0 := cql_partition_cursor(__partition__0, __key__0, __child_cursor__0);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- we need a shape for our result, it is the columns of the parent plus the child rowset</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE __out_cursor__0 CURSOR LIKE (id INTEGER NOT NULL, a INTEGER, b INTEGER,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                       child1 OBJECT&lt;child SET&gt; NOT NULL);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- now we call the parent and iterate it</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE __parent__0 CURSOR FOR CALL parent(x_);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH __parent__0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    -- we load the key values out of the parent this time, same key fields</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH __key__0(id) FROM VALUES(__parent__0.id);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    -- now we create a result row using the parent columns and the child result set</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH __out_cursor__0(id, a, b, child1) FROM VALUES(__parent__0.id, __parent__0.a, __parent__0.b, cql_extract_partition(__partition__0, __key__0));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    -- and then we emit that row</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    OUT UNION __out_cursor__0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This code iterates the child once and the parent once and only has two database calls,
one for the child and one for the parent.  And this is enough to create parent/child result
sets for the most common examples.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="result-set-values">Result Set Values<a class="hash-link" href="#result-set-values" title="Direct link to heading">â€‹</a></h2><p>While the above is probably the most common case, another case can happen where you might
want to make a procedure call for each parent row to compute the child.  And, more generally,
there was no good way to work with result sets from procedure calls other than iterating them
with a cursor.  The iteration pattern is very good if the data is coming from a select statement
-- we don&#x27;t want to materialize all of the results if we can stream instead.  However, when working
with result sets the whole point is to create materialized results for use elsewhere.
We now had the power to express a result set type with <code>object&lt;proc_name set&gt;</code> but no way to
actually get such a set from an existing procedure.  Procedures generated them,
but they could only be consumed in the C layer.</p><p>Fortunately this is also an easy problem to solve.  We already supported the ability to use
procedures as functions in expressions if they had the right signature.  We now add the ability
to call a procedure that returns a result set and capture that result.
Previously this was not supported and would have produced an error.</p><p>With the new features you can write:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare child_result object&lt;child set&gt;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">set child_result := child(args);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or better still:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let child_result := child(args);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With this simple change we had the power to write something like this:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare proc parent(x integer not null) (id integer not null, a integer, b integer);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">declare proc child(id integer not null) (id integer not null, u text, v text);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">create proc parent_child(x_ integer not null, y_ integer not null)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- the result is like the parent with an extra column for the child</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  declare result cursor like (like parent, child object&lt;child set&gt;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  -- call the parent and loop over the results</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  declare P cursor for call parent(x_);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  loop fetch P</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     -- compute the child for each P and then emit it</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     fetch result from values(from P, child(P.id));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     out union result;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  end;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>After the sugar is applied this compiles down to this program:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC parent (x INTEGER NOT NULL) (id INTEGER NOT NULL, a INTEGER, b INTEGER);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">DECLARE PROC child (id INTEGER NOT NULL) (id INTEGER NOT NULL, u TEXT, v TEXT);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CREATE PROC parent_child (x_ INTEGER NOT NULL, y_ INTEGER NOT NULL)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">BEGIN</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE result CURSOR LIKE (id INTEGER NOT NULL, a INTEGER, b INTEGER,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                              child OBJECT&lt;child SET&gt;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DECLARE P CURSOR FOR CALL parent(x_);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  LOOP FETCH P</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  BEGIN</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    FETCH result(id, a, b, child) FROM VALUES(P.id, P.a, P.b, child(P.id));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    OUT UNION result;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  END;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">END;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>LIKE</code> and <code>FROM</code> forms are very powerful but they aren&#x27;t new.  They do make
it a lot easier to express this notion of just adding one more column to the result.
Note that the code for emitting the <code>parent_child</code> result before the transformation
doesn&#x27;t need to specify what the columns of the parent are or the columns of the child,
only that the parent has at least the <code>id</code> column.  Even that could have been removed.</p><p>This call could have been used instead:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">fetch result from values(from P, child(from P like child arguments));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That syntax would result in using the columns of P that match the arguments of <code>child</code> -- just
<code>P.id</code> in this case.  But if there were 7 such columns the sugar might be easier to understand.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="additional-language-support">Additional Language Support<a class="hash-link" href="#additional-language-support" title="Direct link to heading">â€‹</a></h2><p>Last, but not least, to make this more accessible we wanted more support in the generated code.
The C interface would have produced generic object results for the child result columns.
This isn&#x27;t wrong exactly but it would mean that a cast would be required in every use case on the
native side, and it&#x27;s easy to get the cast wrong.  So the result type of column getters was
adjusted to be a <code>child_result_set_ref</code> instead of just <code>cql_object_ref</code>.</p><p>Similar transforms were needed if column setters were being emitted (yes that&#x27;s an option!)
and of course the Java and Objective C output needed the same transform.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">â€‹</a></h2><p>The prosecution of native support for parent/child result sets in CQL resulted in a bunch of
very useful generalizations for declaring and managing cursors.  The old special case code for
blobs was actually replaced by these forms.  The language overall expressiveness increased far
more than just the ability to do this one kind of join.  It&#x27;s now possible to write general
purpose debug helpers for cursors.  It&#x27;s possible to store and return pre-cooked result sets,
creating useful caches and other such combinations.  The type extensions to allow extending
and narrowing existing types allow even more return flexibility while keeping everything
strongly typed.</p><p>Parent/Child result sets exploit all of these things.</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_u0Nl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/facebook">facebook</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/cg-sql">cg-sql</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/facebookincubator/CG-SQL/edit/master/website/blog/blog/2022-10-06-parent-child.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/schema-notes-2022"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Some updates on the CQL schema upgrade system</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/backed-tables"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Introducing Backed Tables</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction-and-context" class="table-of-contents__link toc-highlight">Introduction and Context</a></li><li><a href="#cursor-types-and-result-types" class="table-of-contents__link toc-highlight">Cursor Types and Result Types</a></li><li><a href="#creating-new-cursor-types-from-existing-cursor-types" class="table-of-contents__link toc-highlight">Creating New Cursor Types From Existing Cursor Types</a><ul><li><a href="#cursor-arguments" class="table-of-contents__link toc-highlight">Cursor Arguments</a></li></ul></li><li><a href="#the-specific-parentchild-functions" class="table-of-contents__link toc-highlight">The Specific Parent/Child Functions</a></li><li><a href="#result-set-sugar" class="table-of-contents__link toc-highlight">Result Set Sugar</a></li><li><a href="#result-set-values" class="table-of-contents__link toc-highlight">Result Set Values</a></li><li><a href="#additional-language-support" class="table-of-contents__link toc-highlight">Additional Language Support</a></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Learn</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.youtube.com/channel/UC2lTapw2Um90sZpGQVaynEg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/metaOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Legal</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_BH7S"><img src="/img/oss_logo.png" alt="Meta Platforms Open Source Logo" class="themedImage_ToTc themedImage--light_HNdA footer__logo"><img src="/img/oss_logo.png" alt="Meta Platforms Open Source Logo" class="themedImage_ToTc themedImage--dark_i4oU footer__logo"></a></div><div class="footer__copyright">Copyright Â© 2022 Meta Platforms, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5025e161.js"></script>
<script src="/assets/js/main.a9e34648.js"></script>
</body>
</html>