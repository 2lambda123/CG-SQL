/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "linetest.h"

#pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
#pragma clang diagnostic ignored "-Wshift-op-parentheses"
#pragma clang diagnostic ignored "-Wlogical-not-parentheses"
#pragma clang diagnostic ignored "-Wliteral-conversion"
cql_string_literal(_literal_1_exp_dump, "exp");
cql_string_literal(_literal_2_act_dump, "act");


//
// This file is auto-generated by linetest.sql, it is checked in just
// in case CQL is broken by a change.  The Last Known Good Verifier
// can be used to verify the tests pass again, or report failures
// while things are still otherwise broken.  Rebuild with 'make regen'
//

# 23 "linetest.sql"

// Generated from linetest.sql:37

/*
CREATE PROC linetest_setup ()
BEGIN
  CREATE TABLE linedata(
    source TEXT NOT NULL,
    procname TEXT NOT NULL,
    line INTEGER NOT NULL,
    data TEXT NOT NULL,
    physical_line INTEGER NOT NULL
  );
  CREATE TABLE procs(
    procname TEXT NOT NULL PRIMARY KEY
  );
  CREATE INDEX __idx__test_lines ON linedata (source, procname);
END;
*/

#define _PROC_ "linetest_setup"
# 23
CQL_WARN_UNUSED cql_code linetest_setup(sqlite3 *_Nonnull _db_) {
# 23
  cql_code _rc_ = SQLITE_OK;
# 25 "linetest.sql"
  _rc_ = cql_exec(_db_,
# 25
    "CREATE TABLE linedata( "
# 25
      "source TEXT NOT NULL, "
# 25
      "procname TEXT NOT NULL, "
# 25
      "line INTEGER NOT NULL, "
# 25
      "data TEXT NOT NULL, "
# 25
      "physical_line INTEGER NOT NULL "
# 25
    ")");
# 25
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 33 "linetest.sql"
  _rc_ = cql_exec(_db_,
# 33
    "CREATE TABLE procs( "
# 33
      "procname TEXT NOT NULL PRIMARY KEY "
# 33
    ")");
# 33
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 36 "linetest.sql"
  _rc_ = cql_exec(_db_,
# 36
    "CREATE INDEX __idx__test_lines ON linedata (source, procname)");
# 36
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 37 "linetest.sql"
  _rc_ = SQLITE_OK;
# 37

# 37
cql_cleanup:
# 37
  return _rc_;
# 37
}
#undef _PROC_
# 40 "linetest.sql"

// Generated from linetest.sql:44

/*
CREATE PROC linetest_add (source_ TEXT NOT NULL, procname_ TEXT NOT NULL, line_ INTEGER NOT NULL, data_ TEXT NOT NULL, physical_line_ INTEGER NOT NULL)
BEGIN
  INSERT INTO linedata(source, procname, line, data, physical_line) VALUES(source_, procname_, line_, data_, physical_line_);
  INSERT OR IGNORE INTO procs(procname) VALUES(procname_);
END;
*/

#define _PROC_ "linetest_add"
# 40
CQL_WARN_UNUSED cql_code linetest_add(sqlite3 *_Nonnull _db_, cql_string_ref _Nonnull source_, cql_string_ref _Nonnull procname_, cql_int32 line_, cql_string_ref _Nonnull data_, cql_int32 physical_line_) {
# 40
  cql_code _rc_ = SQLITE_OK;
# 40
  sqlite3_stmt *_temp_stmt = NULL;
# 40

# 42 "linetest.sql"
  _rc_ = cql_prepare(_db_, &_temp_stmt,
# 42
    "INSERT INTO linedata(source, procname, line, data, physical_line) VALUES(?, ?, ?, ?, ?)");
# 42
  cql_multibind(&_rc_, _db_, &_temp_stmt, 5,
# 42
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, source_,
# 42
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, procname_,
# 42
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line_,
# 42
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, data_,
# 42
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, physical_line_);
# 42
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 42
  _rc_ = sqlite3_step(_temp_stmt);
# 42
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 42
  cql_finalize_stmt(&_temp_stmt);
# 43 "linetest.sql"
  _rc_ = cql_prepare(_db_, &_temp_stmt,
# 43
    "INSERT OR IGNORE INTO procs(procname) VALUES(?)");
# 43
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
# 43
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, procname_);
# 43
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 43
  _rc_ = sqlite3_step(_temp_stmt);
# 43
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 43
  cql_finalize_stmt(&_temp_stmt);
# 44 "linetest.sql"
  _rc_ = SQLITE_OK;
# 44

# 44
cql_cleanup:
# 44
  cql_finalize_stmt(&_temp_stmt);
# 44
  return _rc_;
# 44
}
#undef _PROC_
# 46 "linetest.sql"

// Generated from linetest.sql:53

/*
CREATE PROC linetest_dump ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM linedata;
  LOOP FETCH C
  BEGIN
    CALL printf("%s %s %4d %3d %s\n", C.source, C.procname, C.physical_line, C.line, C.data);
  END;
END;
*/

#define _PROC_ "linetest_dump"
# 46

# 46
typedef struct linetest_dump_C_row {
# 46
  cql_bool _has_row_;
# 46
  cql_uint16 _refs_count_;
# 46
  cql_uint16 _refs_offset_;
# 46
  cql_int32 line;
# 46
  cql_int32 physical_line;
# 46
  cql_string_ref _Nonnull source;
# 46
  cql_string_ref _Nonnull procname;
# 46
  cql_string_ref _Nonnull data;
# 46
} linetest_dump_C_row;
# 46

# 46
#define linetest_dump_C_refs_offset cql_offsetof(linetest_dump_C_row, source) // count = 3
# 46
CQL_WARN_UNUSED cql_code linetest_dump(sqlite3 *_Nonnull _db_) {
# 46
  cql_code _rc_ = SQLITE_OK;
# 46
  sqlite3_stmt *C = NULL;
# 46
  linetest_dump_C_row C_ = { ._refs_count_ = 3, ._refs_offset_ = linetest_dump_C_refs_offset };
# 46

# 48 "linetest.sql"
  _rc_ = cql_prepare(_db_, &C,
# 48
    "SELECT source, procname, line, data, physical_line "
# 48
      "FROM linedata");
# 48
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 49 "linetest.sql"
  for (;;) {
# 49
    _rc_ = sqlite3_step(C);
# 49
    C_._has_row_ = _rc_ == SQLITE_ROW;
# 49
    cql_multifetch(_rc_, C, 5,
# 49
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.source,
# 49
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.procname,
# 49
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.line,
# 49
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.data,
# 49
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.physical_line);
# 49
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 49
    if (!C_._has_row_) break;
# 51 "linetest.sql"
    cql_alloc_cstr(_cstr_1, C_.source);
# 51
    cql_alloc_cstr(_cstr_2, C_.procname);
# 51
    cql_alloc_cstr(_cstr_3, C_.data);
# 51
    printf("%s %s %4d %3d %s\n", _cstr_1, _cstr_2, C_.physical_line, C_.line, _cstr_3);
# 51
    cql_free_cstr(_cstr_1, C_.source);
# 51
    cql_free_cstr(_cstr_2, C_.procname);
# 51
    cql_free_cstr(_cstr_3, C_.data);
# 51
  }
# 53 "linetest.sql"
  _rc_ = SQLITE_OK;
# 53

# 53
cql_cleanup:
# 53
  cql_finalize_stmt(&C);
# 53
  cql_teardown_row(C_);
# 53
  return _rc_;
# 53
}
#undef _PROC_
# 55 "linetest.sql"

// Generated from linetest.sql:62

/*
CREATE PROC dump_proc_records (source_ TEXT NOT NULL, procname_ TEXT NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM linedata
    WHERE procname = procname_ AND source = source_;
  LOOP FETCH C
  BEGIN
    CALL printf("%5d %s\n", C.line, C.data);
  END;
END;
*/

#define _PROC_ "dump_proc_records"
# 55

# 55
typedef struct dump_proc_records_C_row {
# 55
  cql_bool _has_row_;
# 55
  cql_uint16 _refs_count_;
# 55
  cql_uint16 _refs_offset_;
# 55
  cql_int32 line;
# 55
  cql_int32 physical_line;
# 55
  cql_string_ref _Nonnull source;
# 55
  cql_string_ref _Nonnull procname;
# 55
  cql_string_ref _Nonnull data;
# 55
} dump_proc_records_C_row;
# 55

# 55
#define dump_proc_records_C_refs_offset cql_offsetof(dump_proc_records_C_row, source) // count = 3
# 55
CQL_WARN_UNUSED cql_code dump_proc_records(sqlite3 *_Nonnull _db_, cql_string_ref _Nonnull source_, cql_string_ref _Nonnull procname_) {
# 55
  cql_code _rc_ = SQLITE_OK;
# 55
  sqlite3_stmt *C = NULL;
# 55
  dump_proc_records_C_row C_ = { ._refs_count_ = 3, ._refs_offset_ = dump_proc_records_C_refs_offset };
# 55

# 57 "linetest.sql"
  _rc_ = cql_prepare(_db_, &C,
# 57
    "SELECT source, procname, line, data, physical_line "
# 57
      "FROM linedata "
# 57
      "WHERE procname = ? AND source = ?");
# 57
  cql_multibind(&_rc_, _db_, &C, 2,
# 57
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, procname_,
# 57
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, source_);
# 57
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 58 "linetest.sql"
  for (;;) {
# 58
    _rc_ = sqlite3_step(C);
# 58
    C_._has_row_ = _rc_ == SQLITE_ROW;
# 58
    cql_multifetch(_rc_, C, 5,
# 58
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.source,
# 58
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.procname,
# 58
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.line,
# 58
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.data,
# 58
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.physical_line);
# 58
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 58
    if (!C_._has_row_) break;
# 60 "linetest.sql"
    cql_alloc_cstr(_cstr_4, C_.data);
# 60
    printf("%5d %s\n", C_.line, _cstr_4);
# 60
    cql_free_cstr(_cstr_4, C_.data);
# 60
  }
# 62 "linetest.sql"
  _rc_ = SQLITE_OK;
# 62

# 62
cql_cleanup:
# 62
  cql_finalize_stmt(&C);
# 62
  cql_teardown_row(C_);
# 62
  return _rc_;
# 62
}
#undef _PROC_
# 64 "linetest.sql"

// Generated from linetest.sql:71

/*
CREATE PROC dump (procname TEXT NOT NULL)
BEGIN
  CALL printf("%s: difference encountered\n", procname);
  CALL printf("<<<< EXPECTED\n");
  CALL dump_proc_records("exp", procname);
  CALL printf(">>>> ACTUAL\n");
  CALL dump_proc_records("act", procname);
END;
*/

#define _PROC_ "dump"
# 64
CQL_WARN_UNUSED cql_code dump(sqlite3 *_Nonnull _db_, cql_string_ref _Nonnull procname) {
# 64
  cql_code _rc_ = SQLITE_OK;
# 66 "linetest.sql"
  cql_alloc_cstr(_cstr_5, procname);
# 66
  printf("%s: difference encountered\n", _cstr_5);
# 66
  cql_free_cstr(_cstr_5, procname);
# 67 "linetest.sql"
  printf("<<<< EXPECTED\n");
# 68 "linetest.sql"
  _rc_ = dump_proc_records(_db_, _literal_1_exp_dump, procname);
# 68
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 69 "linetest.sql"
  printf(">>>> ACTUAL\n");
# 70 "linetest.sql"
  _rc_ = dump_proc_records(_db_, _literal_2_act_dump, procname);
# 70
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 71 "linetest.sql"
  _rc_ = SQLITE_OK;
# 71

# 71
cql_cleanup:
# 71
  return _rc_;
# 71
}
#undef _PROC_
# 73 "linetest.sql"

// Generated from linetest.sql:135

/*
CREATE PROC compare_lines (OUT procs INTEGER NOT NULL, OUT compares INTEGER NOT NULL, OUT errors INTEGER NOT NULL)
BEGIN
  SET compares := 0;
  SET errors := 0;
  SET procs := 0;
  DECLARE p CURSOR FOR SELECT *
    FROM procs;
  LOOP FETCH p
  BEGIN
    SET procs := procs + 1;
    DECLARE actual CURSOR FOR SELECT *
      FROM linedata
      WHERE source = 'act' AND procname = p.procname;
    DECLARE expected CURSOR FOR SELECT *
      FROM linedata
      WHERE source = 'exp' AND procname = p.procname;
    FETCH actual;
    FETCH expected;
    WHILE actual AND expected
    BEGIN
      SET compares := compares + 1;
      IF actual.line <> expected.line OR actual.data <> expected.data THEN
        CALL dump(p.procname);
        CALL printf("\nFirst difference:\n");
        CALL printf("expected: %5d %s\n", expected.line, expected.data);
        CALL printf("  actual: %5d %s\n", actual.line, actual.data);
        CALL printf("\nDifferences at:\n line %d in expected\n line %d in actual", expected.physical_line, actual.physical_line);
        CALL printf("\n");
        SET errors := errors + 1;
        LEAVE;
      END IF;
      FETCH actual;
      FETCH expected;
    END;
    IF actual <> expected THEN
      IF NOT actual THEN
        CALL dump(p.procname);
        CALL printf("\nRan out of lines in actual:\n");
        CALL printf("\nDifferences at:\n line %d in expected\n", expected.physical_line);
        CALL printf("\n");
        SET errors := errors + 1;
      END IF;
      IF NOT expected THEN
        CALL dump(p.procname);
        CALL printf("\nRan out of lines in expected:\n");
        CALL printf("\nDifferences at:\n line %d in actual\n", actual.physical_line);
        CALL printf("\n");
        SET errors := errors + 1;
      END IF;
    END IF;
  END;
END;
*/

#define _PROC_ "compare_lines"
# 73

# 73
typedef struct compare_lines_p_row {
# 73
  cql_bool _has_row_;
# 73
  cql_uint16 _refs_count_;
# 73
  cql_uint16 _refs_offset_;
# 73
  cql_string_ref _Nonnull procname;
# 73
} compare_lines_p_row;
# 73

# 73
#define compare_lines_p_refs_offset cql_offsetof(compare_lines_p_row, procname) // count = 1
# 73

# 73
typedef struct compare_lines_actual_row {
# 73
  cql_bool _has_row_;
# 73
  cql_uint16 _refs_count_;
# 73
  cql_uint16 _refs_offset_;
# 73
  cql_int32 line;
# 73
  cql_int32 physical_line;
# 73
  cql_string_ref _Nonnull source;
# 73
  cql_string_ref _Nonnull procname;
# 73
  cql_string_ref _Nonnull data;
# 73
} compare_lines_actual_row;
# 73

# 73
#define compare_lines_actual_refs_offset cql_offsetof(compare_lines_actual_row, source) // count = 3
# 73

# 73
typedef struct compare_lines_expected_row {
# 73
  cql_bool _has_row_;
# 73
  cql_uint16 _refs_count_;
# 73
  cql_uint16 _refs_offset_;
# 73
  cql_int32 line;
# 73
  cql_int32 physical_line;
# 73
  cql_string_ref _Nonnull source;
# 73
  cql_string_ref _Nonnull procname;
# 73
  cql_string_ref _Nonnull data;
# 73
} compare_lines_expected_row;
# 73

# 73
#define compare_lines_expected_refs_offset cql_offsetof(compare_lines_expected_row, source) // count = 3
# 73
CQL_WARN_UNUSED cql_code compare_lines(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull procs, cql_int32 *_Nonnull compares, cql_int32 *_Nonnull errors) {
# 73
  cql_code _rc_ = SQLITE_OK;
# 73
  sqlite3_stmt *p = NULL;
# 73
  compare_lines_p_row p_ = { ._refs_count_ = 1, ._refs_offset_ = compare_lines_p_refs_offset };
# 73
  sqlite3_stmt *actual = NULL;
# 73
  compare_lines_actual_row actual_ = { ._refs_count_ = 3, ._refs_offset_ = compare_lines_actual_refs_offset };
# 73
  sqlite3_stmt *expected = NULL;
# 73
  compare_lines_expected_row expected_ = { ._refs_count_ = 3, ._refs_offset_ = compare_lines_expected_refs_offset };
# 73

# 78 "linetest.sql"
  *compares = 0;
# 79 "linetest.sql"
  *errors = 0;
# 80 "linetest.sql"
  *procs = 0;
# 81 "linetest.sql"
  _rc_ = cql_prepare(_db_, &p,
# 81
    "SELECT procname "
# 81
      "FROM procs");
# 81
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 82 "linetest.sql"
  for (;;) {
# 82
    _rc_ = sqlite3_step(p);
# 82
    p_._has_row_ = _rc_ == SQLITE_ROW;
# 82
    cql_multifetch(_rc_, p, 1,
# 82
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &p_.procname);
# 82
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 82
    if (!p_._has_row_) break;
# 84 "linetest.sql"
    *procs = (*procs) + 1;
# 86 "linetest.sql"
    _rc_ = cql_prepare(_db_, &actual,
# 86
      "SELECT source, procname, line, data, physical_line "
# 86
        "FROM linedata "
# 86
        "WHERE source = 'act' AND procname = ?");
# 86
    cql_multibind(&_rc_, _db_, &actual, 1,
# 86
                  CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, p_.procname);
# 86
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 91 "linetest.sql"
    _rc_ = cql_prepare(_db_, &expected,
# 91
      "SELECT source, procname, line, data, physical_line "
# 91
        "FROM linedata "
# 91
        "WHERE source = 'exp' AND procname = ?");
# 91
    cql_multibind(&_rc_, _db_, &expected, 1,
# 91
                  CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, p_.procname);
# 91
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 96 "linetest.sql"
    _rc_ = sqlite3_step(actual);
# 96
    actual_._has_row_ = _rc_ == SQLITE_ROW;
# 96
    cql_multifetch(_rc_, actual, 5,
# 96
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &actual_.source,
# 96
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &actual_.procname,
# 96
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &actual_.line,
# 96
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &actual_.data,
# 96
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &actual_.physical_line);
# 96
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 97 "linetest.sql"
    _rc_ = sqlite3_step(expected);
# 97
    expected_._has_row_ = _rc_ == SQLITE_ROW;
# 97
    cql_multifetch(_rc_, expected, 5,
# 97
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &expected_.source,
# 97
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &expected_.procname,
# 97
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &expected_.line,
# 97
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &expected_.data,
# 97
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &expected_.physical_line);
# 97
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 99 "linetest.sql"
    for (;;) {
# 99
    if (!(actual_._has_row_ && expected_._has_row_)) break;
# 101 "linetest.sql"
      *compares = (*compares) + 1;
# 102 "linetest.sql"
# 103 "linetest.sql"
      if (actual_.line != expected_.line || cql_string_compare(actual_.data, expected_.data) != 0) {
# 104 "linetest.sql"
        _rc_ = dump(_db_, p_.procname);
# 104
        if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 105 "linetest.sql"
        printf("\nFirst difference:\n");
# 106 "linetest.sql"
        cql_alloc_cstr(_cstr_6, expected_.data);
# 106
        printf("expected: %5d %s\n", expected_.line, _cstr_6);
# 106
        cql_free_cstr(_cstr_6, expected_.data);
# 107 "linetest.sql"
        cql_alloc_cstr(_cstr_7, actual_.data);
# 107
        printf("  actual: %5d %s\n", actual_.line, _cstr_7);
# 107
        cql_free_cstr(_cstr_7, actual_.data);
# 108 "linetest.sql"
        printf("\nDifferences at:\n line %d in expected\n line %d in actual", expected_.physical_line, actual_.physical_line);
# 109 "linetest.sql"
        printf("\n");
# 110 "linetest.sql"
        *errors = (*errors) + 1;
# 111 "linetest.sql"
        break;
# 104 "linetest.sql"
      }
# 113 "linetest.sql"
      _rc_ = sqlite3_step(actual);
# 113
      actual_._has_row_ = _rc_ == SQLITE_ROW;
# 113
      cql_multifetch(_rc_, actual, 5,
# 113
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &actual_.source,
# 113
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &actual_.procname,
# 113
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &actual_.line,
# 113
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &actual_.data,
# 113
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &actual_.physical_line);
# 113
      if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 114 "linetest.sql"
      _rc_ = sqlite3_step(expected);
# 114
      expected_._has_row_ = _rc_ == SQLITE_ROW;
# 114
      cql_multifetch(_rc_, expected, 5,
# 114
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &expected_.source,
# 114
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &expected_.procname,
# 114
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &expected_.line,
# 114
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &expected_.data,
# 114
                     CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &expected_.physical_line);
# 114
      if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
# 114
    }
# 117 "linetest.sql"
# 117 "linetest.sql"
    if (actual_._has_row_ != expected_._has_row_) {
# 118 "linetest.sql"
# 118 "linetest.sql"
      if (! actual_._has_row_) {
# 119 "linetest.sql"
        _rc_ = dump(_db_, p_.procname);
# 119
        if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 120 "linetest.sql"
        printf("\nRan out of lines in actual:\n");
# 121 "linetest.sql"
        printf("\nDifferences at:\n line %d in expected\n", expected_.physical_line);
# 122 "linetest.sql"
        printf("\n");
# 123 "linetest.sql"
        *errors = (*errors) + 1;
# 119 "linetest.sql"
      }
# 126 "linetest.sql"
# 126 "linetest.sql"
      if (! expected_._has_row_) {
# 127 "linetest.sql"
        _rc_ = dump(_db_, p_.procname);
# 127
        if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
# 128 "linetest.sql"
        printf("\nRan out of lines in expected:\n");
# 129 "linetest.sql"
        printf("\nDifferences at:\n line %d in actual\n", actual_.physical_line);
# 130 "linetest.sql"
        printf("\n");
# 131 "linetest.sql"
        *errors = (*errors) + 1;
# 127 "linetest.sql"
      }
# 124 "linetest.sql"
    }
# 124
  }
# 135 "linetest.sql"
  _rc_ = SQLITE_OK;
# 135

# 135
cql_cleanup:
# 135
  cql_finalize_stmt(&p);
# 135
  cql_teardown_row(p_);
# 135
  cql_finalize_stmt(&actual);
# 135
  cql_teardown_row(actual_);
# 135
  cql_finalize_stmt(&expected);
# 135
  cql_teardown_row(expected_);
# 135
  return _rc_;
# 135
}
#undef _PROC_
