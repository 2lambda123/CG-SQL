<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CQL Internals</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">CQL Internals</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#cql-internals-guide-part-1">CQL Internals Guide: Part 1</a>
<ul>
<li><a href="#overview">Overview</a></li>
</ul></li>
<li><a href="#lexical-analysis-parsing-and-the-abstract-syntax-tree">Lexical Analysis, Parsing, and the Abstract Syntax Tree</a>
<ul>
<li><a href="#lexical-analysis">Lexical Analysis</a></li>
<li><a href="#parsing-and-the-abstract-syntax-tree">Parsing and the Abstract Syntax Tree</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#ast-definitions">AST definitions</a></li>
</ul></li>
<li><a href="#echoing-the-ast">Echoing the AST</a>
<ul>
<li><a href="#configuring-the-output-with-callbacks-and-flags">Configuring the Output with Callbacks and Flags</a></li>
<li><a href="#invoking-the-generator">Invoking the Generator</a></li>
<li><a href="#generator-internals">Generator Internals</a></li>
</ul></li>
<li><a href="#cql-internals-guide-part-2">CQL Internals Guide: Part 2</a>
<ul>
<li><a href="#overview-1">Overview</a></li>
</ul></li>
<li><a href="#semantic-analysis">Semantic Analysis</a>
<ul>
<li><a href="#decorated-ast-examples">Decorated AST examples</a></li>
<li><a href="#the-base-data-structures">The Base Data Structures</a></li>
<li><a href="#initiating-semantic-analysis">Initiating Semantic Analysis</a></li>
<li><a href="#semantic-errors">Semantic Errors</a></li>
<li><a href="#the-primitive-types">The Primitive Types</a></li>
<li><a href="#unary-operators">Unary Operators</a></li>
<li><a href="#binary-operators">Binary Operators</a></li>
<li><a href="#simple-statement-validation">Simple Statement Validation</a></li>
<li><a href="#expression-contexts">Expression Contexts</a></li>
<li><a href="#name-resolution">Name Resolution</a></li>
<li><a href="#structure-types-and-the-notion-of-shapes">Structure types and the notion of Shapes</a></li>
<li><a href="#join-types">Join Types</a></li>
</ul></li>
</ul>
</nav>
<!--- @generated -->
<h2 id="cql-internals-guide-part-1">CQL Internals Guide: Part 1</h2>
<!---
-- Copyright (c) Facebook, Inc. and its affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="overview">Overview</h3>
<p>The following is a summary of the implementation theory of the CQL compiler. This is an adjuct to the Guide proper, which describes the language, and to a lesser extent the code that the compiler generates.</p>
<p>The actual code is heavily commented, so it’s better to read the code to see the details of how any particular operation happens rather than try to guess from the language specification or from this overview. However, some things, like general principles, really are nowhere, or everywhere, in the codebase and its important to understand how things hang together.</p>
<p>If you choose to go on adventures in the source code, especially if you aren’t already familiar with compilers and how they are typically built, this is a good place to start.</p>
<h2 id="lexical-analysis-parsing-and-the-abstract-syntax-tree">Lexical Analysis, Parsing, and the Abstract Syntax Tree</h2>
<p>The CQL compiler uses a very standard lex+yacc parser, though to be more precise it’s flex+bison. The grammar is a large subset of the SQLite dialect of SQL augmented with control flow and compiler directives. As a consequence its a useful asset in and of itself – if you’re looking for an economical SQL grammar you could do a lot worse than start with the one CQL uses. The grammar is of course in the usual <code>.y</code> format that bison consumes but its also extracted into more readable versions for use in the railroad diagram and the documentation. Any of those sources would be a good starting place for a modest SQL project.</p>
<h3 id="lexical-analysis">Lexical Analysis</h3>
<p>Inside of <code>cql.l</code> you’ll find the formal defintion of all the lexemes. There are many that correspond to the various tokens needed to parse the SQL language. There’s no need to dicsuss the approximately 150 such tokens but the following points are of general interest:</p>
<ul>
<li>the lexer expects plain text files, and all the lexemes are defined in plain ASCII only, however
<ul>
<li>the presence of UTF8 characters in places where any text is legal (such as string literals) should just work</li>
</ul></li>
<li>all of the lexemes are case-insensitive
<ul>
<li>this means only vanilla ASCII insensitivity, no attempt is made to understand more complex code points</li>
</ul></li>
<li>multi-word lexemes typically are defined with an expression like this: <code>IS[ \t]+NOT[ \t]+FALSE/[^A-Z_]</code>
<ul>
<li>in most cases, to avoid ambiguity, and to get order of operations correct, the entire word sequence is one lexeme</li>
<li>only spaces and tabs are allowed between the words</li>
<li>the token ends on non-identifier characters, so the text “X IS NOT FALSEY” must become the lexemes { <code>X</code>, <code>IS_NOT</code>, <code>FALSEY</code> } and not { <code>X</code>, <code>IS_NOT_FALSE</code>, <code>Y</code> }
<ul>
<li>the latter would result in the longest lexeme so without the trailing qualifier and hence would be preferred, hence where a contuation is possible the trailing context must be specified in multi=word lexemes</li>
</ul></li>
<li>Note: a quick reading shows this isn’t done completely consistently and that should be fixed</li>
</ul></li>
<li>there is special processing needed to lex <code>/* ... */</code> comments correctly</li>
<li>there are token types for each of the sorts of literals that can be encountered, special care is taken to keep the literals in string form so that no precision is lost
<ul>
<li>integer literals are compared against 0x7fffffff and if greater they automatically become long literals even if they are not marekd with the trailing <code>L</code> as in <code>1L</code></li>
<li>string literals include the quotation marks in the lexeme text which distinguishes them from identifiers, they are otherwise encoded similarly</li>
</ul></li>
<li>the character class <code>[-+&amp;~|^/%*(),.;!&lt;&gt;:=]</code> produces single character tokens for identifiers, other non-matching single characters (e.g. <code>'$'</code> produce an error)</li>
<li>line directives <code>^#\ [0-9]+\ \"[^"]*\".*</code> get special processing so that pre-processed input does not lose file and line number fidelity</li>
</ul>
<h3 id="parsing-and-the-abstract-syntax-tree">Parsing and the Abstract Syntax Tree</h3>
<p>Inside of <code>cql.y</code> you will find the token declarations, precededence rules, and all of the productions in the overall grammar. The grammar processing does as little as possible in that stage to create an abstract syntax tree. AST itself is a simple binary tree; where nodes might require more than just left and right children to specify things fully, additional nodes are used in the tree shape rather than introducy n-ary nodes. This means the tree is sometimes bigger but generally not very much bigger. The benefit is that the AST can always be walked generically as a binary tree, so if you need to find all the <code>table_factor</code> nodes it is easy to do so without having to worry about how every kind of node expands. If new node types come along the generic walkers can go through those as well. All of the grammar productions simply make one or more AST nodes and link them together so that in the end there is a single root for the entire program.</p>
<p>There are 4 kinds of ast nodes, they all begin with the following 5 fields, these represent the AST base type if you like.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nonnull type<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_node <span class="op">*</span>_Nullable sem<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nullable parent<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> lineno<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nonnull filename<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>type</code> – a string literal that uniquely identifies the node type
<ul>
<li>the string literal is compared for identity (it’s an exact pointer match) you don’t <code>strcmp</code> it</li>
</ul></li>
<li><code>sem</code> – begins as <code>NULL</code> this is where the semantic type goes once semantic processing happens</li>
<li><code>parent</code> – the parent node in the AST (not often used but sometimes indispensible)</li>
<li><code>lineno</code> – the line number of the file that had the text that led to this AST (useful for errors)</li>
<li><code>filename</code> – the name of the file that had the text that led to this AST (useful for errors)
<ul>
<li>this string is durable, should not be mutated, and is shared between MANY nodes</li>
</ul></li>
</ul>
<h4 id="generic-ast-node">Generic AST node</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> ast_node <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nullable left<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nullable right<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> ast_node<span class="op">;</span></span></code></pre></div>
<p>This node gives the tree its shape, this is is how all the expression operators and statments get encoded. An example says this more clearly</p>
<pre><code>SET X := 1 + 3;

  {assign}
  | {name X}
  | {add}
    | {int 1}
    | {int 3}</code></pre>
<p>In the above “assign” and “add” are the generic nodes. Node that these can be leaves but often are not.</p>
<p>Note that in the above the node type was directly printed (because it’s a meaningful name). Likewise, the type needs no decoding when viewing the AST in a debugger. Simply printing the node with something like <code>p *ast</code> in lldb will show you all the node fields and the type in a human readable fashion.</p>
<h4 id="grammar-code-node">Grammar Code Node</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> int_ast_node <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int64_t</span> value<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> int_ast_node<span class="op">;</span></span></code></pre></div>
<p>This kind of node holds an integer that quantifies some kind of choice in the grammar. Note that this does NOT hold numeric literals (see below). The file <code>ast.h</code> includes many <code>#define</code> constants such as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>define JOIN_INNER <span class="dv">1</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>define JOIN_CROSS <span class="dv">2</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>define JOIN_LEFT_OUTER <span class="dv">3</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>define JOIN_RIGHT_OUTER <span class="dv">4</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>define JOIN_LEFT <span class="dv">5</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>define JOIN_RIGHT <span class="dv">6</span></span></code></pre></div>
<p>The integer here is one of those values. It can be a bitmask, or an enumeration. In this statement:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">FROM</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">LEFT</span> <span class="kw">OUTER</span> <span class="kw">JOIN</span> b;</span></code></pre></div>
<p>a part of the AST will look like this:</p>
<pre><code>| {join_clause}
| | {table_or_subquery}
| | | {name a}
| | {join_target_list}
|   | {join_target}
|     | {int 3}
|     | {table_join}
|       | {table_or_subquery}
|         | {name b}</code></pre>
<p>The <code>{int 3}</code> ia an int_ast_node and it corresponds to <code>JOIN_LEFT_OUTER</code>.</p>
<p>This node type is always a leaf.</p>
<h4 id="string-node">String Node</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> str_ast_node <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nullable value<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  bool_t cstr_literal<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> str_ast_node<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>value</code> – the text of the string</li>
<li><code>cstr_literal</code> – true if the string was specified using “C” syntax (see below)</li>
</ul>
<p>This node type holds: * string literals * blob literals * identifiers</p>
<p>CQL supports C style string literals with C style escapes such as <code>"foo\n"</code>. These are normalized into the SQL version of the same literal so that SQLite will see a literal it understands. However, if the origin of the string was the C string form (i.e. <code>"foo"</code> rather than <code>'bar'</code>) then the <code>cstr_literal</code> boolean flag will be set. When echoing the program back as plain text, the C string will be converted back to the C form for display. This means, for instance, that the comments in the output C correspond to the original string format even though the code that gets set to SQLite is always in SQL format.</p>
<p>Identifiers can be distinguised from string literals because the quotation marks are stil in the string.</p>
<p>This node type is always a leaf.</p>
<h4 id="number-node">Number Node</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> num_ast_node <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> num_type<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nullable value<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> num_ast_node<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>num_type</code> the kind of numeric</li>
<li><code>value</code> the text of the number</li>
</ul>
<p>All numerics are stored as strings so that there is no loss of precision. This is important because it is entirely possible that the CQL compiler is build with a different floating point library, or different integer sizes, than the target system. As a result CQL does not evaluate anything outside of an explicit <code>const()</code> expression. This avoids integer overflows at compile time or loss of floating point precesion; Constants in the text of the output are emitted byte-for-byte as they appeared in the source code.</p>
<p>This node type is always a leaf.</p>
<h3 id="examples">Examples</h3>
<h4 id="example-1-a-let-statement-and-expression">Example 1: A let statement and expression</h4>
<pre><code>LET x := 1 + (3 - 2);

  {let_stmt}
  | {name x}
  | {add}
    | {int 1}
    | {sub}
      | {int 3}
      | {int 2}</code></pre>
<p>Note that there are no parentheses in the AST but it exactly and authoritatively captures the precedence with its shape. This means, among other things, that when CQL echos its input, any redundant parentheses will be gone.</p>
<h4 id="example-2-an-ifelse-construct">Example 2: An if/else construct</h4>
<pre><code>IF x THEN
  LET x := 1.5e7;
ELSE IF y THEN
  LET y := &#39;that&#39;;
ELSE
  LET z := &quot;this&quot;;
END IF;

  {if_stmt}
  | {cond_action}
  | | {name x}
  | | {stmt_list}
  |   | {let_stmt}
  |     | {name x}
  |     | {dbl 1.5e7}
  | {if_alt}
    | {elseif}
    | | {cond_action}
    |   | {name y}
    |   | {stmt_list}
    |     | {let_stmt}
    |       | {name y}
    |       | {strlit &#39;that&#39;}
    | {else}
      | {stmt_list}
        | {let_stmt}
          | {name z}
          | {strlit &#39;this&#39;}</code></pre>
<p>Note that the string “this” was normalized to ‘this’ (which was trivial in this case) but rest assured that <code>cstr_literal</code> was set. This is shown because the text of the statement came out with double quotes. The text above was not the input to the compiler, the compiler was actually given this text</p>
<pre><code>if x then let x := 1.5e7; else if y then let y := &#39;that&#39;; else let z := &quot;this&quot;; end if;</code></pre>
<p>And it was normalized into what you see as part of the output. We’ll talk about this output echoing in coming sections, but as you can see, the compiler can be used as a SQL normalizer/beautifier.</p>
<h4 id="example-3-a-select-statement">Example 3: A select statement</h4>
<pre><code>SELECT *
  FROM foo
  INNER JOIN bar
  WHERE foo.x = 1
LIMIT 3;

  {select_stmt}
  | {select_core_list}
  | | {select_core}
  |   | {select_expr_list_con}
  |     | {select_expr_list}
  |     | | {star}
  |     | {select_from_etc}
  |       | {join_clause}
  |       | | {table_or_subquery}
  |       | | | {name foo}
  |       | | {join_target_list}
  |       |   | {join_target}
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}
  |       |         | {name bar}
  |       | {select_where}
  |         | {opt_where}
  |         | | {eq}
  |         |   | {dot}
  |         |   | | {name foo}
  |         |   | | {name x}
  |         |   | {int 1}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}
      | | {int 3}
      | {select_offset}</code></pre>
<p>As you can see the trees rapidly get more complex. The select statement has many optional pieces and so the AST actually has places in its skeleton where these could go but are abasent (e.g. group by, having, order, and offset are all missing).</p>
<p>The shape of the AST is self evident.</p>
<p>The compiler can produce these diagrams in ‘dot’ format which makes pretty pictures but the reality is that for non-trivial examples that pictures are so large as to be unreadable whereas the simple text format remains readable even up to several hundred lines of output and is readily searchable, and diffable. The test suites for semantic analysis do pattern matching on the text of the AST to verify correctness.</p>
<p>We’ll discuss semantic analysis in later sections.</p>
<h3 id="ast-definitions">AST definitions</h3>
<p><code>ast.h</code> defines the all the tree types mentioned above. There are helper methods to create AST nodes with type safety. It includes helper functions for the various leaf types mentioned above but also for the various “normal” types. These are specified using the AST macros <code>AST</code>, <code>AST1</code>, and <code>AST0</code></p>
<p>Examples:</p>
<pre><code>AST0(star)
AST1(not)
AST(or)</code></pre>
<p>This says that:</p>
<ul>
<li>the <code>star</code> AST node (used in <code>select *</code>) is a leaf, it has 0 children
<ul>
<li>this means the left and right nodes will always be <code>NULL</code></li>
</ul></li>
<li>the <code>not</code> AST node (used in <code>select NOT x</code>) is unary
<ul>
<li>this means only the left node is populated, the right is always <code>NULL</code></li>
<li>node many unary nodes have optional children, so the left node might still be <code>NULL</code></li>
</ul></li>
<li>the <code>or</code> AST node (used in <code>select x OR y</code>) is binary
<ul>
<li>this means both its left and right children are populated</li>
<li>note that some binary nodes have optional children, so left or right still might be <code>NULL</code></li>
</ul></li>
</ul>
<p>At present there are about 300 unique AST node types.</p>
<h2 id="echoing-the-ast">Echoing the AST</h2>
<p>The first set of features that were built after parsing was the ability to echo back the parse tree as SQL again. This all happens in <code>gen_sql.c</code> and since it has to be able to echo back any tree it often has the best and simplest examples of how to crack the AST for a particular type of node.</p>
<p>There are several reasons why we might want to echo the SQL but the inescapable one is this: any hunk of SQL that appears as part of a CQL program (i.e. DDL/DML rather than control flow like IF/WHILE) has to go to SQLite and SQLite expects it to be plain text. So the AST must be reformatted as plain text that is exactly equivalent to the input. The process of parsing removes extra white space and parentheses and instead some standard formatting (including indenting) is applied to the output text. This has the effect of normalizing the input and potentially beautifying it as well if it was particularly poorly formatted initially.</p>
<p>To see these features you need only run cql with no arguments, by default it reads stdin, makes the AST, and then emits the normalized formatted text. If there are no syntax errors, the input and the output should be equivalent. And here is where we start to see some of the extra demands.</p>
<p>CQL includes a lot of versioning directives like <code>@create(...)</code> <code>@delete(...)</code> and so forth. SQLite should never see these things when the DDL for SQLite is emitted. But when echoing the input they should be included. Additionally, any local or global variables in a SQL statement should be replaced with <code>?</code> in the text that goes to SQLite and then followed up with binding instructions. We’ll cover the binding more in the section code generation, but importantly this also has to significantly alter the desired outcome. As a result the standard formatter includes extensive configurably to get these results.</p>
<h3 id="configuring-the-output-with-callbacks-and-flags">Configuring the Output with Callbacks and Flags</h3>
<p>Some of these features, like variable binding, require a callback to formatter’s client to get a notification, these callbacks along with a few control variables decide exactly how the output will be created. The control structure is <code>struct gen_sql_callbacks</code>, described below. It’s quite flexible so it ends up not changing very often. It includes the various callbacks (all of which are optional) and each callback gets a ‘context’ pointer. This is some <code>void *</code> value that you provide which will be given to your function along with the AST pointer relevant to the call. The callback also gets the current output buffer so it can choose to emit something (like ‘?’ into the stream)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// signature for a callback, you get your context plus the ast</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">// if you return true then the normal output is suppressed</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">// in any case the output you provide is emitted</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> bool_t <span class="op">(*</span>_Nullable gen_sql_callback<span class="op">)(</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nonnull ast<span class="op">,</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable context<span class="op">,</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>_Nonnull output</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>The meaning of the <code>bool_t</code> return value varies depend on which callback it is.</p>
<p>The coarsest control is provided by the generation mode. It is one of these values.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// These modes control the overall style of the output</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> gen_sql_mode <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  gen_mode_echo<span class="op">,</span>          <span class="co">// Prints everything in the original, with standard whitespace and parentheses</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  gen_mode_sql<span class="op">,</span>           <span class="co">// Prints the AST formatted for SQLite consumption, omits anything CQL specific</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  gen_mode_no_annotations <span class="co">// Equivalent to gen_mode_echo without versioning attributes or generic attribues</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>                          <span class="co">// * @create, @delete, @recreate, and @attribute are removed</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>                          <span class="co">// * statements like @echo are not affected, nor is the type specifier @sensitive</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The actual callbacks structure is optional, if it is null then you get full echo of the AST with no changes. Otherwise the callbacks and flags alter the behavior somewhat.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Callbacks allow you to significantly alter the generated sql, see the particular flags below.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> gen_sql_callbacks <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Each time a local/global variable is encountered in the AST, this callback is invoked</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this is to allow the varialbe reference to be noted and replaced with ? in the generated SQL</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable variables_callback<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable variables_context<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Each time a column definition is emitted this callback is invoked, it may choose to</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// suppress that column.  This is used to remove columns that were added in later schema</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// versions from the baseline schema.</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable col_def_callback<span class="op">;</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable col_def_context<span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This callback is used to expland the * in select * or select T.*</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable star_callback<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable star_context<span class="op">;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This callback is used to force the &quot;IF NOT EXISTS&quot; form of DDL statements when generating</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// schema upgrade steps.  e.g. a &quot;CREATE TABLE Foo declarations get &quot;IF NOT EXISTS&quot; added</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// to them in upgrade steps.</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable if_not_exists_callback<span class="op">;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable if_not_exists_context<span class="op">;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If true, hex literals are converted to decimal.  This is for JSON which does not support hex literals.</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>  bool_t convert_hex<span class="op">;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If true casts like &quot;CAST(NULL as TEXT)&quot; are reduced to just NULL.  The type information is not needed</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// by SQLite so it just wasts space.</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>  bool_t minify_casts<span class="op">;</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If true then unused aliases in select statements are elided to save space.  This is safe because</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">// CQL always binds the top level select statement by ordinal anyway.</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>  bool_t minify_aliases<span class="op">;</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// mode to print cql statement: gen_mode_echo, gen_mode_sql, gen_mode_no_annotations.</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">// gen_mode_sql mode causes the AS part of virtual table to be suppressed</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> gen_sql_mode mode<span class="op">;</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If CQL finds a column such as &#39;x&#39; below&#39;</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">// create table foo(</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   x long_int primary key autoincrement</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">// );</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>  <span class="co">// that column must be converted to this form:</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">// create table foo(</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   x integer primary key autoincrement</span></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">// );</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This is because SQLite mandates that autoincrement must be exactly</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>  <span class="co">// in the second example above however, it is also the case that in SQLite</span></span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>  <span class="co">// an integer can store a 64 bit value.  So sending &quot;integer&quot; to SQLite while</span></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>  <span class="co">// keeping the sense that the column is to be treated as 64 bits in CQL works</span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>  <span class="co">// just fine.</span></span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a>  <span class="co">// However, when we are emitting CQL (rather than SQL) we want to keep</span></span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the original long_int type so as not to lose fidelity when processing</span></span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>  <span class="co">// schema for other semantic checks (such as matching FK data types).</span></span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This flag is for that purpose: It tells us that the target isn&#39;t SQLite</span></span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a>  <span class="co">// and we don&#39;t need to do the mapping (yet). Indeed, we shouldn&#39;t, or the</span></span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">// types will be messed up.</span></span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a>  <span class="co">// In short, if CQL is going to process the output again, use this flag</span></span>
<span id="cb17-66"><a href="#cb17-66" aria-hidden="true" tabindex="-1"></a>  <span class="co">// to control the autoincrement transform.  It might be possible to fold</span></span>
<span id="cb17-67"><a href="#cb17-67" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this flag with the mode flag but it&#39;s sufficiently wierd that this</span></span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a>  <span class="co">// extra documention and special handling is probably worth the extra</span></span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a>  <span class="co">// boolean storage.</span></span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a>  bool_t long_to_int_conv<span class="op">;</span></span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> gen_sql_callbacks<span class="op">;</span></span></code></pre></div>
<p>Each callback can be best understood by reading the source, so we’ll avoid trying to precisely define it here. But it is helpful to give the jist of these options.</p>
<ul>
<li><code>mode</code> : one of the three enum modes that control overall behavior</li>
<li><code>variables_callback</code> : invoked when a variable appears in the SQL, the caller can record the specific variable and then use it for binding</li>
<li><code>col_def_callback</code> : when creating the “baseline” schema you don’t want column defintions from later schema to be included, this gives you a chance to suppress them</li>
<li><code>star_callback</code> : normally the <code>*</code> in <code>select *</code> or <code>select T.*</code> is expanded when emitting for SQLite, this callback does the expansion when appropriate</li>
<li><code>if_not_exists_callback</code> : when generating DDL for schema upgrade you typically want to force <code>IF NOT EXISTS</code> to be added to the schema even if it wasn’t present in the declaration, this callback lets you do that</li>
<li><code>convert_hex</code> : hex constants are converted to decimal if true, used when emitting JSON because it doesn’t understand hex constants</li>
<li><code>minify_casts</code> : minification conversts casts like <code>CAST(NULL AS TEXT)</code> to just <code>NULL</code> – the former is only useful for type information, SQLite does need to see it</li>
<li><code>minify_aliases</code> : unused column aliases as in <code>select foo.x as some_really_long_alias</code> can be removed from the output when targetting SQLite top save space</li>
</ul>
<h3 id="invoking-the-generator">Invoking the Generator</h3>
<p>There are several generation functions but they all follow a similar pattern, the differences are essentially what fragment of the AST they expect to begin on. We’ll just cover one here.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_statement_with_callbacks<span class="op">(</span>ast_node <span class="op">*</span>_Nonnull ast<span class="op">,</span> gen_sql_callbacks <span class="op">*</span>_Nullable _callbacks<span class="op">);</span></span></code></pre></div>
<p>This has the typical signature * <code>ast</code> : the part of the tree to print * <code>_callbacks</code> : the optional callbacks described above</p>
<p>To use these you’ll need</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_init<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_cleanup<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span></code></pre></div>
<p>You’ll want to call <code>gen_init()</code> one time before doing any generation. That sets up the necessary tables. When you’re done use <code>gen_cleanup()</code> to release any memory that was allocated in setup. You don’t have to do the cleanup step if the process is going to exit anyway, but because of the amalgam options, <code>cql_main()</code> assumes it might be called again and so it tidies things up rather than leak.</p>
<p>With the one time initialization in place there are these preliminaries.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> init_gen_sql_callbacks<span class="op">(</span>gen_sql_callbacks <span class="op">*</span>_Nullable callbacks<span class="op">);</span></span></code></pre></div>
<p>Use <code>init_gen_sql_callbacks</code> to fill in your callback structure with the normal defaults. This give you normal echo for SQL by default. To get full echo, <code>NULL</code> callback may be used. And of course other options are possible.</p>
<p>Finally,</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_set_output_buffer<span class="op">(</span><span class="kw">struct</span> charbuf <span class="op">*</span>_Nonnull buffer<span class="op">);</span></span></code></pre></div>
<p>Use this before the call to <code>gen_&lt;something&gt;_with_callbacks</code> to redirect the output into a growable character buffer of your choice.</p>
<p>The buffers can then be written where they are needed. Maybe into a C string literal for compiler output, or into a comment, or just right back to stdout.</p>
<p>There are a few simplified versions of this sequence like this one:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_stmt_list_to_stdout<span class="op">(</span>ast_node <span class="op">*</span>_Nullable ast<span class="op">);</span></span></code></pre></div>
<p>This does <code>NULL</code> callbacks and emits directly to stdout with no extra steps. The extra wiring is done for you.</p>
<h3 id="generator-internals">Generator Internals</h3>
<p>The generator has to be able to walk the entire tree and emit plain text, and in many areas the tree is very flexible so we want a simple dynamic dispatch mechanism that can call the right formatting function from anyplace in the tree.</p>
<p>It turns out two different signatures are needed to do this properly, one for formatting statements and the other for expressions. The difference being that expressions have to concern themselves with the precedence of the various operators so that parentheses can be correctly re-inserted into the output.</p>
<p>To do this there are two symbol tables that map from a AST node type string to a formatting function. They are initialized with a series of statements similar to these:</p>
<h4 id="generating-expressions">Generating Expressions</h4>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  gen_stmts <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  gen_exprs <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>if_stmt<span class="op">);</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mul<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;*&quot;</span><span class="op">,</span> EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>div<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;/&quot;</span><span class="op">,</span> EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mod<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;%&quot;</span><span class="op">,</span> EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>add<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;+&quot;</span><span class="op">,</span> EXPR_PRI_ADD<span class="op">);</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>sub<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">,</span> EXPR_PRI_ADD<span class="op">);</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>not<span class="op">,</span> gen_unary<span class="op">,</span> <span class="st">&quot;NOT &quot;</span><span class="op">,</span> EXPR_PRI_NOT<span class="op">);</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>tilde<span class="op">,</span> gen_unary<span class="op">,</span> <span class="st">&quot;~&quot;</span><span class="op">,</span> EXPR_PRI_TILDE<span class="op">);</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>These statements populate the symbol tables. * For statements, the entry maps <code>if_stmt</code> to the function <code>gen_if_stmt</code> * For expressions, the entry maps <code>mul</code> to <code>gen_binary</code> including the metadata "*" and <code>EXPR_PRI_MUL</code></p>
<p>As you can see (nearly) all binary operators are handled identically as are all unary operators. Let’s look at those two in detail.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_binary<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">,</span> <span class="dt">int32_t</span> pri<span class="op">,</span> <span class="dt">int32_t</span> pri_new<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We add parens if our priority is less than the parent prioirty</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// meaning something like this:</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// * we&#39;re a + node, our parent is a * node</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// * we need parens because the tree specifies that the + happens before the *</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Also, grouping of equal operators is left to right</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so for so if our right child is the same precendence as us</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// that means there were parens there in the original expression</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// e.g.  3+(4-7);</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// effectively it&#39;s like we&#39;re one binding strength higher for our right child</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so we call it with pri_new + 1.  If it&#39;s equal to us it must emit parens</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  gen_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> pri_new<span class="op">);</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot; %s &quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>  gen_expr<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">,</span> pri_new <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The convention gives us: * <code>ast</code> : pointer to the current AST node * <code>op</code> : the text of the operator (<code>CSTR</code> is simply <code>const char *</code>) * <code>pri</code> : the binding strength of the node above us * <code>pri_new</code> : the binding strength of this node (the new node)</p>
<p>So generically, if our binding strength is weaker than the context we are contained in, then we must wrap the current node in parentheses to preserve order of operations. See the comment for more details.</p>
<p>With parens taken care of, we emit the left expression, the operator, and the right expression.</p>
<p>And as you can see below, unary operators are much the same.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_unary<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">,</span> <span class="dt">int32_t</span> pri<span class="op">,</span> <span class="dt">int32_t</span> pri_new<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot;%s&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  gen_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> pri_new<span class="op">);</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There are special case formatters for some of the postfix operators and other cases that are special like <code>CASE... WHEN... THEN... ELSE... END</code> but they operate on the same principles down to the leaf nodes.</p>
<h4 id="generating-statements">Generating Statements</h4>
<p>With no binding strenght to worry about, statement processing is quite a bit simpler.</p>
<p>Here’s the code for the <code>IF</code> statement mentioned above.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_if_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_if_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NOTNULL<span class="op">(</span>cond_action<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NOTNULL<span class="op">(</span>if_alt<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>elseif<span class="op">,</span> if_alt<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NAMED<span class="op">(</span>elsenode<span class="op">,</span> <span class="cf">else</span><span class="op">,</span> if_alt<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot;IF &quot;</span><span class="op">);</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  gen_cond_action<span class="op">(</span>cond_action<span class="op">);</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>elseif<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    gen_elseif_list<span class="op">(</span>elseif<span class="op">);</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>elsenode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    gen_printf<span class="op">(</span><span class="st">&quot;ELSE</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> elsenode<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    gen_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot;END IF&quot;</span><span class="op">);</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There is a general boiler plate sort of recursive form to all of these, they follow the same basic shape. These patterns are designed to make it impossible to walk the tree incorrectly, so if the tree shape changes because of a grammar change, you get immediate concrete failures were the tree walk has to change. Since there are test cases to cover every tree shape you can always be sure you have it exactly right if the macros do not force assertion failures.</p>
<ul>
<li>use <code>Contract</code> to assert that the node we are given is the type we expect</li>
<li>use <code>EXTRACT</code> macros (detailed below) to get the tree parts you want starting from your root</li>
<li>use <code>gen_printf</code> to emit the constant pieces of the statement</li>
<li>use recursion to print sub fragments (like the IF condition in this case)</li>
<li>test the tree fragments where optional peices are present, emit them as needed</li>
</ul>
<p>It might be instructive to include <code>gen_cond_action</code>, it is entirely unremarkable</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_cond_action<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_cond_action<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  gen_root_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot; THEN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  gen_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A <code>cond_action</code> node has an expression on the left and a statement list on the right it can appear in the base <code>IF x THEN y</code> part of the <code>IF</code> or as <code>ELSE IF x THEN y</code>. Either case is formatted the same.</p>
<h4 id="extraction-macros">Extraction Macros</h4>
<p>These macros are used by all the parts of CQL that walk the AST. They are designed to make it impossible for you to get the tree shape wrong without immediately failing. We do not ever want to walk off the tree in some exotic way and then continue to several levels of recursion before things go wrong. CQL locks this down by checking the node type at every step – any problems are found immediately exactly at the extraction site and can be quickly corrected. Again 100% coverage of all the tree shapes makes this rock solid, so CQL never compromises on 100% code coverage. The standard macros all appear in this example:</p>
<ul>
<li><code>EXTRACT_NOTNULL(cond_action, ast-&gt;left);</code>
<ul>
<li>read ast-&gt;left, assert that it is of type <code>cond_action</code>, it must not be NULL</li>
<li>declare a local variable named <code>cond_action</code> to hold the result</li>
</ul></li>
<li><code>EXTRACT_NOTNULL(if_alt, ast-&gt;right);</code>
<ul>
<li>read ast-&gt;right, assert that it is of type <code>if_alt</code>, it must not be NULL</li>
<li>declare a local variable named <code>if_alt</code> to hold the result</li>
</ul></li>
<li><code>EXTRACT(elseif, if_alt-&gt;left);</code>
<ul>
<li>read <code>if_alt-&gt;left</code>, assert that it is either NULL or else of type <code>elseif</code></li>
<li>declare a variable named <code>elseif</code> to hold the result</li>
</ul></li>
<li><code>EXTRACT_NAMED(elsenode, else, if_alt-&gt;right);</code>
<ul>
<li>read <code>if_alt-&gt;right</code>, assert that it is either NULL or else of type <code>else</code></li>
<li>declare a variable named <code>elsenode</code> to hold the result</li>
<li>note that we can’t use a variable named <code>else</code> because <code>else</code> is a keyword in C</li>
</ul></li>
</ul>
<p>Other options:</p>
<ul>
<li><code>EXTRACT_NAMED_NOTNULL</code> : like the <code>NAMED</code> variant</li>
<li><code>EXTRACT_ANY</code> : if the tree type is not known (e.g. expr-&gt;left could be any expression type)</li>
<li><code>EXTRACT_ANY_NOTNULL</code> : as above but not optional</li>
<li><code>EXTRACT_NUM_TYPE</code> : extracts the num_type field from a numeric AST node</li>
</ul>
<p>The <code>ANY</code> variants are usually redispatched with something like <code>gen_expr</code> that uses the name table again and that will check thet type or else they are checked with ad hoc logic immediately if it’s perhaps one of two or three variations. In all cases the idea is to force a failure very quickly. <code>gen_root_expr()</code> for instance in the <code>if_cond</code> example will fail immediately if the node is not an expression type.</p>
<p>Because of the clear use of <code>EXTRACT</code>, the <code>gen_</code> family of functions are often the best/fastest way to understand the shape of the AST. You can dump a few sample and look at the <code>gen_</code> function and quickly see exactly what the options are authoritatively. As a result it’s very normal to paste the extraction code from a <code>gen_</code> into a new/needed semantic analysis or code-generation functions which we will come to in later sections.</p>
<h2 id="cql-internals-guide-part-2">CQL Internals Guide: Part 2</h2>
<!---
-- Copyright (c) Facebook, Inc. and its affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="overview-1">Overview</h3>
<p>Part 2 continues with a discussion of the essentials of the semantic analysis pass of the CQL compiler. As in the previous sections, the goal here is not to go over every single rule but rather to give a sense of how semantic analysis happens in general, the core strategies and implementation choices so that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish this various key data structures will be explained in detail as well as selected examples of their use.</p>
<h2 id="semantic-analysis">Semantic Analysis</h2>
<p>The overall goal of the semantic analysis pass is to verify that a correct program has been submitted to the compiler. The compiler does this by “decorating” the AST with semantic information. This information is mainly concerned about the “types” of the various things in the program. A key function of the semantic analyzer, the primary “weapon” in computing these types if you will, is name resolution. The semantic analyzer decides what any given name means in any context and then uses that meaning, which is itself based on the AST constructs that came before, to compute types and then check those types for errors.</p>
<p>Broadly speaking the errors that can be discovered are of these forms:</p>
<ul>
<li>mentioned names do not exist
<ul>
<li>e.g. using a variable or table or column without declaring it</li>
</ul></li>
<li>mentioned names are not unique or are ambiguous
<ul>
<li>e.g. table names need to be unique or aliased when joining tables</li>
</ul></li>
<li>operands are not compatible with each other or with the operation
<ul>
<li>e.g. you can’t add a string to a real</li>
<li>e.g. you can’t do the ‘%’ operation on a real</li>
<li>e.g. the expression in a <code>WHERE</code> clause must be numeric</li>
<li>e.g. the first argument to <code>printf</code> must be a string literal.</li>
<li>e.g. you can’t assign a long value to an integer variable</li>
<li>e.g. you can’t assign a possibly null result to a not-null variable</li>
</ul></li>
<li>there are too many or two few operands for an operation
<ul>
<li>e.g. an <code>INSERT</code> statement must include sufficiently many columns and no extras</li>
<li>e.g. a function or procedure call must have the correct number of operands</li>
</ul></li>
<li>an operation is happening in a context where it is not allowed
<ul>
<li>e.g. use of aggregate functions in the <code>WHERE</code> clause</li>
<li>e.g. use of unique SQLite functions outside of a SQL statement</li>
</ul></li>
</ul>
<p>There are several hundred possible errors, no attempt will be made to cover them all here but we will talk about how errors are created, recorded, and reported.</p>
<h3 id="decorated-ast-examples">Decorated AST examples</h3>
<p>Recalling the AST output from Part 1, this is what it looks like with semantic information attached.</p>
<pre><code>LET X := 1 + 3;

  {let_stmt}: X: integer notnull variable
  | {name X}: X: integer notnull variable
  | {add}: integer notnull
    | {int 1}: integer notnull
    | {int 3}: integer notnull</code></pre>
<p>And here’s an example with some structure types</p>
<pre><code>SELECT 1 AS x, 3.2 AS y;

  {select_stmt}: select: { x: integer notnull, y: real notnull }
  | {select_core_list}: select: { x: integer notnull, y: real notnull }
  | | {select_core}: select: { x: integer notnull, y: real notnull }
  |   | {select_expr_list_con}: select: { x: integer notnull, y: real notnull }
  |     | {select_expr_list}: select: { x: integer notnull, y: real notnull }
  |     | | {select_expr}: x: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name x}
  |     | | {select_expr_list}
  |     |   | {select_expr}: y: real notnull
  |     |     | {dbl 3.2}: real notnull
  |     |     | {opt_as_alias}
  |     |       | {name y}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}</code></pre>
<p>These can be generated by adding <code>--sem --print</code> to the CQL command line along with <code>--in your_file.sql</code>.</p>
<p>Keep these shapes in mind as we discuss the various sources of type information.</p>
<h3 id="the-base-data-structures">The Base Data Structures</h3>
<p>First recall that every AST node has this field in it:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sem_node <span class="op">*</span>_Nullable sem<span class="op">;</span></span></code></pre></div>
<p>This is the pointer to the semantic information for that node. Semantic analysis happens immediately after parsing and before any of the code-generators run. Importantly code generators never run if semantic analysis reported any errors. Before we get into the shape of the semantic node, we should start with the fundamental unit of type info <code>sem_t</code> which is usually stored in a variable called <code>sem_type</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">uint64_t</span> sem_t<span class="op">;</span></span></code></pre></div>
<p>The low order bits of a <code>sem_t</code> encode the core type and indeed there is an helper macro to extract the core type from a <code>sem_t</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Strips out all the flag bits and gives you the base/core type.</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>cql_noexport sem_t core_type_of<span class="op">(</span>sem_t sem_type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sem_type <span class="op">&amp;</span> SEM_TYPE_CORE<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The core bits are as follows:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_NULL 0         </span><span class="co">// the subtree is a null literal (not just nullable)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_BOOL 1         </span><span class="co">// the subtree is a bool</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_INTEGER 2      </span><span class="co">// the subtree is an integer</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_LONG_INTEGER 3 </span><span class="co">// the subtree is a long integer</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_REAL 4         </span><span class="co">// the subtree is a real</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_TEXT 5         </span><span class="co">// the subtree is a text type</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_BLOB 6         </span><span class="co">// the subtree is a blob type</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_OBJECT 7       </span><span class="co">// the subtree is any object type</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_STRUCT 8       </span><span class="co">// the subtree is a table/view</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_JOIN 9         </span><span class="co">// the subtree is a join</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_ERROR 10       </span><span class="co">// marks the subtree as having a problem</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_OK 11          </span><span class="co">// sentinel for ok but no type info</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_PENDING 12     </span><span class="co">// sentinel for type calculation in flight</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_REGION 13      </span><span class="co">// the ast is a schema region</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CORE 0xff      </span><span class="co">// bit mask for the core types</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) </span><span class="co">// the last unitary type</span></span></code></pre></div>
<p>These break into a few categories: * <code>NULL</code> to <code>OBJECT</code> are the “unitary” types, these are the types that a single simple variable can be * a column can be any of these except <code>OBJECT</code> or <code>NULL</code> * the <code>NULL</code> type begins only from the <code>NULL</code> literal which has no type * instance of say a <code>TEXT</code> column might have a <code>NULL</code> value but they are known to be <code>TEXT</code> * <code>STRUCT</code> indicates that the object has many fields, like a table, or a cursor * <code>JOIN</code> indicates that the object is the concatenation of many <code>STRUCT</code> types * e.g. <code>T1 inner join T2</code> is a <code>JOIN</code> type with <code>T1</code> and <code>T2</code> being the parts * a <code>JOIN</code> can be flattend to <code>STRUCT</code> but this is typically not done * the type of a <code>SELECT</code> statement will be a <code>STRUCT</code> representing the columns that were selected which in turn came from the <code>JOIN</code> that was the <code>FROM</code> clause * <code>ERROR</code> indicates that the subtree had an error, it will have been already reported, this generally cascades up the AST to the root * <code>OK</code> indicates that there is no type information but there was no problem, for instance a correct <code>IF</code> statement will resolve to simply <code>OK</code> (no error) * <code>PENDING</code> is used sometimes while a type computation is in progress, it doesn’t appear in the AST but has its own unique value so as to not conflict with any others * <code>REGION</code> used to identify AST fragments that correspond to schema regions (see the Guide for mor info on regions) * <code>CORE</code> is the mask for the core parts, <code>0xf</code> would do the job but for easy reading in the debugger we use <code>0xff</code> * new core types are not added very often, adding a new one is usually a sign that you are doing something wrong</p>
<p>The core type can be modified by various flags. The flags in principle can be combined in any way but in practice many combinations make no sense. for instance, <code>HAS_DEFAULT</code> is for table columns and <code>CREATE_FUNC</code> is for function declarations. There is no one object that could require both of these.</p>
<p>The full list as of this writing is as follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_NOTNULL               _64(0x0100) </span><span class="co">// set if and only if null is not possible</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) </span><span class="co">// set for table columns with a default</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) </span><span class="co">// set for table columns with autoinc</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VARIABLE              _64(0x0800) </span><span class="co">// set for variables and parameters</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_IN_PARAMETER          _64(0x1000) </span><span class="co">// set for in parameters (can mix with below)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) </span><span class="co">// set for out paramters (can mix with above)</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_DML_PROC              _64(0x4000) </span><span class="co">// set for stored procs that have DML/DDL</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) </span><span class="co">// set for a cursor with simplified fetch syntax</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CREATE_FUNC          _64(0x10000) </span><span class="co">// set for a function that returns a created object +1 ref</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_SELECT_FUNC          _64(0x20000) </span><span class="co">// set for a sqlite UDF function declaration</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_DELETED              _64(0x40000) </span><span class="co">// set for columns that are not visible in the current schema version</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VALIDATED            _64(0x80000) </span><span class="co">// set if item has already been validated against previous schema</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_USES_OUT            _64(0x100000) </span><span class="co">// set if proc has a one rowresult using the OUT statement</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) </span><span class="co">// set if proc uses the OUT UNION form for multi row result</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_PK                  _64(0x400000) </span><span class="co">// set if column is a primary key</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_FK                  _64(0x800000) </span><span class="co">// set if column is a foreign key</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_UK                 _64(0x1000000) </span><span class="co">// set if column is a unique key</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) </span><span class="co">// set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_SENSITIVE          _64(0x4000000) </span><span class="co">// set if the object is privacy sensitive</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) </span><span class="co">// set if the object is a deployable region</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_BOXED             _64(0x10000000) </span><span class="co">// set if a cursor&#39;s lifetime is managed by a box object</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_CHECK         _64(0x20000000) </span><span class="co">// set for table column with a &quot;check&quot; clause</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) </span><span class="co">// set for table column with a &quot;collate&quot; clause</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) </span><span class="co">// set if inferred to not be nonnull (but was originally nullable)</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VIRTUAL          _64(0x100000000) </span><span class="co">// set if and only if this is a virtual table</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) </span><span class="co">// set if and only if hidden column on a virtual table</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_TVF              _64(0x400000000) </span><span class="co">// set if and only table node is a table valued function</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_IMPLICIT         _64(0x800000000) </span><span class="co">// set if and only the variable was declare implicitly (via declare out)</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) </span><span class="co">// set if proc calls an out union proc for</span></span></code></pre></div>
<p>Going over the meaning of all of the above is again beyond the scope of this document, some of them are very specialized and essentially the validation requires a bit of storage in the tree to do its job so that storage is provided with a bit. However two flag bits are especially important and are computed almost everywhere <code>sem_t</code> is used. These are <code>SEM_TYPE_NOTNULL</code> and <code>SEM_TYPE_SENSITIVE</code>.</p>
<ul>
<li><code>SEM_TYPE_NOTNULL</code> indicates that the marked item is known to be <code>NOT NULL</code>, probably because it was declared as such or directly derived from a not null item
<ul>
<li>Typically when two operands are combined both must be marked <code>NOT NULL</code> for the result to still be NOT NULL (there are exceptions like <code>COALESCE</code>)</li>
<li>Values that might be null cannot be assigned to targets that must be not null</li>
</ul></li>
<li><code>SEM_TYPE_SENSITIVE</code> indicates that the marked item is some kind of PII or other sensitive data.
<ul>
<li>Any time a sensitive item is combined with some other piece of data the result is a new sensitive piece of data, there are very few ways to “get rid” of the sensitive bit. It corresponds to the presence of <code>@sensitive</code> in the data type declaration.</li>
<li>Values that are sensitive cannot be assigned to targets that are not also marked sensitive</li>
</ul></li>
</ul>
<p>The semantic node <code>sem_node</code> carries all the possible semantic info we might need, the <code>sem_type</code> holds the flags above and tells us how to interpret it. There are many fields, we’ll talk about some of the most important ones here to give you a sense of how things hang together.</p>
<p>Note that <code>CSTR</code> is simply an alias for <code>const char *</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_node <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type<span class="op">;</span>                   <span class="co">// core type plus flags</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  CSTR name<span class="op">;</span>                        <span class="co">// for named expressions in select columns etc.</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  CSTR kind<span class="op">;</span>                        <span class="co">// the Foo in object&lt;Foo&gt;, not a variable or column name</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  CSTR error<span class="op">;</span>                       <span class="co">// error text for test output, not used otherwise</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_struct <span class="op">*</span>sptr<span class="op">;</span>          <span class="co">// encoded struct if any</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_join <span class="op">*</span>jptr<span class="op">;</span>            <span class="co">// encoded join if any</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> create_version<span class="op">;</span>           <span class="co">// create version if any (really only for tables and columns)</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> delete_version<span class="op">;</span>           <span class="co">// create version if any (really only for tables and columns)</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  bool_t recreate<span class="op">;</span>                  <span class="co">// for tables only, true if marked @recreate</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  CSTR recreate_group_name<span class="op">;</span>         <span class="co">// for tables only, the name of the recreate gruop if they are in one</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>  CSTR region<span class="op">;</span>                      <span class="co">// the schema region, if applicable, null means unscoped (default)</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>used_symbols<span class="op">;</span>             <span class="co">// for select statements, we need to know which of the ids in the select list was used if any</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>  list_item <span class="op">*</span>index_list<span class="op">;</span>            <span class="co">// for tables we need the list of indices that use this table (so we can recreate them together if needed)</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> eval_node <span class="op">*</span>value<span class="op">;</span>          <span class="co">// for enum values we have to store the evaluated constant value of each member of the enum</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_node<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>sem_type</code> : already discussed above, this tells you how to interpret everything else</li>
<li><code>name</code> : variables, columns, etc. have a canonical name, when a name case-insenstively resolves, the canonical name is stored here
<ul>
<li>typically you want to emit the canonical variable name (e.g. <code>FoO</code> and <code>fOO</code> might both resolve to <code>foo</code> if that is how it was declared)</li>
</ul></li>
<li><code>kind</code> : in CQL any type can be discriminated as in <code>declare foo real&lt;meters&gt;</code>, the kind here is <code>meters</code>
<ul>
<li>expressions of the same core type (e.g. <code>real</code>) are incompatible if they have a <code>kind</code> and the <code>kind</code> does not match</li>
<li>e.g. you can’t assign if you have <code>bar real&lt;liters&gt;</code> then <code>set foo := bar;</code> is an error even though both are <code>real</code>.</li>
</ul></li>
<li><code>sptr</code> : if the item’s core type is <code>SEM_TYPE_STRUCT</code> then this is populated, see below</li>
<li><code>jptr</code> : if the item’s core type is <code>SEM_TYPE_JOIN</code> then this is populated, see below</li>
</ul>
<p>If the object is a structure type then this is simply an array of names, kinds, and semantic types. In fact the semantic types will be all be unitary possibly modified by <code>NOT_NULL</code> or <code>SENSITIVE</code> but none of the other flags apply. A single <code>sptr</code> directly corresponds to the notion of a <code>shape</code> in the analyzer. Shapes come from anything that looks like a table, such as a cursor, or the result of a <code>SELECT</code> statement.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for tables and views and the result of a select</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_struct <span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  CSTR struct_name<span class="op">;</span>               <span class="co">// struct name</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of fields</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// field names</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>kinds<span class="op">;</span>                    <span class="co">// the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>semtypes<span class="op">;</span>                <span class="co">// typecode for each field</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_struct<span class="op">;</span></span></code></pre></div>
<p>If the object is a join type (such as the parts of the <code>FROM</code> clause) then the <code>jptr</code> field will be populated. This is nothing more than a named list of struct types.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for the data type of (parts of) the FROM clause</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">// sometimes I refer to as a &quot;joinscope&quot;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_join <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of table/views in the join</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// names of the table/view</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_struct <span class="op">**</span>tables<span class="op">;</span>     <span class="co">// struct type of each table/view</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_join<span class="op">;</span></span></code></pre></div>
<p>With these building blocks we can represent the type of anything in the CQL language.</p>
<h3 id="initiating-semantic-analysis">Initiating Semantic Analysis</h3>
<p>The semantic analysis pass runs much the same way as the AST emitter. In <code>sem.c</code> there is the essential function <code>sem_main</code>. It suffices to call <code>sem_main</code> on the root of your AST, that is expect to be a <code>stmt_list</code> node.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This method loads up the global symbol tables in either empty state or</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">// with the appropriate tokens ready to go.  Using our own symbol tables for</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co">// dispatch saves us a lot of if/else string comparison verbosity.</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> sem_main<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// restore all globals and statics we own</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  sem_cleanup<span class="op">();</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  eval_init<span class="op">();</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As you can see, <code>sem_main</code> begins by reseting all the state. You can of course do this yourself after calling <code>sem_main</code> (when you’re done with the results).</p>
<p><code>sem_main</code> sets a variety of useful and public global variables that describe the results of the analysis. The ones in <code>sem.h</code> are part of the contract and you should feel free to use them in a downstream code-generator. Other items are internal and should be avoided. These are typically defined statically in <code>sem.c</code>.</p>
<p>The cleanup has this structure:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This method frees all the global state of the semantic analyzer</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> sem_cleanup<span class="op">()</span> <span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  eval_cleanup<span class="op">();</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  BYTEBUF_CLEANUP<span class="op">(</span>deployable_validations<span class="op">);</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  BYTEBUF_CLEANUP<span class="op">(</span>recreate_annotations<span class="op">);</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  BYTEBUF_CLEANUP<span class="op">(</span>schema_annotations<span class="op">);</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>funcs<span class="op">);</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>globals<span class="op">);</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>indices<span class="op">);</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>locals<span class="op">);</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  all_ad_hoc_list <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>  all_functions_list <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p><code>sem_main</code> of course has to walk the AST and it does so in much the same way as we saw in <code>gen_sql.c</code> there are a set of symbol tables whose key is an ast type and whose value is a function plus arguments to dispatch (effectively a lambda). The semantic analyzer doesn’t have to think about things like “should I emit parentheses” so the signature of each type of lambda can be quite a bit simpler. We’ll go over each kind with some examples.</p>
<p>First we have the non-sql statements, these are basic flow control or other things that SQLite will never see directly.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>syms <span class="op">=</span> non_sql_stmts<span class="op">;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>if_stmt<span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>while_stmt<span class="op">);</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>switch_stmt<span class="op">);</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>leave_stmt<span class="op">);</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Here <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>if_stmt</code> and the function <code>sem_if_stmt</code>. This lets us dispatch any part of the AST directly.</p>
<p>Next we have the SQL statements. These get analyzed in the same way as the others, and with functions that have the same signature, however, if you use one of these it means that procedure that contained this statement must get a database connection in order to run. This changes its signature and causes the <code>SEM_TYPE_DML_PROC</code> flag bit to be set on it.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>  syms <span class="op">=</span> sql_stmts<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>create_table_stmt<span class="op">);</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>drop_table_stmt<span class="op">);</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>create_index_stmt<span class="op">);</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>create_view_stmt<span class="op">);</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>select_stmt<span class="op">);</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>delete_stmt<span class="op">);</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>update_stmt<span class="op">);</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>insert_stmt<span class="op">);</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Again <code>STMT_INIT</code> creates a binding between (e.g.) the AST type <code>delete_stmt</code> and the function <code>sem_delete_stmt</code>. This lets us dispatch any part of the AST directly.</p>
<p>Next we have expression types, these are set up with <code>EXPR_INIT</code>. Many of the operators require exactly the same kinds of verification so in order to be able to share the code, the expression analysis functions get an extra argument for the operator in question. Typically the string of the operator is only needed so make a good quality error message and validation is otherwise identical. Here are some samples…</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>num<span class="op">,</span> sem_expr_num<span class="op">,</span> <span class="st">&quot;NUM&quot;</span><span class="op">);</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>str<span class="op">,</span> sem_expr_str<span class="op">,</span> <span class="st">&quot;STR&quot;</span><span class="op">);</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>blob<span class="op">,</span> sem_expr_blob<span class="op">,</span> <span class="st">&quot;BLB&quot;</span><span class="op">);</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>null<span class="op">,</span> sem_expr_null<span class="op">,</span> <span class="st">&quot;NULL&quot;</span><span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>dot<span class="op">,</span> sem_expr_dot<span class="op">,</span> <span class="st">&quot;DOT&quot;</span><span class="op">);</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span><span class="dt">const</span><span class="op">,</span> sem_expr_const<span class="op">,</span> <span class="st">&quot;CONST&quot;</span><span class="op">);</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mul<span class="op">,</span> sem_binary_math<span class="op">,</span> <span class="st">&quot;*&quot;</span><span class="op">);</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mod<span class="op">,</span> sem_binary_integer_math<span class="op">,</span> <span class="st">&quot;%&quot;</span><span class="op">);</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>not<span class="op">,</span> sem_unary_logical<span class="op">,</span> <span class="st">&quot;NOT&quot;</span><span class="op">);</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>is_true<span class="op">,</span> sem_unary_is_true_or_false<span class="op">,</span> <span class="st">&quot;IS TRUE&quot;</span><span class="op">);</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>tilde<span class="op">,</span> sem_unary_integer_math<span class="op">,</span> <span class="st">&quot;~&quot;</span><span class="op">);</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>uminus<span class="op">,</span> sem_unary_math<span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Looking at the very first entry as an example we see that <code>EXPR_INIT</code> creates a mapping between the AST type <code>num</code> and the analysis function <code>sem_expr_num</code> and that function will get the text <code>"NUM"</code> as an extra argument.</p>
<p>Let’s quickly go over this list as these are the most important analyzers</p>
<ul>
<li><code>sem_expr_num</code> : analyzes any numeric constant</li>
<li><code>sem_expr_str</code> : analyzes any string literal or identifier</li>
<li><code>sem_expr_blob</code> : analyzes any blob literal</li>
<li><code>sem_expr_null</code> : analyzes the NULL literal (and nothing else)</li>
<li><code>sem_expr_dot</code> : analyzes a compound name like <code>T1.id</code></li>
<li><code>sem_expr_const</code> : analyzes a <code>const(...)</code> expression, doing the constant evaluation</li>
<li><code>sem_binary_math</code> : analyzes any normal binary math operator like ‘+’, ‘-’, ‘/’ etc.</li>
<li><code>sem_binary_integer_math</code> : analyzes any binary math operator where the operands must be integers like ‘%’ or ‘|’</li>
<li><code>sem_unary_logical</code> : analyzes any unary logical operator (the result is a bool), this is really only <code>NOT</code></li>
<li><code>sem_unary_is_true_or_false</code> : analyzes any of the <code>IS TRUE</code>, <code>IS FALSE</code>, family of postfix unary operators</li>
<li><code>sem_unary_integer_math</code> : any unary operator where the operand must be an integer, this is really only <code>~</code></li>
<li><code>sem_unary_math</code> : any math unary, presently only unary negation (but in the future unary <code>+</code> too)</li>
</ul>
<p>The final plentiful group of associations are for builtin functions, like these.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>changes<span class="op">);</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>printf<span class="op">);</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>strftime<span class="op">);</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>date<span class="op">);</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>time<span class="op">);</span></span></code></pre></div>
<p>Each of these is dispatched when a function call is found in the tree. By way of example <code>FUNC_INIT(changes)</code> causes the <code>changes</code> function to map to <code>sem__func_changes</code>.</p>
<p>There are a few other similar macros for more exotic cases but the general pattern should be clear now. We these in place it’s very easy to traverse arbitary statement lists and arbitary expressions with sub expressions and have the correct function be called without having large <code>switch</code> blocks all over.</p>
<h3 id="semantic-errors">Semantic Errors</h3>
<p>Some of the following examples will show the handling of semantic errors more precisely but the theory is pretty simple. Each of these analyzers that has been registered is responsible for putting an appropriate <code>sem_node</code> into the AST it was invoked on. The caller will look to see if that <code>sem_node</code> is of type <code>SEM_TYPE_ERROR</code> using <code>is_error(ast)</code>. If it is the caller will mark its own AST as errant using <code>record_error(ast)</code> and this continues all the way up the tree. The net of this is that wherever you begin semantic analysis you can know if there were any problems by checking for an error at the top of the tree you provided.</p>
<p>At the point of the initial error, the analyzer is expected to also call <code>report_error</code> providing a suitable message. This will be logged to stderr. In test mode it is also stored in the AST so that verification steps can confirm that errors were reported at exactly the right place.</p>
<p>If there is no error, then either a suitable <code>sem_node</code> is created or else at minimum <code>record_ok(ast)</code> is used to place the shared “OK” type on the node. The OK type indicates no type information but no errors either. “OK” is helpful for statements that don’t involve expressions like <code>DROP TABLE Foo</code>.</p>
<h3 id="the-primitive-types">The Primitive Types</h3>
<p>Perhaps the simplest analysis of all happens at the leaves of the AST. By way of example, here is the code for expression nodes of type <code>num</code>, the numeric literals.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Expression type for numeric primitives</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_expr_num<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR cstr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_num<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NUM_TYPE<span class="op">(</span>num_type<span class="op">,</span> ast<span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>num_type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> NUM_BOOL<span class="op">:</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_BOOL <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> NUM_INT<span class="op">:</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_INTEGER <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> NUM_LONG<span class="op">:</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_LONG_INTEGER <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">default</span><span class="op">:</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is all that&#39;s left</span></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">(</span>num_type <span class="op">==</span> NUM_REAL<span class="op">);</span></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_REAL <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As you can see the code simply looks at the AST node, confirming first that it is a <code>num</code> node. Then it extract the <code>num_type</code>. <code>ast-&gt;sem</code> is set to a semantic node of the matching type adding in <code>SEM_TYPE_NOTNULL</code> because literals are never null.</p>
<p>The <code>new_sem</code> function is used to make an empty <code>sem_node</code> with the <code>sem_type</code> filled in as specified. Nothing can go wrong creating a literal so there are no failure modes.</p>
<p>It doesn’t get much simpler unless maybe…</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Expression type for constant NULL</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_expr_null<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR cstr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_null<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// null literal</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_NULL<span class="op">);</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="unary-operators">Unary Operators</h3>
<p>Let’s dive in to a simple case – the unary operators. There are comparatively few and there isn’t much code required to handle them all.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The only unary math operators are &#39;-&#39; and &#39;~&#39;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Reference types are not allowed</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_unary_math<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  sem_t core_type<span class="op">,</span> combined_flags<span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_unary_prep<span class="op">(</span>ast<span class="op">,</span> <span class="op">&amp;</span>core_type<span class="op">,</span> <span class="op">&amp;</span>combined_flags<span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_validate_numeric<span class="op">(</span>ast<span class="op">,</span> core_type<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The result of unary math promotes to integer.  Basically this converts</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// bool to integer.  Long integer and Real stay as they are.  Text is</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// already ruled out.</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type_result <span class="op">=</span> sem_combine_types<span class="op">(</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>SEM_TYPE_INTEGER <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">),</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>core_type <span class="op">|</span> combined_flags<span class="op">));</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>sem_type_result<span class="op">);</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind <span class="op">=</span> ast<span class="op">-&gt;</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">;</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// note ast-&gt;sem-&gt;name is NOT propogated because SQLite doesn&#39;t let you refer to</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the column &#39;x&#39; in &#39;select -x&#39; -- the column name is actually &#39;-x&#39; which is useless</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so we have no name once you apply unary math (unless you use &#39;as&#39;)</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// hence ast-&gt;sem-&gt;name = ast-&gt;left-&gt;sem-&gt;name is WRONG here and it is not missing on accident</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>Unary Prep</em></p>
<p>OK already we need to pause, there is a “prep” pattern here common to most of the shared operators. This takes care of most of the normal error handling which is the same for all the unary operators. The same pattern happens in binary operators. Let’s take a look at that function.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The unary operators all have a similar prep to the binary.  We need</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to visit the left side (it&#39;s always the left node even if the operator goes on the right)</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">// if that&#39;s ok then we need the combined_flags and core type.  There is only</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co">// the one.  Returns true if everything is ok.</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_unary_prep<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t <span class="op">*</span>core_type<span class="op">,</span> sem_t <span class="op">*</span>combined_flags<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// op left | left op</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">))</span> <span class="op">{</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>core_type <span class="op">=</span> SEM_TYPE_ERROR<span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>combined_flags <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>  sem_node <span class="op">*</span>sem <span class="op">=</span> ast<span class="op">-&gt;</span>left<span class="op">-&gt;</span>sem<span class="op">;</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type <span class="op">=</span> sem<span class="op">-&gt;</span>sem_type<span class="op">;</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>core_type <span class="op">=</span> core_type_of<span class="op">(</span>sem_type<span class="op">);</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>combined_flags <span class="op">=</span> not_nullable_flag<span class="op">(</span>sem_type<span class="op">)</span> <span class="op">|</span> sensitive_flag<span class="op">(</span>sem_type<span class="op">);</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>is_unitary<span class="op">(*</span>core_type<span class="op">));</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Reviewing the steps:</p>
<ul>
<li>first evaluate the operand, it will be in <code>ast-&gt;left</code></li>
<li>if that’s an error, just return the error code from the prep steps</li>
<li>now that it’s not an error, pull the core type out of the operand</li>
<li>pull the not nullable and sensitive flag bits out of the operand</li>
<li>return a boolean indicating the presence of an error or not for convenience</li>
</ul>
<p>This is useful setup for all the unary operators, and as we’ll see, the binary operator case has a similar prep step.</p>
<p><em>Back to Unary Processing</em></p>
<p>Looking at the overall step we see:</p>
<ul>
<li><code>sem_unary_prep</code> : verifies that the operand is not an error, and gets its core type and flag bits</li>
<li><code>sem_validate_numeric</code> : verifies that the operand is a numeric type</li>
<li><code>sem_combine_types</code> : creates the smallest type that holds two compatible types
<ul>
<li>by combining with integer not null we ensure that the resulting type is at least as big as an integer</li>
<li>if the argument is of type <code>long</code> or <code>real</code> then it will be the bigger type and the resulting type will be <code>long</code> or <code>real</code></li>
<li>in short, <code>bool</code> is promoted to <code>int</code>, everything else stays the same</li>
<li><code>sem_combine_types</code> also combines the nullability and sensitivity appropriately</li>
</ul></li>
<li>a new <code>sem_node</code> is created of the combined type
<ul>
<li>the type kind of the operand is preserved (e.g. the <code>meters</code> in <code>real&lt;meters&gt;</code>)</li>
<li>any column alias or variable name is not preserved, the value is now anonymous</li>
</ul></li>
</ul>
<p>These primitives are designed to combine well, for instance, consider <code>sem_unary_integer_math</code>, the steps are</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_unary_integer_math<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  sem_unary_math<span class="op">(</span>ast<span class="op">,</span> op<span class="op">);</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  sem_reject_real<span class="op">(</span>ast<span class="op">,</span> op<span class="op">);</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_unary_math</code> : do all the above</li>
<li><code>sem_reject_real</code> : report/record an error if the type is <code>real</code> otherwise do nothing</li>
</ul>
<p>Note that in all cases the <code>op</code> string simply gets pushed down to the place where the errors happen. Let’s take a quick look at one of the sources of errors in the above. Here’s the numeric validator:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_validate_numeric<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t core_type<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_blob<span class="op">(</span>core_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0045: blob operand not allowed in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_object<span class="op">(</span>core_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0046: object operand not allowed in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_text<span class="op">(</span>core_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0047: string operand not allowed in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is pretty much dumb as rocks. The non-numeric types are blob, object, and text. There is a custom error for each type (it could have been shared but specific error messages seem to help users). This code doesn’t know it’s context, but all it needs is <code>op</code> to tell it what the numeric-only operator was and it can produce a nice error message. It leaves an error in the AST using <code>record_error</code> and so its caller can simply <code>return</code> if anything goes wrong.</p>
<p>It’s not hard to guess how <code>sem_reject_real</code> works:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Some math operators like &lt;&lt; &gt;&gt; &amp; | % only make sense on integers</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">// This function does the extra checking to ensure they do not get real values</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">// as arguments.  It&#39;s a post-pass after the normal math checks.</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_reject_real<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>is_error<span class="op">(</span>ast<span class="op">))</span> <span class="op">{</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    sem_t core_type <span class="op">=</span> core_type_of<span class="op">(</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>core_type <span class="op">==</span> SEM_TYPE_REAL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>      report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0001: operands must be an integer type, not real&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>      record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>if the AST node isn’t already an error, and it is of type real, report an error</li>
<li>it assumes the type is already known to be numeric</li>
<li>the pre-check for errors is to avoid double reporting if something has already gone wrong, the core type will be <code>SEM_TYPE_ERROR</code></li>
</ul>
<h3 id="binary-operators">Binary Operators</h3>
<h4 id="binary-prep">Binary Prep</h4>
<p>The code pretty much speaks for itself, we’ll walk through it</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// All the binary ops do the same preparation, they evaluate the left and the</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co">// right expression, then they check those for errors.  Then they need</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">// the types of those expressions and the combined_flags of the result.  This</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co">// does exactly that for its various callers.  Returns true if all is well.</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_binary_prep<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t <span class="op">*</span>core_type_left<span class="op">,</span> sem_t <span class="op">*</span>core_type_right<span class="op">,</span> sem_t <span class="op">*</span>combined_flags<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>left<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>right<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// left op right</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>left<span class="op">);</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>right<span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>left<span class="op">)</span> <span class="op">||</span> is_error<span class="op">(</span>right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>core_type_left <span class="op">=</span> SEM_TYPE_ERROR<span class="op">;</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>core_type_right <span class="op">=</span> SEM_TYPE_ERROR<span class="op">;</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>combined_flags <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>core_type_left <span class="op">=</span> core_type_of<span class="op">(</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>core_type_right <span class="op">=</span> core_type_of<span class="op">(</span>right<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>combined_flags <span class="op">=</span> combine_flags<span class="op">(</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">,</span> right<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>is_unitary<span class="op">(*</span>core_type_left<span class="op">));</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>is_unitary<span class="op">(*</span>core_type_right<span class="op">));</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_expr</code> is used to recursively walk the left and right nodes</li>
<li><code>is_error</code> checks if either had errors, if so, simply propogate the error</li>
<li>extract the left and right core types</li>
<li>combine nullability and sensitivity flags</li>
</ul>
<p>These are the standard prep steps, the caller now has the core types of left and right plus combined flags on a silver platter.</p>
<h4 id="example-is-or-is-not">Example: Is or Is Not</h4>
<p>This analyzer is the simplest of all the binaries</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// IS and IS NOT are special in that they return a not null boolean.</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_binary_is_or_is_not<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  sem_t core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> combined_flags<span class="op">;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_binary_prep<span class="op">(</span>ast<span class="op">,</span> <span class="op">&amp;</span>core_type_left<span class="op">,</span> <span class="op">&amp;</span>core_type_right<span class="op">,</span> <span class="op">&amp;</span>combined_flags<span class="op">))</span> <span class="op">{</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_compat<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the result of is or is not is always a bool and never null</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_BOOL <span class="op">|</span> SEM_TYPE_NOTNULL <span class="op">|</span> sensitive_flag<span class="op">(</span>combined_flags<span class="op">));</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_binary_prep</code> checks for errors in the left or right</li>
<li><code>sem_verify_compat</code> ensures that left and right operands are type compatible (discussed later)</li>
<li>the result is always of type <code>bool not null</code></li>
</ul>
<p>If either step goes wrong the error will naturally propogate.</p>
<h4 id="example-binary-math">Example: Binary Math</h4>
<p>This is the general worker for binary math operations, the most common operations like ‘+’, ‘-’, ’*’ and so forth.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// For all math operations, we combine the types and yield the type that</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">// holds both using the helper.  If any text, that&#39;s an error.</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_binary_math<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  sem_t core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> combined_flags<span class="op">;</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_binary_prep<span class="op">(</span>ast<span class="op">,</span> <span class="op">&amp;</span>core_type_left<span class="op">,</span> <span class="op">&amp;</span>core_type_right<span class="op">,</span> <span class="op">&amp;</span>combined_flags<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>error_any_object<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>error_any_blob_types<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>error_any_text_types<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>  sem_t core_type <span class="op">=</span> sem_combine_types<span class="op">(</span>core_type_left<span class="op">,</span> core_type_right<span class="op">);</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>  CSTR kind <span class="op">=</span> sem_combine_kinds<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">);</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>core_type <span class="op">|</span> combined_flags<span class="op">);</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind <span class="op">=</span> kind<span class="op">;</span></span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_binary_prep</code> checks for errors on the left or right</li>
<li><code>error_any_object</code> reports an error if the left or right is of type object</li>
<li><code>error_any_blob_types</code> reports an error if the left or right is of type blob</li>
<li><code>error_any_text_types</code> reports an error if the left or right is of type text</li>
<li><code>sem_combine_type</code> computes the combined type, the smallest numeric type that holds both left and right
<ul>
<li>note the operands are now known to be numeric</li>
<li>the three type error checkers give nice right errors about the left or right operand</li>
</ul></li>
<li><code>sem_combine_kinds</code> tries to create a single type <code>kind</code> for both operands
<ul>
<li>if their <code>kind</code> is incompatible, records an error on the right</li>
</ul></li>
<li><code>new_sem</code> creates a <code>sem_node</code> with the combined type, flags, and then the <code>kind</code> is set.</li>
</ul>
<p>At this point it might help to look a few more of the base validators, they are very unremarkable.</p>
<h4 id="example-validator-error_any_object">Example Validator: error_any_object</h4>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If either of the types is an object then produce an error on the ast.</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t error_any_object<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t core_type_left<span class="op">,</span> sem_t core_type_right<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_object<span class="op">(</span>core_type_left<span class="op">))</span> <span class="op">{</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0002: left operand cannot be an object in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_object<span class="op">(</span>core_type_right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">,</span> <span class="st">&quot;CQL0003: right operand cannot be an object in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>is_object</code> checks a <code>sem_type</code> against <code>SEM_TYPE_OBJECT</code></li>
<li>if left or right is an object an appropraite error is generated</li>
<li>there is no strong convention about returning <code>true</code> if ok or <code>true</code> if error, it’s pretty ad hoc
<ul>
<li>this doesn’t seem to cause a lot of problems</li>
</ul></li>
</ul>
<h4 id="example-validator-sem_combine_kinds">Example Validator: sem_combine_kinds</h4>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Here we check that type&lt;Foo&gt; only combines with type&lt;Foo&gt; or type.</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">// If there is a current object type, then the next item must match</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co">// If there is no such type, then an object type that arrives becomes the required type</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">// if they ever don&#39;t match record an error</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> CSTR sem_combine_kinds_general<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR kleft<span class="op">,</span> CSTR kright<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>kright<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>kleft<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>strcmp<span class="op">(</span>kleft<span class="op">,</span> kright<span class="op">))</span> <span class="op">{</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>        CSTR errmsg <span class="op">=</span> dup_printf<span class="op">(</span><span class="st">&quot;CQL0070: expressions of different kinds can&#39;t be mixed: &#39;%s&#39; vs. &#39;%s&#39;&quot;</span><span class="op">,</span> kright<span class="op">,</span> kleft<span class="op">);</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>        report_error<span class="op">(</span>ast<span class="op">,</span> errmsg<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kright<span class="op">;</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> kleft<span class="op">;</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a><span class="co">// helper to crack the ast nodes first and then call the normal comparisons</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> CSTR sem_combine_kinds<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR kright<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>  CSTR kleft <span class="op">=</span> ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">;</span></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sem_combine_kinds_general<span class="op">(</span>ast<span class="op">,</span> kleft<span class="op">,</span> kright<span class="op">);</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_combine_kinds</code> uses the worker <code>sem_combine_kinds_general</code> after extracting the <code>kind</code> from the left node
<ul>
<li>usually you already have one <code>kind</code> and you want to know if another <code>kind</code> is compatible hence this helper</li>
</ul></li>
<li><code>sem_combine_kinds_general</code> applies the general rules
<ul>
<li>NULL + NULL =&gt; NULL</li>
<li>NULL + x =&gt; x</li>
<li>x + NULL =&gt; x</li>
<li>x + x =&gt; x</li>
<li>x + y =&gt; error if x != y</li>
</ul></li>
<li>this is one of the rare functions that creates a dynamic error message</li>
</ul>
<h4 id="example-validator-is_numeric_compat">Example Validator : is_numeric_compat</h4>
<p>This helper is frequently called several times in the course of other semantic checks. This one produces no errors, that’s up to the caller. Often there is a numeric path and a non-numeric path so this helper can’t create the errors.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>cql_noexport bool_t is_numeric_compat<span class="op">(</span>sem_t sem_type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  sem_type <span class="op">=</span> core_type_of<span class="op">(</span>sem_type<span class="op">);</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sem_type <span class="op">&gt;=</span> SEM_TYPE_NULL <span class="op">&amp;&amp;</span> sem_type <span class="op">&lt;=</span> SEM_TYPE_REAL<span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It operates by checking the core type for the numeric range. Note that <code>NULL</code> is compatible with numerics because expressions like <code>NULL + 2</code> have meaning in SQL.</p>
<h4 id="example-validator-sem_combine_types">Example Validator : sem_combine_types</h4>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The second workhorse of semantic analysis, given two types that</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">// are previously known to be compatible, it returns the smallest type</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co">// that holds both.  If either is nullable the result is nullable.</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: in the few cases where that isn&#39;t true the normal algorithm for</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co">// nullablity result must be overrided (see coalesce for instance).</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> sem_t sem_combine_types<span class="op">(</span>sem_t sem_type_1<span class="op">,</span> sem_t sem_type_2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This beast is rather lengthy but unremarkable. It follows these rules: * text is only compatible with text * object is only compatible with object * blob is only compatible with blob * numerics are only compatible with any other numerics * NULL promotes the other operand, whatever it is * bool promotes to integer * integer promotes to long integer * long integer promotes to real * the combined type is the smallest numeric type according to the promotion rules</p>
<p>Some examples might be helpful:</p>
<ul>
<li>1 + 2L -&gt; long</li>
<li>false + 3.1 -&gt; real</li>
<li>2L + 3.1 -&gt; real</li>
<li>true + 2 -&gt; integer</li>
<li>‘x’ + 1 -&gt; not compatible</li>
</ul>
<p>Note that <code>sem_combine_types</code> assumes the types have already been checked for compatiblitiy and will use <code>Contract</code> to enforce this. You should be using other helpers like <code>is_numeric_compat</code> and friends to ensure the types agree before computing the combined type. A list of values that must be compatible with each other (e.g. in <code>needle IN (haystack)</code>) can be checked using <code>sem_verify_compat</code> repeatedly.</p>
<h4 id="example-validator-sem_verify_assignment">Example Validator : sem_verify_assignment</h4>
<p>The <code>sem_verify_assignment</code> function is use any time there is something like a logical <code>assignment</code> going on. There are two important cases:</p>
<ul>
<li><code>SET x := y</code> : an actual assignment</li>
<li><code>call foo(x)</code> : the expression <code>x</code> must be “assignable” to the formal variable for the argument of <code>foo</code></li>
</ul>
<p>This is a lot like normal binary operator compatibility with one extra rule. The expression must not be a bigger type than the target. i.e. you cannot assign a <code>long</code> to an <code>integer</code>.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This verifies that the types are compatible and that it&#39;s ok to assign</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co">// the expression to the variable.  In practice that means:</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable type core type and kind must be compatible with the expression core type and kind</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable must be nullable if the expression is nullable</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable must be sensitive if the assignment is sensitive</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable type must be bigger than the expression type</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Here ast is used only to give a place to put any errors.</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_verify_assignment<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t sem_type_needed<span class="op">,</span> sem_t sem_type_found<span class="op">,</span> CSTR var_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_compat<span class="op">(</span>ast<span class="op">,</span> sem_type_needed<span class="op">,</span> sem_type_found<span class="op">,</span> var_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_safeassign<span class="op">(</span>ast<span class="op">,</span> sem_type_needed<span class="op">,</span> sem_type_found<span class="op">,</span> var_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_nullable<span class="op">(</span>sem_type_found<span class="op">)</span> <span class="op">&amp;&amp;</span> is_not_nullable<span class="op">(</span>sem_type_needed<span class="op">))</span> <span class="op">{</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0013: cannot assign/copy possibly null expression to not null target&quot;</span><span class="op">,</span> var_name<span class="op">);</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>sensitive_flag<span class="op">(</span>sem_type_found<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>sensitive_flag<span class="op">(</span>sem_type_needed<span class="op">))</span> <span class="op">{</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0014: cannot assign/copy sensitive expression to non-sensitive target&quot;</span><span class="op">,</span> var_name<span class="op">);</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_verify_compat</code> checks for standard type compatibility between the left and the right</li>
<li><code>sem_verify_safeassign</code> checks that if the types are different the right operand is the smaller</li>
<li>nullability checks ensure you aren’t trying to assign a nullable value to a not null variable</li>
<li>sensitivity checks ensure you aren’t trying to assign a sensitive value to a not sensitive variable</li>
</ul>
<h3 id="simple-statement-validation">Simple Statement Validation</h3>
<p>With the expression building blocks, most of the usual kind of language statements become quite simple to check for correctness. It’s probably easiest to illustrate this with an example, let’s look at validation for the <code>WHILE</code> statement.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// While semantic analysis is super simple.</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">//  * the condition must be numeric</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co">//  * the statement list must be error-free</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co">//  * loop_depth is increased allowing the use of interior leave/continue</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_while_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_while_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>expr<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// WHILE [expr] </span><span class="re">BEGIN</span><span class="co"> [stmt_list] </span><span class="re">END</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>  sem_numeric_expr<span class="op">(</span>expr<span class="op">,</span> ast<span class="op">,</span> <span class="st">&quot;WHILE&quot;</span><span class="op">,</span> SEM_EXPR_CONTEXT_NONE<span class="op">);</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>expr<span class="op">))</span> <span class="op">{</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>stmt_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>    loop_depth<span class="op">++;</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>    sem_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>    loop_depth<span class="op">--;</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>stmt_list<span class="op">))</span> <span class="op">{</span></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>      record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a>  record_ok<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>first we pull out the tree parts we need using <code>EXTRACT</code> macros</li>
<li>the loop expression verified to be numeric</li>
<li>then the statement list is recursively validated</li>
</ul>
<p>Note: the while expression is one of the loop constructs which means <code>LEAVE</code> and <code>CONTINUE</code> are legal inside it, the <code>loop_depth</code> global tracks the fact that we are in a loop so that <code>LEAVE</code> and <code>CONTINUE</code> can report errors if we are not.</p>
<p>It’s not hard to imagine that <code>sem_stmt_list</code> will basically walk the AST, pulling out statements and dispatching them using the <code>STMT_INIT</code> tables previously discussed. Hence you could land right back in <code>sem_while_stmt</code> for a nested <code>WHILE</code>. It’s turtles all the way down.</p>
<p>If <code>SEM_EXPR_CONTEXT_NONE</code> is a mystery, don’t worry it’s covered in the next section.</p>
<h3 id="expression-contexts">Expression Contexts</h3>
<p>It turns out that in the SQL language some expression types are only valid in some parts of a SQL statement (e.g. aggregate functions can’t appear in a <code>LIMIT</code> clause) and so there is always a context for any numeric expression. When a new root expression is being evaluated, it sets the xpression context according to the caller.</p>
<p>The expression contexts are as follows:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_NONE           0x0001</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_WHERE          0x0004</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_ON             0x0008</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_HAVING         0x0010</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_LIMIT          0x0080</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_OFFSET         0x0100</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_TABLE_FUNC     0x0200</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_WINDOW         0x0400</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000</span></span></code></pre></div>
<p>The idea here is simple, you set the context bit that correponds to the current context such as <code>SEM_EXPR_CONTEXT_WHERE</code> if the expression is in the <code>WHERE</code> clause. The validators check this context, in particular anything that is only available in some contexts has a bit-mask of the context bits where it can be used. It checks the possibilities against the current context with one bitwise “and” operation. A zero result indicates that the operation is not valid in the current context.</p>
<p>This bitwise “and” is performed by one of these two helper macros which makes the usage a little clearer</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context &amp; (x)))</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context &amp; (x)))</span></span></code></pre></div>
<h4 id="expression-context-example-concat">Expression Context Example : Concat</h4>
<p>The concatenation operator <code>||</code> is challenging to successfully emulate because it does many different kinds of numeric conversions automatically. Rather than perenially getting this wrong, we simply do not support this operator in a context where SQLite isn’t going to be doing the concatenation. So typically you use “printf” instead to get your formatting done outside of a SQL state. The check for this is very simple and it happens of course in <code>sem_concat</code>.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>CURRENT_EXPR_CONTEXT_IS<span class="op">(</span>SEM_EXPR_CONTEXT_NONE<span class="op">))</span> <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0241: CONCAT may only appear in the context of a SQL statement&quot;</span><span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<h4 id="expression-context-example-in">Expression Context Example : IN</h4>
<p>A slightly more complex example happens processing the <code>IN</code> operator. This operator has two forms, the form with an expression list, which can be used anywhere, and the form with a select statement. The latter form can only appear in some sections of SQL and not at all in loose expressions. For instance, that form may not appear in the <code>LIMIT</code> or <code>OFFSET</code> sections of a SQLite statement.</p>
<p>We use this construct to get all the bits we like.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> valid <span class="op">=</span> SEM_EXPR_CONTEXT_SELECT_LIST</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_WHERE</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_ON</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_HAVING</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_TABLE_FUNC<span class="op">;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>CURRENT_EXPR_CONTEXT_IS_NOT<span class="op">(</span>valid<span class="op">))</span> <span class="op">{</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>      report_error<span class="op">(</span> ast<span class="op">,</span> <span class="st">&quot;CQL0078: [not] in (select ...) is only allowed inside &quot;</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>                         <span class="st">&quot;of select lists, where, on, and having clauses&quot;</span><span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>      record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>If the reader is interested in a simple learning exercise, run down the purpose of <code>SEM_EXPR_CONTEXT_TABLE_FUNC</code>, it’s simple but important and it only has one use case so it’s easy to find.</p>
<h3 id="name-resolution">Name Resolution</h3>
<p>We’ve gotten pretty far without talking about the elephant in the room: name resolution.</p>
<p>Like SQL, many statements in CQL have names in positions where the type of the name is completely unambiguous. For instance nobody could be confused what sort of symbol <code>Foo</code> is in <code>DROP INDEX Foo;</code></p>
<p>These are the easiest name resolutions, and there are a lot in this form. Let’s do an example</p>
<h4 id="example-index-name-resolution">Example: Index Name Resolution</h4>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is the basic checking for the drop index statement</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">// * the index must exist (have been declared) in some version</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co">// * it could be deleted now, that&#39;s ok, but the name has to be valid</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_drop_index_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_drop_index_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">);</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>index_ast <span class="op">=</span> find_usable_index<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">,</span>  <span class="st">&quot;CQL0112: index in drop statement was not declared&quot;</span><span class="op">);</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>index_ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>  record_ok<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Well, this is interesting. But what’s going on with <code>find_usable_index</code> what is usable? Why aren’t we just looking up the index name in some name table and that’s it. Let’s have a look at the details:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">// returns the node only if it exists and is not restricted by the schema region.</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> ast_node <span class="op">*</span>find_usable_index<span class="op">(</span>CSTR name<span class="op">,</span> ast_node <span class="op">*</span>err_target<span class="op">,</span> CSTR msg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>index_ast <span class="op">=</span> find_index<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>index_ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>err_target<span class="op">,</span> msg<span class="op">,</span> name<span class="op">);</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_validate_object_ast_in_current_region<span class="op">(</span>name<span class="op">,</span> index_ast<span class="op">,</span> err_target<span class="op">,</span> msg<span class="op">))</span> <span class="op">{</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> index_ast<span class="op">;</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We haven’t discussed schema regions yet but what you need to know about them for now is this: any piece of schema can be in a region and these can be nested. A region may depend on other regions. If this is done then the region may only use schema parts that are in its dependencies (transitively). The point of this is that you might have a rather large schema and you probably don’t want any peice of code to use any piece of schema. You can use regions to ensure that the code for feature “X” doesn’t try to use schema designed exclusively for feature “Y”.</p>
<p>So now <code>usable</code> simply means, we can find the name in the symbol table for indices that’s <code>find_index</code> and it is accessible by the current region.</p>
<p>If we had used an example requiring a table or a column the same considerations would apply however additionally tables can be deprecated with <code>@delete</code> so we might need additional checks to make sure we’re talking about a table, not a table’s tombstone.</p>
<p>In short, these cases just require looking up the entity and verifying that it’s accessible in the current context.</p>
<h4 id="flexible-name-resolution">Flexible Name Resolution</h4>
<p>The “hard case” for name resolution is where the name is occuring in an expression. Such a name might mean a lot of things. It could be a global variable, a local variable, an argument, a table column, a field in a cursor, and others. The general name resolution goes through several phases looking for the name. Each phase can either report an affirmative success or error (in which case the search stops), or it may simply report that the name was not found but the search should continue.</p>
<p>We can demystify this a bit by looking at the two most common ways to get this done.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Resolves a (potentially qualified) identifier, writing semantic information</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">// into `ast` if successful, or reporting and recording an error for `ast` if</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co">// not.</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_resolve_id<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR name<span class="op">,</span> CSTR scope<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_id<span class="op">(</span>ast<span class="op">)</span> <span class="op">||</span> is_ast_dot<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We have no use for `type` and simply throw it away.</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>type <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>  sem_resolve_id_with_type<span class="op">(</span>ast<span class="op">,</span> name<span class="op">,</span> scope<span class="op">,</span> <span class="op">&amp;</span>type<span class="op">);</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The name resolver works on either a vanilla name (e.g. <code>x</code>) or a scoped name (e.g. <code>T1.x</code>). The name and scope are provided. The <code>ast</code> parameter is used only as a place to report errors, there is no further cracking of the ast needed to resolve the name. As you can see <code>sem_resolve_id</code> just calls the more general function <code>sem_resolve_id_with_type</code> and is used in the most common case where you don’t need the sematic type info for the identifier.</p>
<p>Let’s move on to the “real” resolver.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This function is responsible for resolving both unqualified identifiers (ids)</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">// and qualified identifiers (dots). It performs the following two roles:</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co">// - If an optional `ast` is provided, it works the same way most semantic</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   analysis functions work: semantic information will be written into into the</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co">//   ast, errors will be reported to the user, and errors will be recorded in</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="co">//   the AST.</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a><span class="co">// - `*typr_ptr` will be set to mutable type (`sem_t *`) in the current</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="co">//   environment if the identifier successfully resolves to a type. (There are,</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="co">//   unfortunately, a few exceptions in which a type will be successfully</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="co">//   resolved and yet `*typr_ptr` will not be set. These include when a cursor</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="co">//   in an expression position, when the expression is `rowid` (or similar), and</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="co">//   when the id resolves to an enum case. The reason no mutable type is</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a><span class="co">//   returned in these cases is that a new type is allocated as part of semantic</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="co">//   analysis, and there exists no single, stable type in the environment to</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a><span class="co">//   which a pointer could be returned. This is a limitation of this function,</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a><span class="co">//   albeit one that&#39;s currently not problematic.)</span></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  Resolution is attempted in the order that the `sem_try_resolve_*` functions</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a><span class="co">//  appear in the `resolver` array. Each takes the same arguments: An (optional)</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a><span class="co">//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a><span class="co">//  identifier provided to one of these resolvers is resolved successfully, *or*</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a><span class="co">//  if the correct resolver was found but there was an error in the program,</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a><span class="co">//  `SEM_RESOLVE_STOP` is returned and resolution is complete, succesful or not.</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a><span class="co">//  If a resolver is tried and it determines that it is not the correct resolver</span></span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a><span class="co">//  for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned and the</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a><span class="co">//  next resolver is tried.</span></span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a><span class="co">// This function should not be called directly. If one is interested in</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a><span class="co">// performing semantic analysis, call `sem_resolve_id` (or, if within an</span></span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a><span class="co">// expression, `sem_resolve_id_expr`). Alternatively, if one wants to get a</span></span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a><span class="co">// mutable type from the environment, call `find_mutable_type`.</span></span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_resolve_id_with_type<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR name<span class="op">,</span> CSTR scope<span class="op">,</span> sem_t <span class="op">**</span>type_ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>type_ptr<span class="op">);</span></span>
<span id="cb67-37"><a href="#cb67-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-38"><a href="#cb67-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>type_ptr <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb67-39"><a href="#cb67-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-40"><a href="#cb67-40" aria-hidden="true" tabindex="-1"></a>  sem_resolve <span class="op">(*</span>resolver<span class="op">[])(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR<span class="op">,</span> CSTR<span class="op">,</span> sem_t <span class="op">**)</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb67-41"><a href="#cb67-41" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_arguments<span class="op">,</span></span>
<span id="cb67-42"><a href="#cb67-42" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_column<span class="op">,</span></span>
<span id="cb67-43"><a href="#cb67-43" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_rowid<span class="op">,</span></span>
<span id="cb67-44"><a href="#cb67-44" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_cursor_as_expression<span class="op">,</span></span>
<span id="cb67-45"><a href="#cb67-45" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_variable<span class="op">,</span></span>
<span id="cb67-46"><a href="#cb67-46" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_enum<span class="op">,</span></span>
<span id="cb67-47"><a href="#cb67-47" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_cursor_field<span class="op">,</span></span>
<span id="cb67-48"><a href="#cb67-48" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_arg_bundle<span class="op">,</span></span>
<span id="cb67-49"><a href="#cb67-49" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb67-50"><a href="#cb67-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-51"><a href="#cb67-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>resolver<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">void</span> <span class="op">*);</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb67-52"><a href="#cb67-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>resolver<span class="op">[</span>i<span class="op">](</span>ast<span class="op">,</span> name<span class="op">,</span> scope<span class="op">,</span> type_ptr<span class="op">)</span> <span class="op">==</span> SEM_RESOLVE_STOP<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-53"><a href="#cb67-53" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb67-54"><a href="#cb67-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-55"><a href="#cb67-55" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb67-56"><a href="#cb67-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-57"><a href="#cb67-57" aria-hidden="true" tabindex="-1"></a>  report_resolve_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0069: name not found&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb67-58"><a href="#cb67-58" aria-hidden="true" tabindex="-1"></a>  record_resolve_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb67-59"><a href="#cb67-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A lot is well described in the comments, but already we can see the structure. There are “mini-resolvers” which are attempted in order</p>
<ul>
<li><code>sem_try_resolve_arguments</code> : an argument in the argument list</li>
<li><code>sem_try_resolve_column</code> : a column name (possibly scoped)</li>
<li><code>sem_try_resolve_rowid</code> : the virtual rowid column (possibly scoped)</li>
<li><code>sem_try_resolve_cursor_as_expression</code> : use of a cursor as a boolean, the bool is true if the cursor has data</li>
<li><code>sem_try_resolve_variable</code> : local or global variables</li>
<li><code>sem_try_resolve_enum</code> : the constant value of an enum (must be scoped)</li>
<li><code>sem_try_resolve_cursor_field</code> : a field in a cursor (must be scoped)</li>
<li><code>sem_try_resolve_arg_bundle</code> : a field in an argument bundle (must be scoped)</li>
</ul>
<p>These all use this enum to communicate progress:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="co">// indicate that the correct resolver was found. Continuing implies that no</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="co">// failure has (yet) occurred, but stopping implies neither success nor failure.</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>  SEM_RESOLVE_CONTINUE <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>  SEM_RESOLVE_STOP <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_resolve<span class="op">;</span></span></code></pre></div>
<p>Each of these mini-resolvers will have a series of rules, for example <code>sem_try_resolve_cursor_field</code> is going to have to do something like this:</p>
<ul>
<li>if there is no scope it can’t be a cursor field, return <code>CONTINUE</code></li>
<li>if the scope is not the name of a cursor, return <code>CONTINUE</code></li>
<li>if the name is a field in the cursor, return <code>STOP</code> with success</li>
<li>else, report that the name is not a valid member of the cursor, and return <code>STOP</code> with an error</li>
</ul>
<p>All the mini-resolvers are similarly structured:</p>
<ul>
<li>if it’s not my case, return <code>CONTINUE</code></li>
<li>if it is my case return <code>STOP</code> with an error as appropriate</li>
</ul>
<p>Some of the resolvers have quite a few steps but any one resolver is only about a screenful of code and it does one job.</p>
<h3 id="structure-types-and-the-notion-of-shapes">Structure types and the notion of Shapes</h3>
<p>Earlier we discussed <code>SEM_TYPE_STRUCT</code> briefly and recall the basic notion of the <code>structure</code> type</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for tables and views and the result of a select</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_struct <span class="op">{</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  CSTR struct_name<span class="op">;</span>               <span class="co">// struct name</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of fields</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// field names</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>kinds<span class="op">;</span>                    <span class="co">// the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>semtypes<span class="op">;</span>                <span class="co">// typecode for each field</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_struct<span class="op">;</span></span></code></pre></div>
<p>The structure is nothing more than an array of names, types and kinds with a count. But it creates the notion of what’s usually called a “shape” in the codebase. Shapes can be used in a variety of ways as is described in <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms">Chapter 5</a> of the CQL Guide. But before we get into shapes, let’s look at an example of how a structure type is created.</p>
<p>The code that follows is the back end of <code>sem_create_table_stmt</code>. At this point the bulk of the analysis is done and the columns all have their types. We’re about to build the struct type for the table. Let’s see how that goes.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// now create a struct type with the correct number of columns</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the types have already been computed so all we have to do is</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// check for duplicates</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  sem_struct <span class="op">*</span>sptr <span class="op">=</span> new_sem_struct<span class="op">(</span>name<span class="op">,</span> cols<span class="op">);</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>columns <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>ast_node <span class="op">*</span>item <span class="op">=</span> col_key_list<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">(</span>is_ast_col_key_list<span class="op">(</span>item<span class="op">));</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>def<span class="op">,</span> item<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_ast_col_def<span class="op">(</span>def<span class="op">))</span> <span class="op">{</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>      Invariant<span class="op">(</span>def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>      Invariant<span class="op">(</span>col <span class="op">&lt;=</span> cols<span class="op">);</span>  <span class="co">// it&#39;s possible that the rest are deleted and we&#39;re at the end.</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">// columns must be unique, including deleted columns</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(!</span>symtab_add<span class="op">(</span>columns<span class="op">,</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">,</span> NULL<span class="op">))</span> <span class="op">{</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>        EXTRACT_NOTNULL<span class="op">(</span>col_def_type_attrs<span class="op">,</span> def<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>        EXTRACT_NOTNULL<span class="op">(</span>col_def_name_type<span class="op">,</span> col_def_type_attrs<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>        EXTRACT_ANY_NOTNULL<span class="op">(</span>col_def_ast<span class="op">,</span> col_def_name_type<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>        report_error<span class="op">(</span>col_def_ast<span class="op">,</span> <span class="st">&quot;CQL0142: duplicate column name&quot;</span><span class="op">,</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a>        record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a>        symtab_delete<span class="op">(</span>columns<span class="op">);</span></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> cleanup<span class="op">;;</span></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>is_deleted<span class="op">(</span>def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-33"><a href="#cb70-33" aria-hidden="true" tabindex="-1"></a>      Invariant<span class="op">(</span>col <span class="op">&lt;</span> cols<span class="op">);</span></span>
<span id="cb70-34"><a href="#cb70-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-35"><a href="#cb70-35" aria-hidden="true" tabindex="-1"></a>      sptr<span class="op">-&gt;</span>names<span class="op">[</span>col<span class="op">]</span> <span class="op">=</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">;</span></span>
<span id="cb70-36"><a href="#cb70-36" aria-hidden="true" tabindex="-1"></a>      sptr<span class="op">-&gt;</span>semtypes<span class="op">[</span>col<span class="op">]</span> <span class="op">=</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">;</span></span>
<span id="cb70-37"><a href="#cb70-37" aria-hidden="true" tabindex="-1"></a>      sptr<span class="op">-&gt;</span>kinds<span class="op">[</span>col<span class="op">]</span> <span class="op">=</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">;</span></span>
<span id="cb70-38"><a href="#cb70-38" aria-hidden="true" tabindex="-1"></a>      col<span class="op">++;</span></span>
<span id="cb70-39"><a href="#cb70-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-40"><a href="#cb70-40" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb70-41"><a href="#cb70-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-42"><a href="#cb70-42" aria-hidden="true" tabindex="-1"></a>  symtab_delete<span class="op">(</span>columns<span class="op">);</span></span>
<span id="cb70-43"><a href="#cb70-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-44"><a href="#cb70-44" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>col <span class="op">==</span> cols<span class="op">);</span></span>
<span id="cb70-45"><a href="#cb70-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-46"><a href="#cb70-46" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_STRUCT<span class="op">);</span></span>
<span id="cb70-47"><a href="#cb70-47" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr <span class="op">=</span> sptr<span class="op">;</span></span>
<span id="cb70-48"><a href="#cb70-48" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>jptr <span class="op">=</span> sem_join_from_sem_struct<span class="op">(</span>sptr<span class="op">);</span></span>
<span id="cb70-49"><a href="#cb70-49" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region <span class="op">=</span> current_region<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>new_sem_struct</code> makes a struct to hold the result, we already have the count of columns and the table name</li>
<li><code>symtab_new</code> is going to gives us a scratch symbol table so we can check for duplicate column names</li>
<li>we walk all the items in the table and use <code>is_ast_col_def(def)</code> to find the column definitions</li>
<li><code>Invariant(def-&gt;sem-&gt;name)</code> claims that we must have already computed the semantic info for the column and it has its name populated
<ul>
<li>this was done earlier</li>
</ul></li>
<li><code>symtab_add(columns, def-&gt;sem-&gt;name, NULL)</code> adds a nil entry under the column name, if this fails we have a duplicate column
<ul>
<li>in which case we report errors and stop</li>
</ul></li>
<li><code>is_deleted</code> tells us if the column was marked with <code>@delete</code> in which case it no longer counts as part of the table</li>
<li>if all this is good we set the <code>names</code>, <code>kinds</code>, and <code>semtypes</code> from the column definition’s semnatic info</li>
<li><code>symtab_delete</code> cleans up the temporary symbol table</li>
<li>and finally we create a <code>sem_node</code> of type <code>SEM_TYPE_STRUCT</code> and fill it in</li>
<li><code>sem_join_from_sem_struct</code> will be discussed shortly, but it creates a jptr with one table in it</li>
</ul>
<p>Structure types are often rooted in the shape of a table, but other things can create a structure type. For instance, the columns of a view, or any select statement are also described by a structure type and are therefore valid “shapes”. The return type of a procedure usually comes from a <code>SELECT</code> statement so the procedure too can be the source of a shape. The arguments of a procedure form a shape. The fields of a cursor form a shape. You can even have a named subset of the arguments of a procedure and use them like a shape. All of these things are described by structure types.</p>
<h4 id="shapes-and-the-like-construct">Shapes and the LIKE construct</h4>
<p>There are many cases where you want to be able to capture or re-use something with a known shape and you don’t want to have to fully re-declare the thing. CQL uses the <code>LIKE</code> construct to do these sorts of things. This is more fully explained in <a href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms">Chapter 5</a> of the Guide, but for now let’s look at two different cases that are of interest.</p>
<p>First, a cursor:</p>
<pre><code>DECLARE C CURSOR LIKE Foo;  -- Foo something with a shape</code></pre>
<p>So, in the above, Foo could be a table, a view, a procedure with a result, another cursor, and so forth.</p>
<p>How might we do this? This is the business of <code>sem_declare_cursor_like_name</code></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Here we&#39;re going to make a new value cursor using the indicated name for the shape.</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="co">// The name has to be &quot;likeable&quot; meaning it refers to some named thing with a shape</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="co">// such as a table, a view, another cursor, or a procedure that returns a result set.</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="co">// These are the so called &quot;value cursors&quot; in that they have no underlying statement</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="co">// that they move through.  You can just load them up with a row and pass them around.</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_declare_cursor_like_name<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_declare_cursor_like_name<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>new_cursor_ast<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>new_cursor_name<span class="op">,</span> new_cursor_ast<span class="op">);</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>like_ast<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> like_ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>like_name<span class="op">,</span> name_ast<span class="op">);</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// no duplicates allowed</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_legal_variable_name<span class="op">(</span>ast<span class="op">,</span> new_cursor_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>new_cursor_ast<span class="op">);</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// must be a valid shape</span></span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>found_shape <span class="op">=</span> sem_find_likeable_ast<span class="op">(</span>like_ast<span class="op">,</span> LIKEABLE_FOR_VALUES<span class="op">);</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>found_shape<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// good to go, make our cursor, with storage.</span></span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>  name_ast<span class="op">-&gt;</span>sem <span class="op">=</span> like_ast<span class="op">-&gt;</span>sem <span class="op">=</span> found_shape<span class="op">-&gt;</span>sem<span class="op">;</span></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>  new_cursor_ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_STRUCT <span class="op">|</span> SEM_TYPE_VARIABLE <span class="op">|</span> SEM_TYPE_VALUE_CURSOR <span class="op">|</span> SEM_TYPE_HAS_SHAPE_STORAGE<span class="op">);</span></span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>  new_cursor_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr <span class="op">=</span> found_shape<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr<span class="op">;</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  new_cursor_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name <span class="op">=</span> new_cursor_name<span class="op">;</span></span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_cursor_ast<span class="op">-&gt;</span>sem<span class="op">;</span></span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>  symtab_add<span class="op">(</span>current_variables<span class="op">,</span> new_cursor_name<span class="op">,</span> new_cursor_ast<span class="op">);</span></span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>EXTRACT</code> the pieces we need from the AST</li>
<li><code>sem_verify_legal_variable_name</code> makes sure the cursor name is unique and doesn’t hide a table name</li>
<li><code>sem_find_likeable_ast</code> searches for something with a suitable name that has a shape</li>
<li>re-use the semantic type of what we found in the name node</li>
<li>make a new <code>sem_node</code> for the cursor variable</li>
<li>use the <code>sptr</code> from the discovered shape for the type</li>
</ul>
<p>Note: <code>name_ast-&gt;sem</code> isn’t actually interesting but it is helpful for debugging and if the AST is printed it shows the original unmodified semantic type on those nodes.</p>
<p>Briefly <code>sem_find_likeable_ast</code> does these steps:</p>
<ul>
<li>if the right of the <code>LIKE</code> refers to procedure arguments (e.g. C LIKE Foo ARGUMENTS), get the args of the named procedure and use them as a shape</li>
<li>if the right is a local or global, and its a cursor, use the shape of that cursor for the new cursor</li>
<li>if the right is the name of an argument bundle, use the shape of the bundle
<ul>
<li>e.g. in <code>CREATE PROC Foo(p1 like Person, p2 like Person)</code> <code>p1</code> and <code>p2</code> are the names of argument bundles shaped like <code>Person</code></li>
</ul></li>
<li>if the right is the name of a table or view, use that shape</li>
<li>if the right is the name of a procedure with a structure result, use that shape</li>
<li>if it’s none of these, produce an error</li>
</ul>
<p>This is the primary source of shape reuse. Let’s look at how we might use that. Suppose we want to write a procedure that inserts a row into the table <code>Foo</code>. We could certainly list the columns of <code>Foo</code> as arguments like this:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC InsertIntoFoo(<span class="kw">id</span> <span class="dt">integer</span>, t text, r <span class="dt">real</span>, b <span class="dt">blob</span>)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">INSERT</span> <span class="kw">INTO</span> Foo(<span class="kw">id</span>, t, r, b) <span class="kw">VALUES</span>(<span class="kw">id</span>, t, r, b);</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>That is going to get a lot less exciting when there are lots of columns and it will be increasingly a maintenance headach.</p>
<p>Compare with</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC InsertIntoFoo(<span class="kw">row</span> <span class="kw">LIKE</span> Foo)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">INSERT</span> <span class="kw">INTO</span> Foo <span class="kw">FROM</span> <span class="kw">row</span>;</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>These two things compile into the same code. The semantic analyzer expands the <code>(row LIKE Foo)</code> into <code>(row_id integer, row_t text, row_r real, row_b blob)</code> and then replaces <code>FROM row</code> with <code>(row_id, row_t, row_r, row_b)</code>. In both case it simply looked up the shape using <code>sem_find_likeable_ast</code> and then altered the AST to the canonical pattern. This kind of “shape sugar” is all over CQL and greatly increases maintainability while eliminating common errors. The most common operation is simply to expland a “shape” into a list of arguments or columns (maybe with or without type). SQLite doesn’t know any of this shape magic so by the time SQLite sees the code it has to look “normal” – the shapes are all resolved.</p>
<h3 id="join-types">Join Types</h3>
<p>The last of the type building data structure is the join type. Recall that we have this shape:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for the data type of (parts of) the FROM clause</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="co">// sometimes I refer to as a &quot;joinscope&quot;</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_join <span class="op">{</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of table/views in the join</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// names of the table/view</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_struct <span class="op">**</span>tables<span class="op">;</span>     <span class="co">// struct type of each table/view</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_join<span class="op">;</span></span></code></pre></div>
<p>This is an array of named structure types, which is exactly what you get when you do something like this</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span> <span class="op">*</span> <span class="kw">from</span> T1 <span class="kw">INNER</span> <span class="kw">JOIN</span> T2;</span></code></pre></div>
<p>The result has all of the columns of T1 and all of the columns of T2. They can be referred to with scoped names like <code>T1.x</code> which means “find the <code>sptr</code> corresponding to the name <code>T1</code> then within that structure find the column named <code>x</code>”. In general, when we join, we take a <code>jptr</code> on the left and concatenate it with a <code>jptr</code> on the right. And for all this to work we have to start somewhere, usually single tables. As we saw when we make a table we use <code>sem_join_from_sem_struct</code> to make its initial <code>jptr</code>. Let’s have a look at that now.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a base join type from a single struct.</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> sem_join <span class="op">*</span>sem_join_from_sem_struct<span class="op">(</span>sem_struct <span class="op">*</span>sptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>  sem_join <span class="op">*</span>jptr <span class="op">=</span> new_sem_join<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>  jptr<span class="op">-&gt;</span>names<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> sptr<span class="op">-&gt;</span>struct_name<span class="op">;</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>  jptr<span class="op">-&gt;</span>tables<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> new_sem_struct_strip_table_flags<span class="op">(</span>sptr<span class="op">);</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> jptr<span class="op">;</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It doesn’t get much simpler than the above:</p>
<ul>
<li><code>new_sem_join</code> gives us an empty <code>sem_join</code> with room for 1 table</li>
<li>we use the struct name for the name and the table’s <code>sptr</code> for the shape</li>
<li><code>new_sem_struct_strip_table_flags</code> copies the table’s <code>sptr</code> keeping only the essential flags
<ul>
<li><code>SEM_TYPE_HIDDEN_COL</code></li>
<li><code>SEM_FLAG_NOTNULL</code></li>
<li><code>SEM_FLAG_SENSITIVE</code></li>
</ul></li>
</ul>
<p>The other flags (e.g. <code>SEM_TYPE_PK</code>) have no value in doing type checking and were only needed to help validate the table itself. They would be harmless but they would also contaminate all of the debug output so they are stripped. As a result the type of columns as they appear in say <code>SELECT</code> statements is simpler than how they appear in a <code>CREATE TABLE</code> statement.</p>
<p>When we need to create a new join type we simply (*) make a new join type that is the concatenation of the left and right parts of the join.</p>
<ul>
<li>some join types change the nullability of columns like <code>LEFT JOIN</code> so we have to handle that too</li>
<li>the names of the table in the new joinscope have to be unique so there is also error checking to do</li>
<li>but basically it’s just a concat…</li>
</ul>
<p>Importantly, we call the thing a “joinscope” because it creates a namespace. When we are evaluating names inside of the <code>FROM</code> clause or even later in say a <code>WHERE</code> clause, the joinscope that we have created so far controls the same of <code>table.column</code> combinations you can use in expressions. This changes again when there is a subquery, so the joinscopes can be pushed and popped as needed.</p>
<p>By way of example, you’ll see these two patterns in the code:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>  PUSH_JOIN<span class="op">(</span>from_scope<span class="op">,</span> select_from_etc<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>jptr<span class="op">);</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  error <span class="op">=</span> sem_select_orderby<span class="op">(</span>select_orderby<span class="op">);</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  POP_JOIN<span class="op">();</span></span></code></pre></div>
<ul>
<li>use the <code>jptr</code> from the <code>FROM</code> clause to put things back in scope for the <code>ORDER BY</code> clause</li>
</ul>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>  PUSH_JOIN_BLOCK<span class="op">();</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  sem_numeric_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> ast<span class="op">,</span> <span class="st">&quot;LIMIT&quot;</span><span class="op">,</span> SEM_EXPR_CONTEXT_LIMIT<span class="op">);</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  POP_JOIN<span class="op">();</span></span></code></pre></div>
<ul>
<li><code>PUSH_JOIN_BLOCK</code> causes the name search to stop, nothing deeper in the stack is searched</li>
<li>in this case we do not allow <code>LIMIT</code> expressions to see any joinscopes, they may not use any columns.
<ul>
<li>even if the <code>LIMIT</code> clause is appearing in a subquery it can’t refer to columns in the parent query.</li>
</ul></li>
</ul>
</body>
</html>
