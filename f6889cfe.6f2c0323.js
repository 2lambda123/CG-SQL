(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{143:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return o})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return u}));var n=a(2),r=a(6),l=(a(0),a(153)),s=["components"],i={id:"ch14",title:"Chapter 14: CQL Query Fragments",sidebar_label:"Chapter 14: CQL Query Fragments"},o={unversionedId:"ch14",id:"ch14",isDocsHomePage:!1,title:"Chapter 14: CQL Query Fragments",description:"\x3c!---",source:"@site/../CQL_Guide/ch14.md",slug:"/ch14",permalink:"/cql-guide/ch14",version:"current",lastUpdatedBy:"CodemodService Bot",lastUpdatedAt:1640960975,sidebar_label:"Chapter 14: CQL Query Fragments",sidebar:"someSidebar",previous:{title:"Chapter 13: JSON Output",permalink:"/cql-guide/ch13"},next:{title:"Appendix 1: Command Line Options",permalink:"/cql-guide/x1"}},c=[{value:"Base Query Fragments",id:"base-query-fragments",children:[]},{value:"Extension Query Fragments",id:"extension-query-fragments",children:[]},{value:"Shared Fragments",id:"shared-fragments",children:[]},{value:"Shared Fragments with Conditionals",id:"shared-fragments-with-conditionals",children:[]}],b={rightToc:c};function u(e){var t=e.components,a=Object(r.a)(e,s);return Object(l.b)("wrapper",Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,'CQL Query fragments are the most sophisticated rewrite CQL offers for productivity.  The idea is that a very large query\ncan be represented in "fragments" that add columns or add rows based on the original "core" query.  The final query\nwill be an assembled rewrite of all the fragments chained together.  Specifically, the motivation for this is that you\ncan have a "core" query that fetches the essential columns for some UI design and then you can add query extension\nfragments that add new/additional columns for some new set of features.  The core and extended columns can be in their\nown fragment and they can be compiled independently.  The result of this is that any errors are in much smaller\nand easier to understand fragments rather than in some monster "fetch everything" query;  any given extension does not\nhave to know all the details of all the other extensions and can take a limited dependency on even the core query.'),Object(l.b)("p",null,"It's easiest to illustrate this with an example so let's begin there."),Object(l.b)("p",null,"Let's first start with this very simple schema."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"create table my_table(\n id integer primary key,\n name text not null,\n rate real not null\n);\n\ncreate table added_rows(\n like my_table -- sugar to duplicate the columns of my_table\n);\n\ncreate table added_columns(\n id integer references my_table(id),\n data text\n);\n\n")),Object(l.b)("p",null,"Typically there would be a lot more columns but where you see ",Object(l.b)("inlineCode",{parentName:"p"},"flag1")," and ",Object(l.b)("inlineCode",{parentName:"p"},"flag2")," appear in fragments you can imagine any number\nof additional columns of any type.  So we can keep the examples simple."),Object(l.b)("h3",{id:"base-query-fragments"},"Base Query Fragments"),Object(l.b)("p",null,"The base fragment might look something like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"@attribute(cql:base_fragment=base_frag)\ncreate proc base_frag_template(id_ integer not null)\nbegin\n  with\n    base_frag(*) as (select * from my_table where my_table.id = id_)\n    select * from base_frag;\nend;\n")),Object(l.b)("p",null,"Here are the essential aspects:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the base fragment is given a name, it can be anything, probably something that describes the purpose of the fragments"),Object(l.b)("li",{parentName:"ul"},"the procedure name can be anything at all"),Object(l.b)("li",{parentName:"ul"},"the procedure must consist of exactly one ",Object(l.b)("inlineCode",{parentName:"li"},"with...select")," statement"),Object(l.b)("li",{parentName:"ul"},"the fragment name must be the one and only CTE in the select statement"),Object(l.b)("li",{parentName:"ul"},"you must select all the columns from the CTE")),Object(l.b)("p",null,"Note the syntax helper ",Object(l.b)("inlineCode",{parentName:"p"},"base_frag(*)")," is just shorthand to avoid retyping all the column names of ",Object(l.b)("inlineCode",{parentName:"p"},"my_table"),"."),Object(l.b)("p",null,"The interesting part is ",Object(l.b)("inlineCode",{parentName:"p"},"(select * from my_table where my_table.id = id_)")," which could have been any select statement\nof your choice. Everything else in the procedure must follow the designated format, and the format is enforced due to\nthe presence of ",Object(l.b)("inlineCode",{parentName:"p"},"@attribute(cql:base_fragment=base_frag)"),"."),Object(l.b)("p",null,"The point of putting everything on rails like this is that all base fragments will look the same and it will be clear how to transform any base fragment into the final query when it is assembled with its extensions."),Object(l.b)("p",null,"Note: the base fragment produces no codegen at all.  There is no ",Object(l.b)("inlineCode",{parentName:"p"},"base_frag_template")," procedure in the output.  This is just a template.  Also, the name of the procedure cannot be ",Object(l.b)("inlineCode",{parentName:"p"},"base_frag")," this name will be used by the assembly fragment later.  Really any descriptive unique name will do since the name does not appear in the output at all."),Object(l.b)("h3",{id:"extension-query-fragments"},"Extension Query Fragments"),Object(l.b)("h4",{id:"adding-columns"},"Adding Columns"),Object(l.b)("p",null,"The most common thing that an extension might want to do is add columns to the result.  There can be any number of such extensions in the final assembly.  Here's a simple example that adds one column."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'@attribute(cql:extension_fragment=base_frag)\ncreate proc adds_columns(id_ integer not null)\nbegin\n  with\n    base_frag(*) as (select 1 id, "name" name, 1.0 rate),\n    col_adder_frag(*) as (\n    select base_frag.*, added_columns.data\n      from base_frag\n      left outer join added_columns on base_frag.id = added_columns.id)\n  select * from col_adder_frag;\nend;\n')),Object(l.b)("p",null,"Again there are some important features to this extension and they are largely completely constrained, i.e. you must follow the pattern."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the attribute indicates ",Object(l.b)("inlineCode",{parentName:"li"},"extension_fragment")," and the name (here ",Object(l.b)("inlineCode",{parentName:"li"},"base_frag"),") must have been previously declared in a ",Object(l.b)("inlineCode",{parentName:"li"},"base_fragment")),Object(l.b)("li",{parentName:"ul"},"the procedure name can be any unique name other than ",Object(l.b)("inlineCode",{parentName:"li"},"base_frag"),", it corresponds to this particular extension's purpose"),Object(l.b)("li",{parentName:"ul"},"the procedure arguments must be identical to those in the base fragment"),Object(l.b)("li",{parentName:"ul"},"the first CTE must match the ",Object(l.b)("inlineCode",{parentName:"li"},"base_fragment")," attribute value, ",Object(l.b)("inlineCode",{parentName:"li"},"base_frag")," in this case"),Object(l.b)("li",{parentName:"ul"},"you do not need to repeat the full select statement for ",Object(l.b)("inlineCode",{parentName:"li"},"base_frag"),", any surrogate with the same column names and types will do",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the base fragment code might include a #define to make this easier",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. ",Object(l.b)("inlineCode",{parentName:"li"},'#define base_frags_core as base_frag(*) as (select 1 id, "name" name, 1.0 rate)')))),Object(l.b)("li",{parentName:"ul"},"doing so will make maintenance easier if new columns are added to the base fragment"))),Object(l.b)("li",{parentName:"ul"},"there must be exactly one additional CTE",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"it may have any unique descriptive name you like"),Object(l.b)("li",{parentName:"ul"},"it must begin with ",Object(l.b)("inlineCode",{parentName:"li"},"select base_frags.*")," with the appropriate CTE name matching the base fragment CTE"),Object(l.b)("li",{parentName:"ul"},"it must add at least one column (or it would be uninteresting)"),Object(l.b)("li",{parentName:"ul"},"it may not have any clause other than the first ",Object(l.b)("inlineCode",{parentName:"li"},"from")," (e.g. no ",Object(l.b)("inlineCode",{parentName:"li"},"where"),", ",Object(l.b)("inlineCode",{parentName:"li"},"having"),", ",Object(l.b)("inlineCode",{parentName:"li"},"limit")," etc.)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"if any of these were allowed they would remove or re-order rows in the base query which is not allowed"),Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},"from")," clause often includes nested selects which have no restrictions"))),Object(l.b)("li",{parentName:"ul"},"it must select from the base fragment name and left outer join to wherever it likes to get optional additional columns",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"because of this the additional column(s) will certainly be a nullable type in the projection"))))),Object(l.b)("li",{parentName:"ul"},"the final select must be of the form ",Object(l.b)("inlineCode",{parentName:"li"},"select * from col_adder_frag")," with the appropriate name"),Object(l.b)("li",{parentName:"ul"},"keeping all this in mind, the interesting bit happens here:  ",Object(l.b)("inlineCode",{parentName:"li"},"left outer join added_columns on base_frag.id = added_columns.id"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"this is where you get the data for your additional column using values in the core columns")))),Object(l.b)("p",null,"This fragment can be (and should be) compiled in its own compiland while using ",Object(l.b)("inlineCode",{parentName:"p"},"#include")," to get the base fragment only.  This will result in code gen for the accessor functions for a piece of the overall query -- the part this extension knows about.  Importantly code that uses this extension's data does not need or want to know about any other extensions that may be present, thereby keeping\ndependencies under control."),Object(l.b)("p",null,"The C signatures generated would look like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-c"},"extern cql_int32 adds_columns_get_id(\n    base_frag_result_set_ref _Nonnull result_set,\n    cql_int32 row);\n\nextern cql_string_ref _Nonnull adds_columns_get_name(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_double adds_columns_get_rate(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_string_ref _Nullable adds_columns_get_data(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_int32 adds_columns_result_count(\n  base_frag_result_set_ref _Nonnull result_set);\n")),Object(l.b)("p",null,'Even if there were dozens of other extensions, the functions for reading those columns would not be declared in the header for\nthis extension.  Any given extension "sees" only the core columns plus any columns it added.'),Object(l.b)("h4",{id:"adding-rows"},"Adding Rows"),Object(l.b)("p",null,"Query extensions also frequently want to add additional rows to the main result set, based on the data that is already present."),Object(l.b)("p",null,"The second form of extension allows for this, it is similarly locked in form.  Here is an example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'@attribute(cql:extension_fragment=base_frag)\ncreate proc adds_rows(id_ integer not null)\nbegin\n  with\n    base_frag(*) as (select 1 id, "name" name, 1.0 rate),\n    row_adder_frag(*) as (\n    select * from base_frag\n    union all\n    select * from added_rows)\n  select * from row_adder_frag;\nend;\n')),Object(l.b)("p",null,"Let's review the features of this second template form:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"there is a surrogate for the core query"),Object(l.b)("li",{parentName:"ul"},"there is a mandatory second CTE"),Object(l.b)("li",{parentName:"ul"},"the second CTE is a compound query with any number of branches, all ",Object(l.b)("inlineCode",{parentName:"li"},"union all")),Object(l.b)("li",{parentName:"ul"},"the first branch must be ",Object(l.b)("inlineCode",{parentName:"li"},"select * from base_frag")," (the base fragment) to ensure that the original rows remain",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"this is also why all the branches must be ",Object(l.b)("inlineCode",{parentName:"li"},"union all")))),Object(l.b)("li",{parentName:"ul"},"this form cannot add new columns"),Object(l.b)("li",{parentName:"ul"},"the extension CTE may not include ",Object(l.b)("inlineCode",{parentName:"li"},"order by")," or ",Object(l.b)("inlineCode",{parentName:"li"},"limit")," because that might reorder or remove rows of the base"),Object(l.b)("li",{parentName:"ul"},"any extensions of this form must come before those of the ",Object(l.b)("inlineCode",{parentName:"li"},"left outer join")," form for a given base fragment",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"which ironically means ",Object(l.b)("inlineCode",{parentName:"li"},"row_adder_frag")," has to come before ",Object(l.b)("inlineCode",{parentName:"li"},"col_adder_frag")))),Object(l.b)("li",{parentName:"ul"},"the usual restrictions on compound selects (same type and number of columns) ensure a consistent result"),Object(l.b)("li",{parentName:"ul"},"the final select after the CTE section must exactly in the form ",Object(l.b)("inlineCode",{parentName:"li"},"select * from row_adder_frag")," which is the name of the one and only additional CTE with no other clauses or options",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"in practice only the CTE will be used to create the final assembly so even if you did change the final select to something else it would be moot")))),Object(l.b)("p",null,"The signatures generated for this will look something like so:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-c"},"extern cql_int32 adds_rows_get_id(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_string_ref _Nonnull adds_rows_get_name(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_double adds_rows_get_rate(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_int32 adds_rows_result_count(\n  base_frag_result_set_ref _Nonnull result_set);\n")),Object(l.b)("p",null,'Which gives you access to the core columns.  Again this fragment can and should be compiled standalone with only the declaration\nfor the base fragment in the same translation unit to get the cleanest possible output.  This is so that consumers of this\nextension do not "see" other extensions which may or may not be related and may or may not always be present.'),Object(l.b)("h4",{id:"assembling-the-fragments"},"Assembling the Fragments"),Object(l.b)("p",null,"With all the fragments independently declared they need to be unified to create one final query. This is where the\nmajor rewriting happens.  The ",Object(l.b)("inlineCode",{parentName:"p"},"assembly_fragment")," looks something like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'@attribute(cql:assembly_fragment=base_frag)\ncreate proc base_frag(id_ integer not null)\nbegin\n  with\n    base_frag(*) as (select 1 id, "name" name, 1.0 rate)\n    select * from base_frag;\nend;\n')),Object(l.b)("p",null,"It will always be as simple as this, all the complexity is in the fragments."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},"assembly_fragment")," name must match the core fragment name"),Object(l.b)("li",{parentName:"ul"},"the procedure arguments must be identical to the base fragment arguments"),Object(l.b)("li",{parentName:"ul"},"the  procedure must have the same name as the assembly fragment (",Object(l.b)("inlineCode",{parentName:"li"},"base_frag")," in this case)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the code that was generated for the previous fragments anticipates this and makes reference to what will be generated here"),Object(l.b)("li",{parentName:"ul"},"this is enforced"))),Object(l.b)("li",{parentName:"ul"},"the assembled query is what you run to get the result set, this has real code behind it",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the other fragments only produce result set readers that call into the helper methods to get columns"))),Object(l.b)("li",{parentName:"ul"},"there is a surrogate for the core fragment as usual"),Object(l.b)("li",{parentName:"ul"},"all of CTE section will ultimately be replaced with the fragments chained together"),Object(l.b)("li",{parentName:"ul"},"the final select should be of the form ",Object(l.b)("inlineCode",{parentName:"li"},"select * from your_frags")," but it can include ordering and/or filtering, this statement will be present in final codegen, the final order is usually defined here")),Object(l.b)("p",null,"When compiling the assembly fragment, you should include the base, and all the other fragments, and the assembly template.  The presence of the assembly_fragment will cause codegen for the extension fragments to be suppressed. The assembly translation unit only contains the assembly query as formed from the fragments."),Object(l.b)("p",null,"Now let's look at how the query is rewritten, the process is pretty methodical."),Object(l.b)("p",null,"After rewriting the assembly looks like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"CREATE PROC base_frag (id_ INTEGER NOT NULL)\nBEGIN\n  WITH\n  base_frag (id, name, rate) AS (SELECT *\n    FROM my_table\n    WHERE my_table.id = id_),\n  row_adder_frag (id, name, rate) AS (SELECT *\n    FROM base_frag\n  UNION ALL\n  SELECT *\n    FROM added_rows),\n  col_adder_frag (id, name, rate, data) AS (SELECT row_adder_frag.*, added_columns.data\n    FROM row_adder_frag\n    LEFT OUTER JOIN added_columns ON row_adder_frag.id = added_columns.id)\n  SELECT *\n    FROM col_adder_frag;\nEND;\n")),Object(l.b)("p",null,"Let's dissect this part by part, each CTE serves a purpose."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the core CTE was replaced by the CTE in the base_fragment, it appears directly"),Object(l.b)("li",{parentName:"ul"},"next the first extension was added as a CTE referring to the base fragment just as before",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"recall that the first extension has to be ",Object(l.b)("inlineCode",{parentName:"li"},"row_adder_frag"),", as that type must come first"),Object(l.b)("li",{parentName:"ul"},"looking at the chain you can see why it would be hard to write a correct fragment if it came after columns were added"))),Object(l.b)("li",{parentName:"ul"},"next the second extension was added as a CTE",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"all references to the base fragment were replaced with references to row_adder_frag"),Object(l.b)("li",{parentName:"ul"},"the extra column names in the CTE were added such that all previous column names are introduced"))),Object(l.b)("li",{parentName:"ul"},"this process continues until all extensions are exhausted"),Object(l.b)("li",{parentName:"ul"},"the final select statement reads all the columns from the last extension CTE and includes and ordering and so forth that was present in the assembly query")),Object(l.b)("p",null,"The result of all this is a single query that gets all the various columns that were requested in all the extensions\nand all the ",Object(l.b)("inlineCode",{parentName:"p"},"union all")," operations play out as written.  The extensions are emitted in the order that they appear\nin the translation unit with the assembly, which again must have the row adding extensions first."),Object(l.b)("p",null,"This facility provides considerable ability to compose a large query, but each fragment can be independently checked for errors\nso that nobody ever has to debug the (possibly monstrous) overall result.  Fragments can be removed simply by\nexcluding them from the final assembly (with e.g. #ifdefs, or build rules)"),Object(l.b)("p",null,"With the rewrite of the assembly_fragment complete, the codegen for that procedure is the normal codegen for a procedure with a single select."),Object(l.b)("p",null,"As always, Java and Objective C codegen on these pieces will produce suitable wrappers for the C."),Object(l.b)("p",null,"The output code for the assembly fragment generates these reading functions:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-c"},"extern cql_int32 base_frag_get_id(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_string_ref _Nonnull base_frag_get_name(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_double base_frag_get_rate(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\n// used by adds_columns_get_data() to read its data\nextern cql_string_ref _Nullable __PRIVATE__base_frag_get_data(\n  base_frag_result_set_ref _Nonnull result_set,\n  cql_int32 row);\n\nextern cql_int32 base_frag_result_count(\n  base_frag_result_set_ref _Nonnull result_set);\n")),Object(l.b)("p",null,"These are exactly what you would get for a normal query except that the pieces that came from extensions are marked ",Object(l.b)("inlineCode",{parentName:"p"},"PRIVATE"),".  Those methods should not be used directly but instead the methods generated for each extension proc should be used."),Object(l.b)("p",null,"Additionally, to create the result set, as usual."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-c"},"extern CQL_WARN_UNUSED cql_code base_frag_fetch_results(\n  sqlite3 *_Nonnull _db_,\n  base_frag_result_set_ref _Nullable *_Nonnull result_set,\n  cql_int32 id_);\n")),Object(l.b)("p",null,"With the combined set of methods you can create a variety of assembled queries from extensions in a fairly straightforward way."),Object(l.b)("h3",{id:"shared-fragments"},"Shared Fragments"),Object(l.b)("p",null,'Shared fragments do not have the various restrictions that the "extension" style fragments have.  While extensions\nwere created to allow a single query to be composed by authors that did not necessarily work with each other,\nand therefore they are full of restrictions on the shape, shared queries instead are designed to give you\nmaximum flexibility in how the fragments are re-used.  You can think of them as being somewhat like a parameterized\nview, but the parameters are both value parameters and type parameters.  In Java or C#, a shared fragments might have\nhad an invocation that looked something like this:  `my_fragment(1,2)<table1, table2>.  As with the other fragment types\nthe common table expression (CTE) is the way that they plug in.'),Object(l.b)("p",null,"It's helpful to consider a real example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"split_text(tok) AS (\n  WITH RECURSIVE\n    splitter(tok,rest) AS (\n      SELECT\n        '' tok,\n        IFNULL( some_variable_ || ',', '') rest\n      UNION ALL\n      SELECT\n        substr(rest, 1, instr(rest, ',') - 1) tok,\n        substr(rest, instr(rest, ',') + 1) rest\n        FROM splitter\n        WHERE rest != ''\n  )\n  SELECT tok from splitter where tok != ''\n)\n")),Object(l.b)("p",null,"This text might appear in dozens of places where a comma seperated list needs to be split into pieces and there is no good way\nto share the code between these locations.  CQL is frequently used in conjunction with the C-pre-processor so you could\ncome up with something using the #define construct but this is problematic for several reasons:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the compiler does not then known that the origin of the text really is the same",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"thus it has no clue that sharing the text of the string might be a good idea"))),Object(l.b)("li",{parentName:"ul"},"any error messages happen in the context of the use of the macro not the definition"),Object(l.b)("li",{parentName:"ul"},"bonus: a multi-line macro like the above gets folded into one line so any error messages are impenetrable"),Object(l.b)("li",{parentName:"ul"},"if you try to compose such macros it only gets, worse, it's more code duplication harder error cases"),Object(l.b)("li",{parentName:"ul"},"any IDE support for syntax coloring and so forth will be confused by the macro as it's not part of the language")),Object(l.b)("p",null,"None of this is any good but the desire to create helpers like this is real both for correctness and for performance."),Object(l.b)("p",null,"To make these things possible, we introduce the notion of shared fragments.  We need to give them parameters\nand the natural way to create a select statement that is bindable in CQL is the procedure so the shape we choose\nlooks like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\nCREATE PROC split_text(value TEXT)\nBEGIN\n  WITH RECURSIVE\n    splitter(tok,rest) AS (\n      SELECT\n        '' tok,\n        IFNULL( value || ',', '') rest\n      UNION ALL\n      SELECT\n        substr(rest, 1, instr(rest, ',') - 1) tok,\n        substr(rest, instr(rest, ',') + 1) rest\n        FROM tokens\n        WHERE rest != ''\n  )\n  SELECT tok from splitter where tok != ''\nEND;\n")),Object(l.b)("p",null,"The introductory attribute ",Object(l.b)("inlineCode",{parentName:"p"},"@attribute(cql:shared_fragment)")," indicates that the procedure is to produce\nno code, but rather it will be inlined as a CTE in other locations.  To use it, we introduce the ability\nto call a procedure as part of a CTE declaration.  Like so:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"WITH\n  result(v) as (call split_text('x,y,z'))\n  select * from result;\n")),Object(l.b)("p",null,"Once the fragment has been defined, the statement above could appear anywhere, and of course the\ntext ",Object(l.b)("inlineCode",{parentName:"p"},"'x,y,z'")," need not be constant.  For instance:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"CREATE PROC print_parts(value TEXT)\nBEGIN\n  DECLARE C CURSOR FOR\n    WITH\n      result(v) as (CALL split_text('x,y,z'))\n      SELECT * from result;\n\n  LOOP FETCH C\n  BEGIN\n     CALL printf(\"%s\\n\", C.v);\n  END;\nEND;\n")),Object(l.b)("p",null,"Fragments are also composable, so for instance, we might also want some shared code that\nextracts comma separated numbers.  We could do this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\nCREATE PROC ids_from_string(value TEXT)\nBEGIN\n  WITH\n    result(v) as (CALL split_text(value))\n  SELECT CAST(v as LONG) as id from result;\nEND;\n")),Object(l.b)("p",null,"Now we could write:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"CREATE PROC print_ids(value TEXT)\nBEGIN\n  DECLARE C CURSOR FOR\n    WITH\n      result(id) as (CALL ids_from_string('1,2,3'))\n      SELECT * from result;\n\n  LOOP FETCH C\n  BEGIN\n     CALL printf(\"%ld\\n\", C.id);\n  END;\nEND;\n")),Object(l.b)("p",null,"Of course these are very simple examples but in principle you can use the generated tables in whatever\nway is necessary.  For instance, here's a silly but illustrative example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"/* This is a bit silly */\nCREATE PROC print_common_ids(value TEXT)\nBEGIN\n  DECLARE C CURSOR FOR\n    WITH\n      v1(id) as (CALL ids_from_string('1,2,3')),\n      v2(id) as (CALL ids_from_string('2,4,6'))\n      SELECT * from v1\n      INTERSECT\n      SELECT * from v2;\n\n  LOOP FETCH C\n  BEGIN\n     CALL printf(\"%ld\\n\", C.id);\n  END;\nEND;\n")),Object(l.b)("p",null,"With a small amount of dynamism in the generation of the SQL for the above, it's possible to share the body\nof v1 and v2.  SQL will of course see the fully expanded but your program only needs one copy no matter\nhow many times you use the fragment anywhere in the code."),Object(l.b)("p",null,'So far we have illustrated the "parameter" part of the flexibility.  Now let\'s look at the "generics" part,\neven though it\'s overkill for this example it should still but illustratative.  You could imagine that\nthe procedure we wrote above ',Object(l.b)("inlineCode",{parentName:"p"},"ids_from_string")," might do something more complicated, maybe filtering out\nnegative ids, ids that are too big, or that don't match some pattern. Whatever the case might be.  You\nmight want these features in a variety of contexts, maybe not just starting from a string to split."),Object(l.b)("p",null,'We can rewrite the fragment in a "generic" way like so:'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'@attribute(cql:shared_fragment)\nCREATE PROC ids_from_string_table()\nBEGIN\n  WITH\n    source(v) LIKE (select "x" v)\n  SELECT CAST(v as LONG) as id from source;\nEND;\n')),Object(l.b)("p",null,'Note the new construct for a CTE definition: inside a fragment we can use "LIKE" to define a pluggable CTE.\nIn this case we used a ',Object(l.b)("inlineCode",{parentName:"p"},"select")," statement to describe the shape the fragment requires.  We could also\nhave used a name ",Object(l.b)("inlineCode",{parentName:"p"},"source(*) LIKE shape_name")," just like we use shape names when describing cursors.  The\nname can be any existing view, table, a procedure with a result, etc.  Any name that describes a shape."),Object(l.b)("p",null,'Now when the fragment is invoked, you provide the actual data source (some table, view, or CTE) and\nthat parameter takes the role of "values".  Here\'s a full example:'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'CREATE PROC print_ids(value TEXT)\nBEGIN\n  DECLARE C CURSOR FOR\n    WITH\n      my_data(*) as (CALL split_text(value)),\n      my_numbers(id) as (CALL ids_from_string_table() USING my_data AS source)\n      SELECT id from my_numbers;\n\n  LOOP FETCH C\n  BEGIN\n     CALL printf("%ld\\n", C.id);\n  END;\nEND;\n')),Object(l.b)("p",null,"We could actually rewrite the previous simple id fragment as follows:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\nCREATE PROC ids_from_string(value TEXT)\nBEGIN\n  WITH\n    tokens(v) as (CALL split_text(value))\n    ids(id) as (CALL ids_from_string_table() USING tokens as source)\n  SELECT * from ids;\nEND;\n")),Object(l.b)("p",null,"And actually we have a convenient name we could use for the shape we need so\nwe could have used the shape syntax to define ",Object(l.b)("inlineCode",{parentName:"p"},"ids_from_string_table"),"."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\nCREATE PROC ids_from_string_table()\nBEGIN\n  WITH\n    source(*) LIKE split_text\n  SELECT CAST(tok as LONG) as id from source;\nEND;\n")),Object(l.b)("p",null,"These examples have made very little use of the database but of course\nnormal data is readily available so shared fragments can make a great\nway to provide access to complex data with shareable, correct, code.\nFor instance you could write a fragment that provides the ids of all\nopen businesses matching a name from a combination of tables.  This is\nsimilar to what you could do with a ",Object(l.b)("inlineCode",{parentName:"p"},"VIEW")," plus a ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE")," clause but:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"such a system can give you well controlled combinations known to work well"),Object(l.b)("li",{parentName:"ul"},"there is no schema required, so your database load time can still be fast"),Object(l.b)("li",{parentName:"ul"},"parameterization is not limited to filtering VIEWs after the fact"),Object(l.b)("li",{parentName:"ul"},'"generic" patterns are available, allowing arbitary data sources to be filtered, validated, augmented'),Object(l.b)("li",{parentName:"ul"},"each fragment can be tested seperately with its own suite rather than only in the context of some larger thing"),Object(l.b)("li",{parentName:"ul"},"code generation can be more economical because the compiler is aware of what is being shared")),Object(l.b)("p",null,"In short, shared fragments can help with the composition of any complicated kinds of queries.\nIf you're producing an SDK to access a data set, they are indispensible."),Object(l.b)("h4",{id:"creating-and-using-valid-shared-fragments"},"Creating and Using Valid Shared Fragments"),Object(l.b)("p",null,"When creating a fragment the following rules are enforced:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the fragment many not have any out arguments"),Object(l.b)("li",{parentName:"ul"},"it must consist of exactly one valid select statement (but see future forms below)"),Object(l.b)("li",{parentName:"ul"},"it may use the LIKE construct in CTE definitions to create placeholder shapes",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"this form is illegal outside of shared fragments (otherwise how would you bind it)"))),Object(l.b)("li",{parentName:"ul"},"the LIKE form may only appear in top level CTE expressions in the fragment"),Object(l.b)("li",{parentName:"ul"},"the fragment is free to use other fragments, but it may not call itself",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"calling itself would result in infinite inlining")))),Object(l.b)("p",null,'Usage of a fragment is always intruced by a "call" to the fragment name in a CTE body.\nWhen using a fragment the following rules are enforced.'),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the provided parameters must create a valid procedure call just like normal procedure calls",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"i.e. the correct number and type of arguments"))),Object(l.b)("li",{parentName:"ul"},"the provided parameters may not use nested ",Object(l.b)("inlineCode",{parentName:"li"},"(SELECT ...)")," expressions",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"this could easily create fragment building within fragment building which seems not worth the complexity"),Object(l.b)("li",{parentName:"ul"},"if database access is required in the parameters simply wrap it in a helper procedure"))),Object(l.b)("li",{parentName:"ul"},"the optional USING clause must specify each required table parameter exactly once and no other tables",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"a fragment that requires table parameters be invoked without a USING clause"))),Object(l.b)("li",{parentName:"ul"},"every actual table provided must match the column names of the corresponding table parameter",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"i.e. in ",Object(l.b)("inlineCode",{parentName:"li"},"USING my_data AS values")," the actual columns in ",Object(l.b)("inlineCode",{parentName:"li"},"my_data")," must be the same as in the ",Object(l.b)("inlineCode",{parentName:"li"},"values")," parameter"),Object(l.b)("li",{parentName:"ul"},"the columns need not be in the same order"))),Object(l.b)("li",{parentName:"ul"},'each column in any actual table must be "assignment compatible" with its corresponding column in the parameters',Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"i.e. the actual type could be converted to the formal type using the same rules as the := operator"),Object(l.b)("li",{parentName:"ul"},"these are the same rules used for procedure calls for instance where the call is kind of like assigning the actual parameter values to the formal parameter variables"))),Object(l.b)("li",{parentName:"ul"},"the provided table values must not conflict with top level CTEs in the shared fragment",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"exception: the top level CTEs that were parameters do not create conflicts"),Object(l.b)("li",{parentName:"ul"},"e.g. it's common to do ",Object(l.b)("inlineCode",{parentName:"li"},"values(*) as (CALL something() using source as source)"),' here the caller\'s "source" takes the value of the fragment\'s "source", this is not a true conflict'),Object(l.b)("li",{parentName:"ul"},"however, the caller's source might itself have been a parameter in which case the value provided could create an inner conflict",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"all these problems are easily avoided with a simple naming convention for parameters so that real arguments never look like parameter names and parameter forwarding is apparent"),Object(l.b)("li",{parentName:"ul"},"e.g. ",Object(l.b)("inlineCode",{parentName:"li"},"USING _source AS _source")," makes it clear that a parameter is being forwarded and ",Object(l.b)("inlineCode",{parentName:"li"},"_source")," is not likely to conflict with real table or view names")))))),Object(l.b)("p",null,"Note that when shared fragments are used, the generated SQL has the text split into parts, with each fragment and its surroundings separated, therefore\nthe text of shared fragments is shared(!) between usages if normal linker optimizations for text folding are enabled (common in production code)."),Object(l.b)("h3",{id:"shared-fragments-with-conditionals"},"Shared Fragments with Conditionals"),Object(l.b)("p",null,'Shared fragments use dynamic assembly of the text to do the sharing but it is also possible create alternative texts.\nThere are many instances where it is desirable to not just replace parameters but use, for instance, an entirely different join sequence.\nWithout shared fragments, the only way to accomplish this is to fork desired query at the topmost level (because SQLite has no internal\npossibly of "IF" conditions).  This is expensive in terms of code size and also cognitive load because the entire alternative sequences\nhave to be kept carefully in sync.  Macros can help with this but then you get the usual macro maintenance problems, including poor diagnostics.\nAnd of course there is no possibilty to share the common parts of the text of the code if it is forked.'),Object(l.b)("p",null,"However, conditional shared fragments allow forms like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"@attribute(cql:shared_fragment)\nCREATE PROC ids_from_string(val TEXT)\nBEGIN\n  IF val IS NULL OR val IS '' THEN\n    SELECT 0 id WHERE 0; -- empty result\n  ELSE\n    WITH\n      tokens(v) as (CALL split_text(val))\n      ids(id) as (CALL ids_from_string_table() USING tokens as source)\n    SELECT * from ids;\n  END IF;\nEND;\n")),Object(l.b)("p",null,"Now when do something like:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"  ids(*) AS (CALL ids_from_string(str))\n")),Object(l.b)("p",null,"In this case, if the string ",Object(l.b)("inlineCode",{parentName:"p"},"val")," is empty then SQLite will not see the complex comma splitting code, it will see\nthe trivial case ",Object(l.b)("inlineCode",{parentName:"p"},"select 0 id where 0"),".  The code in a conditinal fragment might be entirely different between the branches\nremoving unnecessary code, or swapping in a new experimental cache in your test environment, or anything like that."),Object(l.b)("p",null,"The generalization is simply this:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},'instead of just one select statement there is one top level "IF" statement'),Object(l.b)("li",{parentName:"ul"},"each statement list of the IF must be exactly one select statement"),Object(l.b)("li",{parentName:"ul"},"there must be an ELSE clause"),Object(l.b)("li",{parentName:"ul"},"the select statements must be type compatible, just like in a normal procedure"),Object(l.b)("li",{parentName:"ul"},"any table parameters with the same name in different branches must have the same type",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"otherwise it would be impossible to provide a single actual table for those table parameters")))),Object(l.b)("p",null,"With this additional flexibility a wide variety of SQL statements can be constructed economically and maintainably.  Importantly\nconsumers of the fragments need not deal with all these various alternate possibilities but they can readily create their own\nuseful combinations out of building blocks."),Object(l.b)("p",null,"Ultimately, from SQLite's perspective, all of these shared fragment forms result in nothing more complicated than a chain of CTE expressions."),Object(l.b)("p",null,"See Appendix 8 for an extensive section on best practices around fragments and common table expressions in general."))}u.isMDXComponent=!0},153:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return h}));var n=a(0),r=a.n(n);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),b=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=b(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=b(a),d=n,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||l;return a?r.a.createElement(h,i(i({ref:t},c),{},{components:a})):r.a.createElement(h,i({ref:t},c))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,s=new Array(l);s[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var c=2;c<l;c++)s[c]=a[c];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);