(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{116:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),l=n(6),i=(n(0),n(143)),r=["components"],o={id:"int03",title:"Part 3: C Code Generation",sidebar_label:"Part 3: C Code Generation"},s={unversionedId:"int03",id:"int03",isDocsHomePage:!1,title:"Part 3: C Code Generation",description:"\x3c!---",source:"@site/../CQL_Guide/int03.md",slug:"/int03",permalink:"/cql-guide/int03",version:"current",lastUpdatedBy:"Rico Mariani",lastUpdatedAt:1629395100,sidebar_label:"Part 3: C Code Generation",sidebar:"someSidebar",previous:{title:"Part 2: Semantic Analysis",permalink:"/cql-guide/int02"}},c=[{value:"Preface",id:"preface",children:[]},{value:"C Code Generation",id:"c-code-generation",children:[{value:"Character Buffers and Byte Buffers",id:"character-buffers-and-byte-buffers",children:[]},{value:"Expressions",id:"expressions",children:[]}]}],b={rightToc:c};function p(e){var t=e.components,n=Object(l.a)(e,r);return Object(i.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h3",{id:"preface"},"Preface"),Object(i.b)("p",null,"Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.\nAs in the previous sections, the goal here is not to go over every detail of code generation but rather to give\na sense of how codegen happens in general -- the core strategies and implementation choices --\nso that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish\nthis, various key data structures will be explained in detail as well as selected examples of their use."),Object(i.b)("h2",{id:"c-code-generation"},"C Code Generation"),Object(i.b)("p",null,"There are several key pieces of C code that we have to generate to make working CQL procedures using C\nfunctions.  This all happens in ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c"),".  From a big picture perspective, these are the essential problems:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"we have to compile SQL expressions into C",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"including expressions with variables that are nullable"),Object(i.b)("li",{parentName:"ul"},"including SQL expressions that are highly complex like ",Object(i.b)("inlineCode",{parentName:"li"},"CASE..WHEN..THEN..END")," and ",Object(i.b)("inlineCode",{parentName:"li"},"IN (..)")))),Object(i.b)("li",{parentName:"ul"},"we have to generate control flow for things like ",Object(i.b)("inlineCode",{parentName:"li"},"IF"),", ",Object(i.b)("inlineCode",{parentName:"li"},"WHILE")," and, ",Object(i.b)("inlineCode",{parentName:"li"},"SWITCH")),Object(i.b)("li",{parentName:"ul"},"we have to make result sets",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"including the code to slurp up all the rows from a SQL statement into an array of values"),Object(i.b)("li",{parentName:"ul"},"we want to do this very economically"))),Object(i.b)("li",{parentName:"ul"},"we have to be able to create the text for every SQLite statement and bind any variables to it"),Object(i.b)("li",{parentName:"ul"},"we have to check every SQLite API for errors and throw exceptions consistently and deal with them",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"including constructs that allow users to handle exceptions, such as ",Object(i.b)("inlineCode",{parentName:"li"},"TRY/CATCH")))),Object(i.b)("li",{parentName:"ul"},"we have to track any reference types carefully so that retain/release pairs are done consistently",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"even in the presence of SQLite errors or other exceptions"))),Object(i.b)("li",{parentName:"ul"},"we have to produce a ",Object(i.b)("inlineCode",{parentName:"li"},".h")," and a ",Object(i.b)("inlineCode",{parentName:"li"},".c")," file for the C compiler",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"contributions to these files could come from various places"),Object(i.b)("li",{parentName:"ul"},"the ",Object(i.b)("inlineCode",{parentName:"li"},".c")," file will itself have various sections and we might need to contribute to them at various points in the compilation"))),Object(i.b)("li",{parentName:"ul"},"we want to do this all in one pass over the AST"),Object(i.b)("li",{parentName:"ul"},"we get to assume that the program is error free, codegen never runs unless semantic analysis reports zero errors",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"so nothing can be wrong by the time the codegen pass runs, we never detect errors here"),Object(i.b)("li",{parentName:"ul"},"sometimes we add ",Object(i.b)("inlineCode",{parentName:"li"},"Contract")," and ",Object(i.b)("inlineCode",{parentName:"li"},"Invariant")," statements to ",Object(i.b)("inlineCode",{parentName:"li"},"cg.c")," that make our assumptions clear and prevent regressions")))),Object(i.b)("p",null,"There are some very important building blocks used to solve these problems we will start with those, then move to\na discussion of each of the essential kinds of code generation that we have to do to get working programs."),Object(i.b)("h3",{id:"character-buffers-and-byte-buffers"},"Character Buffers and Byte Buffers"),Object(i.b)("p",null,"The first kind of text output that CQL could produce was the AST echoing.  This was original done directly with ",Object(i.b)("inlineCode",{parentName:"p"},"fprintf")," but\nthat was not flexible enough as the output had to be captured to be emitted into other places like comments or the text of\nSQL statements to go to SQLite.  This forces that pass to use character buffers, which we touched on in Part 1.  Code generation\nhas a more profound dependency on character buffers -- they are literally all over ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c")," and we need to go over how hey are used."),Object(i.b)("p",null,"The public interace is in ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf.h")," and it's really quite simple.  You allocate a ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," and then you can ",Object(i.b)("inlineCode",{parentName:"p"},"bprintf")," into it.\nLet's be a bit more specific:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_INTERNAL_SIZE 1024\n#define CHARBUF_GROWTH_SIZE 1024\n\ntypedef struct charbuf\n{\n  char *ptr;      // pointer to stored data, if any\n  uint32_t used;  // bytes used in current buffer\n  uint32_t max;   // max bytes in current buffer\n\n  // builtin buffer storage\n  char internal[CHARBUF_INTERNAL_SIZE];\n} charbuf;\n\ncql_data_decl( int32_t charbuf_open_count );\n\ncql_noexport void bopen(charbuf* b);\ncql_noexport void bclose(charbuf *b);\ncql_noexport void bprintf(charbuf *b, const char *format, ...);\n")),Object(i.b)("p",null,"The typical pattern goes something like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  charbuf foo;\n  bopen(&foo);\n  bprintf(&foo, "Hello %s\\n", "World");\n  // do something with foo.ptr\n  bclose(&foo);\n')),Object(i.b)("p",null,"Note that ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," includes ",Object(i.b)("inlineCode",{parentName:"p"},"CHARBUF_INTERNAL_SIZE")," of storage that does not\nhave to be allocated with ",Object(i.b)("inlineCode",{parentName:"p"},"malloc")," and it doesn't grow very aggressively.\nThis reflects that fact that most ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," instances are very small.\nOf course a ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," could go on the heap if it needs to outlive\nthe function it appears in, but this is exceedingly rare."),Object(i.b)("p",null,"To make sure buffers are consistently closed (and this is a problem because\nthere are often a lot of them.  They are allocated with these simple helper\nmacros."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_OPEN(x) \\\n  int32_t __saved_charbuf_count##x = charbuf_open_count; \\\n  charbuf x; \\\n  bopen(&x)\n\n#define CHARBUF_CLOSE(x) \\\n  bclose(&x); \\\n  Invariant(__saved_charbuf_count##x == charbuf_open_count)\n")),Object(i.b)("p",null,"the earlier example would be written more properly:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  CHARBUF_OPEN(foo);\n    bprintf(&foo, "Hello %s\\n", "World");\n    // do something with foo.ptr\n  CHARBUF_CLOSE(foo);\n')),Object(i.b)("p",null,"If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure."),Object(i.b)("p",null,'It\'s normal to create several buffers in the course of doing code generation.  In fact some of these buffers\nbecome "globally" visible and get swapped out as needed.  For instance this kind of chaining is normal.\nInside of ',Object(i.b)("inlineCode",{parentName:"p"},"cg_create_proc_stmt")," there is these sequence:"),Object(i.b)("p",null,"Make new buffers..."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  CHARBUF_OPEN(proc_fwd_ref);\n  CHARBUF_OPEN(proc_body);\n  CHARBUF_OPEN(proc_locals);\n  CHARBUF_OPEN(proc_cleanup);\n")),Object(i.b)("p",null,"Save what we got..."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  charbuf *saved_main = cg_main_output;\n  charbuf *saved_decls = cg_declarations_output;\n  charbuf *saved_scratch = cg_scratch_vars_output;\n  charbuf *saved_cleanup = cg_cleanup_output;\n  charbuf *saved_fwd_ref = cg_fwd_ref_output;\n")),Object(i.b)("p",null,"Switch to the new..."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  cg_fwd_ref_output = &proc_fwd_ref;\n  cg_main_output = &proc_body;\n  cg_declarations_output = &proc_locals;\n  cg_scratch_vars_output = &proc_locals;\n  cg_cleanup_output = &proc_cleanup;\n")),Object(i.b)("p",null,"And of course the code puts the original values back when it's done and closes the buffers."),Object(i.b)("p",null,"This means that while processing a procedure the codegen that declares say scratch variables,\nwhich would go to ",Object(i.b)("inlineCode",{parentName:"p"},"cg_scratch_vars_output")," is going to target the ",Object(i.b)("inlineCode",{parentName:"p"},"proc_locals")," buffer\nwhich will be emitted before the ",Object(i.b)("inlineCode",{parentName:"p"},"body"),".  By the time ",Object(i.b)("inlineCode",{parentName:"p"},"cg_stmt_list")," is invoked the\n",Object(i.b)("inlineCode",{parentName:"p"},"cg_main_output")," variable will be pointing to the procedure body, thus any statements\nwill go into there rather than being acculated at the global level -- it's possible to\nhave code that is not in a procedure (see ",Object(i.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/x1#--global_proc-name"},Object(i.b)("inlineCode",{parentName:"a"},"--global_proc")),")."),Object(i.b)("p",null,"But in general, it's very useful to have different buffers going on at the same time.  New local variables\nor scratch variables can be added to their own buffer which goes before the code runs.  New cleanup\nsteps that are necessary can be added to the cleanup output which will appear at the end.  The final\nfunction combines all of these pieces with maybe some glue.  Everything works like this, ",Object(i.b)("inlineCode",{parentName:"p"},"IF")," statements,\nexpressions, all of it."),Object(i.b)("p",null,"One interesting but unexpected feature of ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," is that it provides helper methods for indenting\nbuffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C\ncode because of course you want (e.g.) the body of an ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statement to be indented.  CQL tries to create\nwell formatted code that is readable by humans as much as possible."),Object(i.b)("h4",{id:"byte-buffers"},"Byte Buffers"),Object(i.b)("p",null,"These are less commonly used but there is a peer to ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," creatively called ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf"),".  This gives you\na growable binary buffer.  It's often used to hold arrays of structures.  Interestingly, ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c")," doesn't\ncurrently consume byte buffers, the presence of ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf.c")," actually came late to the CQL compiler. However\nthe CQL runtime ",Object(i.b)("inlineCode",{parentName:"p"},"cqlrt.c")," (and ",Object(i.b)("inlineCode",{parentName:"p"},"cqlrt_common.c"),") provide ",Object(i.b)("inlineCode",{parentName:"p"},"cql_bytebuf_open"),", ",Object(i.b)("inlineCode",{parentName:"p"},"cql_bytebuf_alloc")," and,\n",Object(i.b)("inlineCode",{parentName:"p"},"cql_bytebuf_close")," which are akin to the ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," methods.  These functions are used in the generated\ncode to create result sets at runtime.  The ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf")," was so useful that it found its way back from the\nruntime into the compiler itself, and is used by other code-generators like the schema upgrader.   The\nsemantic analyzer also uses it to help with query fragments and to track the various upgrade annotations."),Object(i.b)("p",null,"Both ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," and ",Object(i.b)("inlineCode",{parentName:"p"},"bytebuf")," are simple enough that they don't need discussion. It's easier to just read\nthe code and the comments."),Object(i.b)("h3",{id:"expressions"},"Expressions"),Object(i.b)("p",null,"Many of the output needs of CQL stemmed from the base case of creating expressions.  A simple CQL\nexpression like"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-sql"},"  SET x := x + y;\n")),Object(i.b)("p",null,"seems innocuous enough, we'd like this to compile to this code:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"  x = x + y;\n")),Object(i.b)("p",null,"And indeed, it might.  Here's some actual output from the compiler:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER NOT NULL;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_int32 x = 0;\n  cql_int32 y = 0;\n\n  x = x + y;\n\n}\n#undef _PROC_\n')),Object(i.b)("p",null,"(*) the output above was created by using ",Object(i.b)("inlineCode",{parentName:"p"},"out/cql --in x --cg x.h x.c --nolines")," to avoid all the # directives"),Object(i.b)("p",null,"Looks easy enough.  And indeed if all expressions were like this, you could do expression compilation pretty simply --\nevery binary operator would look something like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"recurse left"),Object(i.b)("li",{parentName:"ul"},"emit infix operator"),Object(i.b)("li",{parentName:"ul"},"recurse right")),Object(i.b)("p",null,"This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have\nthe whole expression."),Object(i.b)("p",null,"This doesn't work at all.  To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result\nis telling:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_nullable_int32 x;\n  cql_set_null(x);\n  cql_nullable_int32 y;\n  cql_set_null(y);\n\n  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);\n\n}\n#undef _PROC_\n')),Object(i.b)("p",null,"All that's happened in the above is that ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y")," became nullable variables, that is the ",Object(i.b)("inlineCode",{parentName:"p"},"NOT NULL")," was\nremoved from the declaration.  This makes all the difference in the world, and this is a fairly easy case.\nThe problem is that nullable value types like cql_nullable_int32 have an integer and a boolean and these\ndon't flow into expressions that use operators like ",Object(i.b)("inlineCode",{parentName:"p"},"+"),", ",Object(i.b)("inlineCode",{parentName:"p"},"-"),", ",Object(i.b)("inlineCode",{parentName:"p"},"/")," and so forth.  This means that even\nsimple expressions involving nullable types actually expand into several statements.  And, in general,\nthese statements need a place to put their temporary results to accumulate the answer, so scratch variables\nare required to make all this work."),Object(i.b)("p",null,"Here's a more realistic example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)\nBEGIN\n  SET result := 5 * x + 3 * y;\nEND;\n*/\n\n#define _PROC_ "combine"\nvoid combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {\n  cql_contract_argument_notnull((void *)result, 3);\n\n  cql_nullable_int32 _tmp_n_int_1;\n  cql_set_null(_tmp_n_int_1);\n  cql_nullable_int32 _tmp_n_int_2;\n  cql_set_null(_tmp_n_int_2);\n\n  cql_set_null(*result); // set out arg to non-garbage\n  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);\n  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);\n  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);\n\n}\n#undef _PROC_\n#pragma clang diagnostic pop\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1")," holds the product of x and 5, it's null if ",Object(i.b)("inlineCode",{parentName:"li"},"x.is_null")," is true"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2")," holds the product of y and 3, it's null if ",Object(i.b)("inlineCode",{parentName:"li"},"y.is_null")," is true"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"*result")," holds the answer, it's null if either of ",Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.is_null"),", ",Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2.is_null")," is true",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"otherwise it's ",Object(i.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.value + _tmp_n_int_2.value"))))),Object(i.b)("p",null,"So, in general, we need to emit arbitarily many statements in the course of evaluating even simple looking expressions\nand we need good mechanisms to manage that.  This is what we'll talk about in the coming sections."),Object(i.b)("h4",{id:"managing-scratch-variables"},"Managing Scratch Variables"),Object(i.b)("p",null,"The function that actually assigns scratch variables is ",Object(i.b)("inlineCode",{parentName:"p"},"cg_scratch_var")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// The scratch variable helper uses the given sem_type and the current\n// stack level to create a temporary variable name for that type at that level.\n// If the variable does not already have a declaration (as determined by the masks)\n// then a declaration is added to the scratch_vars section.  This is one of the root\n// ways of getting an .is_null and .value back.  Note that not null variables always\n// have a .is_null of "0" which becomes important when deciding how to assign\n// one result to another.  Everything stays uniform.\nstatic void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)\n')),Object(i.b)("p",null,"The signature is a bit unexpected so we'll go over this, some of this will make more\nsense as we learn about expressions generally but this is as good an introduction as any."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ast")," holds a reference to a variable we want to assign to, this is normally ",Object(i.b)("inlineCode",{parentName:"li"},"NULL")," for scratch variables, it's not null for the ",Object(i.b)("inlineCode",{parentName:"li"},"RESULT")," macros which we'll study later, so for now ignore this"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"sem_type")," holds the type of the variable we need, it must be a unitary type, optionally with ",Object(i.b)("inlineCode",{parentName:"li"},"SEM_TYPE_NOTNULL")," set"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"var")," is a character buffer that will get the name of the variable"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null")," is a character buffer that will get the ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression for this variable (more below)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value")," is a character buffer that will get the ",Object(i.b)("inlineCode",{parentName:"li"},"value")," expression for this variable (more below)")),Object(i.b)("p",null,"And this is a good time to talk about ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," because they will be everywhere."),Object(i.b)("p",null,'Every expression evaluation in the C code generator has two essential results, the text that corresponds to the current\nvalue so far (e.g. "(1+2)*3") and the text for the current expression that will tell you if the result is null,\nthis could be as simple as "0" for a expression that is known to be not null.  So let\'s make this a little more concrete:'),Object(i.b)("p",null,"Suppose you ask for a scratch not null integer we get results like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"var"),":  ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_n_int_1"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"0"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_n_int_1"'))),Object(i.b)("p",null,'Meaning: if you want the value, use the text "_tmp_n_int_1" if you want to know if the variable is null, use the text "0"\nNote: many parts of ',Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c")," special case an ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," value of ",Object(i.b)("inlineCode",{parentName:"p"},'"0"')," to make better code because such a thing is known to\nbe not null at compile time."),Object(i.b)("p",null,"Now let's suppose you ask for a scratch nullable integer, we get results like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"var"),":  ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_int_1"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_int_1.is_null"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value"),": ",Object(i.b)("inlineCode",{parentName:"li"},'"_tmp_int_1.value"'))),Object(i.b)("p",null,"So again, you have exactly the text you need to test for null and the test you need to get the value."),Object(i.b)("p",null,"Additional notes:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},'scratch variables can be re-used, they are on a "stack"'),Object(i.b)("li",{parentName:"ul"},"a bitmask is used to track which scratch variables have aleady had a declaration emitted, so they are only declared once"),Object(i.b)("li",{parentName:"ul"},"the variable name is based on the current value of the ",Object(i.b)("inlineCode",{parentName:"li"},"stack_level")," variable which is increased in a push/pop fashion as temporaries come in and out of scope"),Object(i.b)("li",{parentName:"ul"},"this strategy isn't perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad"),Object(i.b)("li",{parentName:"ul"},"importantly there is one stacklevel variable for all temporaries not one stacklevel for every type of temporary, this seemed like a reasonable simplification")),Object(i.b)("h4",{id:"allocating-scratch-variables"},"Allocating Scratch Variables"),Object(i.b)("p",null,"The most common reason for a scratch variable is that a temporary is needed for some part of the computation.\nThe most common reason for a temporary variable is to hold an intermediate result of a computation involving\nnullable arithmetic."),Object(i.b)("p",null,"These temporaries are created with ",Object(i.b)("inlineCode",{parentName:"p"},"CG_PUSH_TEMP")," which simply creates the three ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," variables you need and then asks for a\nscratch variable of the type you need.  The variables follow a simple naming convention.  The stack level is increased."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers\n// with the text needed to refer to the variable.  cg_scratch_var picks the name\n// based on stack level-and type.\n#define CG_PUSH_TEMP(name, sem_type) \\\nCHARBUF_OPEN(name); \\\nCHARBUF_OPEN(name##_is_null); \\\nCHARBUF_OPEN(name##_value); \\\ncg_scratch_var(NULL, sem_type, &name, &name##_is_null, &name##_value); \\\nstack_level++;\n")),Object(i.b)("p",null,"Symetrically, ",Object(i.b)("inlineCode",{parentName:"p"},"CG_POP_TEMP")," releases the charbufs and restores the stack level.  As with the other macros, these are designed to\nmake it impossible to forget to free your buffers or get the stack wrong.  In fact, the stack is checked at strategic places\nto ensure its back to baseline.  You can always just snapshot ",Object(i.b)("inlineCode",{parentName:"p"},"stacklevel"),", do some work that should be clean, and then\nadd an ",Object(i.b)("inlineCode",{parentName:"p"},"Invariant")," that ",Object(i.b)("inlineCode",{parentName:"p"},"stacklevel")," is back to where it was."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Release the buffers for the temporary, restore the stack level.\n#define CG_POP_TEMP(name) \\\nCHARBUF_CLOSE(name##_value); \\\nCHARBUF_CLOSE(name##_is_null); \\\nCHARBUF_CLOSE(name); \\\nstack_level--;\n")),Object(i.b)("h4",{id:"recursing-sub-expressions"},"Recursing Sub-expressions"),Object(i.b)("p",null,"Now that we understand that we can create scratch variables as needed, it's time to take a look at the typical evaluation patterns\nand how the evaluation works within that pattern.  This is everywhere in ",Object(i.b)("inlineCode",{parentName:"p"},"cg_c.c"),"."),Object(i.b)("p",null,"So let's look at an actual evaluator, the simplest of them all, this one does code generation for the ",Object(i.b)("inlineCode",{parentName:"p"},"NULL")," literal."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'static void cg_expr_null(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {\n  Contract(is_ast_null(expr));\n  // null literal\n  bprintf(value, "NULL");\n  bprintf(is_null, "1");\n}\n')),Object(i.b)("p",null,"Now this may be looking familiar.  The signature of the code generator is very much like the signature of the semantic\nanalyzer for the same AST fragment."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"expr")," : the AST we are generating code for"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"op")," : the relevant operator if any (operators share code)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"is_null")," : a ",Object(i.b)("inlineCode",{parentName:"li"},"charbuf")," into which we can write the ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression text"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"value")," : a ",Object(i.b)("inlineCode",{parentName:"li"},"charbuf")," into which we can write the ",Object(i.b)("inlineCode",{parentName:"li"},"value")," expression text"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pri")," : the binding strength of the node above this one"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pri_new")," : the binding strength of this node")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"pri")," and ",Object(i.b)("inlineCode",{parentName:"p"},"pri_new")," work exactly like they did in the echoing code (Part 1), they are used to allow the codegen\nto decide if it needs to emit parentheses.  Note that the binding strengths now will be the C binding strengths\nNOT the SQL binding strengths.  The placement of parens frequently has to change because the order of operations\nis different in C.  For instance in SQL ",Object(i.b)("inlineCode",{parentName:"p"},"NOT")," is very weak but in C logical not (",Object(i.b)("inlineCode",{parentName:"p"},"!"),") is very strong."),Object(i.b)("p",null,"This particular generator is going to produce ",Object(i.b)("inlineCode",{parentName:"p"},'"NULL"')," for the value and ",Object(i.b)("inlineCode",{parentName:"p"},'"1"')," for the is_null expression."),Object(i.b)("p",null,"The caller will use these to create its own expression results."),Object(i.b)("p",null,"Let's look at one of the simplest examples, this is the ",Object(i.b)("inlineCode",{parentName:"p"},"IS NULL")," operator handled by ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr_is_null")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// The code-gen for is_null is one of the easiest.  The recursive call\n// produces is_null as one of the outputs.  Use that.  Our is_null result\n// is always zero because IS NULL is never, itself, null.\nstatic void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {\n  sem_t sem_type_expr = expr->sem->sem_type;\n\n  // expr IS NULL\n  bprintf(is_null, "0"); // the result of is null is never null\n\n  // The fact that this is not constant not null for not null reference types reflects\n  // the weird state of affairs with uninitualized reference variables which\n  // must be null even if they are typed not null.\n\n  if (is_not_nullable(sem_type_expr) && !is_ref_type(sem_type_expr)) {\n    // Note, sql has no side-effects so we can fold this away.\n    bprintf(value, "0");\n  }\n  else {\n    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);\n    bprintf(value, "%s", expr_is_null.ptr);\n    CG_POP_EVAL(expr);\n  }\n}\n')),Object(i.b)("p",null,"So walking through this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the result of ",Object(i.b)("inlineCode",{parentName:"li"},"IS NULL"),' is never null, so we can immediately put "0" into the ',Object(i.b)("inlineCode",{parentName:"li"},"is_null")," buffer"),Object(i.b)("li",{parentName:"ul"},"if the operand is a not-null numeric type then the result of ",Object(i.b)("inlineCode",{parentName:"li"},"IS NULL")," is ",Object(i.b)("inlineCode",{parentName:"li"},"0")),Object(i.b)("li",{parentName:"ul"},"if the operand might actually be null then",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"use ",Object(i.b)("inlineCode",{parentName:"li"},"CG_PUSH_EVAL")," to recursively do codegen for it"),Object(i.b)("li",{parentName:"ul"},"copy its ",Object(i.b)("inlineCode",{parentName:"li"},"expr_is_null")," text into our ",Object(i.b)("inlineCode",{parentName:"li"},"value")," text")))),Object(i.b)("p",null,"Note: the code reveals one of the big CQL secrets that not null reference variables can be null...  C has the same issue with ",Object(i.b)("inlineCode",{parentName:"p"},"_Nonnull")," globals."),Object(i.b)("p",null,"Now let's look at those helper macros, they are pretty simple:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Make a temporary buffer for the evaluation results using the canonical naming convention\n// burn the stack slot so that any type and numbered temporary that was needed\n// won't be re-used until this scope is over.\n#define CG_PUSH_EVAL(expr, pri) \\\nCHARBUF_OPEN(expr##_is_null); \\\nCHARBUF_OPEN(expr##_value); \\\ncg_expr(expr, &expr##_is_null, &expr##_value, pri); \\\nstack_level++;\n")),Object(i.b)("p",null,"The push macro simply creates buffers to hold the ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," results, then it calls ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr")," to dispatch the indicated expression.\nThe ",Object(i.b)("inlineCode",{parentName:"p"},"pri")," value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is your ",Object(i.b)("inlineCode",{parentName:"p"},"pri_new"),"\nvalue but often you can use ",Object(i.b)("inlineCode",{parentName:"p"},"C_EXPR_PRI_ROOT")," if you know that, because of your current context, the callee will never need parentheses."),Object(i.b)("p",null,"How do we know this here? It seems like the operand of ",Object(i.b)("inlineCode",{parentName:"p"},"IS NULL")," could be anything surely it might need parentheses?  Let's consider:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"if the operand is of not null numeric type then we aren't even going to evaluate it, we're on the easy \"no it's not null\" path"),Object(i.b)("li",{parentName:"ul"},"if the operand is nullable then the only place the answer can be stored is in a scratch variable and its ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression will be exactly like ",Object(i.b)("inlineCode",{parentName:"li"},"var.is_null")),Object(i.b)("li",{parentName:"ul"},"if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is ",Object(i.b)("inlineCode",{parentName:"li"},"is_null")," expression will be like ",Object(i.b)("inlineCode",{parentName:"li"},"!var"))),Object(i.b)("p",null,"None of these require further wrapping regardless of what is above this node in the tree because of he strength of the ",Object(i.b)("inlineCode",{parentName:"p"},".")," and ",Object(i.b)("inlineCode",{parentName:"p"},"!")," operators."),Object(i.b)("p",null,'Other cases are usually simpler, such as "no parentheses need to be added by the child node becasue it will be used as the argument to a helper\nfunction so there will always be parens hard-coded anyway".  However these things need to be carefully tested hence the huge variety of codegen tests.'),Object(i.b)("p",null,"Note that after calling ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr")," the stack level was artificially increased.  We'll get to that in the next section.  For now, looking at ",Object(i.b)("inlineCode",{parentName:"p"},"POP_EVAL")," we\ncan see it's very straightforward:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Close the buffers used for the above.  Return the stack level to its original state.\n// Numbered scratch variables are re-used as though they were a stack.\n#define CG_POP_EVAL(expr) \\\nCHARBUF_CLOSE(expr##_value); \\\nCHARBUF_CLOSE(expr##_is_null); \\\nstack_level--;\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"CG_POP_EVAL")," simply closes the buffers and restores the stack."),Object(i.b)("h4",{id:"result-variables"},"Result Variables"),Object(i.b)("p",null,'When recursion happens in the codegen, the common place that the result will be found is\nin a temporary variable -- the generated code will use one or more statements to arrange for the correct\nanswer to be in that variable.  To do this, the codegen needs to first get the name of a suitable\nresult variable of a suitable type.  This is the "other" reason for making scratch variables.'),Object(i.b)("p",null,"There are three macros that make this pretty simple.  The first is ",Object(i.b)("inlineCode",{parentName:"p"},"CG_RESERVE_RESULT_VAR")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Make a scratch variable to hold the final result of an evaluation.\n// It may or may not be used.  It should be the first thing you put\n// so that it is on the top of your stack.  This only saves the slot.\n#define CG_RESERVE_RESULT_VAR(ast, sem_type) \\\nint32_t stack_level_reserved = stack_level; \\\nsem_t sem_type_reserved = sem_type; \\\nast_node *ast_reserved = ast; \\\nCHARBUF_OPEN(result_var); \\\nCHARBUF_OPEN(result_var_is_null); \\\nCHARBUF_OPEN(result_var_value); \\\nstack_level++;\n")),Object(i.b)("p",null,"If this looks a lot like ",Object(i.b)("inlineCode",{parentName:"p"},"PUSH_TEMP")," that shouldn't be surprising.  The name of the variable\nand the expression parts always go into ",Object(i.b)("inlineCode",{parentName:"p"},"charbuf")," variables named ",Object(i.b)("inlineCode",{parentName:"p"},"result_var")," ",Object(i.b)("inlineCode",{parentName:"p"},"result_var_is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"result_var_value"),"\nbut the scratch variable isn't actually allocated!  However -- we burn the stack_level as though it had been\nallocated.  What's up with that?"),Object(i.b)("p",null,"The name might be a clue, this macro reserves stack level slot for the result variable, it's used if you might\nneed a result variable, but you might not.  When you want it we can artificially move the stack level back\nto this spot where the slot was burned, allocate the scratch variable, and then put the stack back.\nThe ",Object(i.b)("inlineCode",{parentName:"p"},"CG_USE_RESULT_VAR")," macro does exactly that."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'// If the result variable is going to be used, this writes its name\n// and .value and .is_null into the is_null and value fields.\n#define CG_USE_RESULT_VAR() \\\nint32_t stack_level_now = stack_level; \\\nstack_level = stack_level_reserved; \\\ncg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value); \\\nstack_level = stack_level_now; \\\nInvariant(result_var.used > 1); \\\nbprintf(is_null, "%s", result_var_is_null.ptr); \\\nbprintf(value, "%s", result_var_value.ptr)\n')),Object(i.b)("p",null,"Once the code generator decides that it will in fact be using a result variable to represent the answer, then\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(i.b)("inlineCode",{parentName:"p"},"value")," buffers can be immediately populated to whatever the values were\nfor the result variable.  That text will be correct regardless of what codegen is used\nto populate the variable."),Object(i.b)("p",null,"There is a simpler macro that reserves and uses the result variable in one step, it's very common.  The\n\"reserve\" pattern is only necessary when there are some paths that need a result variable and some\nthat don't."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"// This does reserve and use in one step\n#define CG_SETUP_RESULT_VAR(ast, sem_type) \\\nCG_RESERVE_RESULT_VAR(ast, sem_type); \\\nCG_USE_RESULT_VAR();\n")),Object(i.b)("p",null,"And now armed with this knowledge we can go back to a previous mystery, let's look at ",Object(i.b)("inlineCode",{parentName:"p"},"CG_PUSH_EVAL")," again"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},"// Make a temporary buffer for the evaluation results using the canonical naming convention\n// burn the stack slot so that any type and numbered temporary that was needed\n// won't be re-used until this scope is over.\n#define CG_PUSH_EVAL(expr, pri) \\\nCHARBUF_OPEN(expr##_is_null); \\\nCHARBUF_OPEN(expr##_value); \\\ncg_expr(expr, &expr##_is_null, &expr##_value, pri); \\\nstack_level++;\n")),Object(i.b)("p",null,"The reason that ",Object(i.b)("inlineCode",{parentName:"p"},"CG_PUSH_EVAL")," includes ",Object(i.b)("inlineCode",{parentName:"p"},"stack_level++")," is that it is entirely possible, even likely,\nthat the result of ",Object(i.b)("inlineCode",{parentName:"p"},"cg_expr")," is in a result variable.  The convention is that if the codegen\nrequires a result variable it is allocated ",Object(i.b)("em",{parentName:"p"},"first")," before any other temporaries.  This is why\nthere is a way to reserve a variable that you ",Object(i.b)("em",{parentName:"p"},"might")," need.  When the codegen is complete,\nand before anything else happens, ",Object(i.b)("inlineCode",{parentName:"p"},"stack_level")," is increased so that the temporary that is\nholding the result will not be re-used!  Any other temporaries are available but the result\nis still live.  This might be easy to get wrong but the macros make it easy to get it right."),Object(i.b)("p",null,"Now, armed with the knowledge that there a result variables and temporary variables and both\ncome from the scratch variable we can resolve the last mystery we left hanging.  Why does\nthe scratch variable API accept an AST pointer?"),Object(i.b)("p",null,"The only place that pointer can be not null is in the ",Object(i.b)("inlineCode",{parentName:"p"},"CG_USE_RESULT_VAR")," macro, it was\nthis line:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"cg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value);\n")),Object(i.b)("p",null,"And ",Object(i.b)("inlineCode",{parentName:"p"},"ast_reserved")," refers to the AST that we are trying to evaluate.  There's an important\nspecial case that we want to optimize that saves a lot of scratch variables.  It's handled\nby this code in ",Object(i.b)("inlineCode",{parentName:"p"},"cg_scratch_var"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-C"},'  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.\n  if (is_assignment_target_reusable(ast, sem_type)) {\n    Invariant(ast && ast->parent && ast->parent->left);\n    EXTRACT_ANY_NOTNULL(name_ast, ast->parent->left);\n    EXTRACT_STRING(name, name_ast);\n    if (is_out_parameter(name_ast->sem->sem_type)) {\n      bprintf(var, "*%s", name);\n    }\n    else {\n      bprintf(var, "%s", name);\n    }\n  }\n')),Object(i.b)("p",null,"The idea is that if the generator is doing an assignment like:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-SQL"},"  SET x := a + b;\n")),Object(i.b)("p",null,"Then the code generator doesn't need a scratch variable to hold the result of the expression ",Object(i.b)("inlineCode",{parentName:"p"},"a + b")," like it would\nin many other contexts.  It can use ",Object(i.b)("inlineCode",{parentName:"p"},"x")," as the result variable!  The ",Object(i.b)("inlineCode",{parentName:"p"},"SET")," codegen will discover\nthat the value it's supposed to set is already in ",Object(i.b)("inlineCode",{parentName:"p"},"x")," so it does nothing and everything just\nworks out.  The price of this is a call to ",Object(i.b)("inlineCode",{parentName:"p"},"is_assignment_target_reusable")," and then some\nlogic to handle the case where ",Object(i.b)("inlineCode",{parentName:"p"},"x")," is an out argument (hence call by reference, hence needs to be used as ",Object(i.b)("inlineCode",{parentName:"p"},"*x"),")."))}p.isMDXComponent=!0},143:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),l=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),b=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=b(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},h=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=b(n),h=a,d=p["".concat(r,".").concat(h)]||p[h]||u[h]||i;return n?l.a.createElement(d,o(o({ref:t},c),{},{components:n})):l.a.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var c=2;c<i;c++)r[c]=n[c];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);