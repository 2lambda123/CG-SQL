(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{116:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),l=(n(0),n(143)),i=["components"],o={id:"int03",title:"Part 3: C Code Generation",sidebar_label:"Part 3: C Code Generation"},c={unversionedId:"int03",id:"int03",isDocsHomePage:!1,title:"Part 3: C Code Generation",description:"\x3c!---",source:"@site/../CQL_Guide/int03.md",slug:"/int03",permalink:"/cql-guide/int03",version:"current",lastUpdatedBy:"Winnie Quinn",lastUpdatedAt:1629346813,sidebar_label:"Part 3: C Code Generation",sidebar:"someSidebar",previous:{title:"Part 2: Semantic Analysis",permalink:"/cql-guide/int02"}},s=[{value:"Preface",id:"preface",children:[]},{value:"C Code Generation",id:"c-code-generation",children:[{value:"Character Buffers and Byte Buffers",id:"character-buffers-and-byte-buffers",children:[]},{value:"Expressions",id:"expressions",children:[]},{value:"Scratch Variables, CG_PUSH_TEMP, CG_POP_TEMP",id:"scratch-variables-cg_push_temp-cg_pop_temp",children:[]},{value:"CG_PUSH_EVAL, CG_POP_EVAL, value, and is_null",id:"cg_push_eval-cg_pop_eval-value-and-is_null",children:[]},{value:"CG_RESERVE_RESULT_VAR, CG_USE_RESULT_VAR, CG_SETUP_RESULT_VAR, CG_CLEANUP_RESULT_VAR",id:"cg_reserve_result_var-cg_use_result_var-cg_setup_result_var-cg_cleanup_result_var",children:[]}]}],b={rightToc:s};function u(e){var t=e.components,n=Object(r.a)(e,i);return Object(l.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h3",{id:"preface"},"Preface"),Object(l.b)("p",null,"Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.\nAs in the previous sections, the goal here is not to go over every detail of code generation but rather to give\na sense of how codegen happens in general -- the core strategies and implementation choices --\nso that when reading the code you have an idea how smaller pieces would fit into the whole. To accomplish\nthis, various key data structures will be explained in detail as well as selected examples of their use."),Object(l.b)("h2",{id:"c-code-generation"},"C Code Generation"),Object(l.b)("p",null,"There are several key pieces of C code that we have to generate to make working CQL procedures using C\nfunctions.  This all happens in ",Object(l.b)("inlineCode",{parentName:"p"},"cg_c.c"),".  From a big picture perspective, these are the essential problems:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"we have to compile SQL expressions into C",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"including expressions with variables that are nullable"),Object(l.b)("li",{parentName:"ul"},"including SQL expressions that are highly complex like ",Object(l.b)("inlineCode",{parentName:"li"},"CASE..WHEN..THEN..END")," and ",Object(l.b)("inlineCode",{parentName:"li"},"IN (..)")))),Object(l.b)("li",{parentName:"ul"},"we have to generate control flow for things like ",Object(l.b)("inlineCode",{parentName:"li"},"IF"),", ",Object(l.b)("inlineCode",{parentName:"li"},"WHILE")," and, ",Object(l.b)("inlineCode",{parentName:"li"},"SWITCH")),Object(l.b)("li",{parentName:"ul"},"we have to make result sets",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"including the code to slurp up all the rows from a SQL statement into an array of values"),Object(l.b)("li",{parentName:"ul"},"we want to do this very economically"))),Object(l.b)("li",{parentName:"ul"},"we have to be able to create the text for every SQLite statement and bind any variables to it"),Object(l.b)("li",{parentName:"ul"},"we have to check every SQLite API for errors and throw exceptions consistently and deal with them",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"including constructs that allow users to handle exceptions, such as ",Object(l.b)("inlineCode",{parentName:"li"},"TRY/CATCH")))),Object(l.b)("li",{parentName:"ul"},"we have to track any reference types carefully so that retain/release pairs are done consistently",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"even in the presence of SQLite errors or other exceptions"))),Object(l.b)("li",{parentName:"ul"},"we have to produce a ",Object(l.b)("inlineCode",{parentName:"li"},".h")," and a ",Object(l.b)("inlineCode",{parentName:"li"},".c")," file for the C compiler",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"contributions to these files could come from various places"),Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},".c")," file will itself have various sections and we might need to contribute to them at various points in the compilation"))),Object(l.b)("li",{parentName:"ul"},"we want to do this all in one pass over the AST"),Object(l.b)("li",{parentName:"ul"},"we get to assume that the program is error free, codegen never runs unless semantic analysis reports zero errors",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"so nothing can be wrong by the time the codegen pass runs, we never detect errors here"),Object(l.b)("li",{parentName:"ul"},"sometimes we add ",Object(l.b)("inlineCode",{parentName:"li"},"Contract")," and ",Object(l.b)("inlineCode",{parentName:"li"},"Invariant")," statements to ",Object(l.b)("inlineCode",{parentName:"li"},"cg.c")," that make our assumptions clear and prevent regressions")))),Object(l.b)("p",null,"There are some very important building blocks used to solve these problems we will start with those, then move to\na discussion of each of the essential kinds of code generation that we have to do to get working programs."),Object(l.b)("h3",{id:"character-buffers-and-byte-buffers"},"Character Buffers and Byte Buffers"),Object(l.b)("p",null,"The first kind of text output that CQL could produce was the AST echoing.  This was original done directly with ",Object(l.b)("inlineCode",{parentName:"p"},"fprintf")," but\nthat was not flexible enough as the output had to be captured to be emitted into other places like comments or the text of\nSQL statements to go to SQLite.  This forces that pass to use character buffers, which we touched on in Part 1.  Code generation\nhas a more profound dependency on character buffers -- they are literally all over ",Object(l.b)("inlineCode",{parentName:"p"},"cg_c.c")," and we need to go over how hey are used."),Object(l.b)("p",null,"The public interace is in ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf.h")," and it's really quite simple.  You allocate a ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," and then you can ",Object(l.b)("inlineCode",{parentName:"p"},"bprintf")," into it.\nLet's be a bit more specific:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_INTERNAL_SIZE 1024\n#define CHARBUF_GROWTH_SIZE 1024\n\ntypedef struct charbuf\n{\n  char *ptr;      // pointer to stored data, if any\n  uint32_t used;  // bytes used in current buffer\n  uint32_t max;   // max bytes in current buffer\n\n  // builtin buffer storage\n  char internal[CHARBUF_INTERNAL_SIZE];\n} charbuf;\n\ncql_data_decl( int32_t charbuf_open_count );\n\ncql_noexport void bopen(charbuf* b);\ncql_noexport void bclose(charbuf *b);\ncql_noexport void bprintf(charbuf *b, const char *format, ...);\n")),Object(l.b)("p",null,"The typical pattern goes something like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},'  charbuf foo;\n  bopen(&foo);\n  bprintf(&foo, "Hello %s\\n", "World");\n  // do something with foo.ptr\n  bclose(&foo);\n')),Object(l.b)("p",null,"Note that ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," includes ",Object(l.b)("inlineCode",{parentName:"p"},"CHARBUF_INTERNAL_SIZE")," of storage that does not\nhave to be allocated with ",Object(l.b)("inlineCode",{parentName:"p"},"malloc")," and it doesn't grow very aggressively.\nThis reflects that fact that most ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," instances are very small.\nOf course a ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," could go on the heap if it needs to outlive\nthe function it appears in, but this is exceedingly rare."),Object(l.b)("p",null,"To make sure buffers are consistently closed (and this is a problem because\nthere are often a lot of them.  They are allocated with these simple helper\nmacros."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_OPEN(x) \\\n  int32_t __saved_charbuf_count##x = charbuf_open_count; \\\n  charbuf x; \\\n  bopen(&x)\n\n#define CHARBUF_CLOSE(x) \\\n  bclose(&x); \\\n  Invariant(__saved_charbuf_count##x == charbuf_open_count)\n")),Object(l.b)("p",null,"the earlier example would be written more properly:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},'  CHARBUF_OPEN(foo);\n    bprintf(&foo, "Hello %s\\n", "World");\n    // do something with foo.ptr\n  CHARBUF_CLOSE(foo);\n')),Object(l.b)("p",null,"If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure."),Object(l.b)("p",null,'It\'s normal to create several buffers in the course of doing code generation.  In fact some of these buffers\nbecome "globally" visible and get swapped out as needed.  For instance this kind of chaining is normal.\nInside of ',Object(l.b)("inlineCode",{parentName:"p"},"cg_create_proc_stmt")," there is these sequence:"),Object(l.b)("p",null,"Make new buffers..."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},"  CHARBUF_OPEN(proc_fwd_ref);\n  CHARBUF_OPEN(proc_body);\n  CHARBUF_OPEN(proc_locals);\n  CHARBUF_OPEN(proc_cleanup);\n")),Object(l.b)("p",null,"Save what we got..."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},"  charbuf *saved_main = cg_main_output;\n  charbuf *saved_decls = cg_declarations_output;\n  charbuf *saved_scratch = cg_scratch_vars_output;\n  charbuf *saved_cleanup = cg_cleanup_output;\n  charbuf *saved_fwd_ref = cg_fwd_ref_output;\n")),Object(l.b)("p",null,"Switch to the new..."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},"  cg_fwd_ref_output = &proc_fwd_ref;\n  cg_main_output = &proc_body;\n  cg_declarations_output = &proc_locals;\n  cg_scratch_vars_output = &proc_locals;\n  cg_cleanup_output = &proc_cleanup;\n")),Object(l.b)("p",null,"And of course the code puts the original values back when it's done and closes the buffers."),Object(l.b)("p",null,"This means that while processing a procedure the codegen that declares say scratch variables,\nwhich would go to ",Object(l.b)("inlineCode",{parentName:"p"},"cg_scratch_vars_output")," is going to target the ",Object(l.b)("inlineCode",{parentName:"p"},"proc_locals")," buffer\nwhich will be emitted before the ",Object(l.b)("inlineCode",{parentName:"p"},"body"),".  By the time ",Object(l.b)("inlineCode",{parentName:"p"},"cg_stmt_list")," is invoked the\n",Object(l.b)("inlineCode",{parentName:"p"},"cg_main_output")," variable will be pointing to the procedure body, thus any statements\nwill go into there rather than being acculated at the global level -- it's possible to\nhave code that is not in a procedure (see ",Object(l.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/x1#--global_proc-name"},Object(l.b)("inlineCode",{parentName:"a"},"--global_proc")),")."),Object(l.b)("p",null,"But in general, it's very useful to have different buffers going on at the same time.  New local variables\nor scratch variables can be added to their own buffer which goes before the code runs.  New cleanup\nsteps that are necessary can be added to the cleanup output which will appear at the end.  The final\nfunction combines all of these pieces with maybe some glue.  Everything works like this, ",Object(l.b)("inlineCode",{parentName:"p"},"IF")," statements,\nexpressions, all of it."),Object(l.b)("p",null,"One interesting but unexpected feature of ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," is that it provides helper methods for indenting\nbuffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C\ncode because of course you want (e.g.) the body of an ",Object(l.b)("inlineCode",{parentName:"p"},"if")," statement to be indented.  CQL tries to create\nwell formatted code that is readable by humans as much as possible."),Object(l.b)("h4",{id:"byte-buffers"},"Byte Buffers"),Object(l.b)("p",null,"These are less commonly used but there is a peer to ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," creatively called ",Object(l.b)("inlineCode",{parentName:"p"},"bytebuf"),".  This gives you\na growable binary buffer.  It's often used to hold arrays of structures.  Interestingly, ",Object(l.b)("inlineCode",{parentName:"p"},"cg_c.c")," doesn't\ncurrently consume byte buffers, the presence of ",Object(l.b)("inlineCode",{parentName:"p"},"bytebuf.c")," actually came late to the CQL compiler. However\nthe CQL runtime ",Object(l.b)("inlineCode",{parentName:"p"},"cqlrt.c")," (and ",Object(l.b)("inlineCode",{parentName:"p"},"cqlrt_common.c"),") provide ",Object(l.b)("inlineCode",{parentName:"p"},"cql_bytebuf_open"),", ",Object(l.b)("inlineCode",{parentName:"p"},"cql_bytebuf_alloc")," and,\n",Object(l.b)("inlineCode",{parentName:"p"},"cql_bytebuf_close")," which are akin to the ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," methods.  These functions are used in the generated\ncode to create result sets at runtime.  The ",Object(l.b)("inlineCode",{parentName:"p"},"bytebuf")," was so useful that it found its way back from the\nruntime into the compiler itself, and is used by other code-generators like the schema upgrader.   The\nsemantic analyzer also uses it to help with query fragments and to track the various upgrade annotations."),Object(l.b)("p",null,"Both ",Object(l.b)("inlineCode",{parentName:"p"},"charbuf")," and ",Object(l.b)("inlineCode",{parentName:"p"},"bytebuf")," are simple enough that they don't need discussion. It's easier to just read\nthe code and the comments."),Object(l.b)("h3",{id:"expressions"},"Expressions"),Object(l.b)("p",null,"Many of the output needs of CQL stemmed from the base case of creating expressions.  A simple CQL\nexpression like"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"  SET x := x + y;\n")),Object(l.b)("p",null,"seems innocuous enough, we'd like this to compile to this code:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},"  x = x + y;\n")),Object(l.b)("p",null,"And indeed, it might.  Here's some actual output from the compiler:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER NOT NULL;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_int32 x = 0;\n  cql_int32 y = 0;\n\n  x = x + y;\n\n}\n#undef _PROC_\n')),Object(l.b)("p",null,"(*) the output above was created by using ",Object(l.b)("inlineCode",{parentName:"p"},"out/cql --in x --cg x.h x.c --nolines")," to avoid all the # directives"),Object(l.b)("p",null,"Looks easy enough.  And indeed if all expressions were like this, you could do expression compilation pretty simply --\nevery binary operator would look something like this:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"recurse left"),Object(l.b)("li",{parentName:"ul"},"emit infix operator"),Object(l.b)("li",{parentName:"ul"},"recurse right")),Object(l.b)("p",null,"This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have\nthe whole expression."),Object(l.b)("p",null,"This doesn't work at all.  To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result\nis telling:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_nullable_int32 x;\n  cql_set_null(x);\n  cql_nullable_int32 y;\n  cql_set_null(y);\n\n  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);\n\n}\n#undef _PROC_\n')),Object(l.b)("p",null,"All that's happened in the above is that ",Object(l.b)("inlineCode",{parentName:"p"},"x")," and ",Object(l.b)("inlineCode",{parentName:"p"},"y")," became nullable variables, that is the ",Object(l.b)("inlineCode",{parentName:"p"},"NOT NULL")," was\nremoved from the declaration.  This makes all the difference in the world, and this is a fairly easy case.\nThe problem is that nullable value types like cql_nullable_int32 have an integer and a boolean and these\ndon't flow into expressions that use operators like ",Object(l.b)("inlineCode",{parentName:"p"},"+"),", ",Object(l.b)("inlineCode",{parentName:"p"},"-"),", ",Object(l.b)("inlineCode",{parentName:"p"},"/")," and so forth.  This means that even\nsimple expressions involving nullable types actually expand into several statements.  And, in general,\nthese statements need a place to put their temporary results to accumulate the answer, so scratch variables\nare required to make all this work."),Object(l.b)("p",null,"Here's a more realistic example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)\nBEGIN\n  SET result := 5 * x + 3 * y;\nEND;\n*/\n\n#define _PROC_ "combine"\nvoid combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {\n  cql_contract_argument_notnull((void *)result, 3);\n\n  cql_nullable_int32 _tmp_n_int_1;\n  cql_set_null(_tmp_n_int_1);\n  cql_nullable_int32 _tmp_n_int_2;\n  cql_set_null(_tmp_n_int_2);\n\n  cql_set_null(*result); // set out arg to non-garbage\n  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);\n  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);\n  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);\n\n}\n#undef _PROC_\n#pragma clang diagnostic pop\n')),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1")," holds the product of x and 5, it's null if ",Object(l.b)("inlineCode",{parentName:"li"},"x.is_null")," is true"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2")," holds the product of y and 3, it's null if ",Object(l.b)("inlineCode",{parentName:"li"},"y.is_null")," is true"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"*result")," holds the answer, it's null if either of ",Object(l.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.is_null"),", ",Object(l.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2.is_null")," is true",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"otherwise it's ",Object(l.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.value + _tmp_n_int_2.value"))))),Object(l.b)("p",null,"So, in general, we need to emit arbitarily many statements in the course of evaluating even simple looking expressions\nand we need good mechanisms to manage that.  This is what we'll talk about in the coming sections."),Object(l.b)("h3",{id:"scratch-variables-cg_push_temp-cg_pop_temp"},"Scratch Variables, CG_PUSH_TEMP, CG_POP_TEMP"),Object(l.b)("h3",{id:"cg_push_eval-cg_pop_eval-value-and-is_null"},"CG_PUSH_EVAL, CG_POP_EVAL, value, and is_null"),Object(l.b)("h3",{id:"cg_reserve_result_var-cg_use_result_var-cg_setup_result_var-cg_cleanup_result_var"},"CG_RESERVE_RESULT_VAR, CG_USE_RESULT_VAR, CG_SETUP_RESULT_VAR, CG_CLEANUP_RESULT_VAR"))}u.isMDXComponent=!0},143:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),b=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=b(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=b(n),d=a,h=u["".concat(i,".").concat(d)]||u[d]||p[d]||l;return n?r.a.createElement(h,o(o({ref:t},s),{},{components:n})):r.a.createElement(h,o({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);