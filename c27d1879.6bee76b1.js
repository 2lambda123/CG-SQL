(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{120:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),l=n(6),r=(n(0),n(147)),i=["components"],s={id:"int03",title:"Part 3: C Code Generation",sidebar_label:"Part 3: C Code Generation"},o={unversionedId:"int03",id:"int03",isDocsHomePage:!1,title:"Part 3: C Code Generation",description:"\x3c!---",source:"@site/../CQL_Guide/int03.md",slug:"/int03",permalink:"/cql-guide/int03",version:"current",lastUpdatedBy:"Winnie Quinn",lastUpdatedAt:1632891120,sidebar_label:"Part 3: C Code Generation",sidebar:"someSidebar",previous:{title:"Part 2: Semantic Analysis",permalink:"/cql-guide/int02"},next:{title:"Part 4: Testing",permalink:"/cql-guide/int04"}},c=[{value:"Preface",id:"preface",children:[]},{value:"C Code Generation",id:"c-code-generation",children:[{value:"Launching the Code Generator",id:"launching-the-code-generator",children:[]},{value:"Character Buffers and Byte Buffers",id:"character-buffers-and-byte-buffers",children:[]},{value:"Expressions",id:"expressions",children:[]},{value:"Basic Control Flow Patterns",id:"basic-control-flow-patterns",children:[]},{value:"Cleanup and Errors",id:"cleanup-and-errors",children:[]},{value:"String Literals",id:"string-literals",children:[]},{value:"Executing SQLite Statements",id:"executing-sqlite-statements",children:[]},{value:"Reading Single Values",id:"reading-single-values",children:[]},{value:"Reading Rows With Cursors",id:"reading-rows-with-cursors",children:[]},{value:"Fetching Data From Cursors",id:"fetching-data-from-cursors",children:[]},{value:"Cursors With Storage",id:"cursors-with-storage",children:[]},{value:"Flowing SQLite Statements Between Procedures",id:"flowing-sqlite-statements-between-procedures",children:[]},{value:"Value Cursors",id:"value-cursors",children:[]},{value:"Returning Value Cursors",id:"returning-value-cursors",children:[]},{value:"Result Sets",id:"result-sets",children:[]},{value:"Recap",id:"recap",children:[]}]}],b={rightToc:c};function p(e){var t=e.components,n=Object(l.a)(e,i);return Object(r.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h3",{id:"preface"},"Preface"),Object(r.b)("p",null,"Part 3 continues with a discussion of the essentials of the C code generation pass of the CQL compiler.\nAs in the previous sections, the goal here is not to go over every detail of code generation but rather to give\na sense of how codegen happens in general -- the core strategies and implementation choices --\nso that when reading the code you will have an idea how smaller pieces would fit into the whole. To accomplish\nthis, various key data structures will be explained in detail as well as selected examples of their use."),Object(r.b)("h2",{id:"c-code-generation"},"C Code Generation"),Object(r.b)("p",null,"There are several key pieces of C code that we have to generate to make working CQL procedures using C\nfunctions.  This all happens in ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c"),".  From a big picture perspective, these are the essential problems:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"we have to compile SQL expressions into C",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"including expressions with variables that are nullable"),Object(r.b)("li",{parentName:"ul"},"including SQL expressions that are highly complex like ",Object(r.b)("inlineCode",{parentName:"li"},"CASE..WHEN..THEN..END")," and ",Object(r.b)("inlineCode",{parentName:"li"},"IN (..)")))),Object(r.b)("li",{parentName:"ul"},"we have to generate control flow for things like ",Object(r.b)("inlineCode",{parentName:"li"},"IF"),", ",Object(r.b)("inlineCode",{parentName:"li"},"WHILE")," and, ",Object(r.b)("inlineCode",{parentName:"li"},"SWITCH")),Object(r.b)("li",{parentName:"ul"},"we have to make result sets",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"including the code to slurp up all the rows from a SQL statement into an array of values"),Object(r.b)("li",{parentName:"ul"},"we want to do this very economically"))),Object(r.b)("li",{parentName:"ul"},"we have to be able to create the text for every SQLite statement and bind any variables to it"),Object(r.b)("li",{parentName:"ul"},"we have to check every SQLite API for errors and throw exceptions consistently and deal with them",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"including constructs that allow users to handle exceptions, such as ",Object(r.b)("inlineCode",{parentName:"li"},"TRY/CATCH")))),Object(r.b)("li",{parentName:"ul"},"we have to track any reference types carefully so that retain/release pairs are done consistently",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"even in the presence of SQLite errors or other exceptions"))),Object(r.b)("li",{parentName:"ul"},"we have to produce a ",Object(r.b)("inlineCode",{parentName:"li"},".h")," and a ",Object(r.b)("inlineCode",{parentName:"li"},".c")," file for the C compiler",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"contributions to these files could come from various places, not necessarily in order"),Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},".c")," file will itself have various sections and we might need to contribute to them at various points in the compilation"))),Object(r.b)("li",{parentName:"ul"},"we want to do this all in one pass over the AST"),Object(r.b)("li",{parentName:"ul"},"we get to assume that the program is error-free -- codegen never runs unless semantic analysis reports zero errors",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"so nothing can be wrong by the time the codegen pass runs, we never detect errors here"),Object(r.b)("li",{parentName:"ul"},"sometimes we add ",Object(r.b)("inlineCode",{parentName:"li"},"Contract")," and ",Object(r.b)("inlineCode",{parentName:"li"},"Invariant")," statements to ",Object(r.b)("inlineCode",{parentName:"li"},"cg.c")," to make our assumptions clear and to prevent regressions")))),Object(r.b)("p",null,"There are some very important building blocks used to solve these problems: we will start with those, then move to\na discussion of each of the essential kinds of code generation that we have to do to get working programs."),Object(r.b)("h3",{id:"launching-the-code-generator"},"Launching the Code Generator"),Object(r.b)("p",null,"Once semantic analysis is done, all of the code generators have the same contract: they\nhave a main function like ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c_main")," for the C code generator.  It gets the root of\nthe AST and it can use the public interface of the semantic analyzer to get additional\ninformation.  See ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int02"},"Part 2")," for those details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Main entry point for code-gen.  This will set up the buffers for the global\n// variables and any loose calls or DML.  Any code that needs to run in the\n// global scope will be added to the global_proc.  This is the only codegen\n// error that is possible.  If you need global code and you don't have a global\n// proc then you can't proceed.  Semantic analysis doesn't want to know that stuff.\n// Otherwise all we do is set up the most general buffers for the global case and\n// spit out a function with the correct name.\ncql_noexport void cg_c_main(ast_node *head) { ... }\n")),Object(r.b)("p",null,"In addition to initializing its scratch storage, the main entry point also sets up a\nsymbol table for AST dispatch just like the ",Object(r.b)("inlineCode",{parentName:"p"},"gen_")," and ",Object(r.b)("inlineCode",{parentName:"p"},"sem_")," functions do.  Here\nare some samples from that table with the most common options:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  DDL_STMT_INIT(drop_table_stmt);\n  DDL_STMT_INIT(drop_view_stmt);\n  DDL_STMT_INIT(create_table_stmt);\n  DDL_STMT_INIT(create_view_stmt);\n")),Object(r.b)("p",null,"The DDL (Data Definition Language) statements all get the same handling:  The text of the statement\nis generated from the AST. Any variables are bound and then the statement is executed.  The work\nis done with ",Object(r.b)("inlineCode",{parentName:"p"},"cg_bound_sql_statement")," which will be discussed later."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Straight up DDL invocation.  The ast has the statement, execute it!\n// We don't minify the aliases because DDL can have views and the view column names\n// can be referred to in users of the view.  Loose select statements can have\n// no external references to column aliases.\nstatic void cg_any_ddl_stmt(ast_node *ast) {\n  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);\n}\n")),Object(r.b)("p",null,"DML (Data Manipulation Language) statements are declared similarly:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"  STD_DML_STMT_INIT(begin_trans_stmt);\n  STD_DML_STMT_INIT(commit_trans_stmt);\n  STD_DML_STMT_INIT(rollback_trans_stmt);\n  STD_DML_STMT_INIT(savepoint_stmt);\n  STD_DML_STMT_INIT(delete_stmt);\n")),Object(r.b)("p",null,"The DML statements are handled by ",Object(r.b)("inlineCode",{parentName:"p"},"cg_std_dml_exec_stmt"),"; the processing is identical to\nDDL except ",Object(r.b)("inlineCode",{parentName:"p"},"CG_MINIFY_ALIASES")," is specified.  This allows the code generator\nto remove unused column aliases in ",Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statements to save space."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"// Straight up DML invocation.  The ast has the statement, execute it!\nstatic void cg_std_dml_exec_stmt(ast_node *ast) {\n  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);\n}\n")),Object(r.b)("p",null,"Note that this flag difference only matters for the ",Object(r.b)("inlineCode",{parentName:"p"},"CREATE VIEW")," statement\nbut for symmetry all the DDL is handled with one macro and all the DML\nwith the second macro."),Object(r.b)("p",null,"Next, the easiest case... there are a bunch of statements that create\nno code-gen at all.  These statements are type definitions that are interesting\nonly to the semantic analyzer, or other control statements.  Some examples:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  NO_OP_STMT_INIT(declare_enum_stmt);\n  NO_OP_STMT_INIT(declare_named_type);\n")),Object(r.b)("p",null,"Next, the general purpose statement handler.  ",Object(r.b)("inlineCode",{parentName:"p"},"STMT_INIT")," creates mappings\nsuch as the ",Object(r.b)("inlineCode",{parentName:"p"},"if_stmt")," AST node mapping to ",Object(r.b)("inlineCode",{parentName:"p"},"cg_if_stmt"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  STMT_INIT(if_stmt);\n  STMT_INIT(switch_stmt);\n  STMT_INIT(while_stmt);\n  STMT_INIT(assign);\n")),Object(r.b)("p",null,"The next group of declarations are the expressions, with precedence and operator specified.\nThere is a lot of code sharing between AST types as you can see from this sample:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  EXPR_INIT(num, cg_expr_num, "num", C_EXPR_PRI_ROOT);\n  EXPR_INIT(str, cg_expr_str, "STR", C_EXPR_PRI_ROOT);\n  EXPR_INIT(null, cg_expr_null, "NULL", C_EXPR_PRI_ROOT);\n  EXPR_INIT(dot, cg_expr_dot, "DOT", C_EXPR_PRI_ROOT);\n\n  EXPR_INIT(mul, cg_binary, "*", C_EXPR_PRI_MUL);\n  EXPR_INIT(div, cg_binary, "/", C_EXPR_PRI_MUL);\n  EXPR_INIT(mod, cg_binary, "%", C_EXPR_PRI_MUL);\n  EXPR_INIT(add, cg_binary, "+", C_EXPR_PRI_ADD);\n  EXPR_INIT(sub, cg_binary, "-", C_EXPR_PRI_ADD);\n  EXPR_INIT(not, cg_unary, "!", C_EXPR_PRI_UNARY);\n  EXPR_INIT(tilde, cg_unary, "~", C_EXPR_PRI_UNARY);\n  EXPR_INIT(uminus, cg_unary, "-", C_EXPR_PRI_UNARY);\n')),Object(r.b)("p",null,"Most (not all) of the binary operators are handled with one function ",Object(r.b)("inlineCode",{parentName:"p"},"cg_binary")," and likewise\nmost unary operators are handled with ",Object(r.b)("inlineCode",{parentName:"p"},"cg_unary"),"."),Object(r.b)("p",null,"Note: the precedence constants are the ",Object(r.b)("inlineCode",{parentName:"p"},"C_EXPR_PRI_*")," flavor because, naturally, parentheses\nwill be generated based on the C rules during C codegen.  Importantly, the AST still, and always,\nauthoritatively encodes the user-specified order of operations -- there's no change there.  The\nonly thing that changes is where parentheses are needed to get the desired result.  Some parens\nmay need to be added, and some that were present in the original text might no longer be needed."),Object(r.b)("p",null,"Here are some helpful examples:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  /* NOT is weaker than + */\n  LET x := (NOT 1) + (NOT 2);\n  SET x := NOT 1 + 2;\nEND;\n")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"void p(void) {\n  cql_bool x = 0;\n\n  /* ! is stronger than + */\n  x = ! 1 + ! 2;\n  x = ! (1 + 2);\n}\n")),Object(r.b)("p",null,"Finally, many built-in functions need special codegen, such as:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  FUNC_INIT(coalesce);\n  FUNC_INIT(printf);\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"FUNC_INIT(coalesce)")," creates a mapping between the function name ",Object(r.b)("inlineCode",{parentName:"p"},"coalesce")," and the generator ",Object(r.b)("inlineCode",{parentName:"p"},"cg_func_coalesce"),"."),Object(r.b)("h3",{id:"character-buffers-and-byte-buffers"},"Character Buffers and Byte Buffers"),Object(r.b)("p",null,"The first kind of text output that CQL could produce was the AST echoing.  This was originally done directly with ",Object(r.b)("inlineCode",{parentName:"p"},"fprintf")," but\nthat was never going to be flexible enough -- we have to be able to emit that output into other places like comments, or the text of\nSQL statements.  This need forces that pass to use character buffers, which we touched on in Part 1.  C Code generation\nhas a more profound dependency on character buffers -- they are literally all over ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," and we need to go over how they are used\nif we're going to understand the codegen passes."),Object(r.b)("p",null,"The public  interface for ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," is in ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf.h")," and it's really quite simple.  You allocate a ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," and then you can\n",Object(r.b)("inlineCode",{parentName:"p"},"bprintf")," into it. Let's be a bit more specific:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_INTERNAL_SIZE 1024\n#define CHARBUF_GROWTH_SIZE 1024\n\ntypedef struct charbuf\n{\n  char *ptr;      // pointer to stored data, if any\n  uint32_t used;  // bytes used in current buffer\n  uint32_t max;   // max bytes in current buffer\n\n  // builtin buffer storage\n  char internal[CHARBUF_INTERNAL_SIZE];\n} charbuf;\n\ncql_data_decl( int32_t charbuf_open_count );\n\ncql_noexport void bopen(charbuf* b);\ncql_noexport void bclose(charbuf *b);\ncql_noexport void bprintf(charbuf *b, const char *format, ...);\n")),Object(r.b)("p",null,"The typical pattern goes something like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  charbuf foo;\n  bopen(&foo);\n  bprintf(&foo, "Hello %s\\n", "World");\n  // do something with foo.ptr\n  bclose(&foo);\n')),Object(r.b)("p",null,"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," includes ",Object(r.b)("inlineCode",{parentName:"p"},"CHARBUF_INTERNAL_SIZE")," of storage that does not\nhave to be allocated with ",Object(r.b)("inlineCode",{parentName:"p"},"malloc")," and it doesn't grow very aggressively.\nThis economy reflects that fact that most ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," instances are very small.\nOf course a ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," could go on the heap if it needs to outlive\nthe function it appears in, but this is exceedingly rare."),Object(r.b)("p",null,"To make sure buffers are consistently closed -- and this is a problem because\nthere are often a lot of them -- they are allocated with these simple helper\nmacros:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#define CHARBUF_OPEN(x) \\\n  int32_t __saved_charbuf_count##x = charbuf_open_count; \\\n  charbuf x; \\\n  bopen(&x)\n\n#define CHARBUF_CLOSE(x) \\\n  bclose(&x); \\\n  Invariant(__saved_charbuf_count##x == charbuf_open_count)\n")),Object(r.b)("p",null,"The earlier example would be written more properly:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  CHARBUF_OPEN(foo);\n    bprintf(&foo, "Hello %s\\n", "World");\n    // do something with foo.ptr\n  CHARBUF_CLOSE(foo);\n')),Object(r.b)("p",null,"If you forget to close a buffer the count will get messed up and the next close will trigger an assertion failure."),Object(r.b)("p",null,'It\'s normal to create several buffers in the course of doing code generation.  In fact some of these buffers\nbecome "globally" visible and get swapped out as needed.  For instance, the kind of chaining we see\ninside of ',Object(r.b)("inlineCode",{parentName:"p"},"cg_create_proc_stmt")," is normal, here is the sequence:"),Object(r.b)("p",null,"Make new buffers..."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  CHARBUF_OPEN(proc_fwd_ref);\n  CHARBUF_OPEN(proc_body);\n  CHARBUF_OPEN(proc_locals);\n  CHARBUF_OPEN(proc_cleanup);\n")),Object(r.b)("p",null,"Save the current buffer pointers..."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  charbuf *saved_main = cg_main_output;\n  charbuf *saved_decls = cg_declarations_output;\n  charbuf *saved_scratch = cg_scratch_vars_output;\n  charbuf *saved_cleanup = cg_cleanup_output;\n  charbuf *saved_fwd_ref = cg_fwd_ref_output;\n")),Object(r.b)("p",null,"Switch to the new buffers..."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  cg_fwd_ref_output = &proc_fwd_ref;\n  cg_main_output = &proc_body;\n  cg_declarations_output = &proc_locals;\n  cg_scratch_vars_output = &proc_locals;\n  cg_cleanup_output = &proc_cleanup;\n")),Object(r.b)("p",null,"And of course the code puts the original values back when it's done and then closes what it opened."),Object(r.b)("p",null,"This means that while processing a procedure the codegen that declares say scratch variables,\nwhich would go to ",Object(r.b)("inlineCode",{parentName:"p"},"cg_scratch_vars_output"),", is going to target the ",Object(r.b)("inlineCode",{parentName:"p"},"proc_locals")," buffer\nwhich will be emitted before the ",Object(r.b)("inlineCode",{parentName:"p"},"proc_body"),".  By the time ",Object(r.b)("inlineCode",{parentName:"p"},"cg_stmt_list")," is invoked the\n",Object(r.b)("inlineCode",{parentName:"p"},"cg_main_output")," variable will be pointing to the procedure body, thus any statements\nwill go into there rather than being accumulated at the global level."),Object(r.b)("p",null,"Note: it's possible to have code that is not in a procedure (see ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/x1#--global_proc-name"},Object(r.b)("inlineCode",{parentName:"a"},"--global_proc")),")."),Object(r.b)("p",null,"In general, it's very useful to have different buffers open at the same time.  New local variables\nor scratch variables can be added to their own buffer. New cleanup steps that are necessary can be added to\n",Object(r.b)("inlineCode",{parentName:"p"},"cg_cleanup_output")," which will appear at the end of a procedure. The final steps of procedure codegen\ncombines all of these pieces plus a little glue to make a working procedure."),Object(r.b)("p",null,"All codegen works like this -- statements, expressions, all of it."),Object(r.b)("p",null,"One interesting but unexpected feature of ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," is that it provides helper methods for indenting\na buffer by whatever amount you like.  This turns out to be invaluable in creating well formatted C\ncode because of course we want (e.g.) the body of an ",Object(r.b)("inlineCode",{parentName:"p"},"if")," statement to be indented.  CQL tries to create\nwell formatted code that is readable by humans as much as possible."),Object(r.b)("h4",{id:"byte-buffers"},"Byte Buffers"),Object(r.b)("p",null,"The byte buffers type, creatively called ",Object(r.b)("inlineCode",{parentName:"p"},"bytebuf")," is less commonly used.  It is a peer to ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf"),"\nand provides a growable binary buffer.  ",Object(r.b)("inlineCode",{parentName:"p"},"bytebuf")," is often used to hold arrays of structures.\nInterestingly, ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," doesn't currently consume byte buffers, the presence of ",Object(r.b)("inlineCode",{parentName:"p"},"bytebuf.c")," actually\ncame late to the CQL compiler. However the CQL runtime ",Object(r.b)("inlineCode",{parentName:"p"},"cqlrt.c")," (and ",Object(r.b)("inlineCode",{parentName:"p"},"cqlrt_common.c"),") provide\n",Object(r.b)("inlineCode",{parentName:"p"},"cql_bytebuf_open"),", ",Object(r.b)("inlineCode",{parentName:"p"},"cql_bytebuf_alloc")," and, ",Object(r.b)("inlineCode",{parentName:"p"},"cql_bytebuf_close")," which are akin to the ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," methods.\nThese functions ",Object(r.b)("em",{parentName:"p"},"are")," used in the generated code to create result sets at runtime."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"bytebuf")," was so useful that it found its way back from the runtime into the compiler itself, and is used by\nother code-generators like the schema upgraded.   The semantic analyzer also uses it to help with query\nfragments and to track the various upgrade annotations."),Object(r.b)("p",null,"Both ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," and ",Object(r.b)("inlineCode",{parentName:"p"},"bytebuf")," are simple enough that they don't need special discussion. Surveying\ntheir code and comments is an excellent exercise for the reader."),Object(r.b)("h3",{id:"expressions"},"Expressions"),Object(r.b)("p",null,"Many of the output needs of CQL stemmed from the base case of creating the code for CQL expressions.\nA simple CQL expression like:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"  SET x := x + y;\n")),Object(r.b)("p",null,"seems innocuous enough, and we'd like that expression to compile to this code:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  x = x + y;\n")),Object(r.b)("p",null,"And indeed, it does.  Here's some actual output from the compiler:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER NOT NULL;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_int32 x = 0;\n  cql_int32 y = 0;\n\n  x = x + y;\n\n}\n#undef _PROC_\n')),Object(r.b)("p",null,"(*) the output above was created by using ",Object(r.b)("inlineCode",{parentName:"p"},"out/cql --in x --cg x.h x.c --nolines")," to avoid all the ",Object(r.b)("inlineCode",{parentName:"p"},"#")," directives"),Object(r.b)("p",null,"That expression looks easy enough. And indeed if all expressions were like this, we could do expression compilation\npretty simply -- every binary operator would look something like this:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"recurse left"),Object(r.b)("li",{parentName:"ul"},"emit infix operator"),Object(r.b)("li",{parentName:"ul"},"recurse right")),Object(r.b)("p",null,"This would sort of build up your expressions inside out and your final buffer after all the recursion was done would have\nthe whole expression."),Object(r.b)("p",null,"This doesn't work at all."),Object(r.b)("p",null,"To illustrate what goes wrong, we only have to change the test case a tiny bit.  The result is telling:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC p ()\nBEGIN\n  DECLARE x, y INTEGER;\n  SET x := x + y;\nEND;\n*/\n\n#define _PROC_ "p"\nvoid p(void) {\n  cql_nullable_int32 x;\n  cql_set_null(x);\n  cql_nullable_int32 y;\n  cql_set_null(y);\n\n  cql_combine_nullables(x, x.is_null, y.is_null, x.value + y.value);\n\n}\n#undef _PROC_\n')),Object(r.b)("p",null,"In this new example above, ",Object(r.b)("inlineCode",{parentName:"p"},"x")," and ",Object(r.b)("inlineCode",{parentName:"p"},"y")," became nullable variables i.e. the ",Object(r.b)("inlineCode",{parentName:"p"},"NOT NULL")," was\nremoved from their declarations -- this makes all the difference in the world."),Object(r.b)("p",null,"Let's take a quick look at ",Object(r.b)("inlineCode",{parentName:"p"},"cql_nullable_int32")," and we'll see the crux of the problem immediately:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct cql_nullable_int32 {\n cql_bool is_null;\n cql_int32 value;\n} cql_nullable_int32;\n")),Object(r.b)("p",null,"The problem is that nullable value types like ",Object(r.b)("inlineCode",{parentName:"p"},"cql_nullable_int32")," have both their ",Object(r.b)("inlineCode",{parentName:"p"},"value")," field\nand a boolean ",Object(r.b)("inlineCode",{parentName:"p"},"is_null")," and these don't flow into expressions that use operators like ",Object(r.b)("inlineCode",{parentName:"p"},"+"),", ",Object(r.b)("inlineCode",{parentName:"p"},"-"),", ",Object(r.b)("inlineCode",{parentName:"p"},"/")," and so forth.\nThis means that even simple expressions involving nullable types actually expand into several statements.  And, in general,\nthese statements need a place to put their temporary results to accumulate the correct answer, so scratch variables\nare required to make all this work."),Object(r.b)("p",null,"Here's a more realistic example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'/*\nCREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)\nBEGIN\n  SET result := 5 * x + 3 * y;\nEND;\n*/\n\n#define _PROC_ "combine"\nvoid combine(cql_nullable_int32 x, cql_nullable_int32 y, cql_nullable_int32 *_Nonnull result) {\n  cql_contract_argument_notnull((void *)result, 3);\n\n  cql_nullable_int32 _tmp_n_int_1;\n  cql_set_null(_tmp_n_int_1);\n  cql_nullable_int32 _tmp_n_int_2;\n  cql_set_null(_tmp_n_int_2);\n\n  cql_set_null(*result); // set out arg to non-garbage\n  cql_set_nullable(_tmp_n_int_1, x.is_null, 5 * x.value);\n  cql_set_nullable(_tmp_n_int_2, y.is_null, 3 * y.value);\n  cql_combine_nullables(*result, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);\n\n}\n#undef _PROC_\n#pragma clang diagnostic pop\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1")," : holds the product of x and 5, it's null if ",Object(r.b)("inlineCode",{parentName:"li"},"x.is_null")," is true"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2")," : holds the product of y and 3, it's null if ",Object(r.b)("inlineCode",{parentName:"li"},"y.is_null")," is true"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"*result")," : holds the answer, it's null if either of ",Object(r.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.is_null"),", ",Object(r.b)("inlineCode",{parentName:"li"},"_tmp_n_int_2.is_null")," is true",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"otherwise it's ",Object(r.b)("inlineCode",{parentName:"li"},"_tmp_n_int_1.value + _tmp_n_int_2.value"))))),Object(r.b)("p",null,"So, in general, we need to emit arbitrarily many statements in the course of evaluating even simple looking expressions\nand we need good mechanisms to manage that.  This is what we'll talk about in the coming sections."),Object(r.b)("h4",{id:"managing-scratch-variables"},"Managing Scratch Variables"),Object(r.b)("p",null,"The function that actually assigns scratch variables is ",Object(r.b)("inlineCode",{parentName:"p"},"cg_scratch_var")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// The scratch variable helper uses the given sem_type and the current\n// stack level to create a temporary variable name for that type at that level.\n// If the variable does not already have a declaration (as determined by the masks)\n// then a declaration is added to the scratch_vars section.  This is one of the root\n// ways of getting an .is_null and .value back.  Note that not null variables always\n// have a .is_null of "0" which becomes important when deciding how to assign\n// one result to another.  Everything stays uniform.\nstatic void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value)\n')),Object(r.b)("p",null,"The signature is a bit unexpected so we'll go over it, some of below will make more\nsense as we learn about expressions generally, but this is as good an introduction as any."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ast")," : holds a reference to a variable we want to assign to",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this argument is normally ",Object(r.b)("inlineCode",{parentName:"li"},"NULL")," for scratch variables"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ast")," is not null for the ",Object(r.b)("inlineCode",{parentName:"li"},"RESULT")," macros which we'll study later"),Object(r.b)("li",{parentName:"ul"},"for now, we can basically ignore this argument"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sem_type")," : holds the type of the variable we need",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"it must be a unitary type, optionally with ",Object(r.b)("inlineCode",{parentName:"li"},"SEM_TYPE_NOTNULL")," set"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"var")," : a character buffer that will get the name of the variable"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_null")," : a character buffer that will get the ",Object(r.b)("inlineCode",{parentName:"li"},"is_null")," expression for this variable (more below)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"value")," : a character buffer that will get the ",Object(r.b)("inlineCode",{parentName:"li"},"value")," expression for this variable (more below)")),Object(r.b)("p",null,"And this is a good time to talk about ",Object(r.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(r.b)("inlineCode",{parentName:"p"},"value")," because they will be everywhere."),Object(r.b)("p",null,"The codegen for expressions in the C code generator produces two results:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'the text that corresponds to the current value so far (e.g. "(1+2)*3"), and,'),Object(r.b)("li",{parentName:"ul"},"the text that will tell you if the current value is null",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},'this could be as simple as "0" for an expression that is known to be not null')))),Object(r.b)("p",null,"Let's make this a little more concrete:"),Object(r.b)("p",null,'Suppose we ask for a scratch "not null integer", we get results like this:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"var"),":  ",Object(r.b)("inlineCode",{parentName:"li"},'"_tmp_n_int_1"')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_null"),": ",Object(r.b)("inlineCode",{parentName:"li"},'"0"')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"value"),": ",Object(r.b)("inlineCode",{parentName:"li"},'"_tmp_n_int_1"'))),Object(r.b)("p",null,"Meaning: if we want the value, use the text ",Object(r.b)("inlineCode",{parentName:"p"},'"_tmp_n_int_1"')," if we want to know if the variable is null, we use the text ",Object(r.b)("inlineCode",{parentName:"p"},'"0"')),Object(r.b)("p",null,"Note: many parts of ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," special case an ",Object(r.b)("inlineCode",{parentName:"p"},"is_null")," value of ",Object(r.b)("inlineCode",{parentName:"p"},'"0"')," to make better code because such a thing is known to\nbe not null at compile time."),Object(r.b)("p",null,"Now let's suppose we ask for a scratch nullable integer, we get results like this:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"var"),":  ",Object(r.b)("inlineCode",{parentName:"li"},'"_tmp_int_1"')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_null"),": ",Object(r.b)("inlineCode",{parentName:"li"},'"_tmp_int_1.is_null"')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"value"),": ",Object(r.b)("inlineCode",{parentName:"li"},'"_tmp_int_1.value"'))),Object(r.b)("p",null,"So again, we have exactly the text we need to test for null, and the test we need to get the value."),Object(r.b)("p",null,"Additional notes:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'scratch variables can be re-used, they are on a "stack"'),Object(r.b)("li",{parentName:"ul"},"a bitmask is used to track which scratch variables have already had a declaration emitted, so they are only declared once"),Object(r.b)("li",{parentName:"ul"},"the variable name is based on the current value of the ",Object(r.b)("inlineCode",{parentName:"li"},"stack_level")," variable which is increased in a push/pop fashion as temporaries come in and out of scope",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this strategy isn't perfect, but the C compiler can consolidate locals even if the CQL codegen is not perfect so it ends up being not so bad"),Object(r.b)("li",{parentName:"ul"},"importantly, there is one ",Object(r.b)("inlineCode",{parentName:"li"},"stack_level")," variable for all temporaries not one ",Object(r.b)("inlineCode",{parentName:"li"},"stack_level")," for every type of temporary, this seemed like a reasonable simplification")))),Object(r.b)("h4",{id:"allocating-scratch-variables"},"Allocating Scratch Variables"),Object(r.b)("p",null,'The most common reason to create a "scratch" variable is that a temporary variable is needed for some part of the computation.\nThe most common reason for a temporary variable is to hold an intermediate result of a computation involving nullable arithmetic.'),Object(r.b)("p",null,"These temporaries are created with ",Object(r.b)("inlineCode",{parentName:"p"},"CG_PUSH_TEMP")," which simply creates the three ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," variables needed and then asks for a\nscratch variable of the required type.  The variables follow a simple naming convention.  The stack level is increased after\neach temporary is allocated."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers\n// with the text needed to refer to the variable.  cg_scratch_var picks the name\n// based on stack level-and type.\n#define CG_PUSH_TEMP(name, sem_type) \\\n  CHARBUF_OPEN(name); \\\n  CHARBUF_OPEN(name##_is_null); \\\n  CHARBUF_OPEN(name##_value); \\\n  cg_scratch_var(NULL, sem_type, &name, &name##_is_null, &name##_value); \\\n  stack_level++;\n")),Object(r.b)("p",null,"Symmetrically, ",Object(r.b)("inlineCode",{parentName:"p"},"CG_POP_TEMP")," closes the ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," variables and restores the stack level."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Release the buffers for the temporary, restore the stack level.\n#define CG_POP_TEMP(name) \\\n  CHARBUF_CLOSE(name##_value); \\\n  CHARBUF_CLOSE(name##_is_null); \\\n  CHARBUF_CLOSE(name); \\\n  stack_level--;\n")),Object(r.b)("p",null,"As with the other ",Object(r.b)("inlineCode",{parentName:"p"},"PUSH/POP")," ",Object(r.b)("inlineCode",{parentName:"p"},"OPEN/CLOSE")," macro types, these macros are designed to make it impossible\nto forget to free the buffers, or to get the stack level wrong.  The stack level can be (and is) checked\nat strategic places to ensure it's back to baseline -- this is easy because the code can always just\nsnapshot ",Object(r.b)("inlineCode",{parentName:"p"},"stack_level"),", do some work that should be clean, and then check that ",Object(r.b)("inlineCode",{parentName:"p"},"stack_level")," is back to\nwhere it's supposed to be with an ",Object(r.b)("inlineCode",{parentName:"p"},"Invariant"),"."),Object(r.b)("h4",{id:"recursing-sub-expressions"},"Recursing Sub-expressions"),Object(r.b)("p",null,"Now that we understand that we can create scratch variables as needed, it's time to take a look at the typical evaluation patterns\nand how the evaluation works within that pattern.  This is everywhere in ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c"),"."),Object(r.b)("p",null,"So let's look at an actual evaluator, the simplest of them all, this one does code generation for the ",Object(r.b)("inlineCode",{parentName:"p"},"NULL")," literal."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'static void cg_expr_null(\n  ast_node *expr,\n  CSTR op,\n  charbuf *is_null,\n  charbuf *value,\n  int32_t pri,\n  int32_t pri_new)\n{\n  Contract(is_ast_null(expr));\n  // null literal\n  bprintf(value, "NULL");\n  bprintf(is_null, "1");\n}\n')),Object(r.b)("p",null,"Now this may be looking familiar: the signature of the code generator is something very much like the\nsignature of the the ",Object(r.b)("inlineCode",{parentName:"p"},"gen_")," functions in the echoing code.  That's really because in some sense\nthe echoing code is a very simple code generator itself."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"expr")," : the AST we are generating code for"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"op")," : the relevant operator if any (operators share code)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_null")," : a ",Object(r.b)("inlineCode",{parentName:"li"},"charbuf")," into which we can write the ",Object(r.b)("inlineCode",{parentName:"li"},"is_null")," expression text"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"value")," : a ",Object(r.b)("inlineCode",{parentName:"li"},"charbuf")," into which we can write the ",Object(r.b)("inlineCode",{parentName:"li"},"value")," expression text"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"pri")," : the binding strength of the node above this one"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"pri_new")," : the binding strength of this node")),Object(r.b)("p",null,"This particular generator is going to produce ",Object(r.b)("inlineCode",{parentName:"p"},'"NULL"')," for the ",Object(r.b)("inlineCode",{parentName:"p"},"value")," and ",Object(r.b)("inlineCode",{parentName:"p"},'"1"')," for the ",Object(r.b)("inlineCode",{parentName:"p"},"is_null")," expression."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(r.b)("inlineCode",{parentName:"p"},"value")," are the chief outputs, and the caller will use these to create its own expression results\nwith recursive logic.  But the expression logic can also write into the statement stream, the cleanup stream,\neven into the header file stream, and as we'll see, it does."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"pri")," and ",Object(r.b)("inlineCode",{parentName:"p"},"pri_new")," work exactly like they did in the echoing code (see ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),"),\nthey are used to allow the code generator to decide if it needs to emit parentheses.  But recall that the binding strengths\nnow will be the C binding strengths NOT the SQL binding strengths (discussed above)."),Object(r.b)("p",null,"Let's look at one of the simplest operators: the ",Object(r.b)("inlineCode",{parentName:"p"},"IS NULL")," operator handled by ",Object(r.b)("inlineCode",{parentName:"p"},"cg_expr_is_null")),Object(r.b)("p",null,"Note: this code has a simpler signature because it's actually part of codegen for ",Object(r.b)("inlineCode",{parentName:"p"},"cg_expr_is")," which\nhas the general contract."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// The code-gen for is_null is one of the easiest.  The recursive call\n// produces is_null as one of the outputs.  Use that.  Our is_null result\n// is always zero because IS NULL is never, itself, null.\nstatic void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {\n  sem_t sem_type_expr = expr->sem->sem_type;\n\n  // expr IS NULL\n  bprintf(is_null, "0"); // the result of is null is never null\n\n  // The fact that this is not constant not null for not null reference types reflects\n  // the weird state of affairs with uninitialized reference variables which\n  // must be null even if they are typed not null.\n\n  if (is_not_nullable(sem_type_expr) && !is_ref_type(sem_type_expr)) {\n    // Note, sql has no side-effects so we can fold this away.\n    bprintf(value, "0");\n  }\n  else {\n    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);\n    bprintf(value, "%s", expr_is_null.ptr);\n    CG_POP_EVAL(expr);\n  }\n}\n')),Object(r.b)("p",null,"So walking through the above:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"the result of ",Object(r.b)("inlineCode",{parentName:"li"},"IS NULL"),' is never null, so we can immediately put "0" into the ',Object(r.b)("inlineCode",{parentName:"li"},"is_null")," buffer"),Object(r.b)("li",{parentName:"ul"},"if the operand is a not-null numeric type then the result of ",Object(r.b)("inlineCode",{parentName:"li"},"IS NULL")," is ",Object(r.b)("inlineCode",{parentName:"li"},"0")),Object(r.b)("li",{parentName:"ul"},"if the operand might actually be null then",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"use ",Object(r.b)("inlineCode",{parentName:"li"},"CG_PUSH_EVAL")," to recursively do codegen for it"),Object(r.b)("li",{parentName:"ul"},"copy its ",Object(r.b)("inlineCode",{parentName:"li"},"expr_is_null")," text into our ",Object(r.b)("inlineCode",{parentName:"li"},"value")," text")))),Object(r.b)("p",null,"Note: the code reveals one of the big CQL secrets -- that not null reference variables can be null...  C has the same issue with ",Object(r.b)("inlineCode",{parentName:"p"},"_Nonnull")," globals."),Object(r.b)("p",null,"Now let's look at those helper macros, they are pretty simple:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Make a temporary buffer for the evaluation results using the canonical naming convention\n// burn the stack slot so that any type and numbered temporary that was needed\n// won't be re-used until this scope is over.\n#define CG_PUSH_EVAL(expr, pri) \\\n  CHARBUF_OPEN(expr##_is_null); \\\n  CHARBUF_OPEN(expr##_value); \\\n  cg_expr(expr, &expr##_is_null, &expr##_value, pri); \\\n  stack_level++;\n")),Object(r.b)("p",null,"The push macro simply creates buffers to hold the ",Object(r.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(r.b)("inlineCode",{parentName:"p"},"value")," results, then it calls ",Object(r.b)("inlineCode",{parentName:"p"},"cg_expr")," to dispatch the indicated expression.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"pri")," value provided to this macro represents the binding strength that the callee should assume its parent has.  Usually this is the ",Object(r.b)("inlineCode",{parentName:"p"},"pri_new")," of the caller.\nbut often ",Object(r.b)("inlineCode",{parentName:"p"},"C_EXPR_PRI_ROOT")," can be used if the current context implies that the callee will never need parentheses."),Object(r.b)("p",null,"How do we know that parens are not needed here? It seems like the operand of ",Object(r.b)("inlineCode",{parentName:"p"},"IS NULL")," could be anything, surely it might need parentheses?  Let's consider:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"if the operand is of not null numeric type then we aren't even going to evaluate it, we're on the easy \"no it's not null\" path",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"no parens there"))),Object(r.b)("li",{parentName:"ul"},"if the operand is nullable then the only place the answer can be stored is in a scratch variable and its ",Object(r.b)("inlineCode",{parentName:"li"},"is_null")," expression will be exactly like ",Object(r.b)("inlineCode",{parentName:"li"},"var.is_null"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"no parens there"))),Object(r.b)("li",{parentName:"ul"},"if the operand is a reference type, there are no operators that combine reference types to get more reference types, so again the result must be in a variable, and is ",Object(r.b)("inlineCode",{parentName:"li"},"is_null")," expression will be like ",Object(r.b)("inlineCode",{parentName:"li"},"!var"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"no parens there")))),Object(r.b)("p",null,"So, none of these require further wrapping regardless of what is above the ",Object(r.b)("inlineCode",{parentName:"p"},"IS NULL")," node in the tree because of the high strength of the ",Object(r.b)("inlineCode",{parentName:"p"},".")," and ",Object(r.b)("inlineCode",{parentName:"p"},"!")," operators."),Object(r.b)("p",null,'Other cases are usually simpler, such as "no parentheses need to be added by the child node because it will be used as the argument to a helper\nfunction so there will always be parens hard-coded anyway".  However these things need to be carefully tested hence the huge variety of codegen tests.'),Object(r.b)("p",null,"Note that after calling ",Object(r.b)("inlineCode",{parentName:"p"},"cg_expr")," the stack level was artificially increased.  We'll get to that in the next section.  For now, looking at ",Object(r.b)("inlineCode",{parentName:"p"},"POP_EVAL")," we\ncan see it's very straightforward:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Close the buffers used for the above.  Return the stack level to its original state.\n// Numbered scratch variables are re-used as though they were a stack.\n#define CG_POP_EVAL(expr) \\\nCHARBUF_CLOSE(expr##_value); \\\nCHARBUF_CLOSE(expr##_is_null); \\\nstack_level--;\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"CG_POP_EVAL")," simply closes the buffers and restores the stack level."),Object(r.b)("h4",{id:"result-variables"},"Result Variables"),Object(r.b)("p",null,'When recursion happens in the codegen, a common place that the result will be found is\nin a temporary variable i.e. the generated code will use one or more statements to arrange for the correct\nanswer to be in a variable.  To do this, the codegen needs to first get the name of a\nresult variable of a suitable type.  This is the "other" reason for making scratch variables.'),Object(r.b)("p",null,"There are three macros that make this pretty simple.  The first is ",Object(r.b)("inlineCode",{parentName:"p"},"CG_RESERVE_RESULT_VAR")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Make a scratch variable to hold the final result of an evaluation.\n// It may or may not be used.  It should be the first thing you put\n// so that it is on the top of your stack.  This only saves the slot.\n#define CG_RESERVE_RESULT_VAR(ast, sem_type) \\\n  int32_t stack_level_reserved = stack_level; \\\n  sem_t sem_type_reserved = sem_type; \\\n  ast_node *ast_reserved = ast; \\\n  CHARBUF_OPEN(result_var); \\\n  CHARBUF_OPEN(result_var_is_null); \\\n  CHARBUF_OPEN(result_var_value); \\\n  stack_level++;\n")),Object(r.b)("p",null,"If this looks a lot like ",Object(r.b)("inlineCode",{parentName:"p"},"PUSH_TEMP")," that shouldn't be surprising.  The name of the variable\nand the expression parts always go into ",Object(r.b)("inlineCode",{parentName:"p"},"charbuf")," variables named ",Object(r.b)("inlineCode",{parentName:"p"},"result_var"),", ",Object(r.b)("inlineCode",{parentName:"p"},"result_var_is_null"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"result_var_value"),"\nbut the scratch variable isn't actually allocated!  However -- we burn the stack_level as though it had been\nallocated."),Object(r.b)("p",null,"The name of the macro provides a clue: this macro reserves a slot for the result variable, it's used if the codegen might\nneed a result variable, but it might not.  If/when the result variable is needed, it we can artificially move the stack level\nback to the reserved spot, allocate the scratch variable, and then put the stack level back."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"CG_USE_RESULT_VAR")," macro does exactly this operation."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// If the result variable is going to be used, this writes its name\n// and .value and .is_null into the is_null and value fields.\n#define CG_USE_RESULT_VAR() \\\n  int32_t stack_level_now = stack_level; \\\n  stack_level = stack_level_reserved; \\\n  cg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value); \\\n  stack_level = stack_level_now; \\\n  Invariant(result_var.used > 1); \\\n  bprintf(is_null, "%s", result_var_is_null.ptr); \\\n  bprintf(value, "%s", result_var_value.ptr)\n')),Object(r.b)("p",null,"Once the code generator decides that it will in fact be using a result variable to represent the answer, then\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"is_null")," and ",Object(r.b)("inlineCode",{parentName:"p"},"value")," buffers can be immediately populated to whatever the values were\nfor the result variable.  That text will be correct regardless of what codegen is used\nto populate the variable.  The variable is the result."),Object(r.b)("p",null,"There is a simpler macro that reserves and uses the result variable in one step, it's used frequently.\nThe \"reserve\" pattern is only necessary when there are some paths that need a result variable and some\nthat don't."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// This does reserve and use in one step\n#define CG_SETUP_RESULT_VAR(ast, sem_type) \\\n  CG_RESERVE_RESULT_VAR(ast, sem_type); \\\n  CG_USE_RESULT_VAR();\n")),Object(r.b)("p",null,"And now armed with this knowledge we can go back to a previous mystery, let's look at ",Object(r.b)("inlineCode",{parentName:"p"},"CG_PUSH_EVAL")," again:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// Make a temporary buffer for the evaluation results using the canonical naming convention\n// burn the stack slot so that any type and numbered temporary that was needed\n// won't be re-used until this scope is over.\n#define CG_PUSH_EVAL(expr, pri) \\\n  CHARBUF_OPEN(expr##_is_null); \\\n  CHARBUF_OPEN(expr##_value); \\\n  cg_expr(expr, &expr##_is_null, &expr##_value, pri); \\\n  stack_level++;\n")),Object(r.b)("p",null,"The reason that ",Object(r.b)("inlineCode",{parentName:"p"},"CG_PUSH_EVAL")," includes ",Object(r.b)("inlineCode",{parentName:"p"},"stack_level++")," is that it is entirely possible, even likely,\nthat the result of ",Object(r.b)("inlineCode",{parentName:"p"},"cg_expr")," is in a result variable.  The convention is that if the codegen\nrequires a result variable it is allocated ",Object(r.b)("em",{parentName:"p"},"first"),", before any other temporaries.  This is why\nthere is a way to reserve a variable that you ",Object(r.b)("em",{parentName:"p"},"might")," need.  When the codegen is complete,\nand before anything else happens, ",Object(r.b)("inlineCode",{parentName:"p"},"stack_level")," is increased so that if a temporary is\nholding the result, it will not be re-used!  Any other temporaries are available, but the result\nis still live.  The macros make it easy to get this stack convention consistently correct."),Object(r.b)("p",null,"Now, armed with the knowledge that there are result variables and temporary variables and both\ncome from the scratch variables we can resolve the last mystery we left hanging.  Why does\nthe scratch variable API accept an AST pointer?"),Object(r.b)("p",null,"The only place that AST pointer can be not null is in the ",Object(r.b)("inlineCode",{parentName:"p"},"CG_USE_RESULT_VAR")," macro, it was\nthis line:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value);\n")),Object(r.b)("p",null,"And ",Object(r.b)("inlineCode",{parentName:"p"},"ast_reserved")," refers to the AST that we are trying to evaluate.  There's an important\nspecial case that we want to optimize that saves a lot of scratch variables.  That case is handled\nby this code in ",Object(r.b)("inlineCode",{parentName:"p"},"cg_scratch_var"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.\n  if (is_assignment_target_reusable(ast, sem_type)) {\n    Invariant(ast && ast->parent && ast->parent->left);\n    EXTRACT_ANY_NOTNULL(name_ast, ast->parent->left);\n    EXTRACT_STRING(name, name_ast);\n    if (is_out_parameter(name_ast->sem->sem_type)) {\n      bprintf(var, "*%s", name);\n    }\n    else {\n      bprintf(var, "%s", name);\n    }\n  }\n')),Object(r.b)("p",null,"The idea is that if the generator is doing an assignment like:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"  SET x := a + b;\n")),Object(r.b)("p",null,"Then the code generator doesn't need a scratch variable to hold the result of the expression ",Object(r.b)("inlineCode",{parentName:"p"},"a + b")," like it would\nin many other contexts.  It can use ",Object(r.b)("inlineCode",{parentName:"p"},"x")," as the result variable!  The ",Object(r.b)("inlineCode",{parentName:"p"},"SET")," codegen will discover\nthat the value it's supposed to set is already in ",Object(r.b)("inlineCode",{parentName:"p"},"x")," so it does nothing and everything just\nworks out.  The price of this is a call to ",Object(r.b)("inlineCode",{parentName:"p"},"is_assignment_target_reusable")," and then some\nlogic to handle the case where ",Object(r.b)("inlineCode",{parentName:"p"},"x")," is an out argument (hence call by reference, hence needs to be used as ",Object(r.b)("inlineCode",{parentName:"p"},"*x"),")."),Object(r.b)("h3",{id:"basic-control-flow-patterns"},"Basic Control Flow Patterns"),Object(r.b)("p",null,"To get a sense of how the compiler generates code for statements, we can look at some of the easiest cases."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// "While" suffers from the same problem as IF and as a consequence\n// generating while (expression) would not generalize.\n// The overall pattern for while has to look like this:\n//\n//  for (;;) {\n//    prep statements;\n//    condition = final expression;\n//    if (!condition) break;\n//\n//    statements;\n//  }\n//\n// Note that while can have leave and continue substatements which have to map\n// to break and continue.   That means other top level statements that aren\'t loops\n// must not create a C loop construct or break/continue would have the wrong target.\nstatic void cg_while_stmt(ast_node *ast) {\n  Contract(is_ast_while_stmt(ast));\n  EXTRACT_ANY_NOTNULL(expr, ast->left);\n  EXTRACT(stmt_list, ast->right);\n  sem_t sem_type = expr->sem->sem_type;\n\n  // WHILE [expr] BEGIN [stmt_list] END\n\n  bprintf(cg_main_output, "for (;;) {\\n");\n\n  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);\n\n  if (is_nullable(sem_type)) {\n    bprintf(cg_main_output, "if (!cql_is_nullable_true(%s, %s)) break;\\n", expr_is_null.ptr, expr_value.ptr);\n  }\n  else {\n    bprintf(cg_main_output, "if (!(%s)) break;\\n", expr_value.ptr);\n  }\n\n  bool_t loop_saved = cg_in_loop;\n  cg_in_loop = true;\n\n  CG_POP_EVAL(expr);\n\n  cg_stmt_list(stmt_list);\n\n  bprintf(cg_main_output, "}\\n");\n\n  cg_in_loop = loop_saved;\n}\n')),Object(r.b)("p",null,"The comment before the ",Object(r.b)("inlineCode",{parentName:"p"},"cg_while_stmt")," actually describes the situation pretty clearly;\nthe issue with this codegen is that the expression in the while statement might actually\nrequire many C statements to evaluate.  There are many cases of this sort of thing, but the\nsimplest is probably when any nullable types are in that expression.  A particular example\nillustrates this pretty clearly:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  DECLARE x INTEGER NOT NULL;\n  SET x := 1;\n  WHILE x < 5\n  BEGIN\n    SET x := x + 1;\n  END;\nEND;\n")),Object(r.b)("p",null,"which generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"void p(void) {\n  cql_int32 x = 0;\n\n  x = 1;\n  for (;;) {\n  /* in trickier cases there would be code right here */\n  if (!(x < 5)) break;\n    x = x + 1;\n  }\n}\n")),Object(r.b)("p",null,"In this case, a ",Object(r.b)("inlineCode",{parentName:"p"},"while")," statement could have been used because the condition is simply ",Object(r.b)("inlineCode",{parentName:"p"},"x < 5"),"\nso this more general pattern is overkill.  But consider this program, just a tiny bit different:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  DECLARE x INTEGER;  -- x is nullable\n  SET x := 1;\n  WHILE x < 5\n  BEGIN\n    SET x := x + 1;\n  END;\nEND;\n")),Object(r.b)("p",null,"which produces:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"void p(void) {\n  cql_nullable_int32 x;\n  cql_set_null(x);\n  cql_nullable_bool _tmp_n_bool_0;\n  cql_set_null(_tmp_n_bool_0);\n\n  cql_set_notnull(x, 1);\n  for (;;) {\n  cql_set_nullable(_tmp_n_bool_0, x.is_null, x.value < 5);\n  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;\n    cql_set_nullable(x, x.is_null, x.value + 1);\n  }\n}\n")),Object(r.b)("p",null,"Even for this small little case, the nullable arithmetic macros have to be used to keep ",Object(r.b)("inlineCode",{parentName:"p"},"x")," up to date.\nThe result of ",Object(r.b)("inlineCode",{parentName:"p"},"x < 5")," is of type ",Object(r.b)("inlineCode",{parentName:"p"},"BOOL")," rather than ",Object(r.b)("inlineCode",{parentName:"p"},"BOOL NOT NULL")," so a temporary variable captures\nthe result of the expression.  This is an easy case, but similar things happen if the expression\nincludes e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"CASE...WHEN...")," or ",Object(r.b)("inlineCode",{parentName:"p"},"IN")," constructs.  There are many other cases."),Object(r.b)("p",null,"So with this in mind, let's reconsider what ",Object(r.b)("inlineCode",{parentName:"p"},"cg_while_stmt")," is doing:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"we start the ",Object(r.b)("inlineCode",{parentName:"li"},"for")," statement in the output",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"there's a bprintf for that"))),Object(r.b)("li",{parentName:"ul"},"we evaluate the while expression, the details will be in ",Object(r.b)("inlineCode",{parentName:"li"},"is_null")," and ",Object(r.b)("inlineCode",{parentName:"li"},"value"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"we use CG_PUSH_EVAL for that"))),Object(r.b)("li",{parentName:"ul"},"if the result is nullable there is a helper macro ",Object(r.b)("inlineCode",{parentName:"li"},"cql_is_nullable_true")," that tells us if the value is not null and true"),Object(r.b)("li",{parentName:"ul"},"if the result is not nullable we can use ",Object(r.b)("inlineCode",{parentName:"li"},"expr_value.ptr")," directly"),Object(r.b)("li",{parentName:"ul"},"we make a note that we're in a loop (this matters for statement cleanup, more on that later)"),Object(r.b)("li",{parentName:"ul"},"we recurse to do more statements with ",Object(r.b)("inlineCode",{parentName:"li"},"cg_stmt_list")),Object(r.b)("li",{parentName:"ul"},"finally we end the ",Object(r.b)("inlineCode",{parentName:"li"},"for")," that we began")),Object(r.b)("p",null,"This kind of structure is common to all the control flow cases.  Generally, we have to deal with the\nfact that CQL expressions often become C statements so we use a more general flow control strategy.\nBut with this in mind, it's easy to imagine how the ",Object(r.b)("inlineCode",{parentName:"p"},"IF"),", ",Object(r.b)("inlineCode",{parentName:"p"},"LOOP"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"SWITCH")," switch statements are\nhandled."),Object(r.b)("h3",{id:"cleanup-and-errors"},"Cleanup and Errors"),Object(r.b)("p",null,"There are a number of places where things can go wrong when running a CQL procedure.  The most\ncommon sources are: (1) SQLite APIs, almost all of which can fail, and, (2) calling other procedures\nwhich also might fail.  Here's a very simple example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'DECLARE PROC something_that_might_fail (arg TEXT) USING TRANSACTION;\n\nCREATE PROC p ()\nBEGIN\n  LET arg := "test";\n  CALL something_that_might_fail(arg);\nEND;\n')),Object(r.b)("p",null,"Which generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'cql_string_literal(_literal_1_test_p, "test");\n\nCQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {\n  cql_code _rc_ = SQLITE_OK;\n  cql_string_ref arg = NULL;\n\n  cql_set_string_ref(&arg, _literal_1_test_p);\n  _rc_ = something_that_might_fail(_db_, arg);\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_string_release(arg);\n  return _rc_;\n}\n')),Object(r.b)("p",null,"Let's look at those fragments carefully:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"first, we had to declare ",Object(r.b)("inlineCode",{parentName:"li"},"something_that_might_fail"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the declaration included ",Object(r.b)("inlineCode",{parentName:"li"},"USING TRANSACTION")," indicating the procedure uses the database"),Object(r.b)("li",{parentName:"ul"},"we didn't provide the procedure definition, this is like an ",Object(r.b)("inlineCode",{parentName:"li"},"extern ... foo(...);")," declaration"))),Object(r.b)("li",{parentName:"ul"},"there is a string literal named ",Object(r.b)("inlineCode",{parentName:"li"},"_literal_1_test_p")," that is auto-created",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_string_literal"),' can expand into a variety of things, whatever you want "make a string literal" to mean'),Object(r.b)("li",{parentName:"ul"},"it's defined in ",Object(r.b)("inlineCode",{parentName:"li"},"cqlrt.h")," and it's designed to be replaced"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_set_string_ref(&arg, _literal_1_test_p);"),' is expected to "retain" the string (+1 ref count)'),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_cleanup")," is the exit label, this cleanup code will run on all exit paths",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"cleanup statements are accumulated by writing to ",Object(r.b)("inlineCode",{parentName:"li"},"cg_cleanup_output")," which usually writes to the ",Object(r.b)("inlineCode",{parentName:"li"},"proc_cleanup")," buffer"),Object(r.b)("li",{parentName:"ul"},"because cleanup is in its own buffer you can add to it freely whenever a new declaration that requires cleanup arises"),Object(r.b)("li",{parentName:"ul"},"in this case the declaration of the string variable caused the ",Object(r.b)("inlineCode",{parentName:"li"},"C")," variable ",Object(r.b)("inlineCode",{parentName:"li"},"arg")," to be created and also the cleanup code"))),Object(r.b)("li",{parentName:"ul"},"now we call ",Object(r.b)("inlineCode",{parentName:"li"},"something_that_might_fail")," passing it our database pointer and the argument"),Object(r.b)("li",{parentName:"ul"},"the hidden ",Object(r.b)("inlineCode",{parentName:"li"},"_db_")," pointer is passed to all procedures that use the database"),Object(r.b)("li",{parentName:"ul"},"these procedures are also the ones that can fail"),Object(r.b)("li",{parentName:"ul"},"any failed return code (not ",Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_OK"),") causes two things:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},"cql_error_trace()")," macro is invoked (this macro typically expands to nothing)"),Object(r.b)("li",{parentName:"ul"},"the code is redirected to the cleanup block via ",Object(r.b)("inlineCode",{parentName:"li"},"goto cql_cleanup;"))))),Object(r.b)("p",null,"The essential sequence is this one:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"}," if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n")),Object(r.b)("p",null,"The C code generator consistently uses this pattern to check if anything went wrong and to exit with an error code.\nExtensive logging can be very expensive, but in debug builds it's quite normal for ",Object(r.b)("inlineCode",{parentName:"p"},"cql_error_trace")," to expand\ninto something like ",Object(r.b)("inlineCode",{parentName:"p"},'fprintf(stderr, "error %d in %s %s:%d\\n", _rc_, _PROC_, __FILE__, __LINE_)')," which is probably\na lot more logging than you want in a production build but great if you're debugging.  Recall that CQL generates\nsomething like ",Object(r.b)("inlineCode",{parentName:"p"},'#define _PROC_ "p"')," before every procedure."),Object(r.b)("p",null,"This error pattern generalizes well and indeed if we use the exception handling pattern, we get a lot of control.\nLet's generalize this example a tiny bit:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC p (OUT success BOOL NOT NULL)\nBEGIN\n  LET arg := "test";\n  BEGIN TRY\n    CALL something_that_might_fail(arg);\n    SET success := 1;\n  END TRY;\n  BEGIN CATCH\n    SET success := 0;\n  END CATCH;\nEND;\n')),Object(r.b)("p",null,"CQL doesn't have complicated exception objects or anything like that, exceptions are just simple\ncontrol flow.  Here's the code for the above:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_bool *_Nonnull success) {\n  cql_contract_argument_notnull((void *)success, 1);\n\n  cql_code _rc_ = SQLITE_OK;\n  cql_string_ref arg = NULL;\n\n  *success = 0; // set out arg to non-garbage\n  cql_set_string_ref(&arg, _literal_1_test_p);\n  // try\n  {\n    _rc_ = something_that_might_fail(_db_, arg);\n    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }\n    *success = 1;\n    goto catch_end_1;\n  }\n  catch_start_1: {\n    *success = 0;\n  }\n  catch_end_1:;\n  _rc_ = SQLITE_OK;\n\n  cql_string_release(arg);\n  return _rc_;\n}\n")),Object(r.b)("p",null,"The code in this case is nearly the same as the previous example.  Let's look at the essential differences:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If there is an error, ",Object(r.b)("inlineCode",{parentName:"li"},"goto catch_start_1")," will run"),Object(r.b)("li",{parentName:"ul"},"If the try block succeeds, ",Object(r.b)("inlineCode",{parentName:"li"},"goto catch_end_1")," will run"),Object(r.b)("li",{parentName:"ul"},"both the ",Object(r.b)("inlineCode",{parentName:"li"},"TRY")," and ",Object(r.b)("inlineCode",{parentName:"li"},"CATCH")," branches set the ",Object(r.b)("inlineCode",{parentName:"li"},"success")," out parameter"),Object(r.b)("li",{parentName:"ul"},"since an out argument was added, CQL generated an error check to ensure that ",Object(r.b)("inlineCode",{parentName:"li"},"success")," is not null",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_contract_argument_notnull((void *)success, 1)"),', the 1 means "argument 1" and will appear in the error message if this test fails'),Object(r.b)("li",{parentName:"ul"},"the hidden ",Object(r.b)("inlineCode",{parentName:"li"},"_db_")," argument doesn't count for error message purposes, so ",Object(r.b)("inlineCode",{parentName:"li"},"success")," is still the first argument")))),Object(r.b)("p",null,"How does this happen?  Let's look at ",Object(r.b)("inlineCode",{parentName:"p"},"cg_trycatch_helper")," which does this work:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// Very little magic is needed to do try/catch in our context.  The error\n// handlers for all the sqlite calls check _rc_ and if it\'s an error they\n// "goto" the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.\n// Inside the try block, the cleanup handler is changed to the catch block.\n// The catch block puts it back.  Otherwise, generate nested statements as usual.\nstatic void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {\n  CHARBUF_OPEN(catch_start);\n  CHARBUF_OPEN(catch_end);\n\n  // We need unique labels for this block\n  ++catch_block_count;\n  bprintf(&catch_start, "catch_start_%d", catch_block_count);\n  bprintf(&catch_end, "catch_end_%d", catch_block_count);\n\n  // Divert the error target.\n  CSTR saved_error_target = error_target;\n  bool_t saved_error_target_used = error_target_used;\n  error_target = catch_start.ptr;\n  error_target_used = 0;\n ...\n')),Object(r.b)("p",null,"The secret is the ",Object(r.b)("inlineCode",{parentName:"p"},"error_target")," global variable.\nAll of the error handling will emit a goto ",Object(r.b)("inlineCode",{parentName:"p"},"error_target")," statement. The\ntry/catch pattern simply changes the current error target.  The rest of\nthe code in the helper is just to save the current error target and to\ncreate unique labels for the try/catch block."),Object(r.b)("p",null,"The important notion is that, if anything goes wrong, whatever it is,\nthe generator simply does a ",Object(r.b)("inlineCode",{parentName:"p"},"goto error_target")," and that will either\nhit the catch block or else go to cleanup."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"THROW")," operation illustrates this well:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// Convert _rc_ into an error code.  If it already is one keep it.\n// Then go to the current error target.\nstatic void cg_throw_stmt(ast_node *ast) {\n  Contract(is_ast_throw_stmt(ast));\n\n  bprintf(cg_main_output, "_rc_ = cql_best_error(%s);\\n", rcthrown_current);\n  bprintf(cg_main_output, "goto %s;\\n", error_target);\n  error_target_used = 1;\n  rcthrown_used = 1;\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"first we make sure ",Object(r.b)("inlineCode",{parentName:"li"},"_rc_")," has some kind of error in it, either ",Object(r.b)("inlineCode",{parentName:"li"},"rcthrown_current")," or else ",Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_ERROR")),Object(r.b)("li",{parentName:"ul"},"then we go to the current error target"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"error_target_used")," tracks whether if the error label was used, this is just to avoid C compiler errors about unused labels.",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"if the label is not used it won't be emitted"),Object(r.b)("li",{parentName:"ul"},"the code never jumps back to an error label, so we'll always know if the label was used before we need to emit it")))),Object(r.b)("p",null,"Note: every catch block captures the value of ",Object(r.b)("inlineCode",{parentName:"p"},"_rc_")," in a local variable whose name is in ",Object(r.b)("inlineCode",{parentName:"p"},"rcthrown_current"),".\nThis captured value is the current failing result code accessible by ",Object(r.b)("inlineCode",{parentName:"p"},"@RC")," in CQL."),Object(r.b)("p",null,"A catch block can therefore do stuff like:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-sql"},"IF @RC = 1 THEN\n  THROW;\nELSE\n  call attempt_retry();\nEND IF;\n")),Object(r.b)("p",null,"This entire mechanism is built with basically just a few state variables that nest.  There is no complicated stack walking\nor anything like that.  All the code has to do is chain the error labels together and let users create new catch blocks\nwith new error labels.  All that together gives you very flexible try/catch behaviour with very little overhead."),Object(r.b)("h3",{id:"string-literals"},"String Literals"),Object(r.b)("p",null,"Before we move on to more complex statements we have to discuss string literals a little bit.  We've mentioned before\nthat the compiler is going to generate something like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'cql_string_literal(_literal_1_test_p, "test");\n')),Object(r.b)("p",null,"To create a reference counted object ",Object(r.b)("inlineCode",{parentName:"p"},"_literal_1_test_p")," that it can use.  Now we're going to talk about how\nthe text ",Object(r.b)("inlineCode",{parentName:"p"},'"test"')," was created and how that gets more complicated."),Object(r.b)("p",null,"The first thing to remember is that the generator creates C programs.  That means\nno matter what kind of literal we might be processing it's ending up encoded as a C string for the C\ncompiler.  The C compiler will be the first thing the decodes the text the generator produces and\nputs the byte we need into the final programs data segment or wherever.  That means if we have\nSQL format strings that need to go to SQLite they will be twice-encoded, the SQL string is escaped\nas needed for SQLite and ",Object(r.b)("em",{parentName:"p"},"that")," is escaped again for the C compiler."),Object(r.b)("p",null,"An example might make this clearer consider the following SQL:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"  SELECT '\"x''y\"' AS a, \"'y'\\n\" AS b;\n")),Object(r.b)("p",null,"The generated text for this statement will be:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  \"SELECT '\\\"x''y\\\"', '''y''\\n'\"\n")),Object(r.b)("p",null,"Let's review that in some detail:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'the first string "a" is a standard SQL string'),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"it is represented unchanged in the AST, it is ",Object(r.b)("em",{parentName:"li"},"not")," unescaped"),Object(r.b)("li",{parentName:"ul"},"even the outer single quotes are preserved, CQL has no need to change it at all"),Object(r.b)("li",{parentName:"ul"},"when we emit it into our output it will be read by the C compiler, so"),Object(r.b)("li",{parentName:"ul"},"at that time it is escaped ",Object(r.b)("em",{parentName:"li"},"again")," into C format",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the double quotes which required no escaping in SQL become ",Object(r.b)("inlineCode",{parentName:"li"},'\\"')))),Object(r.b)("li",{parentName:"ul"},"the single quote character requires no escape but there are still two of them because SQLite will also process this string"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'the second string "b" is a C formatted string literal'),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"SQLite doesn't support this format or its escapes, therefore"),Object(r.b)("li",{parentName:"ul"},"as discussed in ",Object(r.b)("a",{parentName:"li",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),", it is decoded to plain text, then re-encoded as a SQL escaped string"),Object(r.b)("li",{parentName:"ul"},"internal newlines do not require escaping in SQL, they are in the string as the newline character not '\\n' or anything like that",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"to be completely precise the byte value 0x0a is in the string unescaped"))),Object(r.b)("li",{parentName:"ul"},"internal single quotes don't require escaping in C, these have to be doubled in a SQL string"),Object(r.b)("li",{parentName:"ul"},"the outer double quotes are removed and replaced by single quotes during this process"),Object(r.b)("li",{parentName:"ul"},"the AST now has a valid SQL formatted string possibly with weird characters in it"),Object(r.b)("li",{parentName:"ul"},"as before, this string has to be formatted for the C compiler so now it has to be escaped again"),Object(r.b)("li",{parentName:"ul"},"the single quotes require no further processing, though now there are quite a few of them"),Object(r.b)("li",{parentName:"ul"},'the embedded newline is converted to the escape sequence "\\n" so we\'re back to sort of where we started',Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the C compiler will convert this back to the byte 0x0a which is what ends up in the data segment")))))),Object(r.b)("p",null,"In the above example we were making one overall string for the ",Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statement so the outer double quotes\nare around the whole statement.  That was just for the convenience of this example.  If the literals had\nbeen in some other loose context then individual strings would be produced the same way.  Except, not so fast,\nnot every string literal is heading for SQLite.  Some are just making regular strings.  In that case even\nif they are destined for SQLite they will go as bound arguments to a statement not in the text of the SQL.\nThat means ",Object(r.b)("em",{parentName:"p"},"those")," strings do not need SQL escaping."),Object(r.b)("p",null,"Consider:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"  LET a := '\"x''y\"';\n  LET b := \"'y'\\n\";\n")),Object(r.b)("p",null,"To do those assignments we need:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'cql_string_literal(_literal_1_x_y_p, "\\"x\'y\\"");\ncql_string_literal(_literal_2_y_p, "\'y\'\\n");\n')),Object(r.b)("p",null,"In both of these cases the steps are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"unescape the escaped SQL string in the AST to plain text",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"removing the outer single quotes of course"))),Object(r.b)("li",{parentName:"ul"},"re-escape the plain text (which might include newlines and such) as a C string",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"emit that text, including its outer double quotes")))),Object(r.b)("p",null,"Trivia: the name of the string literal variables include a fragment of the string to make them a little easier to spot."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"encoders.h")," has the encoding functions"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cg_decode_string_literal")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cg_encode_string_literal")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cg_encode_c_string_literal")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cg_decode_c_string_literal"))),Object(r.b)("p",null,"As well as similar functions for single characters to make all this possible.  Pretty much every combination\nof encoding and re-encoding happens in some path through the code generator."),Object(r.b)("h3",{id:"executing-sqlite-statements"},"Executing SQLite Statements"),Object(r.b)("p",null,"By way of example let's consider a pretty simple piece of SQL we might want to run."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE TABLE foo(id INTEGER, t TEXT);\n\nCREATE PROC p (id_ INTEGER, t_ TEXT)\nBEGIN\n  UPDATE foo\n  SET t = t_\n    WHERE id = id_;\nEND;\n")),Object(r.b)("p",null,"To make this happen we're going to have to do the following things:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"create a string literal with the statement we need"),Object(r.b)("li",{parentName:"ul"},"the references to ",Object(r.b)("inlineCode",{parentName:"li"},"id_")," and ",Object(r.b)("inlineCode",{parentName:"li"},"t_")," have to be replaced with ",Object(r.b)("inlineCode",{parentName:"li"},"?")),Object(r.b)("li",{parentName:"ul"},"we prepare that statement"),Object(r.b)("li",{parentName:"ul"},"we bind the values of ",Object(r.b)("inlineCode",{parentName:"li"},"id_")," and ",Object(r.b)("inlineCode",{parentName:"li"},"t_")),Object(r.b)("li",{parentName:"ul"},"we ",Object(r.b)("inlineCode",{parentName:"li"},"step")," the statement"),Object(r.b)("li",{parentName:"ul"},"we ",Object(r.b)("inlineCode",{parentName:"li"},"finalize")," the statement"),Object(r.b)("li",{parentName:"ul"},"suitable error checks have to be done at each stage")),Object(r.b)("p",null,"That's quite a bit of code and it's easy to forget a step, this is an area where CQL shines.  The\ncode we had to write in CQL was very clear and all the error checking is implicit."),Object(r.b)("p",null,"This is the generated code.  We'll walk through it and discuss how it is created."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'CQL_WARN_UNUSED cql_code p(\n  sqlite3 *_Nonnull _db_,\n  cql_nullable_int32 id_,\n  cql_string_ref _Nullable t_)\n{\n  cql_code _rc_ = SQLITE_OK;\n  sqlite3_stmt *_temp_stmt = NULL;\n\n  _rc_ = cql_prepare(_db_, &_temp_stmt,\n    "UPDATE foo "\n    "SET t = ? "\n      "WHERE id = ?");\n  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,\n                CQL_DATA_TYPE_INT32, &id_,\n                CQL_DATA_TYPE_STRING, t_);\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = sqlite3_step(_temp_stmt);\n  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n  cql_finalize_stmt(&_temp_stmt);\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_finalize_stmt(&_temp_stmt);\n  return _rc_;\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"the functions signature includes the hidden ",Object(r.b)("inlineCode",{parentName:"li"},"_db_")," parameter plus the two arguments"),Object(r.b)("li",{parentName:"ul"},"we need a hidden ",Object(r.b)("inlineCode",{parentName:"li"},"_rc_")," variable to hold the result codes from SQLite"),Object(r.b)("li",{parentName:"ul"},"we need a scratch ",Object(r.b)("inlineCode",{parentName:"li"},"sqlite3_stmt *")," named ",Object(r.b)("inlineCode",{parentName:"li"},"_temp_stmt")," to talk to SQLite",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"when this is created, the cleanup section gets ",Object(r.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt(&_temp_stmt);")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt")," sets the statement to null and does nothing if it's already null"))),Object(r.b)("li",{parentName:"ul"},"the string ",Object(r.b)("inlineCode",{parentName:"li"},'"INSERT INTO foo(id, t) VALUES(?, ?)"')," is created from the AST",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"recall that we have ",Object(r.b)("inlineCode",{parentName:"li"},"variables_callback")," as an option, it's used here to track the variables and replace them with ",Object(r.b)("inlineCode",{parentName:"li"},"?")),Object(r.b)("li",{parentName:"ul"},"more on this shortly"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_multibind")," is used to bind the values of ",Object(r.b)("inlineCode",{parentName:"li"},"id_")," and ",Object(r.b)("inlineCode",{parentName:"li"},"t_"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this is just a varargs version of the normal SQLite binding functions, it's only done this way to save space"),Object(r.b)("li",{parentName:"ul"},"only one error check is needed for any binding failure"),Object(r.b)("li",{parentName:"ul"},"the type of binding is encoded very economically"),Object(r.b)("li",{parentName:"ul"},'the "2" here refers to two arguments'))),Object(r.b)("li",{parentName:"ul"},"the usual error processing happens with ",Object(r.b)("inlineCode",{parentName:"li"},"cql_error_trace")," and ",Object(r.b)("inlineCode",{parentName:"li"},"goto cql_cleanup")),Object(r.b)("li",{parentName:"ul"},"the statement is executed with ",Object(r.b)("inlineCode",{parentName:"li"},"sqlite3_step")),Object(r.b)("li",{parentName:"ul"},"temporary statements are finalized immediately with ",Object(r.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"in this case its redundant because the code is going to fall through to cleanup anyway"),Object(r.b)("li",{parentName:"ul"},"in general there could be many statements and we want to finalize immediately"),Object(r.b)("li",{parentName:"ul"},"this is an optimization opportunity, procedures with just one statement are very common")))),Object(r.b)("p",null,"Most of these steps are actually hard coded.  There is no variability in the sequence\nafter the ",Object(r.b)("inlineCode",{parentName:"p"},"multibind")," call, so that's just boiler-plate the compiler can inject."),Object(r.b)("p",null,"We don't want to declare ",Object(r.b)("inlineCode",{parentName:"p"},"_temp_stmt")," over and over so there's a flag that records\nwhether it has already been declared in the current procedure."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// Emit a declaration for the temporary statement _temp_stmt_ if we haven\'t\n// already done so.  Also emit the cleanup once.\nstatic void ensure_temp_statement() {\n  if (!temp_statement_emitted) {\n    bprintf(cg_declarations_output, "sqlite3_stmt *_temp_stmt = NULL;\\n");\n    bprintf(cg_cleanup_output, "  cql_finalize_stmt(&_temp_stmt);\\n");\n    temp_statement_emitted = 1;\n  }\n}\n')),Object(r.b)("p",null,"This is a great example of how, no matter where the processing happens to be,\nthe generator can emit things into the various sections.  Here it adds\na declaration and an cleanup with no concern about what else might be going on."),Object(r.b)("p",null,"So most of the above is just boiler-plate, the tricky part is:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"getting the text of the SQL"),Object(r.b)("li",{parentName:"ul"},"binding the variables")),Object(r.b)("p",null,"All of this is the business of this function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// This is the most important function for sqlite access;  it does the heavy\n// lifting of generating the C code to prepare and bind a SQL statement.\n// If cg_exec is true (CG_EXEC) then the statement is executed immediately\n// and finalized.  No results are expected.  To accomplish this we do the following:\n//   * figure out the name of the statement, either it's given to us\n//     or we're using the temp statement\n//   * call get_statement_with_callback to get the text of the SQL from the AST\n//     * the callback will give us all the variables to bind\n//     * count the variables so we know what column numbers to use (the list is backwards!)\n//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form\n//   * bind any variables\n//   * if there are variables CG_EXEC will step and finalize\nstatic void cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_flags)\n{\n  ...\n}\n")),Object(r.b)("p",null,"The core of this function looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  gen_sql_callbacks callbacks;\n  init_gen_sql_callbacks(&callbacks);\n  callbacks.variables_callback = cg_capture_variables;\n  callbacks.variables_context = &vars;\n  // ... more flags\n\n  CHARBUF_OPEN(temp);\n  gen_set_output_buffer(&temp);\n  gen_statement_with_callbacks(stmt, &callbacks);\n")),Object(r.b)("p",null,"It's set up the callbacks for variables and it calls the echoing function on the buffer.  We've\ntalked about ",Object(r.b)("inlineCode",{parentName:"p"},"gen_statement_with_callbacks")," in  ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/int01"},"Part 1"),"."),Object(r.b)("p",null,"Let's take a look at that callback function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'// This is the callback method handed to the gen_ method that creates SQL for us\n// it will call us every time it finds a variable that needs to be bound.  That\n// variable is replaced by ? in the SQL output.  We end up with a list of variables\n// to bind on a silver platter (but in reverse order).\nstatic bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {\n  list_item **head = (list_item**)context;\n  add_item_to_list(head, ast);\n\n  bprintf(buffer, "?");\n  return true;\n}\n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"context")," variable was set to be ",Object(r.b)("inlineCode",{parentName:"p"},"vars"),", we convert it back to the correct type\nand add the current ast to that list.  ",Object(r.b)("inlineCode",{parentName:"p"},"add_item_to_list")," always puts things at the\nhead so the list will be in reverse order."),Object(r.b)("p",null,"With this done, we're pretty much set.  We'll produce the statement with a sequence\nlike this one (there are a couple of variations, but this is the most general)"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  bprintf(cg_main_output, "_rc_ = cql_prepare(_db_, %s%s_stmt,\\n  ", amp, stmt_name);\n  cg_pretty_quote_plaintext(temp.ptr, cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);\n  bprintf(cg_main_output, ");\\n");\n')),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"cg_pretty_quote_plaintext")," is one of the C string encoding formats, it could have been just the regular C string encoding\nbut that would have been a bit wasteful and it wouldn't have looked as nice.  This function does a little transform."),Object(r.b)("p",null,"The normal echo of the update statement in question looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"  UPDATE foo\n  SET t = ?\n    WHERE id = ?;\n")),Object(r.b)("p",null,"Note that it has indenting and newlines embedded in it.  The standard encoding of that would look like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'"  UPDATE foo\\n  SET t = ?\\n    WHERE id = ?;"\n')),Object(r.b)("p",null,"That surely works, but it's wasteful and ugly. The pretty format instead produces:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'    "UPDATE foo "\n    "SET t = ? "\n      "WHERE id = ?"\n')),Object(r.b)("p",null,"So, the newlines are gone from the string (they aren't needed), instead the string literal was broken into lines for readability.\nThe indenting is gone from the string, instead the string fragments are indented.  So what you get is a string literal that\nreads nicely but doesn't have unnecessary whitespace for SQLite.  Obviously you can't use pretty-quoted literals in all cases,\nit's exclusively for SQLite formatting."),Object(r.b)("p",null,"All that's left to do is bind the arguments.  Remember that arg list is in reverse order:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  uint32_t count = 0;\n  for (list_item *item = vars; item; item = item->next, count++) ;\n\n  // ...\n\n  reverse_list(&vars);\n\n  if (count) {\n    bprintf(cg_main_output, "cql_multibind(&_rc_, _db_, %s%s_stmt, %d", amp, stmt_name, count);\n\n    // Now emit the binding args for each variable\n    for (list_item *item = vars; item; item = item->next)  {\n      Contract(item->ast->sem->name);\n      bprintf(cg_main_output, ",\\n              ");\n      cg_bind_column(item->ast->sem->sem_type, item->ast->sem->name);\n    }\n\n    bprintf(cg_main_output, ");\\n");\n  }\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"first compute the count, we don't need to bind if there are no variables"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"reverse_list")," does exactly what is sounds like (finally a real-world use-case for reverse-list-in-place)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cg_bind_column")," creates one line of the var-args output: column type and variable name",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the type and name information is right there on the ",Object(r.b)("inlineCode",{parentName:"li"},"AST")," in the ",Object(r.b)("inlineCode",{parentName:"li"},"sem_node"))))),Object(r.b)("p",null,"And that's it.  With those few helpers we can bind any SQLite statement the same way.  All of the\n",Object(r.b)("inlineCode",{parentName:"p"},"DDL_STMT_INIT")," and ",Object(r.b)("inlineCode",{parentName:"p"},"DML_STMT_INIT")," statements are completely implemented by this path."),Object(r.b)("h3",{id:"reading-single-values"},"Reading Single Values"),Object(r.b)("p",null,"In many cases you need just one value"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p (id_ INTEGER NOT NULL, OUT t_ TEXT)\nBEGIN\n  SET t_ := ( SELECT t\n    FROM foo\n    WHERE id = id_ );\nEND;\n")),Object(r.b)("p",null,"This is going to be very similar to the examples we've seen so far:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_int32 id_, cql_string_ref _Nullable *_Nonnull t_) {\n  cql_contract_argument_notnull((void *)t_, 2);\n\n  cql_code _rc_ = SQLITE_OK;\n  cql_string_ref _tmp_text_0 = NULL;\n  sqlite3_stmt *_temp_stmt = NULL;\n\n  *(void **)t_ = NULL; // set out arg to non-garbage\n  _rc_ = cql_prepare(_db_, &_temp_stmt,\n    "SELECT t "\n      "FROM foo "\n      "WHERE id = ?");\n  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,\n                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_);\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = sqlite3_step(_temp_stmt);\n  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }\n    cql_column_string_ref(_temp_stmt, 0, &_tmp_text_0);\n  cql_finalize_stmt(&_temp_stmt);\n  cql_set_string_ref(&*t_, _tmp_text_0);\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_string_release(_tmp_text_0);\n  cql_finalize_stmt(&_temp_stmt);\n  return _rc_;\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_db_")," : incoming arg for a procedure that uses the database same as always, check"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"*(void **)t_ = NULL;")," : out args are always set to NULL on entry, note, there is no ",Object(r.b)("inlineCode",{parentName:"li"},"release")," here",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"argument is assumed to be garbage, that's the ABI"),Object(r.b)("li",{parentName:"ul"},"if argument is non-garbage caller must release it first, that's the ABI"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_rc_")," : same as always, check"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_tmp_text_0")," : new temporary text, including cleanup (this could have been avoided)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_temp_stmt")," : as before, including cleanup"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_prepare")," : same as always, check"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_multibind")," : just one integer bound this time"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sqlite3_step")," : as before, we're stepping once, this time we want the data"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"if (_rc_ != SQLITE_ROW)")," new error check and goto cleanup if no row",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this is the same as the ",Object(r.b)("inlineCode",{parentName:"li"},"IF NOTHING THROW")," variant of construct, that's the default"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_column_string_ref")," : reads one string from ",Object(r.b)("inlineCode",{parentName:"li"},"_temp_stmt")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt")," : as before"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_set_string_ref(&*t_, _tmp_text_0)")," : copy the temporary string to the out arg",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"includes retain, out arg is NULL so ",Object(r.b)("inlineCode",{parentName:"li"},"cql_set_string_ref")," will do no release"),Object(r.b)("li",{parentName:"ul"},"if this were (e.g.) running in a loop, the out arg would not be null and there would be a release, as expected"),Object(r.b)("li",{parentName:"ul"},"if something else had previously set the out arg, again, there would be a release as expected")))),Object(r.b)("p",null,"There are variations of this form such as:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p (id_ INTEGER NOT NULL, OUT t_ TEXT)\nBEGIN\n  SET t_ := ( SELECT t\n    FROM foo\n    WHERE id = id_\n    IF NOTHING '');\nEND;\n")),Object(r.b)("p",null,"This simply changes the handling of the case where there is no row.  The that part of the code\nends up looking like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n  if (_rc_ == SQLITE_ROW) {\n    cql_column_string_ref(_temp_stmt, 0, &_tmp_text_1);\n    cql_set_string_ref(&_tmp_text_0, _tmp_text_1);\n  }\n  else {\n    cql_set_string_ref(&_tmp_text_0, _literal_1_p);\n  }\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"any error code leads to cleanup"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_ROW")," : leads to the same fetch as before"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_DONE")," : leads to the no row case which sets ",Object(r.b)("inlineCode",{parentName:"li"},"_tmp_text_0")," to the empty string",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'cql_string_literal(_literal_1_p, "");')," is included as a data declaration")))),Object(r.b)("p",null,"There is also the ",Object(r.b)("inlineCode",{parentName:"p"},"IF NOTHING OR NULL")," variant which is left as an exercise to the reader.\nYou can find all the flavors in ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," in the this function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// This is a nested select expression.  To evaluate we will\n//  * prepare a temporary to hold the result\n//  * generate the bound SQL statement\n//  * extract the exactly one argument into the result variable\n//    which is of exactly the right type\n//  * use that variable as the result.\n// The helper methods take care of sqlite error management.\nstatic void cg_expr_select(...\n")),Object(r.b)("p",null,"This handles all of the ",Object(r.b)("inlineCode",{parentName:"p"},"(select ...)")," expressions and it has the usual expression handler\nsyntax. Another great example of a CQL expressions that might require many C statements\nto implement."),Object(r.b)("h3",{id:"reading-rows-with-cursors"},"Reading Rows With Cursors"),Object(r.b)("p",null,"This section is about the cases where we are expecting results back from SQLite.  By results here\nI mean the results of some kind of query, not like a return code.  SQLite does this by giving\nyou a ",Object(r.b)("inlineCode",{parentName:"p"},"sqlite3_stmt *")," which you can then use like a cursor to read out a bunch of rows.  So\nit should be no surprise that CQL cursors map directly to SQLite statements."),Object(r.b)("p",null,"Most of the code to get a statement we've already seen before, we only saw the ",Object(r.b)("inlineCode",{parentName:"p"},"_temp_stmt"),"\ncase and we did very little with it.  Let's look at the code for something a little bit more\ngeneral and we'll see how little it takes to generalize."),Object(r.b)("p",null,"First, let's look at how a CQL cursor is initialized:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;\nEND;\n")),Object(r.b)("p",null,"Now in this case there can only be one row in the result, but it would be no different if there were more."),Object(r.b)("p",null,"Here's the C code:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {\n  cql_code _rc_ = SQLITE_OK;\n  sqlite3_stmt *C_stmt = NULL;\n  cql_bool _C_has_row_ = 0;\n\n  _rc_ = cql_prepare(_db_, &C_stmt,\n    "SELECT 1, 2");\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_finalize_stmt(&C_stmt);\n  return _rc_;\n}\n')),Object(r.b)("p",null,"Let's look over that code very carefully and see what is necessary to make it happen."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_db_")," : incoming arg for a procedure that uses the database same as always, check"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_rc_")," : same as always, check"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C_stmt")," : we need to generate this instead of using ",Object(r.b)("inlineCode",{parentName:"li"},"_temp_stmt"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_finalize_stmt(&C_stmt)")," in cleanup, just like ",Object(r.b)("inlineCode",{parentName:"li"},"_temp_stmt")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_prepare")," : same as always, check"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_multibind")," : could have been binding, not none needed here, but same as always anyway, check"),Object(r.b)("li",{parentName:"ul"},"no step, no finalize (until cleanup) : that boiler-plate is removed")),Object(r.b)("p",null,"And that's it, we now have a statement in ",Object(r.b)("inlineCode",{parentName:"p"},"C_stmt")," ready to go.  We'll see later that ",Object(r.b)("inlineCode",{parentName:"p"},"_C_has_row_"),"\nwill track whether or not the cursor has any data in it."),Object(r.b)("p",null,"How do we make this happen?  Well you could look at ",Object(r.b)("inlineCode",{parentName:"p"},"cg_declare_cursor")," and your eye might hurt at\nfirst.  The truth is there are many kinds of cursors in CQL and this method handles all of them.\nWe're going to go over the various flavors but for now we're only discussing the so-called\n\"statement cursor\", so named because it simply holds a SQLite statement.  This was the\nfirst, and for a while only, type of cursor added to the CQL language."),Object(r.b)("p",null,"OK so how do we make a statement cursor.  It's once again ",Object(r.b)("inlineCode",{parentName:"p"},"cg_bound_sql_statement")," just like so:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cg_bound_sql_statement(cursor_name, select_stmt, CG_PREPARE|CG_MINIFY_ALIASES);\n")),Object(r.b)("p",null,"The entire difference is that the first argument is the cursor name rather than NULL.  If you\npass NULL it means use the temporary statement."),Object(r.b)("p",null,"And you'll notice that even in this simple example the SQLite text was altered a bit:\nthe text that went to SQLite was ",Object(r.b)("inlineCode",{parentName:"p"},'"SELECT 1, 2"')," -- that's CG_MINIFY_ALIASES at work.\nSQLite didn't need to see those column aliases, it makes no difference in the result.\nColumn aliases are often long and numerous.  Even in this simple example we saved 4 bytes.\nBut the entire query was only 12 bytes long (including trailing null) so that's 25%.\nIt's not a huge savings in general but it's something."),Object(r.b)("p",null,"The other flag ",Object(r.b)("inlineCode",{parentName:"p"},"CG_PREPARE")," tells the binder that it should not step or finalize the query.\nThe alternative is ",Object(r.b)("inlineCode",{parentName:"p"},"CG_EXEC")," (which was used in the previous section for the ",Object(r.b)("inlineCode",{parentName:"p"},"UPDATE")," example)."),Object(r.b)("h3",{id:"fetching-data-from-cursors"},"Fetching Data From Cursors"),Object(r.b)("p",null,"The first cursor reading primitive that was implemented as ",Object(r.b)("inlineCode",{parentName:"p"},"FETCH [cursor] INTO [variables]")," and\nit's the simplest to understand so let's start there."),Object(r.b)("p",null,"We change the example just a bit:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  DECLARE x INTEGER NOT NULL;\n  DECLARE y INTEGER NOT NULL;\n  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;\n  FETCH C INTO x, y;\nEND;\n")),Object(r.b)("p",null,"For simplicity I will only include the code that is added.  The rest is the same."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  cql_int32 x = 0;\n  cql_int32 y = 0;\n\n  // same as before\n\n  _rc_ = sqlite3_step(C_stmt);\n  _C_has_row_ = _rc_ == SQLITE_ROW;\n  cql_multifetch(_rc_, C_stmt, 2,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &x,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &y);\n  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n")),Object(r.b)("p",null,"Do to the ",Object(r.b)("inlineCode",{parentName:"p"},"FETCH")," we do the following:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"step the cursor"),Object(r.b)("li",{parentName:"ul"},"set the ",Object(r.b)("inlineCode",{parentName:"li"},"_C_has_row_")," variable so to indicate if we got a row or not"),Object(r.b)("li",{parentName:"ul"},"use the varargs ",Object(r.b)("inlineCode",{parentName:"li"},"cql_multifetch")," to read 2 columns from the cursor",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this helper simply uses the usual ",Object(r.b)("inlineCode",{parentName:"li"},"sqlite3_*_column")," functions to read the data out"),Object(r.b)("li",{parentName:"ul"},"again, we do it this way so that there is less error checking needed in the generated code"),Object(r.b)("li",{parentName:"ul"},"also, there are fewer function calls so the code is overall smaller"),Object(r.b)("li",{parentName:"ul"},"trivia: ",Object(r.b)("inlineCode",{parentName:"li"},"multibind")," and ",Object(r.b)("inlineCode",{parentName:"li"},"multifetch")," are totally references to ",Object(r.b)("em",{parentName:"li"},"The Fifth Element"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},'hence, they should be pronounced like Leeloo saying "multipass"'))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"multifetch")," uses the varargs to clobber the contents of the target variables if there is no row according to ",Object(r.b)("inlineCode",{parentName:"li"},"_rc_")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"multifetch")," uses the ",Object(r.b)("inlineCode",{parentName:"li"},"CQL_DATA_TYPE_NOT_NULL")," to decide if it should ask SQLite first if the column is null")),Object(r.b)("p",null,"So now this begs the question, in the CQL, how do you know if a row was fetched or not?"),Object(r.b)("p",null,"The answer is, you can use the cursor name like a boolean.  Let's complicate this up a little more."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'DECLARE PROCEDURE printf NO CHECK;\n\nCREATE PROC p ()\nBEGIN\n  DECLARE x INTEGER NOT NULL;\n  DECLARE y INTEGER NOT NULL;\n  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;\n  FETCH C INTO x, y;\n  WHILE C\n  BEGIN\n    CALL printf("%d, %d\\n", x, y);\n    FETCH C INTO x, y;\n  END;\nEND;\n')),Object(r.b)("p",null,"Again here is what is now added, we've seen the ",Object(r.b)("inlineCode",{parentName:"p"},"WHILE")," pattern before:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  for (;;) {\n  if (!(_C_has_row_)) break;\n    printf("%d, %d\\n", x, y);\n    _rc_ = sqlite3_step(C_stmt);\n    _C_has_row_ = _rc_ == SQLITE_ROW;\n    cql_multifetch(_rc_, C_stmt, 2,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &x,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &y);\n    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n  }\n')),Object(r.b)("p",null,"So, if you use the cursors name in an ordinary expression that is converted to a reference to\nthe boolean ",Object(r.b)("inlineCode",{parentName:"p"},"_C_has_row_"),".  Within the loop we're going to print some data and then fetch the next row.\nThe internal fetch is of course the same as the first."),Object(r.b)("p",null,"The next improvement that was added to the language was the ",Object(r.b)("inlineCode",{parentName:"p"},"LOOP")," statement.  Let's take a look:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'BEGIN\n  DECLARE x INTEGER NOT NULL;\n  DECLARE y INTEGER NOT NULL;\n  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;\n  LOOP FETCH C INTO x, y\n  BEGIN\n    CALL printf("%d, %d\\n", x, y);\n  END;\nEND;\n')),Object(r.b)("p",null,"The generated code is very similar:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  for (;;) {\n    _rc_ = sqlite3_step(C_stmt);\n    _C_has_row_ = _rc_ == SQLITE_ROW;\n    cql_multifetch(_rc_, C_stmt, 2,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &x,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &y);\n    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n    if (!_C_has_row_) break;\n    printf("%d, %d\\n", x, y);\n  }\n')),Object(r.b)("p",null,"This is done by:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"emit the ",Object(r.b)("inlineCode",{parentName:"li"},"for (;;) {")," to start the loop"),Object(r.b)("li",{parentName:"ul"},"generate the ",Object(r.b)("inlineCode",{parentName:"li"},"FETCH")," just as if it was standalone"),Object(r.b)("li",{parentName:"ul"},"emit ",Object(r.b)("inlineCode",{parentName:"li"},"if (!_C_has_row_) break;")," (with the correct cursor name)"),Object(r.b)("li",{parentName:"ul"},"use ",Object(r.b)("inlineCode",{parentName:"li"},"cg_stmt_list")," to emit the internal statement list (",Object(r.b)("inlineCode",{parentName:"li"},"CALL printf")," in this case)"),Object(r.b)("li",{parentName:"ul"},"close the loop with ",Object(r.b)("inlineCode",{parentName:"li"},"}")," and we're done")),Object(r.b)("h3",{id:"cursors-with-storage"},"Cursors With Storage"),Object(r.b)("p",null,"We now come to the big motivating reasons for having the notion of shapes in the CQL language.\nThis particular case was the first such example in the language and it's very commonly\nused and saves you a lot of typing.  Like the other examples it's only sugar in that\nit doesn't give you any new language powers you didn't have, but it does give clarity\nand maintenance advantages.  And it's just a lot less to type."),Object(r.b)("p",null,"Let's go back to one of the earlier examples, but write it the modern way:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;\n  FETCH C;\nEND;\n")),Object(r.b)("p",null,"And the generated C code:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'typedef struct p_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 x;\n  cql_int32 y;\n} p_C_row;\n\nCQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {\n  cql_code _rc_ = SQLITE_OK;\n  sqlite3_stmt *C_stmt = NULL;\n  p_C_row C = { 0 };\n\n  _rc_ = cql_prepare(_db_, &C_stmt,\n    "SELECT 1, 2");\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = sqlite3_step(C_stmt);\n  C._has_row_ = _rc_ == SQLITE_ROW;\n  cql_multifetch(_rc_, C_stmt, 2,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.y);\n  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_finalize_stmt(&C_stmt);\n  return _rc_;\n}\n')),Object(r.b)("p",null,"Let's look at what's different here:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"struct p_C_row")," has been created, it contains:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_has_row_")," for the cursor"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"x")," and ",Object(r.b)("inlineCode",{parentName:"li"},"y")," the data fields"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_refs_count")," the number of reference fields in the cursor (0 in this case)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_refs_offset")," the offset of the references fields (they always go at the end)"),Object(r.b)("li",{parentName:"ul"},"because the references are together a cursor with lots of reference fields can be cleaned up easily"))),Object(r.b)("li",{parentName:"ul"},"in the generated code the variable ",Object(r.b)("inlineCode",{parentName:"li"},"C")," refers to the current data that has been fetched",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"convenient for debugging ",Object(r.b)("inlineCode",{parentName:"li"},"p C")," in lldb shows you the row"))),Object(r.b)("li",{parentName:"ul"},"references to ",Object(r.b)("inlineCode",{parentName:"li"},"x")," and ",Object(r.b)("inlineCode",{parentName:"li"},"y")," became ",Object(r.b)("inlineCode",{parentName:"li"},"C.x")," and ",Object(r.b)("inlineCode",{parentName:"li"},"C.y")),Object(r.b)("li",{parentName:"ul"},"references to ",Object(r.b)("inlineCode",{parentName:"li"},"_C_has_row_")," became ",Object(r.b)("inlineCode",{parentName:"li"},"C._has_row_"))),Object(r.b)("p",null,"That's pretty much it.  The beauty of this is that you can't get the declarations of your locals wrong\nand you don't have to list them all no matter how big the data is.  If the data shape changes the\ncursor change automatically changes to accommodate it.  Everything is still statically typed."),Object(r.b)("p",null,"Now lets look at the loop pattern:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FOR SELECT 1 AS x, 2 AS y;\n  LOOP FETCH C\n  BEGIN\n    CALL printf("%d, %d\\n", C.x, C.y);\n  END;\nEND;\n')),Object(r.b)("p",null,"Note that the columns of the cursor were defined by the column aliases of the ",Object(r.b)("inlineCode",{parentName:"p"},"SELECT"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'  for (;;) {\n    _rc_ = sqlite3_step(C_stmt);\n    C._has_row_ = _rc_ == SQLITE_ROW;\n    cql_multifetch(_rc_, C_stmt, 2,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.y);\n    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n    if (!C._has_row_) break;\n    printf("%d, %d\\n", C.x, C.y);\n  }\n')),Object(r.b)("p",null,"The loop is basically the same except ",Object(r.b)("inlineCode",{parentName:"p"},"x")," and ",Object(r.b)("inlineCode",{parentName:"p"},"y")," have been replaced with ",Object(r.b)("inlineCode",{parentName:"p"},"C.x")," and ",Object(r.b)("inlineCode",{parentName:"p"},"C.y"),"\nand again ",Object(r.b)("inlineCode",{parentName:"p"},"_C_has_row_")," is now ",Object(r.b)("inlineCode",{parentName:"p"},"C._has_row_"),"."),Object(r.b)("p",null,"The code generator knows that it should allocate storage for the ",Object(r.b)("inlineCode",{parentName:"p"},"C")," cursor if it has\nthe flag ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_HAS_SHAPE_STORAGE")," on it. The semantic analyzer adds that flag\nif it ever finds ",Object(r.b)("inlineCode",{parentName:"p"},"FETCH C")," with no ",Object(r.b)("inlineCode",{parentName:"p"},"INTO")," part."),Object(r.b)("p",null,"Finally let's look at an example with cleanup required.  We'll just change the test case a tiny bit."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FOR SELECT 1 AS x, "2" AS y;\n  LOOP FETCH C\n  BEGIN\n    CALL printf("%d, %s\\n", C.x, C.y);\n  END;\nEND;\n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"x")," column is now text.  We'll get this code which will be studied below:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'typedef struct p_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} p_C_row;\n\n#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1\n\nCQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {\n  cql_code _rc_ = SQLITE_OK;\n  sqlite3_stmt *C_stmt = NULL;\n  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };\n\n  _rc_ = cql_prepare(_db_, &C_stmt,\n    "SELECT \'1\', 2");\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  for (;;) {\n    _rc_ = sqlite3_step(C_stmt);\n    C._has_row_ = _rc_ == SQLITE_ROW;\n    cql_multifetch(_rc_, C_stmt, 2,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.x,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.y);\n    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n    if (!C._has_row_) break;\n    cql_alloc_cstr(_cstr_1, C.x);\n    printf("%s, %d\\n", _cstr_1, C.y);\n    cql_free_cstr(_cstr_1, C.x);\n  }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_finalize_stmt(&C_stmt);\n  cql_teardown_row(C);\n  return _rc_;\n}\n')),Object(r.b)("p",null,"It's very similar to what we had before, let's quickly review the differences."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct p_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} p_C_row;\n\n#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"x")," is now ",Object(r.b)("inlineCode",{parentName:"li"},"cql_string_ref _Nonnull x;")," rather than ",Object(r.b)("inlineCode",{parentName:"li"},"cql_int32")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"x")," has moved to the end (because it's a reference type)"),Object(r.b)("li",{parentName:"ul"},"the offset of the first ref is computed in a constant")),Object(r.b)("p",null,"Recall the reference types are always at the end and together."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_C_row")," is now initialized to to ref count 1 and refs offset ",Object(r.b)("inlineCode",{parentName:"li"},"p_C_refs_offset")," defined above")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  cql_multifetch(_rc_, C_stmt, 2,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.x,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.y);\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"C.x is now of type string")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'    cql_alloc_cstr(_cstr_1, C.x);\n    printf("%s, %d\\n", _cstr_1, C.y);\n    cql_free_cstr(_cstr_1, C.x);\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"C.x has to be converted to a C style string before it can be used with ",Object(r.b)("inlineCode",{parentName:"li"},"printf")," as a ",Object(r.b)("inlineCode",{parentName:"li"},"%s")," argument")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  cql_teardown_row(C);\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"the cleanup section has to include code to teardown the cursor, this will release all of its reference variables in bulk",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"remember we know the count, and the offset of the first one -- that's all we need to do them all")))),Object(r.b)("p",null,"With these primitives we can easily create cursors of any shape and load them up with data.  We don't have to\nredundantly declare locals that match the shape of our select statements which is both error prone and\na hassle."),Object(r.b)("p",null,"All of this is actually very easy for the code-generator.  The semantic analysis phase knows if the cursor needs\nshape storage.  And it also recognizes when a variable reference like ",Object(r.b)("inlineCode",{parentName:"p"},"C.x")," happens, the variable references are\nre-written in the AST so that the code-generator doesn't even have to know there was a cursor reference, from\nits perspective the variable IS ",Object(r.b)("inlineCode",{parentName:"p"},"C.x")," (which it sort of is).  The code generator does have to create the\nstorage for the cursor but it knows it should do so because the cursor variable is marked with ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_HAS_SHAPE_STORAGE"),".\nA cursor without this marking only gets its statement (but not always as we'll see later) and its ",Object(r.b)("inlineCode",{parentName:"p"},"_cursor_has_row_"),"\nhidden variable."),Object(r.b)("h3",{id:"flowing-sqlite-statements-between-procedures"},"Flowing SQLite Statements Between Procedures"),Object(r.b)("p",null,"Earlier we saw that we can get a cursor from a SQLite ",Object(r.b)("inlineCode",{parentName:"p"},"SELECT")," statement.  The cursor is used to iterate\nover the ",Object(r.b)("inlineCode",{parentName:"p"},"sqlite3_stmt *")," that SQLite provides to us.  This process can be done between procedures.  Here's a\nsimple example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'@ATTRIBUTE(cql:private)\nCREATE PROC q ()\nBEGIN\n  SELECT "1" AS x, 2 AS y;\nEND;\n')),Object(r.b)("p",null,"This is the first example of a procedure that return a result set that we've seen.  The wiring for this is\nvery simple."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"static CQL_WARN_UNUSED cql_code q(\n  sqlite3 *_Nonnull _db_,\n  sqlite3_stmt *_Nullable *_Nonnull _result_stmt)\n{\n  cql_code _rc_ = SQLITE_OK;\n  *_result_stmt = NULL;\n  _rc_ = cql_prepare(_db_, _result_stmt,\n    \"SELECT '1', 2\");\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);\n  return _rc_;\n}\n")),Object(r.b)("p",null,"First note that there are now ",Object(r.b)("em",{parentName:"p"},"two")," hidden parameters to ",Object(r.b)("inlineCode",{parentName:"p"},"q"),":"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_db_")," : the database pointer as usual,"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_result_stmt")," : the statement produced by this procedure")),Object(r.b)("p",null,"The rest of the code is just like any other bound SQL statement.  Note that if\n",Object(r.b)("inlineCode",{parentName:"p"},"_result_stmt")," isn't otherwise set by the code it will be initialized to a statement\nthat will return zero rows."),Object(r.b)("p",null,"All of this is pretty much old news except for the new hidden variable.  Note let's look how we might use\nthis.  We can write a procedure that calls ",Object(r.b)("inlineCode",{parentName:"p"},"q"),", like so:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FOR CALL q();\n  FETCH C;\nEND;\n")),Object(r.b)("p",null,"This generates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {\n  cql_code _rc_ = SQLITE_OK;\n  sqlite3_stmt *C_stmt = NULL;\n  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };\n\n  _rc_ = q(_db_, &C_stmt);\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = sqlite3_step(C_stmt);\n  C._has_row_ = _rc_ == SQLITE_ROW;\n  cql_multifetch(_rc_, C_stmt, 2,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.x,\n                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.y);\n  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  cql_finalize_stmt(&C_stmt);\n  cql_teardown_row(C);\n  return _rc_;\n}\n")),Object(r.b)("p",null,"All of the above is ",Object(r.b)("em",{parentName:"p"},"exactly")," the same as the previous cases where we got\ndata from the database except that instead of using ",Object(r.b)("inlineCode",{parentName:"p"},"cql_prepare")," the\ncompiler produced ",Object(r.b)("inlineCode",{parentName:"p"},"_rc_ = q(_db_, &C_stmt);"),"  That function call gives us,\nof course, a ready-to-use ",Object(r.b)("inlineCode",{parentName:"p"},"sqlite3_stmt *")," which we can then step, and\nuse to fetch values.  The shape of the cursor ",Object(r.b)("inlineCode",{parentName:"p"},"C")," is determined by the\nresult type of procedure ",Object(r.b)("inlineCode",{parentName:"p"},"q")," -- hence they always match."),Object(r.b)("p",null,"If q was in some other module, it could be declared with:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"DECLARE PROC q () (x TEXT NOT NULL, y INTEGER NOT NULL);\n")),Object(r.b)("p",null,"This is a procedure that takes no arguments and returns a result with the indicated shape."),Object(r.b)("p",null,"CQL can generate this declaration for you if you add ",Object(r.b)("inlineCode",{parentName:"p"},"--generate_exports")," to the command line.  Note\nthat in this case ",Object(r.b)("inlineCode",{parentName:"p"},"q")," was marked with ",Object(r.b)("inlineCode",{parentName:"p"},"@attribute(cql:private)")," which caused ",Object(r.b)("inlineCode",{parentName:"p"},"q")," to be ",Object(r.b)("inlineCode",{parentName:"p"},"static"),"\nin the output. Hence it can't be called outside this translation unit and ",Object(r.b)("inlineCode",{parentName:"p"},"--generate_exports"),"\nwon't provide the declaration."),Object(r.b)("p",null,"If the private annotation were removed, the full exports for this file would be:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"DECLARE PROC q () (x TEXT NOT NULL, y INTEGER NOT NULL);\nDECLARE PROC p () USING TRANSACTION;\n")),Object(r.b)("p",null,"And these would allow calling both procedures from elsewhere.  Simply ",Object(r.b)("inlineCode",{parentName:"p"},"#include")," the exports file."),Object(r.b)("p",null,"There is a special function in the echoing code that can emit a procedure that was created in the\nform that is needed to declare it, this is ",Object(r.b)("inlineCode",{parentName:"p"},"gen_declare_proc_from_create_proc"),"."),Object(r.b)("h3",{id:"value-cursors"},"Value Cursors"),Object(r.b)("p",null,"Once CQL had the ability to fetch rows into a cursor with no need to declare all the locals\nit was clear that it could benefit from the ability to save a copy of any given row. That is\nbasic cursor operations seemed like they should be part of the calculus of CQL.  Here's a\nsimple sample program that illustrates this."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FOR SELECT "1" AS x, 2 AS y;\n  FETCH C;\n  DECLARE D CURSOR LIKE C;\n  FETCH D from C;\nEND;\n')),Object(r.b)("p",null,"We already have a good idea what is going to happen with ",Object(r.b)("inlineCode",{parentName:"p"},"C")," in this program.  Let's look at the\ngenerated code focusing just on the parts that involve ",Object(r.b)("inlineCode",{parentName:"p"},"D"),"."),Object(r.b)("p",null,"First there is a row defintion for ",Object(r.b)("inlineCode",{parentName:"p"},"D"),". Unsurprisingly it is exactly the samea as the one for ",Object(r.b)("inlineCode",{parentName:"p"},"C"),".\nThis must be the case since we specified ",Object(r.b)("inlineCode",{parentName:"p"},"D CURSOR LIKE C"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct p_D_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} p_D_row;\n\n#define p_D_refs_offset cql_offsetof(p_D_row, x) // count = 1\n")),Object(r.b)("p",null,"Then the ",Object(r.b)("inlineCode",{parentName:"p"},"D")," cursor variables will be needed:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"p_D_row D = { ._refs_count_ = 1, ._refs_offset_ = p_D_refs_offset };\n")),Object(r.b)("p",null,"The above also implies the cleanup code:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  cql_teardown_row(D);\n")),Object(r.b)("p",null,"finally, we fetch ",Object(r.b)("inlineCode",{parentName:"p"},"D")," from ",Object(r.b)("inlineCode",{parentName:"p"},"C"),".  That's just some assignments:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  D._has_row_ = 1;\n  cql_set_string_ref(&D.x, C.x);\n  D.y = C.y;\n")),Object(r.b)("p",null,"Importantly, there is no ",Object(r.b)("inlineCode",{parentName:"p"},"D_stmt")," variable.  ",Object(r.b)("inlineCode",{parentName:"p"},"D")," is ",Object(r.b)("em",{parentName:"p"},"not")," a statement cursor like ",Object(r.b)("inlineCode",{parentName:"p"},"C"),', it\'s\na so-called "value" cursor.  In that it can only hold values.'),Object(r.b)("p",null,"A value cursor can actually be loaded from anywhere, it just holds data.  You don't\nloop over it (attempts to do so will result in errors)."),Object(r.b)("p",null,"The general syntax for loading such a cursor is something like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"}," FETCH D(x, y) FROM VALUES(C.x, C.y);\n")),Object(r.b)("p",null,"And indeed the form ",Object(r.b)("inlineCode",{parentName:"p"},"FETCH D FROM C")," was rewritten automatically into the general form.\nThe short form is just sugar."),Object(r.b)("p",null,"Once loaded, ",Object(r.b)("inlineCode",{parentName:"p"},"D.x")," and ",Object(r.b)("inlineCode",{parentName:"p"},"D.y")," can be used as always.  The data type of ",Object(r.b)("inlineCode",{parentName:"p"},"D")," is similar to ",Object(r.b)("inlineCode",{parentName:"p"},"C"),"."),Object(r.b)("p",null,"The AST would report:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"{declare_cursor_like_name}: D: select: { x: text notnull, y: integer notnull }\n   variable shape_storage value_cursor\n")),Object(r.b)("p",null,"meaning ",Object(r.b)("inlineCode",{parentName:"p"},"D")," has the flags ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_STRUCT"),", ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_VARIABLE"),", ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_HAS_SHAPE_STORAGE"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_VALUE_CURSOR"),".\nThat last flag indicates that there is no statement for this cursor, it's just values. And all such cursors must have\n",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_HAS_SHAPE_STORAGE")," -- if they had no statement and no storage they would be -- nothing."),Object(r.b)("p",null,"Value cursors are enormously helpful and there is sugar for loading them from all kinds of sources with a shape.\nThese forms are described more properly in ",Object(r.b)("a",{parentName:"p",href:"https://cgsql.dev/cql-guide/ch05"},"Chapter 5")," of the Guide but they\nall end up going through the general form, making the codegen considerably simpler. There are many examples where the semantic\nanalyzer rewrites a sugar form to a canonical form to keep the codegen from forking into dozens of special cases\nand most of them have to do with shapes and cursors."),Object(r.b)("h3",{id:"returning-value-cursors"},"Returning Value Cursors"),Object(r.b)("p",null,"Let's look at an example that is similar to the previous one:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'@ATTRIBUTE(cql:private)\nCREATE PROC q ()\nBEGIN\n  DECLARE C CURSOR LIKE SELECT "1" AS x, 2 AS y;\n  FETCH C USING\n   "foo" x,\n   3 y;\n  OUT C;\nEND;\n\nCREATE PROC p ()\nBEGIN\n  DECLARE C CURSOR FETCH FROM CALL q();\n  -- do something with C\nEND;\n')),Object(r.b)("p",null,"Let's discuss some of what is above, first looking at ",Object(r.b)("inlineCode",{parentName:"p"},"q"),":"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'DECLARE C CURSOR LIKE SELECT "1" AS x, 2 AS y;')," : this makes an empty value cursor",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"note the shape is ",Object(r.b)("inlineCode",{parentName:"li"},"LIKE")," the indicated ",Object(r.b)("inlineCode",{parentName:"li"},"SELECT"),", the ",Object(r.b)("inlineCode",{parentName:"li"},"SELECT")," does not actually run"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"FETCH ... USING")," : this form is sugar, it lets you put the column names ",Object(r.b)("inlineCode",{parentName:"li"},"x")," and ",Object(r.b)("inlineCode",{parentName:"li"},"y")," adjacent to the values but is otherwise equivalent to the canonical form",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'FETCH C(x, y) FROM VALUES("foo", 3);')," is the canonical form"),Object(r.b)("li",{parentName:"ul"},"codegen only ever sees the canonical form"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"OUT C")," is new, we'll cover this shortly")),Object(r.b)("p",null,"Now let's look at the C for ",Object(r.b)("inlineCode",{parentName:"p"},"q")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'typedef struct q_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} q_row;\n\n#define q_refs_offset cql_offsetof(q_row, x) // count = 1\n\ncql_string_literal(_literal_1_foo_q, "foo");\n\ntypedef struct q_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} q_C_row;\n\n#define q_C_refs_offset cql_offsetof(q_C_row, x) // count = 1\n\nstatic void q(q_row *_Nonnull _result_) {\n  memset(_result_, 0, sizeof(*_result_));\n  q_C_row C = { ._refs_count_ = 1, ._refs_offset_ = q_C_refs_offset };\n\n  C._has_row_ = 1;\n  cql_set_string_ref(&C.x, _literal_1_foo_q);\n  C.y = 3;\n  _result_->_has_row_ = C._has_row_;\n  _result_->_refs_count_ = 1;\n  _result_->_refs_offset_ = q_refs_offset;\n  cql_set_string_ref(&_result_->x, C.x);\n  _result_->y = C.y;\n\n  cql_teardown_row(C);\n}\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},"_result_")," variable is clobbed with zeros, it is assumed to be junk coming in",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"if it had valid data, the caller is expected to use ",Object(r.b)("inlineCode",{parentName:"li"},"cql_teardown_row")," to clean it up ",Object(r.b)("em",{parentName:"li"},"before")," calling"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"q_row")," : this is new, this is the structure type for the result of ",Object(r.b)("inlineCode",{parentName:"li"},"q"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"it's exactly the same shape as C"),Object(r.b)("li",{parentName:"ul"},"it has its own ",Object(r.b)("inlineCode",{parentName:"li"},"q_refs_offset")," like other shapes"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"q_C_row")," : this is the same old same old row structure for cursor C"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"static void q(q_row *_Nonnull _result_)")," : q now accepts a q_row to fill in!",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"note that ",Object(r.b)("inlineCode",{parentName:"li"},"q")," does not have the ",Object(r.b)("inlineCode",{parentName:"li"},"_db_")," parameter, it doesn't use the database!"),Object(r.b)("li",{parentName:"ul"},"it is entirely possible to fill value cursors from non-database sources, e.g. constants, math, whatever"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C")," : the value cursor is declared as usual"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C.x")," and ",Object(r.b)("inlineCode",{parentName:"li"},"C.y")," are loaded, this resolves the ",Object(r.b)("inlineCode",{parentName:"li"},"FETCH")," statement"),Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},"_result_")," fields are copied from ",Object(r.b)("inlineCode",{parentName:"li"},"C"),", this resolves the ",Object(r.b)("inlineCode",{parentName:"li"},"OUT")," statement"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C")," can be torn down"),Object(r.b)("li",{parentName:"ul"},"there is no cleanup label, there are no error cases, nothing can go wrong!")),Object(r.b)("p",null,"The net of all this is that we have loaded a value cursor that was passed in to the procedure via\na hidden argument and it has retained references as appropriate."),Object(r.b)("p",null,"Now let's look at ",Object(r.b)("inlineCode",{parentName:"p"},"p"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct p_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} p_C_row;\n\n#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1\nvoid p(void) {\n  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };\n\n  cql_teardown_row(C);\n  q((q_row *)&C); // q_row identical to cursor type\n\n  // usually you do something with C at this point\n\n  cql_teardown_row(C);\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_C_row")," : the cursor type for ",Object(r.b)("inlineCode",{parentName:"li"},"C")," in the procedure ",Object(r.b)("inlineCode",{parentName:"li"},"p")," is defined"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_C_refs_offset")," : the refs offset for ",Object(r.b)("inlineCode",{parentName:"li"},"C")," in ",Object(r.b)("inlineCode",{parentName:"li"},"p")," as usual"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C = {...}")," : the usual initialization for a cursor with shape",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"note that ",Object(r.b)("inlineCode",{parentName:"li"},"C")," is a value cursor, so it has no ",Object(r.b)("inlineCode",{parentName:"li"},"C_stmt")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_teardown_row(C)")," : releases any references in C, there are none",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"this pattern is general purpose, the call to ",Object(r.b)("inlineCode",{parentName:"li"},"q")," might be in a loop or something"),Object(r.b)("li",{parentName:"ul"},"in this instance the teardown here is totally redundant, but harmless"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"q((q_row *)&C)")," : fetch ",Object(r.b)("inlineCode",{parentName:"li"},"C")," by calling ",Object(r.b)("inlineCode",{parentName:"li"},"q"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_C_row")," has been constructed to be exactly the same as ",Object(r.b)("inlineCode",{parentName:"li"},"q_row")," so this cast is safe"),Object(r.b)("li",{parentName:"ul"},"there are no error checks because ",Object(r.b)("inlineCode",{parentName:"li"},"q")," can't fail!"))),Object(r.b)("li",{parentName:"ul"},"some code that would use ",Object(r.b)("inlineCode",{parentName:"li"},"C")," is absent for this sample, it would go where the comment is"),Object(r.b)("li",{parentName:"ul"},"the cleanup label is missing because there are no error cases, emitting the label would just cause warnings",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"such warnings are often escalated to errors in production builds..."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_teardown_row(C)")," is needed as always,",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"even though there is no cleanup label the ",Object(r.b)("inlineCode",{parentName:"li"},"teardown")," is in the cleanup section"),Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},"teardown")," was added as usual when ",Object(r.b)("inlineCode",{parentName:"li"},"C")," was declared")))),Object(r.b)("p",null,"So with just normal value cursor codegen we can pretty easily create a situation where\nprocedures can move structures from one to another.  As we saw, the source of value cursors\nmay or may not be the database.  Value cursors are frequently invaluable in test code\nas they can easily hold mock rows based on any kind of computation."),Object(r.b)("h3",{id:"result-sets"},"Result Sets"),Object(r.b)("p",null,"In addition to returning a single row into a value cursor, or returning a statement to consume with a statement cursor,\nit's possible to generate a result set.  So far the samples have included ",Object(r.b)("inlineCode",{parentName:"p"},"@attribute(cql:private)")," to suppress that\ncode.  This pattern is intended to let regular C code access the data so ",Object(r.b)("inlineCode",{parentName:"p"},"private")," suppresses it."),Object(r.b)("p",null,"Let's consider a simple example, this example returns only one row but the mechanism works for any number of rows,\nwe're just using this form because it's what we've used so far and its simple.  Let's begin:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC p ()\nBEGIN\n  SELECT "1" AS x, 2 AS y;\nEND;\n')),Object(r.b)("p",null,"The core generated function is this one:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {\n  cql_code _rc_ = SQLITE_OK;\n  *_result_stmt = NULL;\n  _rc_ = cql_prepare(_db_, _result_stmt,\n    \"SELECT '1', 2\");\n  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }\n  _rc_ = SQLITE_OK;\n\ncql_cleanup:\n  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);\n  return _rc_;\n}\n")),Object(r.b)("p",null,"We've seen this before, it creates the SQLite statement.  But that isn't all the code that was generated,\nlet's have a look at what else we got in our outputs:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"CQL_WARN_UNUSED cql_code p_fetch_results(\n  sqlite3 *_Nonnull _db_,\n  p_result_set_ref _Nullable *_Nonnull result_set)\n{\n  sqlite3_stmt *stmt = NULL;\n  cql_profile_start(CRC_p, &p_perf_index);\n  cql_code rc = p(_db_, &stmt);\n  cql_fetch_info info = {\n    .rc = rc,\n    .db = _db_,\n    .stmt = stmt,\n    .data_types = p_data_types,\n    .col_offsets = p_col_offsets,\n    .refs_count = 1,\n    .refs_offset = p_refs_offset,\n    .encode_context_index = -1,\n    .rowsize = sizeof(p_row),\n    .crc = CRC_p,\n    .perf_index = &p_perf_index,\n  };\n  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);\n}\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"p_fetch_results")," does two main things:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_code rc = p(_db_, &stmt)")," : it calls the underlying function to get the statement"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_fetch_all_results")," : it calls a standard helper to read all the results from the statement and put them into ",Object(r.b)("inlineCode",{parentName:"li"},"result_set"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"to do the fetch, it sets up a ",Object(r.b)("inlineCode",{parentName:"li"},"cql_fetch_info")," for this result set, this has all the information needed to do the fetch"),Object(r.b)("li",{parentName:"ul"},"the intent here is that even a complex fetch with lots of columns can be done economically, and"),Object(r.b)("li",{parentName:"ul"},"the code that does the fetching is shared")))),Object(r.b)("p",null,"Let's look at the things that are needed to load up that ",Object(r.b)("inlineCode",{parentName:"p"},"info")," structure."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct p_row {\n  cql_int32 y;\n  cql_string_ref _Nonnull x;\n} p_row;\n\nuint8_t p_data_types[p_data_types_count] = {\n  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // x\n  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // y\n};\n\n#define p_refs_offset cql_offsetof(p_row, x) // count = 1\n\nstatic cql_uint16 p_col_offsets[] = { 2,\n  cql_offsetof(p_row, x),\n  cql_offsetof(p_row, y)\n};\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_row")," : the row structure for this result set, same as always, reference types last"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_data_types")," : an array with the data types encoded as bytes"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_refs_offset")," : the offset of the first reference type"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_col_offsets")," : this is the offset of each column within the row structure",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"these are in column order, not offset order")))),Object(r.b)("p",null,"Code generation creates a ",Object(r.b)("inlineCode",{parentName:"p"},".c")," file and a ",Object(r.b)("inlineCode",{parentName:"p"},".h")," file, we haven't talked much about the ",Object(r.b)("inlineCode",{parentName:"p"},".h"),"\nbecause it's mostly prototypes for the functions in the ",Object(r.b)("inlineCode",{parentName:"p"},".c")," file.  But in this case we have\na few more interesting things.  We need just two of them:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#define CRC_p -6643602732498616851L\n\n#define p_data_types_count 2\n")),Object(r.b)("p",null,"Now we're armed to discuss loading the ",Object(r.b)("inlineCode",{parentName:"p"},"info")," structure:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".rc")," : the fetcher needs to know if ",Object(r.b)("inlineCode",{parentName:"li"},"p")," was successful, it won't read from the statement if it wasn't"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".db")," : the database handle, the fetcher needs this to call SQLite APIs"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".stmt")," : the statement that came from ",Object(r.b)("inlineCode",{parentName:"li"},"p")," that is to be enumerated"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".data_types")," : types of the columns, this tells the fetcher what columns to read to the statement in what order"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".col_offsets")," : the column offsets, this tells the fetcher were to store the column data within each row"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".refs_count")," : the number of references in the row, this is needed to tear down the rows in the result set when it is released"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".refs_offset")," : the first reference offset, as usual this tells the fetcher where the references that need to be released are"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".encode_context_index")," : it's possible to have sensitive fields encoded, this identifies an optional column that will be combined with the sensitive data\n. ",Object(r.b)("inlineCode",{parentName:"li"},".rowsize")," : the size of ",Object(r.b)("inlineCode",{parentName:"li"},"p_row"),", this is needed to allocate rows in a growable buffer"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".crc")," : this is a CRC of the code of ",Object(r.b)("inlineCode",{parentName:"li"},"p"),", it's used to uniquely identify ",Object(r.b)("inlineCode",{parentName:"li"},"p")," economically, performance logging APIs typically use this CRC in a begin/end logging pair"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},".perf_index")," : performance data for stored procedures is typically stored in an array of stats, CQL provides storage for the index for each procedure")),Object(r.b)("p",null,"With this data (which is in the end pretty small) the ",Object(r.b)("inlineCode",{parentName:"p"},"cql_fetch_all_results")," can do all the things it needs to do:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_profile_start")," has already been called, it can call ",Object(r.b)("inlineCode",{parentName:"li"},"cql_profile_end")," once the data is fetched",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_profile_start")," and ",Object(r.b)("inlineCode",{parentName:"li"},"_end")," do nothing by default, but those macros can be defined to log performance data however you like"))),Object(r.b)("li",{parentName:"ul"},"it can allocate a ",Object(r.b)("inlineCode",{parentName:"li"},"bytebuf")," with ",Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf_open")," and then grow it with ",Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf_alloc"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"in the end all the rows are in one contiguous block of storage"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_multifetch_meta")," is used to read each row from the result set, it's similar to ",Object(r.b)("inlineCode",{parentName:"li"},"cql_multifetch"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"the ",Object(r.b)("inlineCode",{parentName:"li"},"meta")," version uses ",Object(r.b)("inlineCode",{parentName:"li"},"data_types")," and ",Object(r.b)("inlineCode",{parentName:"li"},"column_offsets")," instead of varargs but is otherwise the same"),Object(r.b)("li",{parentName:"ul"},"the first member of the ",Object(r.b)("inlineCode",{parentName:"li"},"col_offsets")," array is the count of columns")))),Object(r.b)("p",null,"With this background, ",Object(r.b)("inlineCode",{parentName:"p"},"cql_fetch_all_results")," should be very approachable.  There's a good bit of work but it's all very simple."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"// By the time we get here, a CQL stored proc has completed execution and there is\n// now a statement (or an error result).  This function iterates the rows that\n// come out of the statement using the fetch info to describe the shape of the\n// expected results.  All of this code is shared so that the cost of any given\n// stored procedure is minimized.  Even the error handling is consolidated.\ncql_code cql_fetch_all_results(\n  cql_fetch_info *_Nonnull info,\n  cql_result_set_ref _Nullable *_Nonnull result_set) {...}\n")),Object(r.b)("p",null,"The core of that function looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  ...\n  cql_bytebuf_open(&b);\n  ...\n  for (;;) {\n    rc = sqlite3_step(stmt);\n    if (rc == SQLITE_DONE) break;\n    if (rc != SQLITE_ROW) goto cql_error;\n    count++;\n    row = cql_bytebuf_alloc(&b, rowsize);\n    memset(row, 0, rowsize);\n\n    cql_multifetch_meta((char *)row, info);\n  }\n  ...\n  cql_profile_stop(info->crc, info->perf_index);\n  ...\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf_open")," : open the buffer, get ready to start appending rows"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sqlite3_step")," : keep reading while we get ",Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_ROW"),", stop on ",Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_DONE")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf_alloc")," : allocate a new row in the buffer"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"memset")," : zero the row"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_multifetch_meta")," : read the data from the the statement into the row"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_profile_stop")," : signals that processing is done and profiling can stop"),Object(r.b)("li",{parentName:"ul"},"if all goes well, ",Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_OK")," is returned as usual")),Object(r.b)("p",null,"The remaining logic is largely about checking for errors and tearing down the result set\nif anything goes wrong.  There is not very much to it, and it's worth a read."),Object(r.b)("p",null,"Now recall that the way ",Object(r.b)("inlineCode",{parentName:"p"},"cql_fetch_all_results")," was used, was as follows:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set)\n")),Object(r.b)("p",null,"And ",Object(r.b)("inlineCode",{parentName:"p"},"result_set")," was the out-argument for the the ",Object(r.b)("inlineCode",{parentName:"p"},"p_fetch_results")," method."),Object(r.b)("p",null,"So ",Object(r.b)("inlineCode",{parentName:"p"},"p_fetch_results")," is used to get that result set.  But what can you do with it?\nWell, the result set contains copy of all the selected data, ready to use in with a C-friendly API.\nThe interface is in the generated ",Object(r.b)("inlineCode",{parentName:"p"},".h")," file.  Let's look at that now, it's the final piece of the puzzle."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"#ifndef result_set_type_decl_p_result_set\n#define result_set_type_decl_p_result_set 1\ncql_result_set_type_decl(p_result_set, p_result_set_ref);\n#endif\n\nextern cql_string_ref _Nonnull p_get_x(p_result_set_ref _Nonnull result_set, cql_int32 row);\nextern cql_int32 p_get_y(p_result_set_ref _Nonnull result_set, cql_int32 row);\nextern cql_int32 p_result_count(p_result_set_ref _Nonnull result_set);\nextern CQL_WARN_UNUSED cql_code p_fetch_results(sqlite3 *_Nonnull _db_, p_result_set_ref _Nullable *_Nonnull result_set);\n\n#define p_row_hash(result_set, row) cql_result_set_get_meta( \\\n  (cql_result_set_ref)(result_set))->rowHash((cql_result_set_ref)(result_set), row)\n\n#define p_row_equal(rs1, row1, rs2, row2) \\\n  cql_result_set_get_meta((cql_result_set_ref)(rs1))->rowsEqual( \\\n    (cql_result_set_ref)(rs1), \\\n    row1, \\\n    (cql_result_set_ref)(rs2), \\\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_result_set_type_decl")," : declares ",Object(r.b)("inlineCode",{parentName:"li"},"p_result_set_ref"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"to avoid being defined more than once, the declaration is protected by ",Object(r.b)("inlineCode",{parentName:"li"},"#ifndef result_set_type_decl_p_result_set")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_get_x"),", ",Object(r.b)("inlineCode",{parentName:"li"},"p_get_y")," : allow access to the named fields of the result set at any given row"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_result_count")," :  provides the count of rows in the result set"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_fetch_results")," : the declaration of the fetcher (previously discussed)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_row_hash")," : provides a hash of any given row, useful for detecting changes between result sets"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_row_equal")," : tests two rows in two results sets of the same shape for equality")),Object(r.b)("p",null,"The getters are defined very simply:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cql_string_ref _Nonnull p_get_x(p_result_set_ref _Nonnull result_set, cql_int32 row) {\n  p_row *data = (p_row *)cql_result_set_get_data((cql_result_set_ref)result_set);\n  return data[row].x;\n}\n\ncql_int32 p_get_y(p_result_set_ref _Nonnull result_set, cql_int32 row) {\n  p_row *data = (p_row *)cql_result_set_get_data((cql_result_set_ref)result_set);\n  return data[row].y;\n}\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"p_row")," is exactly the right size, and of course the right shape, the final access looks something like ",Object(r.b)("inlineCode",{parentName:"p"},"data[row].x"),"."),Object(r.b)("h4",{id:"result-sets-from-the-out-statement"},"Result Sets from the OUT statement"),Object(r.b)("p",null,"Recalling this earlier example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},'CREATE PROC q ()\nBEGIN\n  DECLARE C CURSOR LIKE SELECT "1" AS x, 2 AS y;\n  FETCH C USING\n   "foo" x,\n   3 y;\n  OUT C;\nEND;\n')),Object(r.b)("p",null,"The original example had ",Object(r.b)("inlineCode",{parentName:"p"},"@attribute(cql:private)")," to suppress the result set, but normally a one-row result is\nis generated from such a method.  The C API is almost identical.  However, there count is always 0 or 1."),Object(r.b)("p",null,"The getters do not have the row number:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"extern cql_string_ref _Nonnull q_get_x(q_result_set_ref _Nonnull result_set);\nextern cql_int32 q_get_y(q_result_set_ref _Nonnull result_set);\n")),Object(r.b)("p",null,"The actual getters are nearly the same as well"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"cql_string_ref _Nonnull q_get_x(q_result_set_ref _Nonnull result_set) {\n  q_row *data = (q_row *)cql_result_set_get_data((cql_result_set_ref)result_set);\n  return data->x;\n}\n\ncql_int32 q_get_y(q_result_set_ref _Nonnull result_set) {\n  q_row *data = (q_row *)cql_result_set_get_data((cql_result_set_ref)result_set);\n  return data->y;\n}\n")),Object(r.b)("p",null,"Basically ",Object(r.b)("inlineCode",{parentName:"p"},"data[row].x")," just became ",Object(r.b)("inlineCode",{parentName:"p"},"data->x")," and the rest is nearly the same.\nVirtually all the code for this is shared."),Object(r.b)("p",null,"You can find all this and more in ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," by looking here:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},'// If a stored procedure generates a result set then we need to do some extra work\n// to create the C friendly rowset creating and accessing helpers.  If stored\n// proc "foo" creates a row set then we need to:\n//  * emit a struct "foo_row" that has the shape of each row\n//    * this isn\'t used by the client code but we use it in our code-gen\n//  * emit a function "foo_fetch_results" that will call "foo" and read the rows\n//    from the statement created by "foo".\n//    * this method will construct a result set object via cql_result_create and store the data\n//    * the remaining functions use cql_result_set_get_data and _get_count to get the data back out\n//  * for each named column emit a function "foo_get_[column-name]" which\n//    gets that column out of the rowset for the indicated row number.\n//  * prototypes for the above go into the main output header file\nstatic void cg_proc_result_set(ast_node *ast)\n')),Object(r.b)("p",null,"There are many variations in that function to handle the cases mentioned so far, but they are\nsubstantially similar to each other with a lot of shared code.  There is one last variation\nwe should talk about and that is the ",Object(r.b)("inlineCode",{parentName:"p"},"OUT UNION")," form.  It is the most flexible of them all."),Object(r.b)("h4",{id:"result-sets-from-the-out-union-statement"},"Result Sets from the OUT UNION statement"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"OUT")," statement, allows the programmer to produce a result set that has exactly one row,\n",Object(r.b)("inlineCode",{parentName:"p"},"OUT UNION")," instead accumulates rows.  This is very much like writing your own ",Object(r.b)("inlineCode",{parentName:"p"},"fetcher")," procedure\nwith your own logic.  The data could come from the database, by, for instance, enumerating\na cursor.  Or it can come from some computation or a mix of both.  Here's a very simple example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC q ()\nBEGIN\n  DECLARE C CURSOR LIKE SELECT 1 AS x;\n  LET i := 0;\n  WHILE i < 5\n  BEGIN\n    FETCH C(x) FROM VALUES(i);\n    OUT UNION C;\n    SET i := i + 1;\n  END;\nEND;\n")),Object(r.b)("p",null,"Let's look at the code for the above, it will be very similar to other examples we've seen so far:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct q_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 x;\n} q_C_row;\nvoid q_fetch_results(q_result_set_ref _Nullable *_Nonnull _result_set_) {\n  cql_bytebuf _rows_;\n  cql_bytebuf_open(&_rows_);\n  *_result_set_ = NULL;\n  q_C_row C = { 0 };\n  cql_int32 i = 0;\n\n  cql_profile_start(CRC_q, &q_perf_index);\n  i = 0;\n  for (;;) {\n  if (!(i < 5)) break;\n    C._has_row_ = 1;\n    C.x = i;\n    cql_retain_row(C);\n    if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));\n    i = i + 1;\n  }\n\n  cql_results_from_data(SQLITE_OK, &_rows_, &q_info, (cql_result_set_ref *)_result_set_);\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"q_C_row")," : the shape of the cursor, as always"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"_rows_")," : the ",Object(r.b)("inlineCode",{parentName:"li"},"bytebuf")," that will hold our data"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf_open(&_rows_);")," : initializes the buffer"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_profile_start(CRC_q, &q_perf_index);")," : start profiling as before"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"for (;;)")," : the while pattern as before"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C.x = i;")," : loads the cursor"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_retain_row(C);")," : retains any references in the cursor (there are none)",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"we're about to copy the cursor into the buffer so all refs need to be +1"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf_append")," : append the the cursor's bytes into the buffer"),Object(r.b)("li",{parentName:"ul"},"the loop does its repetitions until finally"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_results_from_data")," : used instead of ",Object(r.b)("inlineCode",{parentName:"li"},"cql_fetch_all_results")," because all the data is already prepared",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"in this particular example there is nothing to go wrong so it always gets ",Object(r.b)("inlineCode",{parentName:"li"},"SQLITE_OK")),Object(r.b)("li",{parentName:"ul"},"in a more complicated example, ",Object(r.b)("inlineCode",{parentName:"li"},"cql_results_from_data")," frees any partly created result set in case of error"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_results_from_data")," also performs any encoding of sensitive data that might be needed"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"q_info")," : created as before, but it can be static as it's always the same now")),Object(r.b)("p",null,"Importantly, when using ",Object(r.b)("inlineCode",{parentName:"p"},"OUT UNION")," the codegen only produces ",Object(r.b)("inlineCode",{parentName:"p"},"q_fetch_results"),", there is no ",Object(r.b)("inlineCode",{parentName:"p"},"q"),".\nIf you try to call ",Object(r.b)("inlineCode",{parentName:"p"},"q")," from CQL you will instead call ",Object(r.b)("inlineCode",{parentName:"p"},"q_fetch_results"),". But since\nmany results as possible, a cursor is needed to make the call."),Object(r.b)("p",null,"Here's an example, here ",Object(r.b)("inlineCode",{parentName:"p"},"p")," calls the ",Object(r.b)("inlineCode",{parentName:"p"},"q")," method above:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-SQL"},"CREATE PROC p (OUT s INTEGER NOT NULL)\nBEGIN\n  DECLARE C CURSOR FOR CALL q();\n  LOOP FETCH C\n  BEGIN\n    SET s := s + C.x;\n  END;\nEND;\n")),Object(r.b)("p",null,"And the relevant code for this is as follows:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-C"},"typedef struct p_C_row {\n  cql_bool _has_row_;\n  cql_uint16 _refs_count_;\n  cql_uint16 _refs_offset_;\n  cql_int32 x;\n} p_C_row;\n\nCQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull s) {\n  cql_contract_argument_notnull((void *)s, 1);\n\n  cql_code _rc_ = SQLITE_OK;\n  q_result_set_ref C_result_set_ = NULL;\n  cql_int32 C_row_num_ = 0;\n  cql_int32 C_row_count_ = 0;\n  p_C_row C = { 0 };\n\n  *s = 0; // set out arg to non-garbage\n  q_fetch_results(&C_result_set_);\n  C_row_num_ = C_row_count_ = -1;\n  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);\n  for (;;) {\n    C_row_num_++;\n    C._has_row_ = C_row_num_ < C_row_count_;\n    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,\n                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x);\n    if (!C._has_row_) break;\n    *s = (*s) + C.x;\n  }\n  _rc_ = SQLITE_OK;\n\n  cql_object_release(C_result_set_);\n  return _rc_;\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"p_C_row")," : the cursor row as always"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_contract_argument_notnull((void *)s, 1)")," : verify that the out arg pointer is not null"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C_result_set_")," : this will hold the result set from ",Object(r.b)("inlineCode",{parentName:"li"},"q_fetch_results")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C_row_num_")," : the current row number being processed in the result set"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C_row_count_")," : the total number of rows in the result set"),Object(r.b)("li",{parentName:"ul"},"other locals are intialized as usual"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"*s = 0;")," : set the out arg to non-garbage as usual"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"q_fetch_results")," : get the result set from ",Object(r.b)("inlineCode",{parentName:"li"},"q_fetch_results"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"in this case no database access was required so this API can't fail"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C_row_num")," : set to -1"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"C_row_count")," : set to the row count"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_copyoutrow")," : copies one row from the result set into the cursor"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"*s = (*s) + C.x;")," : computes the sum"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cql_object_release")," : the result set is torn down"),Object(r.b)("li",{parentName:"ul"},"if there are any reference fields in the cursor there would have been a ",Object(r.b)("inlineCode",{parentName:"li"},"cql_teardown_row(C)"))),Object(r.b)("p",null,"In short, this is another form of cursor, it's a value cursor, so it has no statement but\nit also needs a result set, a count and an index to go with it so that it can enumerate the result set."),Object(r.b)("p",null,"In the AST it looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"{name C}: C: select: { x: integer notnull } variable shape_storage uses_out_union\n")),Object(r.b)("p",null,"This implies we have the semantic flags: ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_STRUCT"),", ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_VARIABLE"),", ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_HAS_SHAPE_STORAGE"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_USES_OUT_UNION"),"."),Object(r.b)("p",null,"The difference is of course the presence of ",Object(r.b)("inlineCode",{parentName:"p"},"SEM_TYPE_USES_OUT_UNION"),"."),Object(r.b)("p",null,"This is the last of the cursor forms and the final complication of ",Object(r.b)("inlineCode",{parentName:"p"},"cg_proc_result_set"),"."),Object(r.b)("h3",{id:"recap"},"Recap"),Object(r.b)("p",null,"At present ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," is a little over 7400 lines of code, maybe 1500 of those lines are comments.   So ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," is actually quite a\nbit smaller and simpler than ",Object(r.b)("inlineCode",{parentName:"p"},"sem.c")," (roughly 1/3 the size).  It is, however, the most complex of the code generators by far.\nPart 3 of the internals guide has come out a lot larger than Part 2 but that's mainly because there are a few more cases worth\ndiscussing in detail and the code examples of Part 3 are bigger than the AST examples of Part 2."),Object(r.b)("p",null,"Topics covered included:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"compiling expressions into C, including nullable types"),Object(r.b)("li",{parentName:"ul"},"techniques used to generate control flow"),Object(r.b)("li",{parentName:"ul"},"creation of result sets, including:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"various helpers to do the reading economically"),Object(r.b)("li",{parentName:"ul"},"the use of ",Object(r.b)("inlineCode",{parentName:"li"},"cql_bytebuf")," to manage the memory"))),Object(r.b)("li",{parentName:"ul"},"create the text for SQLite statements and binding variables to that text"),Object(r.b)("li",{parentName:"ul"},"error management, and how it relates to ",Object(r.b)("inlineCode",{parentName:"li"},"TRY")," and ",Object(r.b)("inlineCode",{parentName:"li"},"CATCH")," blocks"),Object(r.b)("li",{parentName:"ul"},"use of cleanup sections to ensure that references and SQLite statement lifetime is always correct"),Object(r.b)("li",{parentName:"ul"},"the contents of the ",Object(r.b)("inlineCode",{parentName:"li"},".c")," and ",Object(r.b)("inlineCode",{parentName:"li"},".h")," files and the key sections in them"),Object(r.b)("li",{parentName:"ul"},"the use of ",Object(r.b)("inlineCode",{parentName:"li"},"charbuf")," to create and assemble fragments")),Object(r.b)("p",null,"As with the other parts, this is not a complete discussion of the code but a useful survey that\nshould enable readers enough context to understand ",Object(r.b)("inlineCode",{parentName:"p"},"cg_c.c")," and the runtime helpers in ",Object(r.b)("inlineCode",{parentName:"p"},"cqlrt.c"),"\nand ",Object(r.b)("inlineCode",{parentName:"p"},"cqlrt_common.c"),".  Good luck in your personal exploration."))}p.isMDXComponent=!0},147:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),l=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),b=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=b(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},_=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=b(n),_=a,d=p["".concat(i,".").concat(_)]||p[_]||u[_]||r;return n?l.a.createElement(d,s(s({ref:t},c),{},{components:n})):l.a.createElement(d,s({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=_;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return l.a.createElement.apply(null,i)}return l.a.createElement.apply(null,n)}_.displayName="MDXCreateElement"}}]);